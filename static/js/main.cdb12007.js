/*! For license information please see main.cdb12007.js.LICENSE.txt */
(()=>{var e={353:e=>{e.exports=n;var t=null;try{t=new WebAssembly.Instance(new WebAssembly.Module(new Uint8Array([0,97,115,109,1,0,0,0,1,13,2,96,0,1,127,96,4,127,127,127,127,1,127,3,7,6,0,1,1,1,1,1,6,6,1,127,1,65,0,11,7,50,6,3,109,117,108,0,1,5,100,105,118,95,115,0,2,5,100,105,118,95,117,0,3,5,114,101,109,95,115,0,4,5,114,101,109,95,117,0,5,8,103,101,116,95,104,105,103,104,0,0,10,191,1,6,4,0,35,0,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,126,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,127,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,128,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,129,34,4,66,32,135,167,36,0,32,4,167,11,36,1,1,126,32,0,173,32,1,173,66,32,134,132,32,2,173,32,3,173,66,32,134,132,130,34,4,66,32,135,167,36,0,32,4,167,11])),{}).exports}catch(N){}function n(e,t,n){this.low=0|e,this.high=0|t,this.unsigned=!!n}function a(e){return!0===(e&&e.__isLong__)}n.prototype.__isLong__,Object.defineProperty(n.prototype,"__isLong__",{value:!0}),n.isLong=a;var r={},s={};function o(e,t){var n,a,o;return t?(o=0<=(e>>>=0)&&e<256)&&(a=s[e])?a:(n=c(e,(0|e)<0?-1:0,!0),o&&(s[e]=n),n):(o=-128<=(e|=0)&&e<128)&&(a=r[e])?a:(n=c(e,e<0?-1:0,!1),o&&(r[e]=n),n)}function i(e,t){if(isNaN(e))return t?y:g;if(t){if(e<0)return y;if(e>=p)return k}else{if(e<=-f)return S;if(e+1>=f)return w}return e<0?i(-e,t).neg():c(e%d|0,e/d|0,t)}function c(e,t,a){return new n(e,t,a)}n.fromInt=o,n.fromNumber=i,n.fromBits=c;var l=Math.pow;function u(e,t,n){if(0===e.length)throw Error("empty string");if("NaN"===e||"Infinity"===e||"+Infinity"===e||"-Infinity"===e)return g;if("number"===typeof t?(n=t,t=!1):t=!!t,(n=n||10)<2||36<n)throw RangeError("radix");var a;if((a=e.indexOf("-"))>0)throw Error("interior hyphen");if(0===a)return u(e.substring(1),t,n).neg();for(var r=i(l(n,8)),s=g,o=0;o<e.length;o+=8){var c=Math.min(8,e.length-o),h=parseInt(e.substring(o,o+c),n);if(c<8){var d=i(l(n,c));s=s.mul(d).add(i(h))}else s=(s=s.mul(r)).add(i(h))}return s.unsigned=t,s}function h(e,t){return"number"===typeof e?i(e,t):"string"===typeof e?u(e,t):c(e.low,e.high,"boolean"===typeof t?t:e.unsigned)}n.fromString=u,n.fromValue=h;var d=4294967296,p=d*d,f=p/2,m=o(1<<24),g=o(0);n.ZERO=g;var y=o(0,!0);n.UZERO=y;var b=o(1);n.ONE=b;var v=o(1,!0);n.UONE=v;var x=o(-1);n.NEG_ONE=x;var w=c(-1,2147483647,!1);n.MAX_VALUE=w;var k=c(-1,-1,!0);n.MAX_UNSIGNED_VALUE=k;var S=c(0,-2147483648,!1);n.MIN_VALUE=S;var I=n.prototype;I.toInt=function(){return this.unsigned?this.low>>>0:this.low},I.toNumber=function(){return this.unsigned?(this.high>>>0)*d+(this.low>>>0):this.high*d+(this.low>>>0)},I.toString=function(e){if((e=e||10)<2||36<e)throw RangeError("radix");if(this.isZero())return"0";if(this.isNegative()){if(this.eq(S)){var t=i(e),n=this.div(t),a=n.mul(t).sub(this);return n.toString(e)+a.toInt().toString(e)}return"-"+this.neg().toString(e)}for(var r=i(l(e,6),this.unsigned),s=this,o="";;){var c=s.div(r),u=(s.sub(c.mul(r)).toInt()>>>0).toString(e);if((s=c).isZero())return u+o;for(;u.length<6;)u="0"+u;o=""+u+o}},I.getHighBits=function(){return this.high},I.getHighBitsUnsigned=function(){return this.high>>>0},I.getLowBits=function(){return this.low},I.getLowBitsUnsigned=function(){return this.low>>>0},I.getNumBitsAbs=function(){if(this.isNegative())return this.eq(S)?64:this.neg().getNumBitsAbs();for(var e=0!=this.high?this.high:this.low,t=31;t>0&&0==(e&1<<t);t--);return 0!=this.high?t+33:t+1},I.isZero=function(){return 0===this.high&&0===this.low},I.eqz=I.isZero,I.isNegative=function(){return!this.unsigned&&this.high<0},I.isPositive=function(){return this.unsigned||this.high>=0},I.isOdd=function(){return 1===(1&this.low)},I.isEven=function(){return 0===(1&this.low)},I.equals=function(e){return a(e)||(e=h(e)),(this.unsigned===e.unsigned||this.high>>>31!==1||e.high>>>31!==1)&&(this.high===e.high&&this.low===e.low)},I.eq=I.equals,I.notEquals=function(e){return!this.eq(e)},I.neq=I.notEquals,I.ne=I.notEquals,I.lessThan=function(e){return this.comp(e)<0},I.lt=I.lessThan,I.lessThanOrEqual=function(e){return this.comp(e)<=0},I.lte=I.lessThanOrEqual,I.le=I.lessThanOrEqual,I.greaterThan=function(e){return this.comp(e)>0},I.gt=I.greaterThan,I.greaterThanOrEqual=function(e){return this.comp(e)>=0},I.gte=I.greaterThanOrEqual,I.ge=I.greaterThanOrEqual,I.compare=function(e){if(a(e)||(e=h(e)),this.eq(e))return 0;var t=this.isNegative(),n=e.isNegative();return t&&!n?-1:!t&&n?1:this.unsigned?e.high>>>0>this.high>>>0||e.high===this.high&&e.low>>>0>this.low>>>0?-1:1:this.sub(e).isNegative()?-1:1},I.comp=I.compare,I.negate=function(){return!this.unsigned&&this.eq(S)?S:this.not().add(b)},I.neg=I.negate,I.add=function(e){a(e)||(e=h(e));var t=this.high>>>16,n=65535&this.high,r=this.low>>>16,s=65535&this.low,o=e.high>>>16,i=65535&e.high,l=e.low>>>16,u=0,d=0,p=0,f=0;return p+=(f+=s+(65535&e.low))>>>16,d+=(p+=r+l)>>>16,u+=(d+=n+i)>>>16,u+=t+o,c((p&=65535)<<16|(f&=65535),(u&=65535)<<16|(d&=65535),this.unsigned)},I.subtract=function(e){return a(e)||(e=h(e)),this.add(e.neg())},I.sub=I.subtract,I.multiply=function(e){if(this.isZero())return g;if(a(e)||(e=h(e)),t)return c(t.mul(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned);if(e.isZero())return g;if(this.eq(S))return e.isOdd()?S:g;if(e.eq(S))return this.isOdd()?S:g;if(this.isNegative())return e.isNegative()?this.neg().mul(e.neg()):this.neg().mul(e).neg();if(e.isNegative())return this.mul(e.neg()).neg();if(this.lt(m)&&e.lt(m))return i(this.toNumber()*e.toNumber(),this.unsigned);var n=this.high>>>16,r=65535&this.high,s=this.low>>>16,o=65535&this.low,l=e.high>>>16,u=65535&e.high,d=e.low>>>16,p=65535&e.low,f=0,y=0,b=0,v=0;return b+=(v+=o*p)>>>16,y+=(b+=s*p)>>>16,b&=65535,y+=(b+=o*d)>>>16,f+=(y+=r*p)>>>16,y&=65535,f+=(y+=s*d)>>>16,y&=65535,f+=(y+=o*u)>>>16,f+=n*p+r*d+s*u+o*l,c((b&=65535)<<16|(v&=65535),(f&=65535)<<16|(y&=65535),this.unsigned)},I.mul=I.multiply,I.divide=function(e){if(a(e)||(e=h(e)),e.isZero())throw Error("division by zero");var n,r,s;if(t)return this.unsigned||-2147483648!==this.high||-1!==e.low||-1!==e.high?c((this.unsigned?t.div_u:t.div_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this;if(this.isZero())return this.unsigned?y:g;if(this.unsigned){if(e.unsigned||(e=e.toUnsigned()),e.gt(this))return y;if(e.gt(this.shru(1)))return v;s=y}else{if(this.eq(S))return e.eq(b)||e.eq(x)?S:e.eq(S)?b:(n=this.shr(1).div(e).shl(1)).eq(g)?e.isNegative()?b:x:(r=this.sub(e.mul(n)),s=n.add(r.div(e)));if(e.eq(S))return this.unsigned?y:g;if(this.isNegative())return e.isNegative()?this.neg().div(e.neg()):this.neg().div(e).neg();if(e.isNegative())return this.div(e.neg()).neg();s=g}for(r=this;r.gte(e);){n=Math.max(1,Math.floor(r.toNumber()/e.toNumber()));for(var o=Math.ceil(Math.log(n)/Math.LN2),u=o<=48?1:l(2,o-48),d=i(n),p=d.mul(e);p.isNegative()||p.gt(r);)p=(d=i(n-=u,this.unsigned)).mul(e);d.isZero()&&(d=b),s=s.add(d),r=r.sub(p)}return s},I.div=I.divide,I.modulo=function(e){return a(e)||(e=h(e)),t?c((this.unsigned?t.rem_u:t.rem_s)(this.low,this.high,e.low,e.high),t.get_high(),this.unsigned):this.sub(this.div(e).mul(e))},I.mod=I.modulo,I.rem=I.modulo,I.not=function(){return c(~this.low,~this.high,this.unsigned)},I.and=function(e){return a(e)||(e=h(e)),c(this.low&e.low,this.high&e.high,this.unsigned)},I.or=function(e){return a(e)||(e=h(e)),c(this.low|e.low,this.high|e.high,this.unsigned)},I.xor=function(e){return a(e)||(e=h(e)),c(this.low^e.low,this.high^e.high,this.unsigned)},I.shiftLeft=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low<<e,this.high<<e|this.low>>>32-e,this.unsigned):c(0,this.low<<e-32,this.unsigned)},I.shl=I.shiftLeft,I.shiftRight=function(e){return a(e)&&(e=e.toInt()),0===(e&=63)?this:e<32?c(this.low>>>e|this.high<<32-e,this.high>>e,this.unsigned):c(this.high>>e-32,this.high>=0?0:-1,this.unsigned)},I.shr=I.shiftRight,I.shiftRightUnsigned=function(e){if(a(e)&&(e=e.toInt()),0===(e&=63))return this;var t=this.high;return e<32?c(this.low>>>e|t<<32-e,t>>>e,this.unsigned):c(32===e?t:t>>>e-32,0,this.unsigned)},I.shru=I.shiftRightUnsigned,I.shr_u=I.shiftRightUnsigned,I.toSigned=function(){return this.unsigned?c(this.low,this.high,!1):this},I.toUnsigned=function(){return this.unsigned?this:c(this.low,this.high,!0)},I.toBytes=function(e){return e?this.toBytesLE():this.toBytesBE()},I.toBytesLE=function(){var e=this.high,t=this.low;return[255&t,t>>>8&255,t>>>16&255,t>>>24,255&e,e>>>8&255,e>>>16&255,e>>>24]},I.toBytesBE=function(){var e=this.high,t=this.low;return[e>>>24,e>>>16&255,e>>>8&255,255&e,t>>>24,t>>>16&255,t>>>8&255,255&t]},n.fromBytes=function(e,t,a){return a?n.fromBytesLE(e,t):n.fromBytesBE(e,t)},n.fromBytesLE=function(e,t){return new n(e[0]|e[1]<<8|e[2]<<16|e[3]<<24,e[4]|e[5]<<8|e[6]<<16|e[7]<<24,t)},n.fromBytesBE=function(e,t){return new n(e[4]<<24|e[5]<<16|e[6]<<8|e[7],e[0]<<24|e[1]<<16|e[2]<<8|e[3],t)}},730:(e,t,n)=>{"use strict";var a=n(43),r=n(853);function s(e){for(var t="https://reactjs.org/docs/error-decoder.html?invariant="+e,n=1;n<arguments.length;n++)t+="&args[]="+encodeURIComponent(arguments[n]);return"Minified React error #"+e+"; visit "+t+" for the full message or use the non-minified dev environment for full errors and additional helpful warnings."}var o=new Set,i={};function c(e,t){l(e,t),l(e+"Capture",t)}function l(e,t){for(i[e]=t,e=0;e<t.length;e++)o.add(t[e])}var u=!("undefined"===typeof window||"undefined"===typeof window.document||"undefined"===typeof window.document.createElement),h=Object.prototype.hasOwnProperty,d=/^[:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD][:A-Z_a-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\-.0-9\u00B7\u0300-\u036F\u203F-\u2040]*$/,p={},f={};function m(e,t,n,a,r,s,o){this.acceptsBooleans=2===t||3===t||4===t,this.attributeName=a,this.attributeNamespace=r,this.mustUseProperty=n,this.propertyName=e,this.type=t,this.sanitizeURL=s,this.removeEmptyString=o}var g={};"children dangerouslySetInnerHTML defaultValue defaultChecked innerHTML suppressContentEditableWarning suppressHydrationWarning style".split(" ").forEach((function(e){g[e]=new m(e,0,!1,e,null,!1,!1)})),[["acceptCharset","accept-charset"],["className","class"],["htmlFor","for"],["httpEquiv","http-equiv"]].forEach((function(e){var t=e[0];g[t]=new m(t,1,!1,e[1],null,!1,!1)})),["contentEditable","draggable","spellCheck","value"].forEach((function(e){g[e]=new m(e,2,!1,e.toLowerCase(),null,!1,!1)})),["autoReverse","externalResourcesRequired","focusable","preserveAlpha"].forEach((function(e){g[e]=new m(e,2,!1,e,null,!1,!1)})),"allowFullScreen async autoFocus autoPlay controls default defer disabled disablePictureInPicture disableRemotePlayback formNoValidate hidden loop noModule noValidate open playsInline readOnly required reversed scoped seamless itemScope".split(" ").forEach((function(e){g[e]=new m(e,3,!1,e.toLowerCase(),null,!1,!1)})),["checked","multiple","muted","selected"].forEach((function(e){g[e]=new m(e,3,!0,e,null,!1,!1)})),["capture","download"].forEach((function(e){g[e]=new m(e,4,!1,e,null,!1,!1)})),["cols","rows","size","span"].forEach((function(e){g[e]=new m(e,6,!1,e,null,!1,!1)})),["rowSpan","start"].forEach((function(e){g[e]=new m(e,5,!1,e.toLowerCase(),null,!1,!1)}));var y=/[\-:]([a-z])/g;function b(e){return e[1].toUpperCase()}function v(e,t,n,a){var r=g.hasOwnProperty(t)?g[t]:null;(null!==r?0!==r.type:a||!(2<t.length)||"o"!==t[0]&&"O"!==t[0]||"n"!==t[1]&&"N"!==t[1])&&(function(e,t,n,a){if(null===t||"undefined"===typeof t||function(e,t,n,a){if(null!==n&&0===n.type)return!1;switch(typeof t){case"function":case"symbol":return!0;case"boolean":return!a&&(null!==n?!n.acceptsBooleans:"data-"!==(e=e.toLowerCase().slice(0,5))&&"aria-"!==e);default:return!1}}(e,t,n,a))return!0;if(a)return!1;if(null!==n)switch(n.type){case 3:return!t;case 4:return!1===t;case 5:return isNaN(t);case 6:return isNaN(t)||1>t}return!1}(t,n,r,a)&&(n=null),a||null===r?function(e){return!!h.call(f,e)||!h.call(p,e)&&(d.test(e)?f[e]=!0:(p[e]=!0,!1))}(t)&&(null===n?e.removeAttribute(t):e.setAttribute(t,""+n)):r.mustUseProperty?e[r.propertyName]=null===n?3!==r.type&&"":n:(t=r.attributeName,a=r.attributeNamespace,null===n?e.removeAttribute(t):(n=3===(r=r.type)||4===r&&!0===n?"":""+n,a?e.setAttributeNS(a,t,n):e.setAttribute(t,n))))}"accent-height alignment-baseline arabic-form baseline-shift cap-height clip-path clip-rule color-interpolation color-interpolation-filters color-profile color-rendering dominant-baseline enable-background fill-opacity fill-rule flood-color flood-opacity font-family font-size font-size-adjust font-stretch font-style font-variant font-weight glyph-name glyph-orientation-horizontal glyph-orientation-vertical horiz-adv-x horiz-origin-x image-rendering letter-spacing lighting-color marker-end marker-mid marker-start overline-position overline-thickness paint-order panose-1 pointer-events rendering-intent shape-rendering stop-color stop-opacity strikethrough-position strikethrough-thickness stroke-dasharray stroke-dashoffset stroke-linecap stroke-linejoin stroke-miterlimit stroke-opacity stroke-width text-anchor text-decoration text-rendering underline-position underline-thickness unicode-bidi unicode-range units-per-em v-alphabetic v-hanging v-ideographic v-mathematical vector-effect vert-adv-y vert-origin-x vert-origin-y word-spacing writing-mode xmlns:xlink x-height".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,null,!1,!1)})),"xlink:actuate xlink:arcrole xlink:role xlink:show xlink:title xlink:type".split(" ").forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/1999/xlink",!1,!1)})),["xml:base","xml:lang","xml:space"].forEach((function(e){var t=e.replace(y,b);g[t]=new m(t,1,!1,e,"http://www.w3.org/XML/1998/namespace",!1,!1)})),["tabIndex","crossOrigin"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!1,!1)})),g.xlinkHref=new m("xlinkHref",1,!1,"xlink:href","http://www.w3.org/1999/xlink",!0,!1),["src","href","action","formAction"].forEach((function(e){g[e]=new m(e,1,!1,e.toLowerCase(),null,!0,!0)}));var x=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED,w=Symbol.for("react.element"),k=Symbol.for("react.portal"),S=Symbol.for("react.fragment"),I=Symbol.for("react.strict_mode"),N=Symbol.for("react.profiler"),T=Symbol.for("react.provider"),E=Symbol.for("react.context"),C=Symbol.for("react.forward_ref"),R=Symbol.for("react.suspense"),A=Symbol.for("react.suspense_list"),_=Symbol.for("react.memo"),D=Symbol.for("react.lazy");Symbol.for("react.scope"),Symbol.for("react.debug_trace_mode");var F=Symbol.for("react.offscreen");Symbol.for("react.legacy_hidden"),Symbol.for("react.cache"),Symbol.for("react.tracing_marker");var O=Symbol.iterator;function M(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=O&&e[O]||e["@@iterator"])?e:null}var L,z=Object.assign;function P(e){if(void 0===L)try{throw Error()}catch(n){var t=n.stack.trim().match(/\n( *(at )?)/);L=t&&t[1]||""}return"\n"+L+e}var B=!1;function W(e,t){if(!e||B)return"";B=!0;var n=Error.prepareStackTrace;Error.prepareStackTrace=void 0;try{if(t)if(t=function(){throw Error()},Object.defineProperty(t.prototype,"props",{set:function(){throw Error()}}),"object"===typeof Reflect&&Reflect.construct){try{Reflect.construct(t,[])}catch(l){var a=l}Reflect.construct(e,[],t)}else{try{t.call()}catch(l){a=l}e.call(t.prototype)}else{try{throw Error()}catch(l){a=l}e()}}catch(l){if(l&&a&&"string"===typeof l.stack){for(var r=l.stack.split("\n"),s=a.stack.split("\n"),o=r.length-1,i=s.length-1;1<=o&&0<=i&&r[o]!==s[i];)i--;for(;1<=o&&0<=i;o--,i--)if(r[o]!==s[i]){if(1!==o||1!==i)do{if(o--,0>--i||r[o]!==s[i]){var c="\n"+r[o].replace(" at new "," at ");return e.displayName&&c.includes("<anonymous>")&&(c=c.replace("<anonymous>",e.displayName)),c}}while(1<=o&&0<=i);break}}}finally{B=!1,Error.prepareStackTrace=n}return(e=e?e.displayName||e.name:"")?P(e):""}function V(e){switch(e.tag){case 5:return P(e.type);case 16:return P("Lazy");case 13:return P("Suspense");case 19:return P("SuspenseList");case 0:case 2:case 15:return e=W(e.type,!1);case 11:return e=W(e.type.render,!1);case 1:return e=W(e.type,!0);default:return""}}function U(e){if(null==e)return null;if("function"===typeof e)return e.displayName||e.name||null;if("string"===typeof e)return e;switch(e){case S:return"Fragment";case k:return"Portal";case N:return"Profiler";case I:return"StrictMode";case R:return"Suspense";case A:return"SuspenseList"}if("object"===typeof e)switch(e.$$typeof){case E:return(e.displayName||"Context")+".Consumer";case T:return(e._context.displayName||"Context")+".Provider";case C:var t=e.render;return(e=e.displayName)||(e=""!==(e=t.displayName||t.name||"")?"ForwardRef("+e+")":"ForwardRef"),e;case _:return null!==(t=e.displayName||null)?t:U(e.type)||"Memo";case D:t=e._payload,e=e._init;try{return U(e(t))}catch(n){}}return null}function G(e){var t=e.type;switch(e.tag){case 24:return"Cache";case 9:return(t.displayName||"Context")+".Consumer";case 10:return(t._context.displayName||"Context")+".Provider";case 18:return"DehydratedFragment";case 11:return e=(e=t.render).displayName||e.name||"",t.displayName||(""!==e?"ForwardRef("+e+")":"ForwardRef");case 7:return"Fragment";case 5:return t;case 4:return"Portal";case 3:return"Root";case 6:return"Text";case 16:return U(t);case 8:return t===I?"StrictMode":"Mode";case 22:return"Offscreen";case 12:return"Profiler";case 21:return"Scope";case 13:return"Suspense";case 19:return"SuspenseList";case 25:return"TracingMarker";case 1:case 0:case 17:case 2:case 14:case 15:if("function"===typeof t)return t.displayName||t.name||null;if("string"===typeof t)return t}return null}function H(e){switch(typeof e){case"boolean":case"number":case"string":case"undefined":case"object":return e;default:return""}}function j(e){var t=e.type;return(e=e.nodeName)&&"input"===e.toLowerCase()&&("checkbox"===t||"radio"===t)}function K(e){e._valueTracker||(e._valueTracker=function(e){var t=j(e)?"checked":"value",n=Object.getOwnPropertyDescriptor(e.constructor.prototype,t),a=""+e[t];if(!e.hasOwnProperty(t)&&"undefined"!==typeof n&&"function"===typeof n.get&&"function"===typeof n.set){var r=n.get,s=n.set;return Object.defineProperty(e,t,{configurable:!0,get:function(){return r.call(this)},set:function(e){a=""+e,s.call(this,e)}}),Object.defineProperty(e,t,{enumerable:n.enumerable}),{getValue:function(){return a},setValue:function(e){a=""+e},stopTracking:function(){e._valueTracker=null,delete e[t]}}}}(e))}function q(e){if(!e)return!1;var t=e._valueTracker;if(!t)return!0;var n=t.getValue(),a="";return e&&(a=j(e)?e.checked?"true":"false":e.value),(e=a)!==n&&(t.setValue(e),!0)}function X(e){if("undefined"===typeof(e=e||("undefined"!==typeof document?document:void 0)))return null;try{return e.activeElement||e.body}catch(t){return e.body}}function Y(e,t){var n=t.checked;return z({},t,{defaultChecked:void 0,defaultValue:void 0,value:void 0,checked:null!=n?n:e._wrapperState.initialChecked})}function Q(e,t){var n=null==t.defaultValue?"":t.defaultValue,a=null!=t.checked?t.checked:t.defaultChecked;n=H(null!=t.value?t.value:n),e._wrapperState={initialChecked:a,initialValue:n,controlled:"checkbox"===t.type||"radio"===t.type?null!=t.checked:null!=t.value}}function J(e,t){null!=(t=t.checked)&&v(e,"checked",t,!1)}function Z(e,t){J(e,t);var n=H(t.value),a=t.type;if(null!=n)"number"===a?(0===n&&""===e.value||e.value!=n)&&(e.value=""+n):e.value!==""+n&&(e.value=""+n);else if("submit"===a||"reset"===a)return void e.removeAttribute("value");t.hasOwnProperty("value")?ee(e,t.type,n):t.hasOwnProperty("defaultValue")&&ee(e,t.type,H(t.defaultValue)),null==t.checked&&null!=t.defaultChecked&&(e.defaultChecked=!!t.defaultChecked)}function $(e,t,n){if(t.hasOwnProperty("value")||t.hasOwnProperty("defaultValue")){var a=t.type;if(!("submit"!==a&&"reset"!==a||void 0!==t.value&&null!==t.value))return;t=""+e._wrapperState.initialValue,n||t===e.value||(e.value=t),e.defaultValue=t}""!==(n=e.name)&&(e.name=""),e.defaultChecked=!!e._wrapperState.initialChecked,""!==n&&(e.name=n)}function ee(e,t,n){"number"===t&&X(e.ownerDocument)===e||(null==n?e.defaultValue=""+e._wrapperState.initialValue:e.defaultValue!==""+n&&(e.defaultValue=""+n))}var te=Array.isArray;function ne(e,t,n,a){if(e=e.options,t){t={};for(var r=0;r<n.length;r++)t["$"+n[r]]=!0;for(n=0;n<e.length;n++)r=t.hasOwnProperty("$"+e[n].value),e[n].selected!==r&&(e[n].selected=r),r&&a&&(e[n].defaultSelected=!0)}else{for(n=""+H(n),t=null,r=0;r<e.length;r++){if(e[r].value===n)return e[r].selected=!0,void(a&&(e[r].defaultSelected=!0));null!==t||e[r].disabled||(t=e[r])}null!==t&&(t.selected=!0)}}function ae(e,t){if(null!=t.dangerouslySetInnerHTML)throw Error(s(91));return z({},t,{value:void 0,defaultValue:void 0,children:""+e._wrapperState.initialValue})}function re(e,t){var n=t.value;if(null==n){if(n=t.children,t=t.defaultValue,null!=n){if(null!=t)throw Error(s(92));if(te(n)){if(1<n.length)throw Error(s(93));n=n[0]}t=n}null==t&&(t=""),n=t}e._wrapperState={initialValue:H(n)}}function se(e,t){var n=H(t.value),a=H(t.defaultValue);null!=n&&((n=""+n)!==e.value&&(e.value=n),null==t.defaultValue&&e.defaultValue!==n&&(e.defaultValue=n)),null!=a&&(e.defaultValue=""+a)}function oe(e){var t=e.textContent;t===e._wrapperState.initialValue&&""!==t&&null!==t&&(e.value=t)}function ie(e){switch(e){case"svg":return"http://www.w3.org/2000/svg";case"math":return"http://www.w3.org/1998/Math/MathML";default:return"http://www.w3.org/1999/xhtml"}}function ce(e,t){return null==e||"http://www.w3.org/1999/xhtml"===e?ie(t):"http://www.w3.org/2000/svg"===e&&"foreignObject"===t?"http://www.w3.org/1999/xhtml":e}var le,ue,he=(ue=function(e,t){if("http://www.w3.org/2000/svg"!==e.namespaceURI||"innerHTML"in e)e.innerHTML=t;else{for((le=le||document.createElement("div")).innerHTML="<svg>"+t.valueOf().toString()+"</svg>",t=le.firstChild;e.firstChild;)e.removeChild(e.firstChild);for(;t.firstChild;)e.appendChild(t.firstChild)}},"undefined"!==typeof MSApp&&MSApp.execUnsafeLocalFunction?function(e,t,n,a){MSApp.execUnsafeLocalFunction((function(){return ue(e,t)}))}:ue);function de(e,t){if(t){var n=e.firstChild;if(n&&n===e.lastChild&&3===n.nodeType)return void(n.nodeValue=t)}e.textContent=t}var pe={animationIterationCount:!0,aspectRatio:!0,borderImageOutset:!0,borderImageSlice:!0,borderImageWidth:!0,boxFlex:!0,boxFlexGroup:!0,boxOrdinalGroup:!0,columnCount:!0,columns:!0,flex:!0,flexGrow:!0,flexPositive:!0,flexShrink:!0,flexNegative:!0,flexOrder:!0,gridArea:!0,gridRow:!0,gridRowEnd:!0,gridRowSpan:!0,gridRowStart:!0,gridColumn:!0,gridColumnEnd:!0,gridColumnSpan:!0,gridColumnStart:!0,fontWeight:!0,lineClamp:!0,lineHeight:!0,opacity:!0,order:!0,orphans:!0,tabSize:!0,widows:!0,zIndex:!0,zoom:!0,fillOpacity:!0,floodOpacity:!0,stopOpacity:!0,strokeDasharray:!0,strokeDashoffset:!0,strokeMiterlimit:!0,strokeOpacity:!0,strokeWidth:!0},fe=["Webkit","ms","Moz","O"];function me(e,t,n){return null==t||"boolean"===typeof t||""===t?"":n||"number"!==typeof t||0===t||pe.hasOwnProperty(e)&&pe[e]?(""+t).trim():t+"px"}function ge(e,t){for(var n in e=e.style,t)if(t.hasOwnProperty(n)){var a=0===n.indexOf("--"),r=me(n,t[n],a);"float"===n&&(n="cssFloat"),a?e.setProperty(n,r):e[n]=r}}Object.keys(pe).forEach((function(e){fe.forEach((function(t){t=t+e.charAt(0).toUpperCase()+e.substring(1),pe[t]=pe[e]}))}));var ye=z({menuitem:!0},{area:!0,base:!0,br:!0,col:!0,embed:!0,hr:!0,img:!0,input:!0,keygen:!0,link:!0,meta:!0,param:!0,source:!0,track:!0,wbr:!0});function be(e,t){if(t){if(ye[e]&&(null!=t.children||null!=t.dangerouslySetInnerHTML))throw Error(s(137,e));if(null!=t.dangerouslySetInnerHTML){if(null!=t.children)throw Error(s(60));if("object"!==typeof t.dangerouslySetInnerHTML||!("__html"in t.dangerouslySetInnerHTML))throw Error(s(61))}if(null!=t.style&&"object"!==typeof t.style)throw Error(s(62))}}function ve(e,t){if(-1===e.indexOf("-"))return"string"===typeof t.is;switch(e){case"annotation-xml":case"color-profile":case"font-face":case"font-face-src":case"font-face-uri":case"font-face-format":case"font-face-name":case"missing-glyph":return!1;default:return!0}}var xe=null;function we(e){return(e=e.target||e.srcElement||window).correspondingUseElement&&(e=e.correspondingUseElement),3===e.nodeType?e.parentNode:e}var ke=null,Se=null,Ie=null;function Ne(e){if(e=vr(e)){if("function"!==typeof ke)throw Error(s(280));var t=e.stateNode;t&&(t=wr(t),ke(e.stateNode,e.type,t))}}function Te(e){Se?Ie?Ie.push(e):Ie=[e]:Se=e}function Ee(){if(Se){var e=Se,t=Ie;if(Ie=Se=null,Ne(e),t)for(e=0;e<t.length;e++)Ne(t[e])}}function Ce(e,t){return e(t)}function Re(){}var Ae=!1;function _e(e,t,n){if(Ae)return e(t,n);Ae=!0;try{return Ce(e,t,n)}finally{Ae=!1,(null!==Se||null!==Ie)&&(Re(),Ee())}}function De(e,t){var n=e.stateNode;if(null===n)return null;var a=wr(n);if(null===a)return null;n=a[t];e:switch(t){case"onClick":case"onClickCapture":case"onDoubleClick":case"onDoubleClickCapture":case"onMouseDown":case"onMouseDownCapture":case"onMouseMove":case"onMouseMoveCapture":case"onMouseUp":case"onMouseUpCapture":case"onMouseEnter":(a=!a.disabled)||(a=!("button"===(e=e.type)||"input"===e||"select"===e||"textarea"===e)),e=!a;break e;default:e=!1}if(e)return null;if(n&&"function"!==typeof n)throw Error(s(231,t,typeof n));return n}var Fe=!1;if(u)try{var Oe={};Object.defineProperty(Oe,"passive",{get:function(){Fe=!0}}),window.addEventListener("test",Oe,Oe),window.removeEventListener("test",Oe,Oe)}catch(ue){Fe=!1}function Me(e,t,n,a,r,s,o,i,c){var l=Array.prototype.slice.call(arguments,3);try{t.apply(n,l)}catch(u){this.onError(u)}}var Le=!1,ze=null,Pe=!1,Be=null,We={onError:function(e){Le=!0,ze=e}};function Ve(e,t,n,a,r,s,o,i,c){Le=!1,ze=null,Me.apply(We,arguments)}function Ue(e){var t=e,n=e;if(e.alternate)for(;t.return;)t=t.return;else{e=t;do{0!==(4098&(t=e).flags)&&(n=t.return),e=t.return}while(e)}return 3===t.tag?n:null}function Ge(e){if(13===e.tag){var t=e.memoizedState;if(null===t&&(null!==(e=e.alternate)&&(t=e.memoizedState)),null!==t)return t.dehydrated}return null}function He(e){if(Ue(e)!==e)throw Error(s(188))}function je(e){return null!==(e=function(e){var t=e.alternate;if(!t){if(null===(t=Ue(e)))throw Error(s(188));return t!==e?null:e}for(var n=e,a=t;;){var r=n.return;if(null===r)break;var o=r.alternate;if(null===o){if(null!==(a=r.return)){n=a;continue}break}if(r.child===o.child){for(o=r.child;o;){if(o===n)return He(r),e;if(o===a)return He(r),t;o=o.sibling}throw Error(s(188))}if(n.return!==a.return)n=r,a=o;else{for(var i=!1,c=r.child;c;){if(c===n){i=!0,n=r,a=o;break}if(c===a){i=!0,a=r,n=o;break}c=c.sibling}if(!i){for(c=o.child;c;){if(c===n){i=!0,n=o,a=r;break}if(c===a){i=!0,a=o,n=r;break}c=c.sibling}if(!i)throw Error(s(189))}}if(n.alternate!==a)throw Error(s(190))}if(3!==n.tag)throw Error(s(188));return n.stateNode.current===n?e:t}(e))?Ke(e):null}function Ke(e){if(5===e.tag||6===e.tag)return e;for(e=e.child;null!==e;){var t=Ke(e);if(null!==t)return t;e=e.sibling}return null}var qe=r.unstable_scheduleCallback,Xe=r.unstable_cancelCallback,Ye=r.unstable_shouldYield,Qe=r.unstable_requestPaint,Je=r.unstable_now,Ze=r.unstable_getCurrentPriorityLevel,$e=r.unstable_ImmediatePriority,et=r.unstable_UserBlockingPriority,tt=r.unstable_NormalPriority,nt=r.unstable_LowPriority,at=r.unstable_IdlePriority,rt=null,st=null;var ot=Math.clz32?Math.clz32:function(e){return e>>>=0,0===e?32:31-(it(e)/ct|0)|0},it=Math.log,ct=Math.LN2;var lt=64,ut=4194304;function ht(e){switch(e&-e){case 1:return 1;case 2:return 2;case 4:return 4;case 8:return 8;case 16:return 16;case 32:return 32;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return 4194240&e;case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:return 130023424&e;case 134217728:return 134217728;case 268435456:return 268435456;case 536870912:return 536870912;case 1073741824:return 1073741824;default:return e}}function dt(e,t){var n=e.pendingLanes;if(0===n)return 0;var a=0,r=e.suspendedLanes,s=e.pingedLanes,o=268435455&n;if(0!==o){var i=o&~r;0!==i?a=ht(i):0!==(s&=o)&&(a=ht(s))}else 0!==(o=n&~r)?a=ht(o):0!==s&&(a=ht(s));if(0===a)return 0;if(0!==t&&t!==a&&0===(t&r)&&((r=a&-a)>=(s=t&-t)||16===r&&0!==(4194240&s)))return t;if(0!==(4&a)&&(a|=16&n),0!==(t=e.entangledLanes))for(e=e.entanglements,t&=a;0<t;)r=1<<(n=31-ot(t)),a|=e[n],t&=~r;return a}function pt(e,t){switch(e){case 1:case 2:case 4:return t+250;case 8:case 16:case 32:case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:return t+5e3;default:return-1}}function ft(e){return 0!==(e=-1073741825&e.pendingLanes)?e:1073741824&e?1073741824:0}function mt(){var e=lt;return 0===(4194240&(lt<<=1))&&(lt=64),e}function gt(e){for(var t=[],n=0;31>n;n++)t.push(e);return t}function yt(e,t,n){e.pendingLanes|=t,536870912!==t&&(e.suspendedLanes=0,e.pingedLanes=0),(e=e.eventTimes)[t=31-ot(t)]=n}function bt(e,t){var n=e.entangledLanes|=t;for(e=e.entanglements;n;){var a=31-ot(n),r=1<<a;r&t|e[a]&t&&(e[a]|=t),n&=~r}}var vt=0;function xt(e){return 1<(e&=-e)?4<e?0!==(268435455&e)?16:536870912:4:1}var wt,kt,St,It,Nt,Tt=!1,Et=[],Ct=null,Rt=null,At=null,_t=new Map,Dt=new Map,Ft=[],Ot="mousedown mouseup touchcancel touchend touchstart auxclick dblclick pointercancel pointerdown pointerup dragend dragstart drop compositionend compositionstart keydown keypress keyup input textInput copy cut paste click change contextmenu reset submit".split(" ");function Mt(e,t){switch(e){case"focusin":case"focusout":Ct=null;break;case"dragenter":case"dragleave":Rt=null;break;case"mouseover":case"mouseout":At=null;break;case"pointerover":case"pointerout":_t.delete(t.pointerId);break;case"gotpointercapture":case"lostpointercapture":Dt.delete(t.pointerId)}}function Lt(e,t,n,a,r,s){return null===e||e.nativeEvent!==s?(e={blockedOn:t,domEventName:n,eventSystemFlags:a,nativeEvent:s,targetContainers:[r]},null!==t&&(null!==(t=vr(t))&&kt(t)),e):(e.eventSystemFlags|=a,t=e.targetContainers,null!==r&&-1===t.indexOf(r)&&t.push(r),e)}function zt(e){var t=br(e.target);if(null!==t){var n=Ue(t);if(null!==n)if(13===(t=n.tag)){if(null!==(t=Ge(n)))return e.blockedOn=t,void Nt(e.priority,(function(){St(n)}))}else if(3===t&&n.stateNode.current.memoizedState.isDehydrated)return void(e.blockedOn=3===n.tag?n.stateNode.containerInfo:null)}e.blockedOn=null}function Pt(e){if(null!==e.blockedOn)return!1;for(var t=e.targetContainers;0<t.length;){var n=Yt(e.domEventName,e.eventSystemFlags,t[0],e.nativeEvent);if(null!==n)return null!==(t=vr(n))&&kt(t),e.blockedOn=n,!1;var a=new(n=e.nativeEvent).constructor(n.type,n);xe=a,n.target.dispatchEvent(a),xe=null,t.shift()}return!0}function Bt(e,t,n){Pt(e)&&n.delete(t)}function Wt(){Tt=!1,null!==Ct&&Pt(Ct)&&(Ct=null),null!==Rt&&Pt(Rt)&&(Rt=null),null!==At&&Pt(At)&&(At=null),_t.forEach(Bt),Dt.forEach(Bt)}function Vt(e,t){e.blockedOn===t&&(e.blockedOn=null,Tt||(Tt=!0,r.unstable_scheduleCallback(r.unstable_NormalPriority,Wt)))}function Ut(e){function t(t){return Vt(t,e)}if(0<Et.length){Vt(Et[0],e);for(var n=1;n<Et.length;n++){var a=Et[n];a.blockedOn===e&&(a.blockedOn=null)}}for(null!==Ct&&Vt(Ct,e),null!==Rt&&Vt(Rt,e),null!==At&&Vt(At,e),_t.forEach(t),Dt.forEach(t),n=0;n<Ft.length;n++)(a=Ft[n]).blockedOn===e&&(a.blockedOn=null);for(;0<Ft.length&&null===(n=Ft[0]).blockedOn;)zt(n),null===n.blockedOn&&Ft.shift()}var Gt=x.ReactCurrentBatchConfig,Ht=!0;function jt(e,t,n,a){var r=vt,s=Gt.transition;Gt.transition=null;try{vt=1,qt(e,t,n,a)}finally{vt=r,Gt.transition=s}}function Kt(e,t,n,a){var r=vt,s=Gt.transition;Gt.transition=null;try{vt=4,qt(e,t,n,a)}finally{vt=r,Gt.transition=s}}function qt(e,t,n,a){if(Ht){var r=Yt(e,t,n,a);if(null===r)Ha(e,t,a,Xt,n),Mt(e,a);else if(function(e,t,n,a,r){switch(t){case"focusin":return Ct=Lt(Ct,e,t,n,a,r),!0;case"dragenter":return Rt=Lt(Rt,e,t,n,a,r),!0;case"mouseover":return At=Lt(At,e,t,n,a,r),!0;case"pointerover":var s=r.pointerId;return _t.set(s,Lt(_t.get(s)||null,e,t,n,a,r)),!0;case"gotpointercapture":return s=r.pointerId,Dt.set(s,Lt(Dt.get(s)||null,e,t,n,a,r)),!0}return!1}(r,e,t,n,a))a.stopPropagation();else if(Mt(e,a),4&t&&-1<Ot.indexOf(e)){for(;null!==r;){var s=vr(r);if(null!==s&&wt(s),null===(s=Yt(e,t,n,a))&&Ha(e,t,a,Xt,n),s===r)break;r=s}null!==r&&a.stopPropagation()}else Ha(e,t,a,null,n)}}var Xt=null;function Yt(e,t,n,a){if(Xt=null,null!==(e=br(e=we(a))))if(null===(t=Ue(e)))e=null;else if(13===(n=t.tag)){if(null!==(e=Ge(t)))return e;e=null}else if(3===n){if(t.stateNode.current.memoizedState.isDehydrated)return 3===t.tag?t.stateNode.containerInfo:null;e=null}else t!==e&&(e=null);return Xt=e,null}function Qt(e){switch(e){case"cancel":case"click":case"close":case"contextmenu":case"copy":case"cut":case"auxclick":case"dblclick":case"dragend":case"dragstart":case"drop":case"focusin":case"focusout":case"input":case"invalid":case"keydown":case"keypress":case"keyup":case"mousedown":case"mouseup":case"paste":case"pause":case"play":case"pointercancel":case"pointerdown":case"pointerup":case"ratechange":case"reset":case"resize":case"seeked":case"submit":case"touchcancel":case"touchend":case"touchstart":case"volumechange":case"change":case"selectionchange":case"textInput":case"compositionstart":case"compositionend":case"compositionupdate":case"beforeblur":case"afterblur":case"beforeinput":case"blur":case"fullscreenchange":case"focus":case"hashchange":case"popstate":case"select":case"selectstart":return 1;case"drag":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"mousemove":case"mouseout":case"mouseover":case"pointermove":case"pointerout":case"pointerover":case"scroll":case"toggle":case"touchmove":case"wheel":case"mouseenter":case"mouseleave":case"pointerenter":case"pointerleave":return 4;case"message":switch(Ze()){case $e:return 1;case et:return 4;case tt:case nt:return 16;case at:return 536870912;default:return 16}default:return 16}}var Jt=null,Zt=null,$t=null;function en(){if($t)return $t;var e,t,n=Zt,a=n.length,r="value"in Jt?Jt.value:Jt.textContent,s=r.length;for(e=0;e<a&&n[e]===r[e];e++);var o=a-e;for(t=1;t<=o&&n[a-t]===r[s-t];t++);return $t=r.slice(e,1<t?1-t:void 0)}function tn(e){var t=e.keyCode;return"charCode"in e?0===(e=e.charCode)&&13===t&&(e=13):e=t,10===e&&(e=13),32<=e||13===e?e:0}function nn(){return!0}function an(){return!1}function rn(e){function t(t,n,a,r,s){for(var o in this._reactName=t,this._targetInst=a,this.type=n,this.nativeEvent=r,this.target=s,this.currentTarget=null,e)e.hasOwnProperty(o)&&(t=e[o],this[o]=t?t(r):r[o]);return this.isDefaultPrevented=(null!=r.defaultPrevented?r.defaultPrevented:!1===r.returnValue)?nn:an,this.isPropagationStopped=an,this}return z(t.prototype,{preventDefault:function(){this.defaultPrevented=!0;var e=this.nativeEvent;e&&(e.preventDefault?e.preventDefault():"unknown"!==typeof e.returnValue&&(e.returnValue=!1),this.isDefaultPrevented=nn)},stopPropagation:function(){var e=this.nativeEvent;e&&(e.stopPropagation?e.stopPropagation():"unknown"!==typeof e.cancelBubble&&(e.cancelBubble=!0),this.isPropagationStopped=nn)},persist:function(){},isPersistent:nn}),t}var sn,on,cn,ln={eventPhase:0,bubbles:0,cancelable:0,timeStamp:function(e){return e.timeStamp||Date.now()},defaultPrevented:0,isTrusted:0},un=rn(ln),hn=z({},ln,{view:0,detail:0}),dn=rn(hn),pn=z({},hn,{screenX:0,screenY:0,clientX:0,clientY:0,pageX:0,pageY:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,getModifierState:Nn,button:0,buttons:0,relatedTarget:function(e){return void 0===e.relatedTarget?e.fromElement===e.srcElement?e.toElement:e.fromElement:e.relatedTarget},movementX:function(e){return"movementX"in e?e.movementX:(e!==cn&&(cn&&"mousemove"===e.type?(sn=e.screenX-cn.screenX,on=e.screenY-cn.screenY):on=sn=0,cn=e),sn)},movementY:function(e){return"movementY"in e?e.movementY:on}}),fn=rn(pn),mn=rn(z({},pn,{dataTransfer:0})),gn=rn(z({},hn,{relatedTarget:0})),yn=rn(z({},ln,{animationName:0,elapsedTime:0,pseudoElement:0})),bn=z({},ln,{clipboardData:function(e){return"clipboardData"in e?e.clipboardData:window.clipboardData}}),vn=rn(bn),xn=rn(z({},ln,{data:0})),wn={Esc:"Escape",Spacebar:" ",Left:"ArrowLeft",Up:"ArrowUp",Right:"ArrowRight",Down:"ArrowDown",Del:"Delete",Win:"OS",Menu:"ContextMenu",Apps:"ContextMenu",Scroll:"ScrollLock",MozPrintableKey:"Unidentified"},kn={8:"Backspace",9:"Tab",12:"Clear",13:"Enter",16:"Shift",17:"Control",18:"Alt",19:"Pause",20:"CapsLock",27:"Escape",32:" ",33:"PageUp",34:"PageDown",35:"End",36:"Home",37:"ArrowLeft",38:"ArrowUp",39:"ArrowRight",40:"ArrowDown",45:"Insert",46:"Delete",112:"F1",113:"F2",114:"F3",115:"F4",116:"F5",117:"F6",118:"F7",119:"F8",120:"F9",121:"F10",122:"F11",123:"F12",144:"NumLock",145:"ScrollLock",224:"Meta"},Sn={Alt:"altKey",Control:"ctrlKey",Meta:"metaKey",Shift:"shiftKey"};function In(e){var t=this.nativeEvent;return t.getModifierState?t.getModifierState(e):!!(e=Sn[e])&&!!t[e]}function Nn(){return In}var Tn=z({},hn,{key:function(e){if(e.key){var t=wn[e.key]||e.key;if("Unidentified"!==t)return t}return"keypress"===e.type?13===(e=tn(e))?"Enter":String.fromCharCode(e):"keydown"===e.type||"keyup"===e.type?kn[e.keyCode]||"Unidentified":""},code:0,location:0,ctrlKey:0,shiftKey:0,altKey:0,metaKey:0,repeat:0,locale:0,getModifierState:Nn,charCode:function(e){return"keypress"===e.type?tn(e):0},keyCode:function(e){return"keydown"===e.type||"keyup"===e.type?e.keyCode:0},which:function(e){return"keypress"===e.type?tn(e):"keydown"===e.type||"keyup"===e.type?e.keyCode:0}}),En=rn(Tn),Cn=rn(z({},pn,{pointerId:0,width:0,height:0,pressure:0,tangentialPressure:0,tiltX:0,tiltY:0,twist:0,pointerType:0,isPrimary:0})),Rn=rn(z({},hn,{touches:0,targetTouches:0,changedTouches:0,altKey:0,metaKey:0,ctrlKey:0,shiftKey:0,getModifierState:Nn})),An=rn(z({},ln,{propertyName:0,elapsedTime:0,pseudoElement:0})),_n=z({},pn,{deltaX:function(e){return"deltaX"in e?e.deltaX:"wheelDeltaX"in e?-e.wheelDeltaX:0},deltaY:function(e){return"deltaY"in e?e.deltaY:"wheelDeltaY"in e?-e.wheelDeltaY:"wheelDelta"in e?-e.wheelDelta:0},deltaZ:0,deltaMode:0}),Dn=rn(_n),Fn=[9,13,27,32],On=u&&"CompositionEvent"in window,Mn=null;u&&"documentMode"in document&&(Mn=document.documentMode);var Ln=u&&"TextEvent"in window&&!Mn,zn=u&&(!On||Mn&&8<Mn&&11>=Mn),Pn=String.fromCharCode(32),Bn=!1;function Wn(e,t){switch(e){case"keyup":return-1!==Fn.indexOf(t.keyCode);case"keydown":return 229!==t.keyCode;case"keypress":case"mousedown":case"focusout":return!0;default:return!1}}function Vn(e){return"object"===typeof(e=e.detail)&&"data"in e?e.data:null}var Un=!1;var Gn={color:!0,date:!0,datetime:!0,"datetime-local":!0,email:!0,month:!0,number:!0,password:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0};function Hn(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return"input"===t?!!Gn[e.type]:"textarea"===t}function jn(e,t,n,a){Te(a),0<(t=Ka(t,"onChange")).length&&(n=new un("onChange","change",null,n,a),e.push({event:n,listeners:t}))}var Kn=null,qn=null;function Xn(e){Pa(e,0)}function Yn(e){if(q(xr(e)))return e}function Qn(e,t){if("change"===e)return t}var Jn=!1;if(u){var Zn;if(u){var $n="oninput"in document;if(!$n){var ea=document.createElement("div");ea.setAttribute("oninput","return;"),$n="function"===typeof ea.oninput}Zn=$n}else Zn=!1;Jn=Zn&&(!document.documentMode||9<document.documentMode)}function ta(){Kn&&(Kn.detachEvent("onpropertychange",na),qn=Kn=null)}function na(e){if("value"===e.propertyName&&Yn(qn)){var t=[];jn(t,qn,e,we(e)),_e(Xn,t)}}function aa(e,t,n){"focusin"===e?(ta(),qn=n,(Kn=t).attachEvent("onpropertychange",na)):"focusout"===e&&ta()}function ra(e){if("selectionchange"===e||"keyup"===e||"keydown"===e)return Yn(qn)}function sa(e,t){if("click"===e)return Yn(t)}function oa(e,t){if("input"===e||"change"===e)return Yn(t)}var ia="function"===typeof Object.is?Object.is:function(e,t){return e===t&&(0!==e||1/e===1/t)||e!==e&&t!==t};function ca(e,t){if(ia(e,t))return!0;if("object"!==typeof e||null===e||"object"!==typeof t||null===t)return!1;var n=Object.keys(e),a=Object.keys(t);if(n.length!==a.length)return!1;for(a=0;a<n.length;a++){var r=n[a];if(!h.call(t,r)||!ia(e[r],t[r]))return!1}return!0}function la(e){for(;e&&e.firstChild;)e=e.firstChild;return e}function ua(e,t){var n,a=la(e);for(e=0;a;){if(3===a.nodeType){if(n=e+a.textContent.length,e<=t&&n>=t)return{node:a,offset:t-e};e=n}e:{for(;a;){if(a.nextSibling){a=a.nextSibling;break e}a=a.parentNode}a=void 0}a=la(a)}}function ha(e,t){return!(!e||!t)&&(e===t||(!e||3!==e.nodeType)&&(t&&3===t.nodeType?ha(e,t.parentNode):"contains"in e?e.contains(t):!!e.compareDocumentPosition&&!!(16&e.compareDocumentPosition(t))))}function da(){for(var e=window,t=X();t instanceof e.HTMLIFrameElement;){try{var n="string"===typeof t.contentWindow.location.href}catch(a){n=!1}if(!n)break;t=X((e=t.contentWindow).document)}return t}function pa(e){var t=e&&e.nodeName&&e.nodeName.toLowerCase();return t&&("input"===t&&("text"===e.type||"search"===e.type||"tel"===e.type||"url"===e.type||"password"===e.type)||"textarea"===t||"true"===e.contentEditable)}function fa(e){var t=da(),n=e.focusedElem,a=e.selectionRange;if(t!==n&&n&&n.ownerDocument&&ha(n.ownerDocument.documentElement,n)){if(null!==a&&pa(n))if(t=a.start,void 0===(e=a.end)&&(e=t),"selectionStart"in n)n.selectionStart=t,n.selectionEnd=Math.min(e,n.value.length);else if((e=(t=n.ownerDocument||document)&&t.defaultView||window).getSelection){e=e.getSelection();var r=n.textContent.length,s=Math.min(a.start,r);a=void 0===a.end?s:Math.min(a.end,r),!e.extend&&s>a&&(r=a,a=s,s=r),r=ua(n,s);var o=ua(n,a);r&&o&&(1!==e.rangeCount||e.anchorNode!==r.node||e.anchorOffset!==r.offset||e.focusNode!==o.node||e.focusOffset!==o.offset)&&((t=t.createRange()).setStart(r.node,r.offset),e.removeAllRanges(),s>a?(e.addRange(t),e.extend(o.node,o.offset)):(t.setEnd(o.node,o.offset),e.addRange(t)))}for(t=[],e=n;e=e.parentNode;)1===e.nodeType&&t.push({element:e,left:e.scrollLeft,top:e.scrollTop});for("function"===typeof n.focus&&n.focus(),n=0;n<t.length;n++)(e=t[n]).element.scrollLeft=e.left,e.element.scrollTop=e.top}}var ma=u&&"documentMode"in document&&11>=document.documentMode,ga=null,ya=null,ba=null,va=!1;function xa(e,t,n){var a=n.window===n?n.document:9===n.nodeType?n:n.ownerDocument;va||null==ga||ga!==X(a)||("selectionStart"in(a=ga)&&pa(a)?a={start:a.selectionStart,end:a.selectionEnd}:a={anchorNode:(a=(a.ownerDocument&&a.ownerDocument.defaultView||window).getSelection()).anchorNode,anchorOffset:a.anchorOffset,focusNode:a.focusNode,focusOffset:a.focusOffset},ba&&ca(ba,a)||(ba=a,0<(a=Ka(ya,"onSelect")).length&&(t=new un("onSelect","select",null,t,n),e.push({event:t,listeners:a}),t.target=ga)))}function wa(e,t){var n={};return n[e.toLowerCase()]=t.toLowerCase(),n["Webkit"+e]="webkit"+t,n["Moz"+e]="moz"+t,n}var ka={animationend:wa("Animation","AnimationEnd"),animationiteration:wa("Animation","AnimationIteration"),animationstart:wa("Animation","AnimationStart"),transitionend:wa("Transition","TransitionEnd")},Sa={},Ia={};function Na(e){if(Sa[e])return Sa[e];if(!ka[e])return e;var t,n=ka[e];for(t in n)if(n.hasOwnProperty(t)&&t in Ia)return Sa[e]=n[t];return e}u&&(Ia=document.createElement("div").style,"AnimationEvent"in window||(delete ka.animationend.animation,delete ka.animationiteration.animation,delete ka.animationstart.animation),"TransitionEvent"in window||delete ka.transitionend.transition);var Ta=Na("animationend"),Ea=Na("animationiteration"),Ca=Na("animationstart"),Ra=Na("transitionend"),Aa=new Map,_a="abort auxClick cancel canPlay canPlayThrough click close contextMenu copy cut drag dragEnd dragEnter dragExit dragLeave dragOver dragStart drop durationChange emptied encrypted ended error gotPointerCapture input invalid keyDown keyPress keyUp load loadedData loadedMetadata loadStart lostPointerCapture mouseDown mouseMove mouseOut mouseOver mouseUp paste pause play playing pointerCancel pointerDown pointerMove pointerOut pointerOver pointerUp progress rateChange reset resize seeked seeking stalled submit suspend timeUpdate touchCancel touchEnd touchStart volumeChange scroll toggle touchMove waiting wheel".split(" ");function Da(e,t){Aa.set(e,t),c(t,[e])}for(var Fa=0;Fa<_a.length;Fa++){var Oa=_a[Fa];Da(Oa.toLowerCase(),"on"+(Oa[0].toUpperCase()+Oa.slice(1)))}Da(Ta,"onAnimationEnd"),Da(Ea,"onAnimationIteration"),Da(Ca,"onAnimationStart"),Da("dblclick","onDoubleClick"),Da("focusin","onFocus"),Da("focusout","onBlur"),Da(Ra,"onTransitionEnd"),l("onMouseEnter",["mouseout","mouseover"]),l("onMouseLeave",["mouseout","mouseover"]),l("onPointerEnter",["pointerout","pointerover"]),l("onPointerLeave",["pointerout","pointerover"]),c("onChange","change click focusin focusout input keydown keyup selectionchange".split(" ")),c("onSelect","focusout contextmenu dragend focusin keydown keyup mousedown mouseup selectionchange".split(" ")),c("onBeforeInput",["compositionend","keypress","textInput","paste"]),c("onCompositionEnd","compositionend focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionStart","compositionstart focusout keydown keypress keyup mousedown".split(" ")),c("onCompositionUpdate","compositionupdate focusout keydown keypress keyup mousedown".split(" "));var Ma="abort canplay canplaythrough durationchange emptied encrypted ended error loadeddata loadedmetadata loadstart pause play playing progress ratechange resize seeked seeking stalled suspend timeupdate volumechange waiting".split(" "),La=new Set("cancel close invalid load scroll toggle".split(" ").concat(Ma));function za(e,t,n){var a=e.type||"unknown-event";e.currentTarget=n,function(e,t,n,a,r,o,i,c,l){if(Ve.apply(this,arguments),Le){if(!Le)throw Error(s(198));var u=ze;Le=!1,ze=null,Pe||(Pe=!0,Be=u)}}(a,t,void 0,e),e.currentTarget=null}function Pa(e,t){t=0!==(4&t);for(var n=0;n<e.length;n++){var a=e[n],r=a.event;a=a.listeners;e:{var s=void 0;if(t)for(var o=a.length-1;0<=o;o--){var i=a[o],c=i.instance,l=i.currentTarget;if(i=i.listener,c!==s&&r.isPropagationStopped())break e;za(r,i,l),s=c}else for(o=0;o<a.length;o++){if(c=(i=a[o]).instance,l=i.currentTarget,i=i.listener,c!==s&&r.isPropagationStopped())break e;za(r,i,l),s=c}}}if(Pe)throw e=Be,Pe=!1,Be=null,e}function Ba(e,t){var n=t[mr];void 0===n&&(n=t[mr]=new Set);var a=e+"__bubble";n.has(a)||(Ga(t,e,2,!1),n.add(a))}function Wa(e,t,n){var a=0;t&&(a|=4),Ga(n,e,a,t)}var Va="_reactListening"+Math.random().toString(36).slice(2);function Ua(e){if(!e[Va]){e[Va]=!0,o.forEach((function(t){"selectionchange"!==t&&(La.has(t)||Wa(t,!1,e),Wa(t,!0,e))}));var t=9===e.nodeType?e:e.ownerDocument;null===t||t[Va]||(t[Va]=!0,Wa("selectionchange",!1,t))}}function Ga(e,t,n,a){switch(Qt(t)){case 1:var r=jt;break;case 4:r=Kt;break;default:r=qt}n=r.bind(null,t,n,e),r=void 0,!Fe||"touchstart"!==t&&"touchmove"!==t&&"wheel"!==t||(r=!0),a?void 0!==r?e.addEventListener(t,n,{capture:!0,passive:r}):e.addEventListener(t,n,!0):void 0!==r?e.addEventListener(t,n,{passive:r}):e.addEventListener(t,n,!1)}function Ha(e,t,n,a,r){var s=a;if(0===(1&t)&&0===(2&t)&&null!==a)e:for(;;){if(null===a)return;var o=a.tag;if(3===o||4===o){var i=a.stateNode.containerInfo;if(i===r||8===i.nodeType&&i.parentNode===r)break;if(4===o)for(o=a.return;null!==o;){var c=o.tag;if((3===c||4===c)&&((c=o.stateNode.containerInfo)===r||8===c.nodeType&&c.parentNode===r))return;o=o.return}for(;null!==i;){if(null===(o=br(i)))return;if(5===(c=o.tag)||6===c){a=s=o;continue e}i=i.parentNode}}a=a.return}_e((function(){var a=s,r=we(n),o=[];e:{var i=Aa.get(e);if(void 0!==i){var c=un,l=e;switch(e){case"keypress":if(0===tn(n))break e;case"keydown":case"keyup":c=En;break;case"focusin":l="focus",c=gn;break;case"focusout":l="blur",c=gn;break;case"beforeblur":case"afterblur":c=gn;break;case"click":if(2===n.button)break e;case"auxclick":case"dblclick":case"mousedown":case"mousemove":case"mouseup":case"mouseout":case"mouseover":case"contextmenu":c=fn;break;case"drag":case"dragend":case"dragenter":case"dragexit":case"dragleave":case"dragover":case"dragstart":case"drop":c=mn;break;case"touchcancel":case"touchend":case"touchmove":case"touchstart":c=Rn;break;case Ta:case Ea:case Ca:c=yn;break;case Ra:c=An;break;case"scroll":c=dn;break;case"wheel":c=Dn;break;case"copy":case"cut":case"paste":c=vn;break;case"gotpointercapture":case"lostpointercapture":case"pointercancel":case"pointerdown":case"pointermove":case"pointerout":case"pointerover":case"pointerup":c=Cn}var u=0!==(4&t),h=!u&&"scroll"===e,d=u?null!==i?i+"Capture":null:i;u=[];for(var p,f=a;null!==f;){var m=(p=f).stateNode;if(5===p.tag&&null!==m&&(p=m,null!==d&&(null!=(m=De(f,d))&&u.push(ja(f,m,p)))),h)break;f=f.return}0<u.length&&(i=new c(i,l,null,n,r),o.push({event:i,listeners:u}))}}if(0===(7&t)){if(c="mouseout"===e||"pointerout"===e,(!(i="mouseover"===e||"pointerover"===e)||n===xe||!(l=n.relatedTarget||n.fromElement)||!br(l)&&!l[fr])&&(c||i)&&(i=r.window===r?r:(i=r.ownerDocument)?i.defaultView||i.parentWindow:window,c?(c=a,null!==(l=(l=n.relatedTarget||n.toElement)?br(l):null)&&(l!==(h=Ue(l))||5!==l.tag&&6!==l.tag)&&(l=null)):(c=null,l=a),c!==l)){if(u=fn,m="onMouseLeave",d="onMouseEnter",f="mouse","pointerout"!==e&&"pointerover"!==e||(u=Cn,m="onPointerLeave",d="onPointerEnter",f="pointer"),h=null==c?i:xr(c),p=null==l?i:xr(l),(i=new u(m,f+"leave",c,n,r)).target=h,i.relatedTarget=p,m=null,br(r)===a&&((u=new u(d,f+"enter",l,n,r)).target=p,u.relatedTarget=h,m=u),h=m,c&&l)e:{for(d=l,f=0,p=u=c;p;p=qa(p))f++;for(p=0,m=d;m;m=qa(m))p++;for(;0<f-p;)u=qa(u),f--;for(;0<p-f;)d=qa(d),p--;for(;f--;){if(u===d||null!==d&&u===d.alternate)break e;u=qa(u),d=qa(d)}u=null}else u=null;null!==c&&Xa(o,i,c,u,!1),null!==l&&null!==h&&Xa(o,h,l,u,!0)}if("select"===(c=(i=a?xr(a):window).nodeName&&i.nodeName.toLowerCase())||"input"===c&&"file"===i.type)var g=Qn;else if(Hn(i))if(Jn)g=oa;else{g=ra;var y=aa}else(c=i.nodeName)&&"input"===c.toLowerCase()&&("checkbox"===i.type||"radio"===i.type)&&(g=sa);switch(g&&(g=g(e,a))?jn(o,g,n,r):(y&&y(e,i,a),"focusout"===e&&(y=i._wrapperState)&&y.controlled&&"number"===i.type&&ee(i,"number",i.value)),y=a?xr(a):window,e){case"focusin":(Hn(y)||"true"===y.contentEditable)&&(ga=y,ya=a,ba=null);break;case"focusout":ba=ya=ga=null;break;case"mousedown":va=!0;break;case"contextmenu":case"mouseup":case"dragend":va=!1,xa(o,n,r);break;case"selectionchange":if(ma)break;case"keydown":case"keyup":xa(o,n,r)}var b;if(On)e:{switch(e){case"compositionstart":var v="onCompositionStart";break e;case"compositionend":v="onCompositionEnd";break e;case"compositionupdate":v="onCompositionUpdate";break e}v=void 0}else Un?Wn(e,n)&&(v="onCompositionEnd"):"keydown"===e&&229===n.keyCode&&(v="onCompositionStart");v&&(zn&&"ko"!==n.locale&&(Un||"onCompositionStart"!==v?"onCompositionEnd"===v&&Un&&(b=en()):(Zt="value"in(Jt=r)?Jt.value:Jt.textContent,Un=!0)),0<(y=Ka(a,v)).length&&(v=new xn(v,e,null,n,r),o.push({event:v,listeners:y}),b?v.data=b:null!==(b=Vn(n))&&(v.data=b))),(b=Ln?function(e,t){switch(e){case"compositionend":return Vn(t);case"keypress":return 32!==t.which?null:(Bn=!0,Pn);case"textInput":return(e=t.data)===Pn&&Bn?null:e;default:return null}}(e,n):function(e,t){if(Un)return"compositionend"===e||!On&&Wn(e,t)?(e=en(),$t=Zt=Jt=null,Un=!1,e):null;switch(e){case"paste":default:return null;case"keypress":if(!(t.ctrlKey||t.altKey||t.metaKey)||t.ctrlKey&&t.altKey){if(t.char&&1<t.char.length)return t.char;if(t.which)return String.fromCharCode(t.which)}return null;case"compositionend":return zn&&"ko"!==t.locale?null:t.data}}(e,n))&&(0<(a=Ka(a,"onBeforeInput")).length&&(r=new xn("onBeforeInput","beforeinput",null,n,r),o.push({event:r,listeners:a}),r.data=b))}Pa(o,t)}))}function ja(e,t,n){return{instance:e,listener:t,currentTarget:n}}function Ka(e,t){for(var n=t+"Capture",a=[];null!==e;){var r=e,s=r.stateNode;5===r.tag&&null!==s&&(r=s,null!=(s=De(e,n))&&a.unshift(ja(e,s,r)),null!=(s=De(e,t))&&a.push(ja(e,s,r))),e=e.return}return a}function qa(e){if(null===e)return null;do{e=e.return}while(e&&5!==e.tag);return e||null}function Xa(e,t,n,a,r){for(var s=t._reactName,o=[];null!==n&&n!==a;){var i=n,c=i.alternate,l=i.stateNode;if(null!==c&&c===a)break;5===i.tag&&null!==l&&(i=l,r?null!=(c=De(n,s))&&o.unshift(ja(n,c,i)):r||null!=(c=De(n,s))&&o.push(ja(n,c,i))),n=n.return}0!==o.length&&e.push({event:t,listeners:o})}var Ya=/\r\n?/g,Qa=/\u0000|\uFFFD/g;function Ja(e){return("string"===typeof e?e:""+e).replace(Ya,"\n").replace(Qa,"")}function Za(e,t,n){if(t=Ja(t),Ja(e)!==t&&n)throw Error(s(425))}function $a(){}var er=null,tr=null;function nr(e,t){return"textarea"===e||"noscript"===e||"string"===typeof t.children||"number"===typeof t.children||"object"===typeof t.dangerouslySetInnerHTML&&null!==t.dangerouslySetInnerHTML&&null!=t.dangerouslySetInnerHTML.__html}var ar="function"===typeof setTimeout?setTimeout:void 0,rr="function"===typeof clearTimeout?clearTimeout:void 0,sr="function"===typeof Promise?Promise:void 0,or="function"===typeof queueMicrotask?queueMicrotask:"undefined"!==typeof sr?function(e){return sr.resolve(null).then(e).catch(ir)}:ar;function ir(e){setTimeout((function(){throw e}))}function cr(e,t){var n=t,a=0;do{var r=n.nextSibling;if(e.removeChild(n),r&&8===r.nodeType)if("/$"===(n=r.data)){if(0===a)return e.removeChild(r),void Ut(t);a--}else"$"!==n&&"$?"!==n&&"$!"!==n||a++;n=r}while(n);Ut(t)}function lr(e){for(;null!=e;e=e.nextSibling){var t=e.nodeType;if(1===t||3===t)break;if(8===t){if("$"===(t=e.data)||"$!"===t||"$?"===t)break;if("/$"===t)return null}}return e}function ur(e){e=e.previousSibling;for(var t=0;e;){if(8===e.nodeType){var n=e.data;if("$"===n||"$!"===n||"$?"===n){if(0===t)return e;t--}else"/$"===n&&t++}e=e.previousSibling}return null}var hr=Math.random().toString(36).slice(2),dr="__reactFiber$"+hr,pr="__reactProps$"+hr,fr="__reactContainer$"+hr,mr="__reactEvents$"+hr,gr="__reactListeners$"+hr,yr="__reactHandles$"+hr;function br(e){var t=e[dr];if(t)return t;for(var n=e.parentNode;n;){if(t=n[fr]||n[dr]){if(n=t.alternate,null!==t.child||null!==n&&null!==n.child)for(e=ur(e);null!==e;){if(n=e[dr])return n;e=ur(e)}return t}n=(e=n).parentNode}return null}function vr(e){return!(e=e[dr]||e[fr])||5!==e.tag&&6!==e.tag&&13!==e.tag&&3!==e.tag?null:e}function xr(e){if(5===e.tag||6===e.tag)return e.stateNode;throw Error(s(33))}function wr(e){return e[pr]||null}var kr=[],Sr=-1;function Ir(e){return{current:e}}function Nr(e){0>Sr||(e.current=kr[Sr],kr[Sr]=null,Sr--)}function Tr(e,t){Sr++,kr[Sr]=e.current,e.current=t}var Er={},Cr=Ir(Er),Rr=Ir(!1),Ar=Er;function _r(e,t){var n=e.type.contextTypes;if(!n)return Er;var a=e.stateNode;if(a&&a.__reactInternalMemoizedUnmaskedChildContext===t)return a.__reactInternalMemoizedMaskedChildContext;var r,s={};for(r in n)s[r]=t[r];return a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=t,e.__reactInternalMemoizedMaskedChildContext=s),s}function Dr(e){return null!==(e=e.childContextTypes)&&void 0!==e}function Fr(){Nr(Rr),Nr(Cr)}function Or(e,t,n){if(Cr.current!==Er)throw Error(s(168));Tr(Cr,t),Tr(Rr,n)}function Mr(e,t,n){var a=e.stateNode;if(t=t.childContextTypes,"function"!==typeof a.getChildContext)return n;for(var r in a=a.getChildContext())if(!(r in t))throw Error(s(108,G(e)||"Unknown",r));return z({},n,a)}function Lr(e){return e=(e=e.stateNode)&&e.__reactInternalMemoizedMergedChildContext||Er,Ar=Cr.current,Tr(Cr,e),Tr(Rr,Rr.current),!0}function zr(e,t,n){var a=e.stateNode;if(!a)throw Error(s(169));n?(e=Mr(e,t,Ar),a.__reactInternalMemoizedMergedChildContext=e,Nr(Rr),Nr(Cr),Tr(Cr,e)):Nr(Rr),Tr(Rr,n)}var Pr=null,Br=!1,Wr=!1;function Vr(e){null===Pr?Pr=[e]:Pr.push(e)}function Ur(){if(!Wr&&null!==Pr){Wr=!0;var e=0,t=vt;try{var n=Pr;for(vt=1;e<n.length;e++){var a=n[e];do{a=a(!0)}while(null!==a)}Pr=null,Br=!1}catch(r){throw null!==Pr&&(Pr=Pr.slice(e+1)),qe($e,Ur),r}finally{vt=t,Wr=!1}}return null}var Gr=[],Hr=0,jr=null,Kr=0,qr=[],Xr=0,Yr=null,Qr=1,Jr="";function Zr(e,t){Gr[Hr++]=Kr,Gr[Hr++]=jr,jr=e,Kr=t}function $r(e,t,n){qr[Xr++]=Qr,qr[Xr++]=Jr,qr[Xr++]=Yr,Yr=e;var a=Qr;e=Jr;var r=32-ot(a)-1;a&=~(1<<r),n+=1;var s=32-ot(t)+r;if(30<s){var o=r-r%5;s=(a&(1<<o)-1).toString(32),a>>=o,r-=o,Qr=1<<32-ot(t)+r|n<<r|a,Jr=s+e}else Qr=1<<s|n<<r|a,Jr=e}function es(e){null!==e.return&&(Zr(e,1),$r(e,1,0))}function ts(e){for(;e===jr;)jr=Gr[--Hr],Gr[Hr]=null,Kr=Gr[--Hr],Gr[Hr]=null;for(;e===Yr;)Yr=qr[--Xr],qr[Xr]=null,Jr=qr[--Xr],qr[Xr]=null,Qr=qr[--Xr],qr[Xr]=null}var ns=null,as=null,rs=!1,ss=null;function os(e,t){var n=_l(5,null,null,0);n.elementType="DELETED",n.stateNode=t,n.return=e,null===(t=e.deletions)?(e.deletions=[n],e.flags|=16):t.push(n)}function is(e,t){switch(e.tag){case 5:var n=e.type;return null!==(t=1!==t.nodeType||n.toLowerCase()!==t.nodeName.toLowerCase()?null:t)&&(e.stateNode=t,ns=e,as=lr(t.firstChild),!0);case 6:return null!==(t=""===e.pendingProps||3!==t.nodeType?null:t)&&(e.stateNode=t,ns=e,as=null,!0);case 13:return null!==(t=8!==t.nodeType?null:t)&&(n=null!==Yr?{id:Qr,overflow:Jr}:null,e.memoizedState={dehydrated:t,treeContext:n,retryLane:1073741824},(n=_l(18,null,null,0)).stateNode=t,n.return=e,e.child=n,ns=e,as=null,!0);default:return!1}}function cs(e){return 0!==(1&e.mode)&&0===(128&e.flags)}function ls(e){if(rs){var t=as;if(t){var n=t;if(!is(e,t)){if(cs(e))throw Error(s(418));t=lr(n.nextSibling);var a=ns;t&&is(e,t)?os(a,n):(e.flags=-4097&e.flags|2,rs=!1,ns=e)}}else{if(cs(e))throw Error(s(418));e.flags=-4097&e.flags|2,rs=!1,ns=e}}}function us(e){for(e=e.return;null!==e&&5!==e.tag&&3!==e.tag&&13!==e.tag;)e=e.return;ns=e}function hs(e){if(e!==ns)return!1;if(!rs)return us(e),rs=!0,!1;var t;if((t=3!==e.tag)&&!(t=5!==e.tag)&&(t="head"!==(t=e.type)&&"body"!==t&&!nr(e.type,e.memoizedProps)),t&&(t=as)){if(cs(e))throw ds(),Error(s(418));for(;t;)os(e,t),t=lr(t.nextSibling)}if(us(e),13===e.tag){if(!(e=null!==(e=e.memoizedState)?e.dehydrated:null))throw Error(s(317));e:{for(e=e.nextSibling,t=0;e;){if(8===e.nodeType){var n=e.data;if("/$"===n){if(0===t){as=lr(e.nextSibling);break e}t--}else"$"!==n&&"$!"!==n&&"$?"!==n||t++}e=e.nextSibling}as=null}}else as=ns?lr(e.stateNode.nextSibling):null;return!0}function ds(){for(var e=as;e;)e=lr(e.nextSibling)}function ps(){as=ns=null,rs=!1}function fs(e){null===ss?ss=[e]:ss.push(e)}var ms=x.ReactCurrentBatchConfig;function gs(e,t,n){if(null!==(e=n.ref)&&"function"!==typeof e&&"object"!==typeof e){if(n._owner){if(n=n._owner){if(1!==n.tag)throw Error(s(309));var a=n.stateNode}if(!a)throw Error(s(147,e));var r=a,o=""+e;return null!==t&&null!==t.ref&&"function"===typeof t.ref&&t.ref._stringRef===o?t.ref:(t=function(e){var t=r.refs;null===e?delete t[o]:t[o]=e},t._stringRef=o,t)}if("string"!==typeof e)throw Error(s(284));if(!n._owner)throw Error(s(290,e))}return e}function ys(e,t){throw e=Object.prototype.toString.call(t),Error(s(31,"[object Object]"===e?"object with keys {"+Object.keys(t).join(", ")+"}":e))}function bs(e){return(0,e._init)(e._payload)}function vs(e){function t(t,n){if(e){var a=t.deletions;null===a?(t.deletions=[n],t.flags|=16):a.push(n)}}function n(n,a){if(!e)return null;for(;null!==a;)t(n,a),a=a.sibling;return null}function a(e,t){for(e=new Map;null!==t;)null!==t.key?e.set(t.key,t):e.set(t.index,t),t=t.sibling;return e}function r(e,t){return(e=Fl(e,t)).index=0,e.sibling=null,e}function o(t,n,a){return t.index=a,e?null!==(a=t.alternate)?(a=a.index)<n?(t.flags|=2,n):a:(t.flags|=2,n):(t.flags|=1048576,n)}function i(t){return e&&null===t.alternate&&(t.flags|=2),t}function c(e,t,n,a){return null===t||6!==t.tag?((t=zl(n,e.mode,a)).return=e,t):((t=r(t,n)).return=e,t)}function l(e,t,n,a){var s=n.type;return s===S?h(e,t,n.props.children,a,n.key):null!==t&&(t.elementType===s||"object"===typeof s&&null!==s&&s.$$typeof===D&&bs(s)===t.type)?((a=r(t,n.props)).ref=gs(e,t,n),a.return=e,a):((a=Ol(n.type,n.key,n.props,null,e.mode,a)).ref=gs(e,t,n),a.return=e,a)}function u(e,t,n,a){return null===t||4!==t.tag||t.stateNode.containerInfo!==n.containerInfo||t.stateNode.implementation!==n.implementation?((t=Pl(n,e.mode,a)).return=e,t):((t=r(t,n.children||[])).return=e,t)}function h(e,t,n,a,s){return null===t||7!==t.tag?((t=Ml(n,e.mode,a,s)).return=e,t):((t=r(t,n)).return=e,t)}function d(e,t,n){if("string"===typeof t&&""!==t||"number"===typeof t)return(t=zl(""+t,e.mode,n)).return=e,t;if("object"===typeof t&&null!==t){switch(t.$$typeof){case w:return(n=Ol(t.type,t.key,t.props,null,e.mode,n)).ref=gs(e,null,t),n.return=e,n;case k:return(t=Pl(t,e.mode,n)).return=e,t;case D:return d(e,(0,t._init)(t._payload),n)}if(te(t)||M(t))return(t=Ml(t,e.mode,n,null)).return=e,t;ys(e,t)}return null}function p(e,t,n,a){var r=null!==t?t.key:null;if("string"===typeof n&&""!==n||"number"===typeof n)return null!==r?null:c(e,t,""+n,a);if("object"===typeof n&&null!==n){switch(n.$$typeof){case w:return n.key===r?l(e,t,n,a):null;case k:return n.key===r?u(e,t,n,a):null;case D:return p(e,t,(r=n._init)(n._payload),a)}if(te(n)||M(n))return null!==r?null:h(e,t,n,a,null);ys(e,n)}return null}function f(e,t,n,a,r){if("string"===typeof a&&""!==a||"number"===typeof a)return c(t,e=e.get(n)||null,""+a,r);if("object"===typeof a&&null!==a){switch(a.$$typeof){case w:return l(t,e=e.get(null===a.key?n:a.key)||null,a,r);case k:return u(t,e=e.get(null===a.key?n:a.key)||null,a,r);case D:return f(e,t,n,(0,a._init)(a._payload),r)}if(te(a)||M(a))return h(t,e=e.get(n)||null,a,r,null);ys(t,a)}return null}function m(r,s,i,c){for(var l=null,u=null,h=s,m=s=0,g=null;null!==h&&m<i.length;m++){h.index>m?(g=h,h=null):g=h.sibling;var y=p(r,h,i[m],c);if(null===y){null===h&&(h=g);break}e&&h&&null===y.alternate&&t(r,h),s=o(y,s,m),null===u?l=y:u.sibling=y,u=y,h=g}if(m===i.length)return n(r,h),rs&&Zr(r,m),l;if(null===h){for(;m<i.length;m++)null!==(h=d(r,i[m],c))&&(s=o(h,s,m),null===u?l=h:u.sibling=h,u=h);return rs&&Zr(r,m),l}for(h=a(r,h);m<i.length;m++)null!==(g=f(h,r,m,i[m],c))&&(e&&null!==g.alternate&&h.delete(null===g.key?m:g.key),s=o(g,s,m),null===u?l=g:u.sibling=g,u=g);return e&&h.forEach((function(e){return t(r,e)})),rs&&Zr(r,m),l}function g(r,i,c,l){var u=M(c);if("function"!==typeof u)throw Error(s(150));if(null==(c=u.call(c)))throw Error(s(151));for(var h=u=null,m=i,g=i=0,y=null,b=c.next();null!==m&&!b.done;g++,b=c.next()){m.index>g?(y=m,m=null):y=m.sibling;var v=p(r,m,b.value,l);if(null===v){null===m&&(m=y);break}e&&m&&null===v.alternate&&t(r,m),i=o(v,i,g),null===h?u=v:h.sibling=v,h=v,m=y}if(b.done)return n(r,m),rs&&Zr(r,g),u;if(null===m){for(;!b.done;g++,b=c.next())null!==(b=d(r,b.value,l))&&(i=o(b,i,g),null===h?u=b:h.sibling=b,h=b);return rs&&Zr(r,g),u}for(m=a(r,m);!b.done;g++,b=c.next())null!==(b=f(m,r,g,b.value,l))&&(e&&null!==b.alternate&&m.delete(null===b.key?g:b.key),i=o(b,i,g),null===h?u=b:h.sibling=b,h=b);return e&&m.forEach((function(e){return t(r,e)})),rs&&Zr(r,g),u}return function e(a,s,o,c){if("object"===typeof o&&null!==o&&o.type===S&&null===o.key&&(o=o.props.children),"object"===typeof o&&null!==o){switch(o.$$typeof){case w:e:{for(var l=o.key,u=s;null!==u;){if(u.key===l){if((l=o.type)===S){if(7===u.tag){n(a,u.sibling),(s=r(u,o.props.children)).return=a,a=s;break e}}else if(u.elementType===l||"object"===typeof l&&null!==l&&l.$$typeof===D&&bs(l)===u.type){n(a,u.sibling),(s=r(u,o.props)).ref=gs(a,u,o),s.return=a,a=s;break e}n(a,u);break}t(a,u),u=u.sibling}o.type===S?((s=Ml(o.props.children,a.mode,c,o.key)).return=a,a=s):((c=Ol(o.type,o.key,o.props,null,a.mode,c)).ref=gs(a,s,o),c.return=a,a=c)}return i(a);case k:e:{for(u=o.key;null!==s;){if(s.key===u){if(4===s.tag&&s.stateNode.containerInfo===o.containerInfo&&s.stateNode.implementation===o.implementation){n(a,s.sibling),(s=r(s,o.children||[])).return=a,a=s;break e}n(a,s);break}t(a,s),s=s.sibling}(s=Pl(o,a.mode,c)).return=a,a=s}return i(a);case D:return e(a,s,(u=o._init)(o._payload),c)}if(te(o))return m(a,s,o,c);if(M(o))return g(a,s,o,c);ys(a,o)}return"string"===typeof o&&""!==o||"number"===typeof o?(o=""+o,null!==s&&6===s.tag?(n(a,s.sibling),(s=r(s,o)).return=a,a=s):(n(a,s),(s=zl(o,a.mode,c)).return=a,a=s),i(a)):n(a,s)}}var xs=vs(!0),ws=vs(!1),ks=Ir(null),Ss=null,Is=null,Ns=null;function Ts(){Ns=Is=Ss=null}function Es(e){var t=ks.current;Nr(ks),e._currentValue=t}function Cs(e,t,n){for(;null!==e;){var a=e.alternate;if((e.childLanes&t)!==t?(e.childLanes|=t,null!==a&&(a.childLanes|=t)):null!==a&&(a.childLanes&t)!==t&&(a.childLanes|=t),e===n)break;e=e.return}}function Rs(e,t){Ss=e,Ns=Is=null,null!==(e=e.dependencies)&&null!==e.firstContext&&(0!==(e.lanes&t)&&(vi=!0),e.firstContext=null)}function As(e){var t=e._currentValue;if(Ns!==e)if(e={context:e,memoizedValue:t,next:null},null===Is){if(null===Ss)throw Error(s(308));Is=e,Ss.dependencies={lanes:0,firstContext:e}}else Is=Is.next=e;return t}var _s=null;function Ds(e){null===_s?_s=[e]:_s.push(e)}function Fs(e,t,n,a){var r=t.interleaved;return null===r?(n.next=n,Ds(t)):(n.next=r.next,r.next=n),t.interleaved=n,Os(e,a)}function Os(e,t){e.lanes|=t;var n=e.alternate;for(null!==n&&(n.lanes|=t),n=e,e=e.return;null!==e;)e.childLanes|=t,null!==(n=e.alternate)&&(n.childLanes|=t),n=e,e=e.return;return 3===n.tag?n.stateNode:null}var Ms=!1;function Ls(e){e.updateQueue={baseState:e.memoizedState,firstBaseUpdate:null,lastBaseUpdate:null,shared:{pending:null,interleaved:null,lanes:0},effects:null}}function zs(e,t){e=e.updateQueue,t.updateQueue===e&&(t.updateQueue={baseState:e.baseState,firstBaseUpdate:e.firstBaseUpdate,lastBaseUpdate:e.lastBaseUpdate,shared:e.shared,effects:e.effects})}function Ps(e,t){return{eventTime:e,lane:t,tag:0,payload:null,callback:null,next:null}}function Bs(e,t,n){var a=e.updateQueue;if(null===a)return null;if(a=a.shared,0!==(2&Cc)){var r=a.pending;return null===r?t.next=t:(t.next=r.next,r.next=t),a.pending=t,Os(e,n)}return null===(r=a.interleaved)?(t.next=t,Ds(a)):(t.next=r.next,r.next=t),a.interleaved=t,Os(e,n)}function Ws(e,t,n){if(null!==(t=t.updateQueue)&&(t=t.shared,0!==(4194240&n))){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,bt(e,n)}}function Vs(e,t){var n=e.updateQueue,a=e.alternate;if(null!==a&&n===(a=a.updateQueue)){var r=null,s=null;if(null!==(n=n.firstBaseUpdate)){do{var o={eventTime:n.eventTime,lane:n.lane,tag:n.tag,payload:n.payload,callback:n.callback,next:null};null===s?r=s=o:s=s.next=o,n=n.next}while(null!==n);null===s?r=s=t:s=s.next=t}else r=s=t;return n={baseState:a.baseState,firstBaseUpdate:r,lastBaseUpdate:s,shared:a.shared,effects:a.effects},void(e.updateQueue=n)}null===(e=n.lastBaseUpdate)?n.firstBaseUpdate=t:e.next=t,n.lastBaseUpdate=t}function Us(e,t,n,a){var r=e.updateQueue;Ms=!1;var s=r.firstBaseUpdate,o=r.lastBaseUpdate,i=r.shared.pending;if(null!==i){r.shared.pending=null;var c=i,l=c.next;c.next=null,null===o?s=l:o.next=l,o=c;var u=e.alternate;null!==u&&((i=(u=u.updateQueue).lastBaseUpdate)!==o&&(null===i?u.firstBaseUpdate=l:i.next=l,u.lastBaseUpdate=c))}if(null!==s){var h=r.baseState;for(o=0,u=l=c=null,i=s;;){var d=i.lane,p=i.eventTime;if((a&d)===d){null!==u&&(u=u.next={eventTime:p,lane:0,tag:i.tag,payload:i.payload,callback:i.callback,next:null});e:{var f=e,m=i;switch(d=t,p=n,m.tag){case 1:if("function"===typeof(f=m.payload)){h=f.call(p,h,d);break e}h=f;break e;case 3:f.flags=-65537&f.flags|128;case 0:if(null===(d="function"===typeof(f=m.payload)?f.call(p,h,d):f)||void 0===d)break e;h=z({},h,d);break e;case 2:Ms=!0}}null!==i.callback&&0!==i.lane&&(e.flags|=64,null===(d=r.effects)?r.effects=[i]:d.push(i))}else p={eventTime:p,lane:d,tag:i.tag,payload:i.payload,callback:i.callback,next:null},null===u?(l=u=p,c=h):u=u.next=p,o|=d;if(null===(i=i.next)){if(null===(i=r.shared.pending))break;i=(d=i).next,d.next=null,r.lastBaseUpdate=d,r.shared.pending=null}}if(null===u&&(c=h),r.baseState=c,r.firstBaseUpdate=l,r.lastBaseUpdate=u,null!==(t=r.shared.interleaved)){r=t;do{o|=r.lane,r=r.next}while(r!==t)}else null===s&&(r.shared.lanes=0);Lc|=o,e.lanes=o,e.memoizedState=h}}function Gs(e,t,n){if(e=t.effects,t.effects=null,null!==e)for(t=0;t<e.length;t++){var a=e[t],r=a.callback;if(null!==r){if(a.callback=null,a=n,"function"!==typeof r)throw Error(s(191,r));r.call(a)}}}var Hs={},js=Ir(Hs),Ks=Ir(Hs),qs=Ir(Hs);function Xs(e){if(e===Hs)throw Error(s(174));return e}function Ys(e,t){switch(Tr(qs,t),Tr(Ks,e),Tr(js,Hs),e=t.nodeType){case 9:case 11:t=(t=t.documentElement)?t.namespaceURI:ce(null,"");break;default:t=ce(t=(e=8===e?t.parentNode:t).namespaceURI||null,e=e.tagName)}Nr(js),Tr(js,t)}function Qs(){Nr(js),Nr(Ks),Nr(qs)}function Js(e){Xs(qs.current);var t=Xs(js.current),n=ce(t,e.type);t!==n&&(Tr(Ks,e),Tr(js,n))}function Zs(e){Ks.current===e&&(Nr(js),Nr(Ks))}var $s=Ir(0);function eo(e){for(var t=e;null!==t;){if(13===t.tag){var n=t.memoizedState;if(null!==n&&(null===(n=n.dehydrated)||"$?"===n.data||"$!"===n.data))return t}else if(19===t.tag&&void 0!==t.memoizedProps.revealOrder){if(0!==(128&t.flags))return t}else if(null!==t.child){t.child.return=t,t=t.child;continue}if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return null;t=t.return}t.sibling.return=t.return,t=t.sibling}return null}var to=[];function no(){for(var e=0;e<to.length;e++)to[e]._workInProgressVersionPrimary=null;to.length=0}var ao=x.ReactCurrentDispatcher,ro=x.ReactCurrentBatchConfig,so=0,oo=null,io=null,co=null,lo=!1,uo=!1,ho=0,po=0;function fo(){throw Error(s(321))}function mo(e,t){if(null===t)return!1;for(var n=0;n<t.length&&n<e.length;n++)if(!ia(e[n],t[n]))return!1;return!0}function go(e,t,n,a,r,o){if(so=o,oo=t,t.memoizedState=null,t.updateQueue=null,t.lanes=0,ao.current=null===e||null===e.memoizedState?$o:ei,e=n(a,r),uo){o=0;do{if(uo=!1,ho=0,25<=o)throw Error(s(301));o+=1,co=io=null,t.updateQueue=null,ao.current=ti,e=n(a,r)}while(uo)}if(ao.current=Zo,t=null!==io&&null!==io.next,so=0,co=io=oo=null,lo=!1,t)throw Error(s(300));return e}function yo(){var e=0!==ho;return ho=0,e}function bo(){var e={memoizedState:null,baseState:null,baseQueue:null,queue:null,next:null};return null===co?oo.memoizedState=co=e:co=co.next=e,co}function vo(){if(null===io){var e=oo.alternate;e=null!==e?e.memoizedState:null}else e=io.next;var t=null===co?oo.memoizedState:co.next;if(null!==t)co=t,io=e;else{if(null===e)throw Error(s(310));e={memoizedState:(io=e).memoizedState,baseState:io.baseState,baseQueue:io.baseQueue,queue:io.queue,next:null},null===co?oo.memoizedState=co=e:co=co.next=e}return co}function xo(e,t){return"function"===typeof t?t(e):t}function wo(e){var t=vo(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var a=io,r=a.baseQueue,o=n.pending;if(null!==o){if(null!==r){var i=r.next;r.next=o.next,o.next=i}a.baseQueue=r=o,n.pending=null}if(null!==r){o=r.next,a=a.baseState;var c=i=null,l=null,u=o;do{var h=u.lane;if((so&h)===h)null!==l&&(l=l.next={lane:0,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null}),a=u.hasEagerState?u.eagerState:e(a,u.action);else{var d={lane:h,action:u.action,hasEagerState:u.hasEagerState,eagerState:u.eagerState,next:null};null===l?(c=l=d,i=a):l=l.next=d,oo.lanes|=h,Lc|=h}u=u.next}while(null!==u&&u!==o);null===l?i=a:l.next=c,ia(a,t.memoizedState)||(vi=!0),t.memoizedState=a,t.baseState=i,t.baseQueue=l,n.lastRenderedState=a}if(null!==(e=n.interleaved)){r=e;do{o=r.lane,oo.lanes|=o,Lc|=o,r=r.next}while(r!==e)}else null===r&&(n.lanes=0);return[t.memoizedState,n.dispatch]}function ko(e){var t=vo(),n=t.queue;if(null===n)throw Error(s(311));n.lastRenderedReducer=e;var a=n.dispatch,r=n.pending,o=t.memoizedState;if(null!==r){n.pending=null;var i=r=r.next;do{o=e(o,i.action),i=i.next}while(i!==r);ia(o,t.memoizedState)||(vi=!0),t.memoizedState=o,null===t.baseQueue&&(t.baseState=o),n.lastRenderedState=o}return[o,a]}function So(){}function Io(e,t){var n=oo,a=vo(),r=t(),o=!ia(a.memoizedState,r);if(o&&(a.memoizedState=r,vi=!0),a=a.queue,Lo(Eo.bind(null,n,a,e),[e]),a.getSnapshot!==t||o||null!==co&&1&co.memoizedState.tag){if(n.flags|=2048,_o(9,To.bind(null,n,a,r,t),void 0,null),null===Rc)throw Error(s(349));0!==(30&so)||No(n,t,r)}return r}function No(e,t,n){e.flags|=16384,e={getSnapshot:t,value:n},null===(t=oo.updateQueue)?(t={lastEffect:null,stores:null},oo.updateQueue=t,t.stores=[e]):null===(n=t.stores)?t.stores=[e]:n.push(e)}function To(e,t,n,a){t.value=n,t.getSnapshot=a,Co(t)&&Ro(e)}function Eo(e,t,n){return n((function(){Co(t)&&Ro(e)}))}function Co(e){var t=e.getSnapshot;e=e.value;try{var n=t();return!ia(e,n)}catch(a){return!0}}function Ro(e){var t=Os(e,1);null!==t&&nl(t,e,1,-1)}function Ao(e){var t=bo();return"function"===typeof e&&(e=e()),t.memoizedState=t.baseState=e,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:xo,lastRenderedState:e},t.queue=e,e=e.dispatch=Xo.bind(null,oo,e),[t.memoizedState,e]}function _o(e,t,n,a){return e={tag:e,create:t,destroy:n,deps:a,next:null},null===(t=oo.updateQueue)?(t={lastEffect:null,stores:null},oo.updateQueue=t,t.lastEffect=e.next=e):null===(n=t.lastEffect)?t.lastEffect=e.next=e:(a=n.next,n.next=e,e.next=a,t.lastEffect=e),e}function Do(){return vo().memoizedState}function Fo(e,t,n,a){var r=bo();oo.flags|=e,r.memoizedState=_o(1|t,n,void 0,void 0===a?null:a)}function Oo(e,t,n,a){var r=vo();a=void 0===a?null:a;var s=void 0;if(null!==io){var o=io.memoizedState;if(s=o.destroy,null!==a&&mo(a,o.deps))return void(r.memoizedState=_o(t,n,s,a))}oo.flags|=e,r.memoizedState=_o(1|t,n,s,a)}function Mo(e,t){return Fo(8390656,8,e,t)}function Lo(e,t){return Oo(2048,8,e,t)}function zo(e,t){return Oo(4,2,e,t)}function Po(e,t){return Oo(4,4,e,t)}function Bo(e,t){return"function"===typeof t?(e=e(),t(e),function(){t(null)}):null!==t&&void 0!==t?(e=e(),t.current=e,function(){t.current=null}):void 0}function Wo(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Oo(4,4,Bo.bind(null,t,e),n)}function Vo(){}function Uo(e,t){var n=vo();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&mo(t,a[1])?a[0]:(n.memoizedState=[e,t],e)}function Go(e,t){var n=vo();t=void 0===t?null:t;var a=n.memoizedState;return null!==a&&null!==t&&mo(t,a[1])?a[0]:(e=e(),n.memoizedState=[e,t],e)}function Ho(e,t,n){return 0===(21&so)?(e.baseState&&(e.baseState=!1,vi=!0),e.memoizedState=n):(ia(n,t)||(n=mt(),oo.lanes|=n,Lc|=n,e.baseState=!0),t)}function jo(e,t){var n=vt;vt=0!==n&&4>n?n:4,e(!0);var a=ro.transition;ro.transition={};try{e(!1),t()}finally{vt=n,ro.transition=a}}function Ko(){return vo().memoizedState}function qo(e,t,n){var a=tl(e);if(n={lane:a,action:n,hasEagerState:!1,eagerState:null,next:null},Yo(e))Qo(t,n);else if(null!==(n=Fs(e,t,n,a))){nl(n,e,a,el()),Jo(n,t,a)}}function Xo(e,t,n){var a=tl(e),r={lane:a,action:n,hasEagerState:!1,eagerState:null,next:null};if(Yo(e))Qo(t,r);else{var s=e.alternate;if(0===e.lanes&&(null===s||0===s.lanes)&&null!==(s=t.lastRenderedReducer))try{var o=t.lastRenderedState,i=s(o,n);if(r.hasEagerState=!0,r.eagerState=i,ia(i,o)){var c=t.interleaved;return null===c?(r.next=r,Ds(t)):(r.next=c.next,c.next=r),void(t.interleaved=r)}}catch(l){}null!==(n=Fs(e,t,r,a))&&(nl(n,e,a,r=el()),Jo(n,t,a))}}function Yo(e){var t=e.alternate;return e===oo||null!==t&&t===oo}function Qo(e,t){uo=lo=!0;var n=e.pending;null===n?t.next=t:(t.next=n.next,n.next=t),e.pending=t}function Jo(e,t,n){if(0!==(4194240&n)){var a=t.lanes;n|=a&=e.pendingLanes,t.lanes=n,bt(e,n)}}var Zo={readContext:As,useCallback:fo,useContext:fo,useEffect:fo,useImperativeHandle:fo,useInsertionEffect:fo,useLayoutEffect:fo,useMemo:fo,useReducer:fo,useRef:fo,useState:fo,useDebugValue:fo,useDeferredValue:fo,useTransition:fo,useMutableSource:fo,useSyncExternalStore:fo,useId:fo,unstable_isNewReconciler:!1},$o={readContext:As,useCallback:function(e,t){return bo().memoizedState=[e,void 0===t?null:t],e},useContext:As,useEffect:Mo,useImperativeHandle:function(e,t,n){return n=null!==n&&void 0!==n?n.concat([e]):null,Fo(4194308,4,Bo.bind(null,t,e),n)},useLayoutEffect:function(e,t){return Fo(4194308,4,e,t)},useInsertionEffect:function(e,t){return Fo(4,2,e,t)},useMemo:function(e,t){var n=bo();return t=void 0===t?null:t,e=e(),n.memoizedState=[e,t],e},useReducer:function(e,t,n){var a=bo();return t=void 0!==n?n(t):t,a.memoizedState=a.baseState=t,e={pending:null,interleaved:null,lanes:0,dispatch:null,lastRenderedReducer:e,lastRenderedState:t},a.queue=e,e=e.dispatch=qo.bind(null,oo,e),[a.memoizedState,e]},useRef:function(e){return e={current:e},bo().memoizedState=e},useState:Ao,useDebugValue:Vo,useDeferredValue:function(e){return bo().memoizedState=e},useTransition:function(){var e=Ao(!1),t=e[0];return e=jo.bind(null,e[1]),bo().memoizedState=e,[t,e]},useMutableSource:function(){},useSyncExternalStore:function(e,t,n){var a=oo,r=bo();if(rs){if(void 0===n)throw Error(s(407));n=n()}else{if(n=t(),null===Rc)throw Error(s(349));0!==(30&so)||No(a,t,n)}r.memoizedState=n;var o={value:n,getSnapshot:t};return r.queue=o,Mo(Eo.bind(null,a,o,e),[e]),a.flags|=2048,_o(9,To.bind(null,a,o,n,t),void 0,null),n},useId:function(){var e=bo(),t=Rc.identifierPrefix;if(rs){var n=Jr;t=":"+t+"R"+(n=(Qr&~(1<<32-ot(Qr)-1)).toString(32)+n),0<(n=ho++)&&(t+="H"+n.toString(32)),t+=":"}else t=":"+t+"r"+(n=po++).toString(32)+":";return e.memoizedState=t},unstable_isNewReconciler:!1},ei={readContext:As,useCallback:Uo,useContext:As,useEffect:Lo,useImperativeHandle:Wo,useInsertionEffect:zo,useLayoutEffect:Po,useMemo:Go,useReducer:wo,useRef:Do,useState:function(){return wo(xo)},useDebugValue:Vo,useDeferredValue:function(e){return Ho(vo(),io.memoizedState,e)},useTransition:function(){return[wo(xo)[0],vo().memoizedState]},useMutableSource:So,useSyncExternalStore:Io,useId:Ko,unstable_isNewReconciler:!1},ti={readContext:As,useCallback:Uo,useContext:As,useEffect:Lo,useImperativeHandle:Wo,useInsertionEffect:zo,useLayoutEffect:Po,useMemo:Go,useReducer:ko,useRef:Do,useState:function(){return ko(xo)},useDebugValue:Vo,useDeferredValue:function(e){var t=vo();return null===io?t.memoizedState=e:Ho(t,io.memoizedState,e)},useTransition:function(){return[ko(xo)[0],vo().memoizedState]},useMutableSource:So,useSyncExternalStore:Io,useId:Ko,unstable_isNewReconciler:!1};function ni(e,t){if(e&&e.defaultProps){for(var n in t=z({},t),e=e.defaultProps)void 0===t[n]&&(t[n]=e[n]);return t}return t}function ai(e,t,n,a){n=null===(n=n(a,t=e.memoizedState))||void 0===n?t:z({},t,n),e.memoizedState=n,0===e.lanes&&(e.updateQueue.baseState=n)}var ri={isMounted:function(e){return!!(e=e._reactInternals)&&Ue(e)===e},enqueueSetState:function(e,t,n){e=e._reactInternals;var a=el(),r=tl(e),s=Ps(a,r);s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=Bs(e,s,r))&&(nl(t,e,r,a),Ws(t,e,r))},enqueueReplaceState:function(e,t,n){e=e._reactInternals;var a=el(),r=tl(e),s=Ps(a,r);s.tag=1,s.payload=t,void 0!==n&&null!==n&&(s.callback=n),null!==(t=Bs(e,s,r))&&(nl(t,e,r,a),Ws(t,e,r))},enqueueForceUpdate:function(e,t){e=e._reactInternals;var n=el(),a=tl(e),r=Ps(n,a);r.tag=2,void 0!==t&&null!==t&&(r.callback=t),null!==(t=Bs(e,r,a))&&(nl(t,e,a,n),Ws(t,e,a))}};function si(e,t,n,a,r,s,o){return"function"===typeof(e=e.stateNode).shouldComponentUpdate?e.shouldComponentUpdate(a,s,o):!t.prototype||!t.prototype.isPureReactComponent||(!ca(n,a)||!ca(r,s))}function oi(e,t,n){var a=!1,r=Er,s=t.contextType;return"object"===typeof s&&null!==s?s=As(s):(r=Dr(t)?Ar:Cr.current,s=(a=null!==(a=t.contextTypes)&&void 0!==a)?_r(e,r):Er),t=new t(n,s),e.memoizedState=null!==t.state&&void 0!==t.state?t.state:null,t.updater=ri,e.stateNode=t,t._reactInternals=e,a&&((e=e.stateNode).__reactInternalMemoizedUnmaskedChildContext=r,e.__reactInternalMemoizedMaskedChildContext=s),t}function ii(e,t,n,a){e=t.state,"function"===typeof t.componentWillReceiveProps&&t.componentWillReceiveProps(n,a),"function"===typeof t.UNSAFE_componentWillReceiveProps&&t.UNSAFE_componentWillReceiveProps(n,a),t.state!==e&&ri.enqueueReplaceState(t,t.state,null)}function ci(e,t,n,a){var r=e.stateNode;r.props=n,r.state=e.memoizedState,r.refs={},Ls(e);var s=t.contextType;"object"===typeof s&&null!==s?r.context=As(s):(s=Dr(t)?Ar:Cr.current,r.context=_r(e,s)),r.state=e.memoizedState,"function"===typeof(s=t.getDerivedStateFromProps)&&(ai(e,t,s,n),r.state=e.memoizedState),"function"===typeof t.getDerivedStateFromProps||"function"===typeof r.getSnapshotBeforeUpdate||"function"!==typeof r.UNSAFE_componentWillMount&&"function"!==typeof r.componentWillMount||(t=r.state,"function"===typeof r.componentWillMount&&r.componentWillMount(),"function"===typeof r.UNSAFE_componentWillMount&&r.UNSAFE_componentWillMount(),t!==r.state&&ri.enqueueReplaceState(r,r.state,null),Us(e,n,r,a),r.state=e.memoizedState),"function"===typeof r.componentDidMount&&(e.flags|=4194308)}function li(e,t){try{var n="",a=t;do{n+=V(a),a=a.return}while(a);var r=n}catch(s){r="\nError generating stack: "+s.message+"\n"+s.stack}return{value:e,source:t,stack:r,digest:null}}function ui(e,t,n){return{value:e,source:null,stack:null!=n?n:null,digest:null!=t?t:null}}function hi(e,t){try{console.error(t.value)}catch(n){setTimeout((function(){throw n}))}}var di="function"===typeof WeakMap?WeakMap:Map;function pi(e,t,n){(n=Ps(-1,n)).tag=3,n.payload={element:null};var a=t.value;return n.callback=function(){Hc||(Hc=!0,jc=a),hi(0,t)},n}function fi(e,t,n){(n=Ps(-1,n)).tag=3;var a=e.type.getDerivedStateFromError;if("function"===typeof a){var r=t.value;n.payload=function(){return a(r)},n.callback=function(){hi(0,t)}}var s=e.stateNode;return null!==s&&"function"===typeof s.componentDidCatch&&(n.callback=function(){hi(0,t),"function"!==typeof a&&(null===Kc?Kc=new Set([this]):Kc.add(this));var e=t.stack;this.componentDidCatch(t.value,{componentStack:null!==e?e:""})}),n}function mi(e,t,n){var a=e.pingCache;if(null===a){a=e.pingCache=new di;var r=new Set;a.set(t,r)}else void 0===(r=a.get(t))&&(r=new Set,a.set(t,r));r.has(n)||(r.add(n),e=Nl.bind(null,e,t,n),t.then(e,e))}function gi(e){do{var t;if((t=13===e.tag)&&(t=null===(t=e.memoizedState)||null!==t.dehydrated),t)return e;e=e.return}while(null!==e);return null}function yi(e,t,n,a,r){return 0===(1&e.mode)?(e===t?e.flags|=65536:(e.flags|=128,n.flags|=131072,n.flags&=-52805,1===n.tag&&(null===n.alternate?n.tag=17:((t=Ps(-1,1)).tag=2,Bs(n,t,1))),n.lanes|=1),e):(e.flags|=65536,e.lanes=r,e)}var bi=x.ReactCurrentOwner,vi=!1;function xi(e,t,n,a){t.child=null===e?ws(t,null,n,a):xs(t,e.child,n,a)}function wi(e,t,n,a,r){n=n.render;var s=t.ref;return Rs(t,r),a=go(e,t,n,a,s,r),n=yo(),null===e||vi?(rs&&n&&es(t),t.flags|=1,xi(e,t,a,r),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~r,Hi(e,t,r))}function ki(e,t,n,a,r){if(null===e){var s=n.type;return"function"!==typeof s||Dl(s)||void 0!==s.defaultProps||null!==n.compare||void 0!==n.defaultProps?((e=Ol(n.type,null,a,t,t.mode,r)).ref=t.ref,e.return=t,t.child=e):(t.tag=15,t.type=s,Si(e,t,s,a,r))}if(s=e.child,0===(e.lanes&r)){var o=s.memoizedProps;if((n=null!==(n=n.compare)?n:ca)(o,a)&&e.ref===t.ref)return Hi(e,t,r)}return t.flags|=1,(e=Fl(s,a)).ref=t.ref,e.return=t,t.child=e}function Si(e,t,n,a,r){if(null!==e){var s=e.memoizedProps;if(ca(s,a)&&e.ref===t.ref){if(vi=!1,t.pendingProps=a=s,0===(e.lanes&r))return t.lanes=e.lanes,Hi(e,t,r);0!==(131072&e.flags)&&(vi=!0)}}return Ti(e,t,n,a,r)}function Ii(e,t,n){var a=t.pendingProps,r=a.children,s=null!==e?e.memoizedState:null;if("hidden"===a.mode)if(0===(1&t.mode))t.memoizedState={baseLanes:0,cachePool:null,transitions:null},Tr(Fc,Dc),Dc|=n;else{if(0===(1073741824&n))return e=null!==s?s.baseLanes|n:n,t.lanes=t.childLanes=1073741824,t.memoizedState={baseLanes:e,cachePool:null,transitions:null},t.updateQueue=null,Tr(Fc,Dc),Dc|=e,null;t.memoizedState={baseLanes:0,cachePool:null,transitions:null},a=null!==s?s.baseLanes:n,Tr(Fc,Dc),Dc|=a}else null!==s?(a=s.baseLanes|n,t.memoizedState=null):a=n,Tr(Fc,Dc),Dc|=a;return xi(e,t,r,n),t.child}function Ni(e,t){var n=t.ref;(null===e&&null!==n||null!==e&&e.ref!==n)&&(t.flags|=512,t.flags|=2097152)}function Ti(e,t,n,a,r){var s=Dr(n)?Ar:Cr.current;return s=_r(t,s),Rs(t,r),n=go(e,t,n,a,s,r),a=yo(),null===e||vi?(rs&&a&&es(t),t.flags|=1,xi(e,t,n,r),t.child):(t.updateQueue=e.updateQueue,t.flags&=-2053,e.lanes&=~r,Hi(e,t,r))}function Ei(e,t,n,a,r){if(Dr(n)){var s=!0;Lr(t)}else s=!1;if(Rs(t,r),null===t.stateNode)Gi(e,t),oi(t,n,a),ci(t,n,a,r),a=!0;else if(null===e){var o=t.stateNode,i=t.memoizedProps;o.props=i;var c=o.context,l=n.contextType;"object"===typeof l&&null!==l?l=As(l):l=_r(t,l=Dr(n)?Ar:Cr.current);var u=n.getDerivedStateFromProps,h="function"===typeof u||"function"===typeof o.getSnapshotBeforeUpdate;h||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==a||c!==l)&&ii(t,o,a,l),Ms=!1;var d=t.memoizedState;o.state=d,Us(t,a,o,r),c=t.memoizedState,i!==a||d!==c||Rr.current||Ms?("function"===typeof u&&(ai(t,n,u,a),c=t.memoizedState),(i=Ms||si(t,n,i,a,d,c,l))?(h||"function"!==typeof o.UNSAFE_componentWillMount&&"function"!==typeof o.componentWillMount||("function"===typeof o.componentWillMount&&o.componentWillMount(),"function"===typeof o.UNSAFE_componentWillMount&&o.UNSAFE_componentWillMount()),"function"===typeof o.componentDidMount&&(t.flags|=4194308)):("function"===typeof o.componentDidMount&&(t.flags|=4194308),t.memoizedProps=a,t.memoizedState=c),o.props=a,o.state=c,o.context=l,a=i):("function"===typeof o.componentDidMount&&(t.flags|=4194308),a=!1)}else{o=t.stateNode,zs(e,t),i=t.memoizedProps,l=t.type===t.elementType?i:ni(t.type,i),o.props=l,h=t.pendingProps,d=o.context,"object"===typeof(c=n.contextType)&&null!==c?c=As(c):c=_r(t,c=Dr(n)?Ar:Cr.current);var p=n.getDerivedStateFromProps;(u="function"===typeof p||"function"===typeof o.getSnapshotBeforeUpdate)||"function"!==typeof o.UNSAFE_componentWillReceiveProps&&"function"!==typeof o.componentWillReceiveProps||(i!==h||d!==c)&&ii(t,o,a,c),Ms=!1,d=t.memoizedState,o.state=d,Us(t,a,o,r);var f=t.memoizedState;i!==h||d!==f||Rr.current||Ms?("function"===typeof p&&(ai(t,n,p,a),f=t.memoizedState),(l=Ms||si(t,n,l,a,d,f,c)||!1)?(u||"function"!==typeof o.UNSAFE_componentWillUpdate&&"function"!==typeof o.componentWillUpdate||("function"===typeof o.componentWillUpdate&&o.componentWillUpdate(a,f,c),"function"===typeof o.UNSAFE_componentWillUpdate&&o.UNSAFE_componentWillUpdate(a,f,c)),"function"===typeof o.componentDidUpdate&&(t.flags|=4),"function"===typeof o.getSnapshotBeforeUpdate&&(t.flags|=1024)):("function"!==typeof o.componentDidUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),t.memoizedProps=a,t.memoizedState=f),o.props=a,o.state=f,o.context=c,a=l):("function"!==typeof o.componentDidUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=4),"function"!==typeof o.getSnapshotBeforeUpdate||i===e.memoizedProps&&d===e.memoizedState||(t.flags|=1024),a=!1)}return Ci(e,t,n,a,s,r)}function Ci(e,t,n,a,r,s){Ni(e,t);var o=0!==(128&t.flags);if(!a&&!o)return r&&zr(t,n,!1),Hi(e,t,s);a=t.stateNode,bi.current=t;var i=o&&"function"!==typeof n.getDerivedStateFromError?null:a.render();return t.flags|=1,null!==e&&o?(t.child=xs(t,e.child,null,s),t.child=xs(t,null,i,s)):xi(e,t,i,s),t.memoizedState=a.state,r&&zr(t,n,!0),t.child}function Ri(e){var t=e.stateNode;t.pendingContext?Or(0,t.pendingContext,t.pendingContext!==t.context):t.context&&Or(0,t.context,!1),Ys(e,t.containerInfo)}function Ai(e,t,n,a,r){return ps(),fs(r),t.flags|=256,xi(e,t,n,a),t.child}var _i,Di,Fi,Oi,Mi={dehydrated:null,treeContext:null,retryLane:0};function Li(e){return{baseLanes:e,cachePool:null,transitions:null}}function zi(e,t,n){var a,r=t.pendingProps,o=$s.current,i=!1,c=0!==(128&t.flags);if((a=c)||(a=(null===e||null!==e.memoizedState)&&0!==(2&o)),a?(i=!0,t.flags&=-129):null!==e&&null===e.memoizedState||(o|=1),Tr($s,1&o),null===e)return ls(t),null!==(e=t.memoizedState)&&null!==(e=e.dehydrated)?(0===(1&t.mode)?t.lanes=1:"$!"===e.data?t.lanes=8:t.lanes=1073741824,null):(c=r.children,e=r.fallback,i?(r=t.mode,i=t.child,c={mode:"hidden",children:c},0===(1&r)&&null!==i?(i.childLanes=0,i.pendingProps=c):i=Ll(c,r,0,null),e=Ml(e,r,n,null),i.return=t,e.return=t,i.sibling=e,t.child=i,t.child.memoizedState=Li(n),t.memoizedState=Mi,e):Pi(t,c));if(null!==(o=e.memoizedState)&&null!==(a=o.dehydrated))return function(e,t,n,a,r,o,i){if(n)return 256&t.flags?(t.flags&=-257,Bi(e,t,i,a=ui(Error(s(422))))):null!==t.memoizedState?(t.child=e.child,t.flags|=128,null):(o=a.fallback,r=t.mode,a=Ll({mode:"visible",children:a.children},r,0,null),(o=Ml(o,r,i,null)).flags|=2,a.return=t,o.return=t,a.sibling=o,t.child=a,0!==(1&t.mode)&&xs(t,e.child,null,i),t.child.memoizedState=Li(i),t.memoizedState=Mi,o);if(0===(1&t.mode))return Bi(e,t,i,null);if("$!"===r.data){if(a=r.nextSibling&&r.nextSibling.dataset)var c=a.dgst;return a=c,Bi(e,t,i,a=ui(o=Error(s(419)),a,void 0))}if(c=0!==(i&e.childLanes),vi||c){if(null!==(a=Rc)){switch(i&-i){case 4:r=2;break;case 16:r=8;break;case 64:case 128:case 256:case 512:case 1024:case 2048:case 4096:case 8192:case 16384:case 32768:case 65536:case 131072:case 262144:case 524288:case 1048576:case 2097152:case 4194304:case 8388608:case 16777216:case 33554432:case 67108864:r=32;break;case 536870912:r=268435456;break;default:r=0}0!==(r=0!==(r&(a.suspendedLanes|i))?0:r)&&r!==o.retryLane&&(o.retryLane=r,Os(e,r),nl(a,e,r,-1))}return ml(),Bi(e,t,i,a=ui(Error(s(421))))}return"$?"===r.data?(t.flags|=128,t.child=e.child,t=El.bind(null,e),r._reactRetry=t,null):(e=o.treeContext,as=lr(r.nextSibling),ns=t,rs=!0,ss=null,null!==e&&(qr[Xr++]=Qr,qr[Xr++]=Jr,qr[Xr++]=Yr,Qr=e.id,Jr=e.overflow,Yr=t),t=Pi(t,a.children),t.flags|=4096,t)}(e,t,c,r,a,o,n);if(i){i=r.fallback,c=t.mode,a=(o=e.child).sibling;var l={mode:"hidden",children:r.children};return 0===(1&c)&&t.child!==o?((r=t.child).childLanes=0,r.pendingProps=l,t.deletions=null):(r=Fl(o,l)).subtreeFlags=14680064&o.subtreeFlags,null!==a?i=Fl(a,i):(i=Ml(i,c,n,null)).flags|=2,i.return=t,r.return=t,r.sibling=i,t.child=r,r=i,i=t.child,c=null===(c=e.child.memoizedState)?Li(n):{baseLanes:c.baseLanes|n,cachePool:null,transitions:c.transitions},i.memoizedState=c,i.childLanes=e.childLanes&~n,t.memoizedState=Mi,r}return e=(i=e.child).sibling,r=Fl(i,{mode:"visible",children:r.children}),0===(1&t.mode)&&(r.lanes=n),r.return=t,r.sibling=null,null!==e&&(null===(n=t.deletions)?(t.deletions=[e],t.flags|=16):n.push(e)),t.child=r,t.memoizedState=null,r}function Pi(e,t){return(t=Ll({mode:"visible",children:t},e.mode,0,null)).return=e,e.child=t}function Bi(e,t,n,a){return null!==a&&fs(a),xs(t,e.child,null,n),(e=Pi(t,t.pendingProps.children)).flags|=2,t.memoizedState=null,e}function Wi(e,t,n){e.lanes|=t;var a=e.alternate;null!==a&&(a.lanes|=t),Cs(e.return,t,n)}function Vi(e,t,n,a,r){var s=e.memoizedState;null===s?e.memoizedState={isBackwards:t,rendering:null,renderingStartTime:0,last:a,tail:n,tailMode:r}:(s.isBackwards=t,s.rendering=null,s.renderingStartTime=0,s.last=a,s.tail=n,s.tailMode=r)}function Ui(e,t,n){var a=t.pendingProps,r=a.revealOrder,s=a.tail;if(xi(e,t,a.children,n),0!==(2&(a=$s.current)))a=1&a|2,t.flags|=128;else{if(null!==e&&0!==(128&e.flags))e:for(e=t.child;null!==e;){if(13===e.tag)null!==e.memoizedState&&Wi(e,n,t);else if(19===e.tag)Wi(e,n,t);else if(null!==e.child){e.child.return=e,e=e.child;continue}if(e===t)break e;for(;null===e.sibling;){if(null===e.return||e.return===t)break e;e=e.return}e.sibling.return=e.return,e=e.sibling}a&=1}if(Tr($s,a),0===(1&t.mode))t.memoizedState=null;else switch(r){case"forwards":for(n=t.child,r=null;null!==n;)null!==(e=n.alternate)&&null===eo(e)&&(r=n),n=n.sibling;null===(n=r)?(r=t.child,t.child=null):(r=n.sibling,n.sibling=null),Vi(t,!1,r,n,s);break;case"backwards":for(n=null,r=t.child,t.child=null;null!==r;){if(null!==(e=r.alternate)&&null===eo(e)){t.child=r;break}e=r.sibling,r.sibling=n,n=r,r=e}Vi(t,!0,n,null,s);break;case"together":Vi(t,!1,null,null,void 0);break;default:t.memoizedState=null}return t.child}function Gi(e,t){0===(1&t.mode)&&null!==e&&(e.alternate=null,t.alternate=null,t.flags|=2)}function Hi(e,t,n){if(null!==e&&(t.dependencies=e.dependencies),Lc|=t.lanes,0===(n&t.childLanes))return null;if(null!==e&&t.child!==e.child)throw Error(s(153));if(null!==t.child){for(n=Fl(e=t.child,e.pendingProps),t.child=n,n.return=t;null!==e.sibling;)e=e.sibling,(n=n.sibling=Fl(e,e.pendingProps)).return=t;n.sibling=null}return t.child}function ji(e,t){if(!rs)switch(e.tailMode){case"hidden":t=e.tail;for(var n=null;null!==t;)null!==t.alternate&&(n=t),t=t.sibling;null===n?e.tail=null:n.sibling=null;break;case"collapsed":n=e.tail;for(var a=null;null!==n;)null!==n.alternate&&(a=n),n=n.sibling;null===a?t||null===e.tail?e.tail=null:e.tail.sibling=null:a.sibling=null}}function Ki(e){var t=null!==e.alternate&&e.alternate.child===e.child,n=0,a=0;if(t)for(var r=e.child;null!==r;)n|=r.lanes|r.childLanes,a|=14680064&r.subtreeFlags,a|=14680064&r.flags,r.return=e,r=r.sibling;else for(r=e.child;null!==r;)n|=r.lanes|r.childLanes,a|=r.subtreeFlags,a|=r.flags,r.return=e,r=r.sibling;return e.subtreeFlags|=a,e.childLanes=n,t}function qi(e,t,n){var a=t.pendingProps;switch(ts(t),t.tag){case 2:case 16:case 15:case 0:case 11:case 7:case 8:case 12:case 9:case 14:return Ki(t),null;case 1:case 17:return Dr(t.type)&&Fr(),Ki(t),null;case 3:return a=t.stateNode,Qs(),Nr(Rr),Nr(Cr),no(),a.pendingContext&&(a.context=a.pendingContext,a.pendingContext=null),null!==e&&null!==e.child||(hs(t)?t.flags|=4:null===e||e.memoizedState.isDehydrated&&0===(256&t.flags)||(t.flags|=1024,null!==ss&&(ol(ss),ss=null))),Di(e,t),Ki(t),null;case 5:Zs(t);var r=Xs(qs.current);if(n=t.type,null!==e&&null!=t.stateNode)Fi(e,t,n,a,r),e.ref!==t.ref&&(t.flags|=512,t.flags|=2097152);else{if(!a){if(null===t.stateNode)throw Error(s(166));return Ki(t),null}if(e=Xs(js.current),hs(t)){a=t.stateNode,n=t.type;var o=t.memoizedProps;switch(a[dr]=t,a[pr]=o,e=0!==(1&t.mode),n){case"dialog":Ba("cancel",a),Ba("close",a);break;case"iframe":case"object":case"embed":Ba("load",a);break;case"video":case"audio":for(r=0;r<Ma.length;r++)Ba(Ma[r],a);break;case"source":Ba("error",a);break;case"img":case"image":case"link":Ba("error",a),Ba("load",a);break;case"details":Ba("toggle",a);break;case"input":Q(a,o),Ba("invalid",a);break;case"select":a._wrapperState={wasMultiple:!!o.multiple},Ba("invalid",a);break;case"textarea":re(a,o),Ba("invalid",a)}for(var c in be(n,o),r=null,o)if(o.hasOwnProperty(c)){var l=o[c];"children"===c?"string"===typeof l?a.textContent!==l&&(!0!==o.suppressHydrationWarning&&Za(a.textContent,l,e),r=["children",l]):"number"===typeof l&&a.textContent!==""+l&&(!0!==o.suppressHydrationWarning&&Za(a.textContent,l,e),r=["children",""+l]):i.hasOwnProperty(c)&&null!=l&&"onScroll"===c&&Ba("scroll",a)}switch(n){case"input":K(a),$(a,o,!0);break;case"textarea":K(a),oe(a);break;case"select":case"option":break;default:"function"===typeof o.onClick&&(a.onclick=$a)}a=r,t.updateQueue=a,null!==a&&(t.flags|=4)}else{c=9===r.nodeType?r:r.ownerDocument,"http://www.w3.org/1999/xhtml"===e&&(e=ie(n)),"http://www.w3.org/1999/xhtml"===e?"script"===n?((e=c.createElement("div")).innerHTML="<script><\/script>",e=e.removeChild(e.firstChild)):"string"===typeof a.is?e=c.createElement(n,{is:a.is}):(e=c.createElement(n),"select"===n&&(c=e,a.multiple?c.multiple=!0:a.size&&(c.size=a.size))):e=c.createElementNS(e,n),e[dr]=t,e[pr]=a,_i(e,t,!1,!1),t.stateNode=e;e:{switch(c=ve(n,a),n){case"dialog":Ba("cancel",e),Ba("close",e),r=a;break;case"iframe":case"object":case"embed":Ba("load",e),r=a;break;case"video":case"audio":for(r=0;r<Ma.length;r++)Ba(Ma[r],e);r=a;break;case"source":Ba("error",e),r=a;break;case"img":case"image":case"link":Ba("error",e),Ba("load",e),r=a;break;case"details":Ba("toggle",e),r=a;break;case"input":Q(e,a),r=Y(e,a),Ba("invalid",e);break;case"option":default:r=a;break;case"select":e._wrapperState={wasMultiple:!!a.multiple},r=z({},a,{value:void 0}),Ba("invalid",e);break;case"textarea":re(e,a),r=ae(e,a),Ba("invalid",e)}for(o in be(n,r),l=r)if(l.hasOwnProperty(o)){var u=l[o];"style"===o?ge(e,u):"dangerouslySetInnerHTML"===o?null!=(u=u?u.__html:void 0)&&he(e,u):"children"===o?"string"===typeof u?("textarea"!==n||""!==u)&&de(e,u):"number"===typeof u&&de(e,""+u):"suppressContentEditableWarning"!==o&&"suppressHydrationWarning"!==o&&"autoFocus"!==o&&(i.hasOwnProperty(o)?null!=u&&"onScroll"===o&&Ba("scroll",e):null!=u&&v(e,o,u,c))}switch(n){case"input":K(e),$(e,a,!1);break;case"textarea":K(e),oe(e);break;case"option":null!=a.value&&e.setAttribute("value",""+H(a.value));break;case"select":e.multiple=!!a.multiple,null!=(o=a.value)?ne(e,!!a.multiple,o,!1):null!=a.defaultValue&&ne(e,!!a.multiple,a.defaultValue,!0);break;default:"function"===typeof r.onClick&&(e.onclick=$a)}switch(n){case"button":case"input":case"select":case"textarea":a=!!a.autoFocus;break e;case"img":a=!0;break e;default:a=!1}}a&&(t.flags|=4)}null!==t.ref&&(t.flags|=512,t.flags|=2097152)}return Ki(t),null;case 6:if(e&&null!=t.stateNode)Oi(e,t,e.memoizedProps,a);else{if("string"!==typeof a&&null===t.stateNode)throw Error(s(166));if(n=Xs(qs.current),Xs(js.current),hs(t)){if(a=t.stateNode,n=t.memoizedProps,a[dr]=t,(o=a.nodeValue!==n)&&null!==(e=ns))switch(e.tag){case 3:Za(a.nodeValue,n,0!==(1&e.mode));break;case 5:!0!==e.memoizedProps.suppressHydrationWarning&&Za(a.nodeValue,n,0!==(1&e.mode))}o&&(t.flags|=4)}else(a=(9===n.nodeType?n:n.ownerDocument).createTextNode(a))[dr]=t,t.stateNode=a}return Ki(t),null;case 13:if(Nr($s),a=t.memoizedState,null===e||null!==e.memoizedState&&null!==e.memoizedState.dehydrated){if(rs&&null!==as&&0!==(1&t.mode)&&0===(128&t.flags))ds(),ps(),t.flags|=98560,o=!1;else if(o=hs(t),null!==a&&null!==a.dehydrated){if(null===e){if(!o)throw Error(s(318));if(!(o=null!==(o=t.memoizedState)?o.dehydrated:null))throw Error(s(317));o[dr]=t}else ps(),0===(128&t.flags)&&(t.memoizedState=null),t.flags|=4;Ki(t),o=!1}else null!==ss&&(ol(ss),ss=null),o=!0;if(!o)return 65536&t.flags?t:null}return 0!==(128&t.flags)?(t.lanes=n,t):((a=null!==a)!==(null!==e&&null!==e.memoizedState)&&a&&(t.child.flags|=8192,0!==(1&t.mode)&&(null===e||0!==(1&$s.current)?0===Oc&&(Oc=3):ml())),null!==t.updateQueue&&(t.flags|=4),Ki(t),null);case 4:return Qs(),Di(e,t),null===e&&Ua(t.stateNode.containerInfo),Ki(t),null;case 10:return Es(t.type._context),Ki(t),null;case 19:if(Nr($s),null===(o=t.memoizedState))return Ki(t),null;if(a=0!==(128&t.flags),null===(c=o.rendering))if(a)ji(o,!1);else{if(0!==Oc||null!==e&&0!==(128&e.flags))for(e=t.child;null!==e;){if(null!==(c=eo(e))){for(t.flags|=128,ji(o,!1),null!==(a=c.updateQueue)&&(t.updateQueue=a,t.flags|=4),t.subtreeFlags=0,a=n,n=t.child;null!==n;)e=a,(o=n).flags&=14680066,null===(c=o.alternate)?(o.childLanes=0,o.lanes=e,o.child=null,o.subtreeFlags=0,o.memoizedProps=null,o.memoizedState=null,o.updateQueue=null,o.dependencies=null,o.stateNode=null):(o.childLanes=c.childLanes,o.lanes=c.lanes,o.child=c.child,o.subtreeFlags=0,o.deletions=null,o.memoizedProps=c.memoizedProps,o.memoizedState=c.memoizedState,o.updateQueue=c.updateQueue,o.type=c.type,e=c.dependencies,o.dependencies=null===e?null:{lanes:e.lanes,firstContext:e.firstContext}),n=n.sibling;return Tr($s,1&$s.current|2),t.child}e=e.sibling}null!==o.tail&&Je()>Uc&&(t.flags|=128,a=!0,ji(o,!1),t.lanes=4194304)}else{if(!a)if(null!==(e=eo(c))){if(t.flags|=128,a=!0,null!==(n=e.updateQueue)&&(t.updateQueue=n,t.flags|=4),ji(o,!0),null===o.tail&&"hidden"===o.tailMode&&!c.alternate&&!rs)return Ki(t),null}else 2*Je()-o.renderingStartTime>Uc&&1073741824!==n&&(t.flags|=128,a=!0,ji(o,!1),t.lanes=4194304);o.isBackwards?(c.sibling=t.child,t.child=c):(null!==(n=o.last)?n.sibling=c:t.child=c,o.last=c)}return null!==o.tail?(t=o.tail,o.rendering=t,o.tail=t.sibling,o.renderingStartTime=Je(),t.sibling=null,n=$s.current,Tr($s,a?1&n|2:1&n),t):(Ki(t),null);case 22:case 23:return hl(),a=null!==t.memoizedState,null!==e&&null!==e.memoizedState!==a&&(t.flags|=8192),a&&0!==(1&t.mode)?0!==(1073741824&Dc)&&(Ki(t),6&t.subtreeFlags&&(t.flags|=8192)):Ki(t),null;case 24:case 25:return null}throw Error(s(156,t.tag))}function Xi(e,t){switch(ts(t),t.tag){case 1:return Dr(t.type)&&Fr(),65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 3:return Qs(),Nr(Rr),Nr(Cr),no(),0!==(65536&(e=t.flags))&&0===(128&e)?(t.flags=-65537&e|128,t):null;case 5:return Zs(t),null;case 13:if(Nr($s),null!==(e=t.memoizedState)&&null!==e.dehydrated){if(null===t.alternate)throw Error(s(340));ps()}return 65536&(e=t.flags)?(t.flags=-65537&e|128,t):null;case 19:return Nr($s),null;case 4:return Qs(),null;case 10:return Es(t.type._context),null;case 22:case 23:return hl(),null;default:return null}}_i=function(e,t){for(var n=t.child;null!==n;){if(5===n.tag||6===n.tag)e.appendChild(n.stateNode);else if(4!==n.tag&&null!==n.child){n.child.return=n,n=n.child;continue}if(n===t)break;for(;null===n.sibling;){if(null===n.return||n.return===t)return;n=n.return}n.sibling.return=n.return,n=n.sibling}},Di=function(){},Fi=function(e,t,n,a){var r=e.memoizedProps;if(r!==a){e=t.stateNode,Xs(js.current);var s,o=null;switch(n){case"input":r=Y(e,r),a=Y(e,a),o=[];break;case"select":r=z({},r,{value:void 0}),a=z({},a,{value:void 0}),o=[];break;case"textarea":r=ae(e,r),a=ae(e,a),o=[];break;default:"function"!==typeof r.onClick&&"function"===typeof a.onClick&&(e.onclick=$a)}for(u in be(n,a),n=null,r)if(!a.hasOwnProperty(u)&&r.hasOwnProperty(u)&&null!=r[u])if("style"===u){var c=r[u];for(s in c)c.hasOwnProperty(s)&&(n||(n={}),n[s]="")}else"dangerouslySetInnerHTML"!==u&&"children"!==u&&"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&"autoFocus"!==u&&(i.hasOwnProperty(u)?o||(o=[]):(o=o||[]).push(u,null));for(u in a){var l=a[u];if(c=null!=r?r[u]:void 0,a.hasOwnProperty(u)&&l!==c&&(null!=l||null!=c))if("style"===u)if(c){for(s in c)!c.hasOwnProperty(s)||l&&l.hasOwnProperty(s)||(n||(n={}),n[s]="");for(s in l)l.hasOwnProperty(s)&&c[s]!==l[s]&&(n||(n={}),n[s]=l[s])}else n||(o||(o=[]),o.push(u,n)),n=l;else"dangerouslySetInnerHTML"===u?(l=l?l.__html:void 0,c=c?c.__html:void 0,null!=l&&c!==l&&(o=o||[]).push(u,l)):"children"===u?"string"!==typeof l&&"number"!==typeof l||(o=o||[]).push(u,""+l):"suppressContentEditableWarning"!==u&&"suppressHydrationWarning"!==u&&(i.hasOwnProperty(u)?(null!=l&&"onScroll"===u&&Ba("scroll",e),o||c===l||(o=[])):(o=o||[]).push(u,l))}n&&(o=o||[]).push("style",n);var u=o;(t.updateQueue=u)&&(t.flags|=4)}},Oi=function(e,t,n,a){n!==a&&(t.flags|=4)};var Yi=!1,Qi=!1,Ji="function"===typeof WeakSet?WeakSet:Set,Zi=null;function $i(e,t){var n=e.ref;if(null!==n)if("function"===typeof n)try{n(null)}catch(a){Il(e,t,a)}else n.current=null}function ec(e,t,n){try{n()}catch(a){Il(e,t,a)}}var tc=!1;function nc(e,t,n){var a=t.updateQueue;if(null!==(a=null!==a?a.lastEffect:null)){var r=a=a.next;do{if((r.tag&e)===e){var s=r.destroy;r.destroy=void 0,void 0!==s&&ec(t,n,s)}r=r.next}while(r!==a)}}function ac(e,t){if(null!==(t=null!==(t=t.updateQueue)?t.lastEffect:null)){var n=t=t.next;do{if((n.tag&e)===e){var a=n.create;n.destroy=a()}n=n.next}while(n!==t)}}function rc(e){var t=e.ref;if(null!==t){var n=e.stateNode;e.tag,e=n,"function"===typeof t?t(e):t.current=e}}function sc(e){var t=e.alternate;null!==t&&(e.alternate=null,sc(t)),e.child=null,e.deletions=null,e.sibling=null,5===e.tag&&(null!==(t=e.stateNode)&&(delete t[dr],delete t[pr],delete t[mr],delete t[gr],delete t[yr])),e.stateNode=null,e.return=null,e.dependencies=null,e.memoizedProps=null,e.memoizedState=null,e.pendingProps=null,e.stateNode=null,e.updateQueue=null}function oc(e){return 5===e.tag||3===e.tag||4===e.tag}function ic(e){e:for(;;){for(;null===e.sibling;){if(null===e.return||oc(e.return))return null;e=e.return}for(e.sibling.return=e.return,e=e.sibling;5!==e.tag&&6!==e.tag&&18!==e.tag;){if(2&e.flags)continue e;if(null===e.child||4===e.tag)continue e;e.child.return=e,e=e.child}if(!(2&e.flags))return e.stateNode}}function cc(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?8===n.nodeType?n.parentNode.insertBefore(e,t):n.insertBefore(e,t):(8===n.nodeType?(t=n.parentNode).insertBefore(e,n):(t=n).appendChild(e),null!==(n=n._reactRootContainer)&&void 0!==n||null!==t.onclick||(t.onclick=$a));else if(4!==a&&null!==(e=e.child))for(cc(e,t,n),e=e.sibling;null!==e;)cc(e,t,n),e=e.sibling}function lc(e,t,n){var a=e.tag;if(5===a||6===a)e=e.stateNode,t?n.insertBefore(e,t):n.appendChild(e);else if(4!==a&&null!==(e=e.child))for(lc(e,t,n),e=e.sibling;null!==e;)lc(e,t,n),e=e.sibling}var uc=null,hc=!1;function dc(e,t,n){for(n=n.child;null!==n;)pc(e,t,n),n=n.sibling}function pc(e,t,n){if(st&&"function"===typeof st.onCommitFiberUnmount)try{st.onCommitFiberUnmount(rt,n)}catch(i){}switch(n.tag){case 5:Qi||$i(n,t);case 6:var a=uc,r=hc;uc=null,dc(e,t,n),hc=r,null!==(uc=a)&&(hc?(e=uc,n=n.stateNode,8===e.nodeType?e.parentNode.removeChild(n):e.removeChild(n)):uc.removeChild(n.stateNode));break;case 18:null!==uc&&(hc?(e=uc,n=n.stateNode,8===e.nodeType?cr(e.parentNode,n):1===e.nodeType&&cr(e,n),Ut(e)):cr(uc,n.stateNode));break;case 4:a=uc,r=hc,uc=n.stateNode.containerInfo,hc=!0,dc(e,t,n),uc=a,hc=r;break;case 0:case 11:case 14:case 15:if(!Qi&&(null!==(a=n.updateQueue)&&null!==(a=a.lastEffect))){r=a=a.next;do{var s=r,o=s.destroy;s=s.tag,void 0!==o&&(0!==(2&s)||0!==(4&s))&&ec(n,t,o),r=r.next}while(r!==a)}dc(e,t,n);break;case 1:if(!Qi&&($i(n,t),"function"===typeof(a=n.stateNode).componentWillUnmount))try{a.props=n.memoizedProps,a.state=n.memoizedState,a.componentWillUnmount()}catch(i){Il(n,t,i)}dc(e,t,n);break;case 21:dc(e,t,n);break;case 22:1&n.mode?(Qi=(a=Qi)||null!==n.memoizedState,dc(e,t,n),Qi=a):dc(e,t,n);break;default:dc(e,t,n)}}function fc(e){var t=e.updateQueue;if(null!==t){e.updateQueue=null;var n=e.stateNode;null===n&&(n=e.stateNode=new Ji),t.forEach((function(t){var a=Cl.bind(null,e,t);n.has(t)||(n.add(t),t.then(a,a))}))}}function mc(e,t){var n=t.deletions;if(null!==n)for(var a=0;a<n.length;a++){var r=n[a];try{var o=e,i=t,c=i;e:for(;null!==c;){switch(c.tag){case 5:uc=c.stateNode,hc=!1;break e;case 3:case 4:uc=c.stateNode.containerInfo,hc=!0;break e}c=c.return}if(null===uc)throw Error(s(160));pc(o,i,r),uc=null,hc=!1;var l=r.alternate;null!==l&&(l.return=null),r.return=null}catch(u){Il(r,t,u)}}if(12854&t.subtreeFlags)for(t=t.child;null!==t;)gc(t,e),t=t.sibling}function gc(e,t){var n=e.alternate,a=e.flags;switch(e.tag){case 0:case 11:case 14:case 15:if(mc(t,e),yc(e),4&a){try{nc(3,e,e.return),ac(3,e)}catch(g){Il(e,e.return,g)}try{nc(5,e,e.return)}catch(g){Il(e,e.return,g)}}break;case 1:mc(t,e),yc(e),512&a&&null!==n&&$i(n,n.return);break;case 5:if(mc(t,e),yc(e),512&a&&null!==n&&$i(n,n.return),32&e.flags){var r=e.stateNode;try{de(r,"")}catch(g){Il(e,e.return,g)}}if(4&a&&null!=(r=e.stateNode)){var o=e.memoizedProps,i=null!==n?n.memoizedProps:o,c=e.type,l=e.updateQueue;if(e.updateQueue=null,null!==l)try{"input"===c&&"radio"===o.type&&null!=o.name&&J(r,o),ve(c,i);var u=ve(c,o);for(i=0;i<l.length;i+=2){var h=l[i],d=l[i+1];"style"===h?ge(r,d):"dangerouslySetInnerHTML"===h?he(r,d):"children"===h?de(r,d):v(r,h,d,u)}switch(c){case"input":Z(r,o);break;case"textarea":se(r,o);break;case"select":var p=r._wrapperState.wasMultiple;r._wrapperState.wasMultiple=!!o.multiple;var f=o.value;null!=f?ne(r,!!o.multiple,f,!1):p!==!!o.multiple&&(null!=o.defaultValue?ne(r,!!o.multiple,o.defaultValue,!0):ne(r,!!o.multiple,o.multiple?[]:"",!1))}r[pr]=o}catch(g){Il(e,e.return,g)}}break;case 6:if(mc(t,e),yc(e),4&a){if(null===e.stateNode)throw Error(s(162));r=e.stateNode,o=e.memoizedProps;try{r.nodeValue=o}catch(g){Il(e,e.return,g)}}break;case 3:if(mc(t,e),yc(e),4&a&&null!==n&&n.memoizedState.isDehydrated)try{Ut(t.containerInfo)}catch(g){Il(e,e.return,g)}break;case 4:default:mc(t,e),yc(e);break;case 13:mc(t,e),yc(e),8192&(r=e.child).flags&&(o=null!==r.memoizedState,r.stateNode.isHidden=o,!o||null!==r.alternate&&null!==r.alternate.memoizedState||(Vc=Je())),4&a&&fc(e);break;case 22:if(h=null!==n&&null!==n.memoizedState,1&e.mode?(Qi=(u=Qi)||h,mc(t,e),Qi=u):mc(t,e),yc(e),8192&a){if(u=null!==e.memoizedState,(e.stateNode.isHidden=u)&&!h&&0!==(1&e.mode))for(Zi=e,h=e.child;null!==h;){for(d=Zi=h;null!==Zi;){switch(f=(p=Zi).child,p.tag){case 0:case 11:case 14:case 15:nc(4,p,p.return);break;case 1:$i(p,p.return);var m=p.stateNode;if("function"===typeof m.componentWillUnmount){a=p,n=p.return;try{t=a,m.props=t.memoizedProps,m.state=t.memoizedState,m.componentWillUnmount()}catch(g){Il(a,n,g)}}break;case 5:$i(p,p.return);break;case 22:if(null!==p.memoizedState){wc(d);continue}}null!==f?(f.return=p,Zi=f):wc(d)}h=h.sibling}e:for(h=null,d=e;;){if(5===d.tag){if(null===h){h=d;try{r=d.stateNode,u?"function"===typeof(o=r.style).setProperty?o.setProperty("display","none","important"):o.display="none":(c=d.stateNode,i=void 0!==(l=d.memoizedProps.style)&&null!==l&&l.hasOwnProperty("display")?l.display:null,c.style.display=me("display",i))}catch(g){Il(e,e.return,g)}}}else if(6===d.tag){if(null===h)try{d.stateNode.nodeValue=u?"":d.memoizedProps}catch(g){Il(e,e.return,g)}}else if((22!==d.tag&&23!==d.tag||null===d.memoizedState||d===e)&&null!==d.child){d.child.return=d,d=d.child;continue}if(d===e)break e;for(;null===d.sibling;){if(null===d.return||d.return===e)break e;h===d&&(h=null),d=d.return}h===d&&(h=null),d.sibling.return=d.return,d=d.sibling}}break;case 19:mc(t,e),yc(e),4&a&&fc(e);case 21:}}function yc(e){var t=e.flags;if(2&t){try{e:{for(var n=e.return;null!==n;){if(oc(n)){var a=n;break e}n=n.return}throw Error(s(160))}switch(a.tag){case 5:var r=a.stateNode;32&a.flags&&(de(r,""),a.flags&=-33),lc(e,ic(e),r);break;case 3:case 4:var o=a.stateNode.containerInfo;cc(e,ic(e),o);break;default:throw Error(s(161))}}catch(i){Il(e,e.return,i)}e.flags&=-3}4096&t&&(e.flags&=-4097)}function bc(e,t,n){Zi=e,vc(e,t,n)}function vc(e,t,n){for(var a=0!==(1&e.mode);null!==Zi;){var r=Zi,s=r.child;if(22===r.tag&&a){var o=null!==r.memoizedState||Yi;if(!o){var i=r.alternate,c=null!==i&&null!==i.memoizedState||Qi;i=Yi;var l=Qi;if(Yi=o,(Qi=c)&&!l)for(Zi=r;null!==Zi;)c=(o=Zi).child,22===o.tag&&null!==o.memoizedState?kc(r):null!==c?(c.return=o,Zi=c):kc(r);for(;null!==s;)Zi=s,vc(s,t,n),s=s.sibling;Zi=r,Yi=i,Qi=l}xc(e)}else 0!==(8772&r.subtreeFlags)&&null!==s?(s.return=r,Zi=s):xc(e)}}function xc(e){for(;null!==Zi;){var t=Zi;if(0!==(8772&t.flags)){var n=t.alternate;try{if(0!==(8772&t.flags))switch(t.tag){case 0:case 11:case 15:Qi||ac(5,t);break;case 1:var a=t.stateNode;if(4&t.flags&&!Qi)if(null===n)a.componentDidMount();else{var r=t.elementType===t.type?n.memoizedProps:ni(t.type,n.memoizedProps);a.componentDidUpdate(r,n.memoizedState,a.__reactInternalSnapshotBeforeUpdate)}var o=t.updateQueue;null!==o&&Gs(t,o,a);break;case 3:var i=t.updateQueue;if(null!==i){if(n=null,null!==t.child)switch(t.child.tag){case 5:case 1:n=t.child.stateNode}Gs(t,i,n)}break;case 5:var c=t.stateNode;if(null===n&&4&t.flags){n=c;var l=t.memoizedProps;switch(t.type){case"button":case"input":case"select":case"textarea":l.autoFocus&&n.focus();break;case"img":l.src&&(n.src=l.src)}}break;case 6:case 4:case 12:case 19:case 17:case 21:case 22:case 23:case 25:break;case 13:if(null===t.memoizedState){var u=t.alternate;if(null!==u){var h=u.memoizedState;if(null!==h){var d=h.dehydrated;null!==d&&Ut(d)}}}break;default:throw Error(s(163))}Qi||512&t.flags&&rc(t)}catch(p){Il(t,t.return,p)}}if(t===e){Zi=null;break}if(null!==(n=t.sibling)){n.return=t.return,Zi=n;break}Zi=t.return}}function wc(e){for(;null!==Zi;){var t=Zi;if(t===e){Zi=null;break}var n=t.sibling;if(null!==n){n.return=t.return,Zi=n;break}Zi=t.return}}function kc(e){for(;null!==Zi;){var t=Zi;try{switch(t.tag){case 0:case 11:case 15:var n=t.return;try{ac(4,t)}catch(c){Il(t,n,c)}break;case 1:var a=t.stateNode;if("function"===typeof a.componentDidMount){var r=t.return;try{a.componentDidMount()}catch(c){Il(t,r,c)}}var s=t.return;try{rc(t)}catch(c){Il(t,s,c)}break;case 5:var o=t.return;try{rc(t)}catch(c){Il(t,o,c)}}}catch(c){Il(t,t.return,c)}if(t===e){Zi=null;break}var i=t.sibling;if(null!==i){i.return=t.return,Zi=i;break}Zi=t.return}}var Sc,Ic=Math.ceil,Nc=x.ReactCurrentDispatcher,Tc=x.ReactCurrentOwner,Ec=x.ReactCurrentBatchConfig,Cc=0,Rc=null,Ac=null,_c=0,Dc=0,Fc=Ir(0),Oc=0,Mc=null,Lc=0,zc=0,Pc=0,Bc=null,Wc=null,Vc=0,Uc=1/0,Gc=null,Hc=!1,jc=null,Kc=null,qc=!1,Xc=null,Yc=0,Qc=0,Jc=null,Zc=-1,$c=0;function el(){return 0!==(6&Cc)?Je():-1!==Zc?Zc:Zc=Je()}function tl(e){return 0===(1&e.mode)?1:0!==(2&Cc)&&0!==_c?_c&-_c:null!==ms.transition?(0===$c&&($c=mt()),$c):0!==(e=vt)?e:e=void 0===(e=window.event)?16:Qt(e.type)}function nl(e,t,n,a){if(50<Qc)throw Qc=0,Jc=null,Error(s(185));yt(e,n,a),0!==(2&Cc)&&e===Rc||(e===Rc&&(0===(2&Cc)&&(zc|=n),4===Oc&&il(e,_c)),al(e,a),1===n&&0===Cc&&0===(1&t.mode)&&(Uc=Je()+500,Br&&Ur()))}function al(e,t){var n=e.callbackNode;!function(e,t){for(var n=e.suspendedLanes,a=e.pingedLanes,r=e.expirationTimes,s=e.pendingLanes;0<s;){var o=31-ot(s),i=1<<o,c=r[o];-1===c?0!==(i&n)&&0===(i&a)||(r[o]=pt(i,t)):c<=t&&(e.expiredLanes|=i),s&=~i}}(e,t);var a=dt(e,e===Rc?_c:0);if(0===a)null!==n&&Xe(n),e.callbackNode=null,e.callbackPriority=0;else if(t=a&-a,e.callbackPriority!==t){if(null!=n&&Xe(n),1===t)0===e.tag?function(e){Br=!0,Vr(e)}(cl.bind(null,e)):Vr(cl.bind(null,e)),or((function(){0===(6&Cc)&&Ur()})),n=null;else{switch(xt(a)){case 1:n=$e;break;case 4:n=et;break;case 16:default:n=tt;break;case 536870912:n=at}n=Rl(n,rl.bind(null,e))}e.callbackPriority=t,e.callbackNode=n}}function rl(e,t){if(Zc=-1,$c=0,0!==(6&Cc))throw Error(s(327));var n=e.callbackNode;if(kl()&&e.callbackNode!==n)return null;var a=dt(e,e===Rc?_c:0);if(0===a)return null;if(0!==(30&a)||0!==(a&e.expiredLanes)||t)t=gl(e,a);else{t=a;var r=Cc;Cc|=2;var o=fl();for(Rc===e&&_c===t||(Gc=null,Uc=Je()+500,dl(e,t));;)try{bl();break}catch(c){pl(e,c)}Ts(),Nc.current=o,Cc=r,null!==Ac?t=0:(Rc=null,_c=0,t=Oc)}if(0!==t){if(2===t&&(0!==(r=ft(e))&&(a=r,t=sl(e,r))),1===t)throw n=Mc,dl(e,0),il(e,a),al(e,Je()),n;if(6===t)il(e,a);else{if(r=e.current.alternate,0===(30&a)&&!function(e){for(var t=e;;){if(16384&t.flags){var n=t.updateQueue;if(null!==n&&null!==(n=n.stores))for(var a=0;a<n.length;a++){var r=n[a],s=r.getSnapshot;r=r.value;try{if(!ia(s(),r))return!1}catch(i){return!1}}}if(n=t.child,16384&t.subtreeFlags&&null!==n)n.return=t,t=n;else{if(t===e)break;for(;null===t.sibling;){if(null===t.return||t.return===e)return!0;t=t.return}t.sibling.return=t.return,t=t.sibling}}return!0}(r)&&(2===(t=gl(e,a))&&(0!==(o=ft(e))&&(a=o,t=sl(e,o))),1===t))throw n=Mc,dl(e,0),il(e,a),al(e,Je()),n;switch(e.finishedWork=r,e.finishedLanes=a,t){case 0:case 1:throw Error(s(345));case 2:case 5:wl(e,Wc,Gc);break;case 3:if(il(e,a),(130023424&a)===a&&10<(t=Vc+500-Je())){if(0!==dt(e,0))break;if(((r=e.suspendedLanes)&a)!==a){el(),e.pingedLanes|=e.suspendedLanes&r;break}e.timeoutHandle=ar(wl.bind(null,e,Wc,Gc),t);break}wl(e,Wc,Gc);break;case 4:if(il(e,a),(4194240&a)===a)break;for(t=e.eventTimes,r=-1;0<a;){var i=31-ot(a);o=1<<i,(i=t[i])>r&&(r=i),a&=~o}if(a=r,10<(a=(120>(a=Je()-a)?120:480>a?480:1080>a?1080:1920>a?1920:3e3>a?3e3:4320>a?4320:1960*Ic(a/1960))-a)){e.timeoutHandle=ar(wl.bind(null,e,Wc,Gc),a);break}wl(e,Wc,Gc);break;default:throw Error(s(329))}}}return al(e,Je()),e.callbackNode===n?rl.bind(null,e):null}function sl(e,t){var n=Bc;return e.current.memoizedState.isDehydrated&&(dl(e,t).flags|=256),2!==(e=gl(e,t))&&(t=Wc,Wc=n,null!==t&&ol(t)),e}function ol(e){null===Wc?Wc=e:Wc.push.apply(Wc,e)}function il(e,t){for(t&=~Pc,t&=~zc,e.suspendedLanes|=t,e.pingedLanes&=~t,e=e.expirationTimes;0<t;){var n=31-ot(t),a=1<<n;e[n]=-1,t&=~a}}function cl(e){if(0!==(6&Cc))throw Error(s(327));kl();var t=dt(e,0);if(0===(1&t))return al(e,Je()),null;var n=gl(e,t);if(0!==e.tag&&2===n){var a=ft(e);0!==a&&(t=a,n=sl(e,a))}if(1===n)throw n=Mc,dl(e,0),il(e,t),al(e,Je()),n;if(6===n)throw Error(s(345));return e.finishedWork=e.current.alternate,e.finishedLanes=t,wl(e,Wc,Gc),al(e,Je()),null}function ll(e,t){var n=Cc;Cc|=1;try{return e(t)}finally{0===(Cc=n)&&(Uc=Je()+500,Br&&Ur())}}function ul(e){null!==Xc&&0===Xc.tag&&0===(6&Cc)&&kl();var t=Cc;Cc|=1;var n=Ec.transition,a=vt;try{if(Ec.transition=null,vt=1,e)return e()}finally{vt=a,Ec.transition=n,0===(6&(Cc=t))&&Ur()}}function hl(){Dc=Fc.current,Nr(Fc)}function dl(e,t){e.finishedWork=null,e.finishedLanes=0;var n=e.timeoutHandle;if(-1!==n&&(e.timeoutHandle=-1,rr(n)),null!==Ac)for(n=Ac.return;null!==n;){var a=n;switch(ts(a),a.tag){case 1:null!==(a=a.type.childContextTypes)&&void 0!==a&&Fr();break;case 3:Qs(),Nr(Rr),Nr(Cr),no();break;case 5:Zs(a);break;case 4:Qs();break;case 13:case 19:Nr($s);break;case 10:Es(a.type._context);break;case 22:case 23:hl()}n=n.return}if(Rc=e,Ac=e=Fl(e.current,null),_c=Dc=t,Oc=0,Mc=null,Pc=zc=Lc=0,Wc=Bc=null,null!==_s){for(t=0;t<_s.length;t++)if(null!==(a=(n=_s[t]).interleaved)){n.interleaved=null;var r=a.next,s=n.pending;if(null!==s){var o=s.next;s.next=r,a.next=o}n.pending=a}_s=null}return e}function pl(e,t){for(;;){var n=Ac;try{if(Ts(),ao.current=Zo,lo){for(var a=oo.memoizedState;null!==a;){var r=a.queue;null!==r&&(r.pending=null),a=a.next}lo=!1}if(so=0,co=io=oo=null,uo=!1,ho=0,Tc.current=null,null===n||null===n.return){Oc=1,Mc=t,Ac=null;break}e:{var o=e,i=n.return,c=n,l=t;if(t=_c,c.flags|=32768,null!==l&&"object"===typeof l&&"function"===typeof l.then){var u=l,h=c,d=h.tag;if(0===(1&h.mode)&&(0===d||11===d||15===d)){var p=h.alternate;p?(h.updateQueue=p.updateQueue,h.memoizedState=p.memoizedState,h.lanes=p.lanes):(h.updateQueue=null,h.memoizedState=null)}var f=gi(i);if(null!==f){f.flags&=-257,yi(f,i,c,0,t),1&f.mode&&mi(o,u,t),l=u;var m=(t=f).updateQueue;if(null===m){var g=new Set;g.add(l),t.updateQueue=g}else m.add(l);break e}if(0===(1&t)){mi(o,u,t),ml();break e}l=Error(s(426))}else if(rs&&1&c.mode){var y=gi(i);if(null!==y){0===(65536&y.flags)&&(y.flags|=256),yi(y,i,c,0,t),fs(li(l,c));break e}}o=l=li(l,c),4!==Oc&&(Oc=2),null===Bc?Bc=[o]:Bc.push(o),o=i;do{switch(o.tag){case 3:o.flags|=65536,t&=-t,o.lanes|=t,Vs(o,pi(0,l,t));break e;case 1:c=l;var b=o.type,v=o.stateNode;if(0===(128&o.flags)&&("function"===typeof b.getDerivedStateFromError||null!==v&&"function"===typeof v.componentDidCatch&&(null===Kc||!Kc.has(v)))){o.flags|=65536,t&=-t,o.lanes|=t,Vs(o,fi(o,c,t));break e}}o=o.return}while(null!==o)}xl(n)}catch(x){t=x,Ac===n&&null!==n&&(Ac=n=n.return);continue}break}}function fl(){var e=Nc.current;return Nc.current=Zo,null===e?Zo:e}function ml(){0!==Oc&&3!==Oc&&2!==Oc||(Oc=4),null===Rc||0===(268435455&Lc)&&0===(268435455&zc)||il(Rc,_c)}function gl(e,t){var n=Cc;Cc|=2;var a=fl();for(Rc===e&&_c===t||(Gc=null,dl(e,t));;)try{yl();break}catch(r){pl(e,r)}if(Ts(),Cc=n,Nc.current=a,null!==Ac)throw Error(s(261));return Rc=null,_c=0,Oc}function yl(){for(;null!==Ac;)vl(Ac)}function bl(){for(;null!==Ac&&!Ye();)vl(Ac)}function vl(e){var t=Sc(e.alternate,e,Dc);e.memoizedProps=e.pendingProps,null===t?xl(e):Ac=t,Tc.current=null}function xl(e){var t=e;do{var n=t.alternate;if(e=t.return,0===(32768&t.flags)){if(null!==(n=qi(n,t,Dc)))return void(Ac=n)}else{if(null!==(n=Xi(n,t)))return n.flags&=32767,void(Ac=n);if(null===e)return Oc=6,void(Ac=null);e.flags|=32768,e.subtreeFlags=0,e.deletions=null}if(null!==(t=t.sibling))return void(Ac=t);Ac=t=e}while(null!==t);0===Oc&&(Oc=5)}function wl(e,t,n){var a=vt,r=Ec.transition;try{Ec.transition=null,vt=1,function(e,t,n,a){do{kl()}while(null!==Xc);if(0!==(6&Cc))throw Error(s(327));n=e.finishedWork;var r=e.finishedLanes;if(null===n)return null;if(e.finishedWork=null,e.finishedLanes=0,n===e.current)throw Error(s(177));e.callbackNode=null,e.callbackPriority=0;var o=n.lanes|n.childLanes;if(function(e,t){var n=e.pendingLanes&~t;e.pendingLanes=t,e.suspendedLanes=0,e.pingedLanes=0,e.expiredLanes&=t,e.mutableReadLanes&=t,e.entangledLanes&=t,t=e.entanglements;var a=e.eventTimes;for(e=e.expirationTimes;0<n;){var r=31-ot(n),s=1<<r;t[r]=0,a[r]=-1,e[r]=-1,n&=~s}}(e,o),e===Rc&&(Ac=Rc=null,_c=0),0===(2064&n.subtreeFlags)&&0===(2064&n.flags)||qc||(qc=!0,Rl(tt,(function(){return kl(),null}))),o=0!==(15990&n.flags),0!==(15990&n.subtreeFlags)||o){o=Ec.transition,Ec.transition=null;var i=vt;vt=1;var c=Cc;Cc|=4,Tc.current=null,function(e,t){if(er=Ht,pa(e=da())){if("selectionStart"in e)var n={start:e.selectionStart,end:e.selectionEnd};else e:{var a=(n=(n=e.ownerDocument)&&n.defaultView||window).getSelection&&n.getSelection();if(a&&0!==a.rangeCount){n=a.anchorNode;var r=a.anchorOffset,o=a.focusNode;a=a.focusOffset;try{n.nodeType,o.nodeType}catch(w){n=null;break e}var i=0,c=-1,l=-1,u=0,h=0,d=e,p=null;t:for(;;){for(var f;d!==n||0!==r&&3!==d.nodeType||(c=i+r),d!==o||0!==a&&3!==d.nodeType||(l=i+a),3===d.nodeType&&(i+=d.nodeValue.length),null!==(f=d.firstChild);)p=d,d=f;for(;;){if(d===e)break t;if(p===n&&++u===r&&(c=i),p===o&&++h===a&&(l=i),null!==(f=d.nextSibling))break;p=(d=p).parentNode}d=f}n=-1===c||-1===l?null:{start:c,end:l}}else n=null}n=n||{start:0,end:0}}else n=null;for(tr={focusedElem:e,selectionRange:n},Ht=!1,Zi=t;null!==Zi;)if(e=(t=Zi).child,0!==(1028&t.subtreeFlags)&&null!==e)e.return=t,Zi=e;else for(;null!==Zi;){t=Zi;try{var m=t.alternate;if(0!==(1024&t.flags))switch(t.tag){case 0:case 11:case 15:case 5:case 6:case 4:case 17:break;case 1:if(null!==m){var g=m.memoizedProps,y=m.memoizedState,b=t.stateNode,v=b.getSnapshotBeforeUpdate(t.elementType===t.type?g:ni(t.type,g),y);b.__reactInternalSnapshotBeforeUpdate=v}break;case 3:var x=t.stateNode.containerInfo;1===x.nodeType?x.textContent="":9===x.nodeType&&x.documentElement&&x.removeChild(x.documentElement);break;default:throw Error(s(163))}}catch(w){Il(t,t.return,w)}if(null!==(e=t.sibling)){e.return=t.return,Zi=e;break}Zi=t.return}m=tc,tc=!1}(e,n),gc(n,e),fa(tr),Ht=!!er,tr=er=null,e.current=n,bc(n,e,r),Qe(),Cc=c,vt=i,Ec.transition=o}else e.current=n;if(qc&&(qc=!1,Xc=e,Yc=r),o=e.pendingLanes,0===o&&(Kc=null),function(e){if(st&&"function"===typeof st.onCommitFiberRoot)try{st.onCommitFiberRoot(rt,e,void 0,128===(128&e.current.flags))}catch(t){}}(n.stateNode),al(e,Je()),null!==t)for(a=e.onRecoverableError,n=0;n<t.length;n++)r=t[n],a(r.value,{componentStack:r.stack,digest:r.digest});if(Hc)throw Hc=!1,e=jc,jc=null,e;0!==(1&Yc)&&0!==e.tag&&kl(),o=e.pendingLanes,0!==(1&o)?e===Jc?Qc++:(Qc=0,Jc=e):Qc=0,Ur()}(e,t,n,a)}finally{Ec.transition=r,vt=a}return null}function kl(){if(null!==Xc){var e=xt(Yc),t=Ec.transition,n=vt;try{if(Ec.transition=null,vt=16>e?16:e,null===Xc)var a=!1;else{if(e=Xc,Xc=null,Yc=0,0!==(6&Cc))throw Error(s(331));var r=Cc;for(Cc|=4,Zi=e.current;null!==Zi;){var o=Zi,i=o.child;if(0!==(16&Zi.flags)){var c=o.deletions;if(null!==c){for(var l=0;l<c.length;l++){var u=c[l];for(Zi=u;null!==Zi;){var h=Zi;switch(h.tag){case 0:case 11:case 15:nc(8,h,o)}var d=h.child;if(null!==d)d.return=h,Zi=d;else for(;null!==Zi;){var p=(h=Zi).sibling,f=h.return;if(sc(h),h===u){Zi=null;break}if(null!==p){p.return=f,Zi=p;break}Zi=f}}}var m=o.alternate;if(null!==m){var g=m.child;if(null!==g){m.child=null;do{var y=g.sibling;g.sibling=null,g=y}while(null!==g)}}Zi=o}}if(0!==(2064&o.subtreeFlags)&&null!==i)i.return=o,Zi=i;else e:for(;null!==Zi;){if(0!==(2048&(o=Zi).flags))switch(o.tag){case 0:case 11:case 15:nc(9,o,o.return)}var b=o.sibling;if(null!==b){b.return=o.return,Zi=b;break e}Zi=o.return}}var v=e.current;for(Zi=v;null!==Zi;){var x=(i=Zi).child;if(0!==(2064&i.subtreeFlags)&&null!==x)x.return=i,Zi=x;else e:for(i=v;null!==Zi;){if(0!==(2048&(c=Zi).flags))try{switch(c.tag){case 0:case 11:case 15:ac(9,c)}}catch(k){Il(c,c.return,k)}if(c===i){Zi=null;break e}var w=c.sibling;if(null!==w){w.return=c.return,Zi=w;break e}Zi=c.return}}if(Cc=r,Ur(),st&&"function"===typeof st.onPostCommitFiberRoot)try{st.onPostCommitFiberRoot(rt,e)}catch(k){}a=!0}return a}finally{vt=n,Ec.transition=t}}return!1}function Sl(e,t,n){e=Bs(e,t=pi(0,t=li(n,t),1),1),t=el(),null!==e&&(yt(e,1,t),al(e,t))}function Il(e,t,n){if(3===e.tag)Sl(e,e,n);else for(;null!==t;){if(3===t.tag){Sl(t,e,n);break}if(1===t.tag){var a=t.stateNode;if("function"===typeof t.type.getDerivedStateFromError||"function"===typeof a.componentDidCatch&&(null===Kc||!Kc.has(a))){t=Bs(t,e=fi(t,e=li(n,e),1),1),e=el(),null!==t&&(yt(t,1,e),al(t,e));break}}t=t.return}}function Nl(e,t,n){var a=e.pingCache;null!==a&&a.delete(t),t=el(),e.pingedLanes|=e.suspendedLanes&n,Rc===e&&(_c&n)===n&&(4===Oc||3===Oc&&(130023424&_c)===_c&&500>Je()-Vc?dl(e,0):Pc|=n),al(e,t)}function Tl(e,t){0===t&&(0===(1&e.mode)?t=1:(t=ut,0===(130023424&(ut<<=1))&&(ut=4194304)));var n=el();null!==(e=Os(e,t))&&(yt(e,t,n),al(e,n))}function El(e){var t=e.memoizedState,n=0;null!==t&&(n=t.retryLane),Tl(e,n)}function Cl(e,t){var n=0;switch(e.tag){case 13:var a=e.stateNode,r=e.memoizedState;null!==r&&(n=r.retryLane);break;case 19:a=e.stateNode;break;default:throw Error(s(314))}null!==a&&a.delete(t),Tl(e,n)}function Rl(e,t){return qe(e,t)}function Al(e,t,n,a){this.tag=e,this.key=n,this.sibling=this.child=this.return=this.stateNode=this.type=this.elementType=null,this.index=0,this.ref=null,this.pendingProps=t,this.dependencies=this.memoizedState=this.updateQueue=this.memoizedProps=null,this.mode=a,this.subtreeFlags=this.flags=0,this.deletions=null,this.childLanes=this.lanes=0,this.alternate=null}function _l(e,t,n,a){return new Al(e,t,n,a)}function Dl(e){return!(!(e=e.prototype)||!e.isReactComponent)}function Fl(e,t){var n=e.alternate;return null===n?((n=_l(e.tag,t,e.key,e.mode)).elementType=e.elementType,n.type=e.type,n.stateNode=e.stateNode,n.alternate=e,e.alternate=n):(n.pendingProps=t,n.type=e.type,n.flags=0,n.subtreeFlags=0,n.deletions=null),n.flags=14680064&e.flags,n.childLanes=e.childLanes,n.lanes=e.lanes,n.child=e.child,n.memoizedProps=e.memoizedProps,n.memoizedState=e.memoizedState,n.updateQueue=e.updateQueue,t=e.dependencies,n.dependencies=null===t?null:{lanes:t.lanes,firstContext:t.firstContext},n.sibling=e.sibling,n.index=e.index,n.ref=e.ref,n}function Ol(e,t,n,a,r,o){var i=2;if(a=e,"function"===typeof e)Dl(e)&&(i=1);else if("string"===typeof e)i=5;else e:switch(e){case S:return Ml(n.children,r,o,t);case I:i=8,r|=8;break;case N:return(e=_l(12,n,t,2|r)).elementType=N,e.lanes=o,e;case R:return(e=_l(13,n,t,r)).elementType=R,e.lanes=o,e;case A:return(e=_l(19,n,t,r)).elementType=A,e.lanes=o,e;case F:return Ll(n,r,o,t);default:if("object"===typeof e&&null!==e)switch(e.$$typeof){case T:i=10;break e;case E:i=9;break e;case C:i=11;break e;case _:i=14;break e;case D:i=16,a=null;break e}throw Error(s(130,null==e?e:typeof e,""))}return(t=_l(i,n,t,r)).elementType=e,t.type=a,t.lanes=o,t}function Ml(e,t,n,a){return(e=_l(7,e,a,t)).lanes=n,e}function Ll(e,t,n,a){return(e=_l(22,e,a,t)).elementType=F,e.lanes=n,e.stateNode={isHidden:!1},e}function zl(e,t,n){return(e=_l(6,e,null,t)).lanes=n,e}function Pl(e,t,n){return(t=_l(4,null!==e.children?e.children:[],e.key,t)).lanes=n,t.stateNode={containerInfo:e.containerInfo,pendingChildren:null,implementation:e.implementation},t}function Bl(e,t,n,a,r){this.tag=t,this.containerInfo=e,this.finishedWork=this.pingCache=this.current=this.pendingChildren=null,this.timeoutHandle=-1,this.callbackNode=this.pendingContext=this.context=null,this.callbackPriority=0,this.eventTimes=gt(0),this.expirationTimes=gt(-1),this.entangledLanes=this.finishedLanes=this.mutableReadLanes=this.expiredLanes=this.pingedLanes=this.suspendedLanes=this.pendingLanes=0,this.entanglements=gt(0),this.identifierPrefix=a,this.onRecoverableError=r,this.mutableSourceEagerHydrationData=null}function Wl(e,t,n,a,r,s,o,i,c){return e=new Bl(e,t,n,i,c),1===t?(t=1,!0===s&&(t|=8)):t=0,s=_l(3,null,null,t),e.current=s,s.stateNode=e,s.memoizedState={element:a,isDehydrated:n,cache:null,transitions:null,pendingSuspenseBoundaries:null},Ls(s),e}function Vl(e){if(!e)return Er;e:{if(Ue(e=e._reactInternals)!==e||1!==e.tag)throw Error(s(170));var t=e;do{switch(t.tag){case 3:t=t.stateNode.context;break e;case 1:if(Dr(t.type)){t=t.stateNode.__reactInternalMemoizedMergedChildContext;break e}}t=t.return}while(null!==t);throw Error(s(171))}if(1===e.tag){var n=e.type;if(Dr(n))return Mr(e,n,t)}return t}function Ul(e,t,n,a,r,s,o,i,c){return(e=Wl(n,a,!0,e,0,s,0,i,c)).context=Vl(null),n=e.current,(s=Ps(a=el(),r=tl(n))).callback=void 0!==t&&null!==t?t:null,Bs(n,s,r),e.current.lanes=r,yt(e,r,a),al(e,a),e}function Gl(e,t,n,a){var r=t.current,s=el(),o=tl(r);return n=Vl(n),null===t.context?t.context=n:t.pendingContext=n,(t=Ps(s,o)).payload={element:e},null!==(a=void 0===a?null:a)&&(t.callback=a),null!==(e=Bs(r,t,o))&&(nl(e,r,o,s),Ws(e,r,o)),o}function Hl(e){return(e=e.current).child?(e.child.tag,e.child.stateNode):null}function jl(e,t){if(null!==(e=e.memoizedState)&&null!==e.dehydrated){var n=e.retryLane;e.retryLane=0!==n&&n<t?n:t}}function Kl(e,t){jl(e,t),(e=e.alternate)&&jl(e,t)}Sc=function(e,t,n){if(null!==e)if(e.memoizedProps!==t.pendingProps||Rr.current)vi=!0;else{if(0===(e.lanes&n)&&0===(128&t.flags))return vi=!1,function(e,t,n){switch(t.tag){case 3:Ri(t),ps();break;case 5:Js(t);break;case 1:Dr(t.type)&&Lr(t);break;case 4:Ys(t,t.stateNode.containerInfo);break;case 10:var a=t.type._context,r=t.memoizedProps.value;Tr(ks,a._currentValue),a._currentValue=r;break;case 13:if(null!==(a=t.memoizedState))return null!==a.dehydrated?(Tr($s,1&$s.current),t.flags|=128,null):0!==(n&t.child.childLanes)?zi(e,t,n):(Tr($s,1&$s.current),null!==(e=Hi(e,t,n))?e.sibling:null);Tr($s,1&$s.current);break;case 19:if(a=0!==(n&t.childLanes),0!==(128&e.flags)){if(a)return Ui(e,t,n);t.flags|=128}if(null!==(r=t.memoizedState)&&(r.rendering=null,r.tail=null,r.lastEffect=null),Tr($s,$s.current),a)break;return null;case 22:case 23:return t.lanes=0,Ii(e,t,n)}return Hi(e,t,n)}(e,t,n);vi=0!==(131072&e.flags)}else vi=!1,rs&&0!==(1048576&t.flags)&&$r(t,Kr,t.index);switch(t.lanes=0,t.tag){case 2:var a=t.type;Gi(e,t),e=t.pendingProps;var r=_r(t,Cr.current);Rs(t,n),r=go(null,t,a,e,r,n);var o=yo();return t.flags|=1,"object"===typeof r&&null!==r&&"function"===typeof r.render&&void 0===r.$$typeof?(t.tag=1,t.memoizedState=null,t.updateQueue=null,Dr(a)?(o=!0,Lr(t)):o=!1,t.memoizedState=null!==r.state&&void 0!==r.state?r.state:null,Ls(t),r.updater=ri,t.stateNode=r,r._reactInternals=t,ci(t,a,e,n),t=Ci(null,t,a,!0,o,n)):(t.tag=0,rs&&o&&es(t),xi(null,t,r,n),t=t.child),t;case 16:a=t.elementType;e:{switch(Gi(e,t),e=t.pendingProps,a=(r=a._init)(a._payload),t.type=a,r=t.tag=function(e){if("function"===typeof e)return Dl(e)?1:0;if(void 0!==e&&null!==e){if((e=e.$$typeof)===C)return 11;if(e===_)return 14}return 2}(a),e=ni(a,e),r){case 0:t=Ti(null,t,a,e,n);break e;case 1:t=Ei(null,t,a,e,n);break e;case 11:t=wi(null,t,a,e,n);break e;case 14:t=ki(null,t,a,ni(a.type,e),n);break e}throw Error(s(306,a,""))}return t;case 0:return a=t.type,r=t.pendingProps,Ti(e,t,a,r=t.elementType===a?r:ni(a,r),n);case 1:return a=t.type,r=t.pendingProps,Ei(e,t,a,r=t.elementType===a?r:ni(a,r),n);case 3:e:{if(Ri(t),null===e)throw Error(s(387));a=t.pendingProps,r=(o=t.memoizedState).element,zs(e,t),Us(t,a,null,n);var i=t.memoizedState;if(a=i.element,o.isDehydrated){if(o={element:a,isDehydrated:!1,cache:i.cache,pendingSuspenseBoundaries:i.pendingSuspenseBoundaries,transitions:i.transitions},t.updateQueue.baseState=o,t.memoizedState=o,256&t.flags){t=Ai(e,t,a,n,r=li(Error(s(423)),t));break e}if(a!==r){t=Ai(e,t,a,n,r=li(Error(s(424)),t));break e}for(as=lr(t.stateNode.containerInfo.firstChild),ns=t,rs=!0,ss=null,n=ws(t,null,a,n),t.child=n;n;)n.flags=-3&n.flags|4096,n=n.sibling}else{if(ps(),a===r){t=Hi(e,t,n);break e}xi(e,t,a,n)}t=t.child}return t;case 5:return Js(t),null===e&&ls(t),a=t.type,r=t.pendingProps,o=null!==e?e.memoizedProps:null,i=r.children,nr(a,r)?i=null:null!==o&&nr(a,o)&&(t.flags|=32),Ni(e,t),xi(e,t,i,n),t.child;case 6:return null===e&&ls(t),null;case 13:return zi(e,t,n);case 4:return Ys(t,t.stateNode.containerInfo),a=t.pendingProps,null===e?t.child=xs(t,null,a,n):xi(e,t,a,n),t.child;case 11:return a=t.type,r=t.pendingProps,wi(e,t,a,r=t.elementType===a?r:ni(a,r),n);case 7:return xi(e,t,t.pendingProps,n),t.child;case 8:case 12:return xi(e,t,t.pendingProps.children,n),t.child;case 10:e:{if(a=t.type._context,r=t.pendingProps,o=t.memoizedProps,i=r.value,Tr(ks,a._currentValue),a._currentValue=i,null!==o)if(ia(o.value,i)){if(o.children===r.children&&!Rr.current){t=Hi(e,t,n);break e}}else for(null!==(o=t.child)&&(o.return=t);null!==o;){var c=o.dependencies;if(null!==c){i=o.child;for(var l=c.firstContext;null!==l;){if(l.context===a){if(1===o.tag){(l=Ps(-1,n&-n)).tag=2;var u=o.updateQueue;if(null!==u){var h=(u=u.shared).pending;null===h?l.next=l:(l.next=h.next,h.next=l),u.pending=l}}o.lanes|=n,null!==(l=o.alternate)&&(l.lanes|=n),Cs(o.return,n,t),c.lanes|=n;break}l=l.next}}else if(10===o.tag)i=o.type===t.type?null:o.child;else if(18===o.tag){if(null===(i=o.return))throw Error(s(341));i.lanes|=n,null!==(c=i.alternate)&&(c.lanes|=n),Cs(i,n,t),i=o.sibling}else i=o.child;if(null!==i)i.return=o;else for(i=o;null!==i;){if(i===t){i=null;break}if(null!==(o=i.sibling)){o.return=i.return,i=o;break}i=i.return}o=i}xi(e,t,r.children,n),t=t.child}return t;case 9:return r=t.type,a=t.pendingProps.children,Rs(t,n),a=a(r=As(r)),t.flags|=1,xi(e,t,a,n),t.child;case 14:return r=ni(a=t.type,t.pendingProps),ki(e,t,a,r=ni(a.type,r),n);case 15:return Si(e,t,t.type,t.pendingProps,n);case 17:return a=t.type,r=t.pendingProps,r=t.elementType===a?r:ni(a,r),Gi(e,t),t.tag=1,Dr(a)?(e=!0,Lr(t)):e=!1,Rs(t,n),oi(t,a,r),ci(t,a,r,n),Ci(null,t,a,!0,e,n);case 19:return Ui(e,t,n);case 22:return Ii(e,t,n)}throw Error(s(156,t.tag))};var ql="function"===typeof reportError?reportError:function(e){console.error(e)};function Xl(e){this._internalRoot=e}function Yl(e){this._internalRoot=e}function Ql(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType)}function Jl(e){return!(!e||1!==e.nodeType&&9!==e.nodeType&&11!==e.nodeType&&(8!==e.nodeType||" react-mount-point-unstable "!==e.nodeValue))}function Zl(){}function $l(e,t,n,a,r){var s=n._reactRootContainer;if(s){var o=s;if("function"===typeof r){var i=r;r=function(){var e=Hl(o);i.call(e)}}Gl(t,o,e,r)}else o=function(e,t,n,a,r){if(r){if("function"===typeof a){var s=a;a=function(){var e=Hl(o);s.call(e)}}var o=Ul(t,a,e,0,null,!1,0,"",Zl);return e._reactRootContainer=o,e[fr]=o.current,Ua(8===e.nodeType?e.parentNode:e),ul(),o}for(;r=e.lastChild;)e.removeChild(r);if("function"===typeof a){var i=a;a=function(){var e=Hl(c);i.call(e)}}var c=Wl(e,0,!1,null,0,!1,0,"",Zl);return e._reactRootContainer=c,e[fr]=c.current,Ua(8===e.nodeType?e.parentNode:e),ul((function(){Gl(t,c,n,a)})),c}(n,t,e,r,a);return Hl(o)}Yl.prototype.render=Xl.prototype.render=function(e){var t=this._internalRoot;if(null===t)throw Error(s(409));Gl(e,t,null,null)},Yl.prototype.unmount=Xl.prototype.unmount=function(){var e=this._internalRoot;if(null!==e){this._internalRoot=null;var t=e.containerInfo;ul((function(){Gl(null,e,null,null)})),t[fr]=null}},Yl.prototype.unstable_scheduleHydration=function(e){if(e){var t=It();e={blockedOn:null,target:e,priority:t};for(var n=0;n<Ft.length&&0!==t&&t<Ft[n].priority;n++);Ft.splice(n,0,e),0===n&&zt(e)}},wt=function(e){switch(e.tag){case 3:var t=e.stateNode;if(t.current.memoizedState.isDehydrated){var n=ht(t.pendingLanes);0!==n&&(bt(t,1|n),al(t,Je()),0===(6&Cc)&&(Uc=Je()+500,Ur()))}break;case 13:ul((function(){var t=Os(e,1);if(null!==t){var n=el();nl(t,e,1,n)}})),Kl(e,1)}},kt=function(e){if(13===e.tag){var t=Os(e,134217728);if(null!==t)nl(t,e,134217728,el());Kl(e,134217728)}},St=function(e){if(13===e.tag){var t=tl(e),n=Os(e,t);if(null!==n)nl(n,e,t,el());Kl(e,t)}},It=function(){return vt},Nt=function(e,t){var n=vt;try{return vt=e,t()}finally{vt=n}},ke=function(e,t,n){switch(t){case"input":if(Z(e,n),t=n.name,"radio"===n.type&&null!=t){for(n=e;n.parentNode;)n=n.parentNode;for(n=n.querySelectorAll("input[name="+JSON.stringify(""+t)+'][type="radio"]'),t=0;t<n.length;t++){var a=n[t];if(a!==e&&a.form===e.form){var r=wr(a);if(!r)throw Error(s(90));q(a),Z(a,r)}}}break;case"textarea":se(e,n);break;case"select":null!=(t=n.value)&&ne(e,!!n.multiple,t,!1)}},Ce=ll,Re=ul;var eu={usingClientEntryPoint:!1,Events:[vr,xr,wr,Te,Ee,ll]},tu={findFiberByHostInstance:br,bundleType:0,version:"18.3.1",rendererPackageName:"react-dom"},nu={bundleType:tu.bundleType,version:tu.version,rendererPackageName:tu.rendererPackageName,rendererConfig:tu.rendererConfig,overrideHookState:null,overrideHookStateDeletePath:null,overrideHookStateRenamePath:null,overrideProps:null,overridePropsDeletePath:null,overridePropsRenamePath:null,setErrorHandler:null,setSuspenseHandler:null,scheduleUpdate:null,currentDispatcherRef:x.ReactCurrentDispatcher,findHostInstanceByFiber:function(e){return null===(e=je(e))?null:e.stateNode},findFiberByHostInstance:tu.findFiberByHostInstance||function(){return null},findHostInstancesForRefresh:null,scheduleRefresh:null,scheduleRoot:null,setRefreshHandler:null,getCurrentFiber:null,reconcilerVersion:"18.3.1-next-f1338f8080-20240426"};if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__){var au=__REACT_DEVTOOLS_GLOBAL_HOOK__;if(!au.isDisabled&&au.supportsFiber)try{rt=au.inject(nu),st=au}catch(ue){}}t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=eu,t.createPortal=function(e,t){var n=2<arguments.length&&void 0!==arguments[2]?arguments[2]:null;if(!Ql(t))throw Error(s(200));return function(e,t,n){var a=3<arguments.length&&void 0!==arguments[3]?arguments[3]:null;return{$$typeof:k,key:null==a?null:""+a,children:e,containerInfo:t,implementation:n}}(e,t,null,n)},t.createRoot=function(e,t){if(!Ql(e))throw Error(s(299));var n=!1,a="",r=ql;return null!==t&&void 0!==t&&(!0===t.unstable_strictMode&&(n=!0),void 0!==t.identifierPrefix&&(a=t.identifierPrefix),void 0!==t.onRecoverableError&&(r=t.onRecoverableError)),t=Wl(e,1,!1,null,0,n,0,a,r),e[fr]=t.current,Ua(8===e.nodeType?e.parentNode:e),new Xl(t)},t.findDOMNode=function(e){if(null==e)return null;if(1===e.nodeType)return e;var t=e._reactInternals;if(void 0===t){if("function"===typeof e.render)throw Error(s(188));throw e=Object.keys(e).join(","),Error(s(268,e))}return e=null===(e=je(t))?null:e.stateNode},t.flushSync=function(e){return ul(e)},t.hydrate=function(e,t,n){if(!Jl(t))throw Error(s(200));return $l(null,e,t,!0,n)},t.hydrateRoot=function(e,t,n){if(!Ql(e))throw Error(s(405));var a=null!=n&&n.hydratedSources||null,r=!1,o="",i=ql;if(null!==n&&void 0!==n&&(!0===n.unstable_strictMode&&(r=!0),void 0!==n.identifierPrefix&&(o=n.identifierPrefix),void 0!==n.onRecoverableError&&(i=n.onRecoverableError)),t=Ul(t,null,e,1,null!=n?n:null,r,0,o,i),e[fr]=t.current,Ua(e),a)for(e=0;e<a.length;e++)r=(r=(n=a[e])._getVersion)(n._source),null==t.mutableSourceEagerHydrationData?t.mutableSourceEagerHydrationData=[n,r]:t.mutableSourceEagerHydrationData.push(n,r);return new Yl(t)},t.render=function(e,t,n){if(!Jl(t))throw Error(s(200));return $l(null,e,t,!1,n)},t.unmountComponentAtNode=function(e){if(!Jl(e))throw Error(s(40));return!!e._reactRootContainer&&(ul((function(){$l(null,null,e,!1,(function(){e._reactRootContainer=null,e[fr]=null}))})),!0)},t.unstable_batchedUpdates=ll,t.unstable_renderSubtreeIntoContainer=function(e,t,n,a){if(!Jl(n))throw Error(s(200));if(null==e||void 0===e._reactInternals)throw Error(s(38));return $l(e,t,n,!1,a)},t.version="18.3.1-next-f1338f8080-20240426"},391:(e,t,n)=>{"use strict";var a=n(950);t.createRoot=a.createRoot,t.hydrateRoot=a.hydrateRoot},950:(e,t,n)=>{"use strict";!function e(){if("undefined"!==typeof __REACT_DEVTOOLS_GLOBAL_HOOK__&&"function"===typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE)try{__REACT_DEVTOOLS_GLOBAL_HOOK__.checkDCE(e)}catch(t){console.error(t)}}(),e.exports=n(730)},153:(e,t,n)=>{"use strict";var a=n(43),r=Symbol.for("react.element"),s=Symbol.for("react.fragment"),o=Object.prototype.hasOwnProperty,i=a.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED.ReactCurrentOwner,c={key:!0,ref:!0,__self:!0,__source:!0};function l(e,t,n){var a,s={},l=null,u=null;for(a in void 0!==n&&(l=""+n),void 0!==t.key&&(l=""+t.key),void 0!==t.ref&&(u=t.ref),t)o.call(t,a)&&!c.hasOwnProperty(a)&&(s[a]=t[a]);if(e&&e.defaultProps)for(a in t=e.defaultProps)void 0===s[a]&&(s[a]=t[a]);return{$$typeof:r,type:e,key:l,ref:u,props:s,_owner:i.current}}t.jsx=l,t.jsxs=l},202:(e,t)=>{"use strict";var n=Symbol.for("react.element"),a=Symbol.for("react.portal"),r=Symbol.for("react.fragment"),s=Symbol.for("react.strict_mode"),o=Symbol.for("react.profiler"),i=Symbol.for("react.provider"),c=Symbol.for("react.context"),l=Symbol.for("react.forward_ref"),u=Symbol.for("react.suspense"),h=Symbol.for("react.memo"),d=Symbol.for("react.lazy"),p=Symbol.iterator;var f={isMounted:function(){return!1},enqueueForceUpdate:function(){},enqueueReplaceState:function(){},enqueueSetState:function(){}},m=Object.assign,g={};function y(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}function b(){}function v(e,t,n){this.props=e,this.context=t,this.refs=g,this.updater=n||f}y.prototype.isReactComponent={},y.prototype.setState=function(e,t){if("object"!==typeof e&&"function"!==typeof e&&null!=e)throw Error("setState(...): takes an object of state variables to update or a function which returns an object of state variables.");this.updater.enqueueSetState(this,e,t,"setState")},y.prototype.forceUpdate=function(e){this.updater.enqueueForceUpdate(this,e,"forceUpdate")},b.prototype=y.prototype;var x=v.prototype=new b;x.constructor=v,m(x,y.prototype),x.isPureReactComponent=!0;var w=Array.isArray,k=Object.prototype.hasOwnProperty,S={current:null},I={key:!0,ref:!0,__self:!0,__source:!0};function N(e,t,a){var r,s={},o=null,i=null;if(null!=t)for(r in void 0!==t.ref&&(i=t.ref),void 0!==t.key&&(o=""+t.key),t)k.call(t,r)&&!I.hasOwnProperty(r)&&(s[r]=t[r]);var c=arguments.length-2;if(1===c)s.children=a;else if(1<c){for(var l=Array(c),u=0;u<c;u++)l[u]=arguments[u+2];s.children=l}if(e&&e.defaultProps)for(r in c=e.defaultProps)void 0===s[r]&&(s[r]=c[r]);return{$$typeof:n,type:e,key:o,ref:i,props:s,_owner:S.current}}function T(e){return"object"===typeof e&&null!==e&&e.$$typeof===n}var E=/\/+/g;function C(e,t){return"object"===typeof e&&null!==e&&null!=e.key?function(e){var t={"=":"=0",":":"=2"};return"$"+e.replace(/[=:]/g,(function(e){return t[e]}))}(""+e.key):t.toString(36)}function R(e,t,r,s,o){var i=typeof e;"undefined"!==i&&"boolean"!==i||(e=null);var c=!1;if(null===e)c=!0;else switch(i){case"string":case"number":c=!0;break;case"object":switch(e.$$typeof){case n:case a:c=!0}}if(c)return o=o(c=e),e=""===s?"."+C(c,0):s,w(o)?(r="",null!=e&&(r=e.replace(E,"$&/")+"/"),R(o,t,r,"",(function(e){return e}))):null!=o&&(T(o)&&(o=function(e,t){return{$$typeof:n,type:e.type,key:t,ref:e.ref,props:e.props,_owner:e._owner}}(o,r+(!o.key||c&&c.key===o.key?"":(""+o.key).replace(E,"$&/")+"/")+e)),t.push(o)),1;if(c=0,s=""===s?".":s+":",w(e))for(var l=0;l<e.length;l++){var u=s+C(i=e[l],l);c+=R(i,t,r,u,o)}else if(u=function(e){return null===e||"object"!==typeof e?null:"function"===typeof(e=p&&e[p]||e["@@iterator"])?e:null}(e),"function"===typeof u)for(e=u.call(e),l=0;!(i=e.next()).done;)c+=R(i=i.value,t,r,u=s+C(i,l++),o);else if("object"===i)throw t=String(e),Error("Objects are not valid as a React child (found: "+("[object Object]"===t?"object with keys {"+Object.keys(e).join(", ")+"}":t)+"). If you meant to render a collection of children, use an array instead.");return c}function A(e,t,n){if(null==e)return e;var a=[],r=0;return R(e,a,"","",(function(e){return t.call(n,e,r++)})),a}function _(e){if(-1===e._status){var t=e._result;(t=t()).then((function(t){0!==e._status&&-1!==e._status||(e._status=1,e._result=t)}),(function(t){0!==e._status&&-1!==e._status||(e._status=2,e._result=t)})),-1===e._status&&(e._status=0,e._result=t)}if(1===e._status)return e._result.default;throw e._result}var D={current:null},F={transition:null},O={ReactCurrentDispatcher:D,ReactCurrentBatchConfig:F,ReactCurrentOwner:S};function M(){throw Error("act(...) is not supported in production builds of React.")}t.Children={map:A,forEach:function(e,t,n){A(e,(function(){t.apply(this,arguments)}),n)},count:function(e){var t=0;return A(e,(function(){t++})),t},toArray:function(e){return A(e,(function(e){return e}))||[]},only:function(e){if(!T(e))throw Error("React.Children.only expected to receive a single React element child.");return e}},t.Component=y,t.Fragment=r,t.Profiler=o,t.PureComponent=v,t.StrictMode=s,t.Suspense=u,t.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED=O,t.act=M,t.cloneElement=function(e,t,a){if(null===e||void 0===e)throw Error("React.cloneElement(...): The argument must be a React element, but you passed "+e+".");var r=m({},e.props),s=e.key,o=e.ref,i=e._owner;if(null!=t){if(void 0!==t.ref&&(o=t.ref,i=S.current),void 0!==t.key&&(s=""+t.key),e.type&&e.type.defaultProps)var c=e.type.defaultProps;for(l in t)k.call(t,l)&&!I.hasOwnProperty(l)&&(r[l]=void 0===t[l]&&void 0!==c?c[l]:t[l])}var l=arguments.length-2;if(1===l)r.children=a;else if(1<l){c=Array(l);for(var u=0;u<l;u++)c[u]=arguments[u+2];r.children=c}return{$$typeof:n,type:e.type,key:s,ref:o,props:r,_owner:i}},t.createContext=function(e){return(e={$$typeof:c,_currentValue:e,_currentValue2:e,_threadCount:0,Provider:null,Consumer:null,_defaultValue:null,_globalName:null}).Provider={$$typeof:i,_context:e},e.Consumer=e},t.createElement=N,t.createFactory=function(e){var t=N.bind(null,e);return t.type=e,t},t.createRef=function(){return{current:null}},t.forwardRef=function(e){return{$$typeof:l,render:e}},t.isValidElement=T,t.lazy=function(e){return{$$typeof:d,_payload:{_status:-1,_result:e},_init:_}},t.memo=function(e,t){return{$$typeof:h,type:e,compare:void 0===t?null:t}},t.startTransition=function(e){var t=F.transition;F.transition={};try{e()}finally{F.transition=t}},t.unstable_act=M,t.useCallback=function(e,t){return D.current.useCallback(e,t)},t.useContext=function(e){return D.current.useContext(e)},t.useDebugValue=function(){},t.useDeferredValue=function(e){return D.current.useDeferredValue(e)},t.useEffect=function(e,t){return D.current.useEffect(e,t)},t.useId=function(){return D.current.useId()},t.useImperativeHandle=function(e,t,n){return D.current.useImperativeHandle(e,t,n)},t.useInsertionEffect=function(e,t){return D.current.useInsertionEffect(e,t)},t.useLayoutEffect=function(e,t){return D.current.useLayoutEffect(e,t)},t.useMemo=function(e,t){return D.current.useMemo(e,t)},t.useReducer=function(e,t,n){return D.current.useReducer(e,t,n)},t.useRef=function(e){return D.current.useRef(e)},t.useState=function(e){return D.current.useState(e)},t.useSyncExternalStore=function(e,t,n){return D.current.useSyncExternalStore(e,t,n)},t.useTransition=function(){return D.current.useTransition()},t.version="18.3.1"},43:(e,t,n)=>{"use strict";e.exports=n(202)},579:(e,t,n)=>{"use strict";e.exports=n(153)},234:(e,t)=>{"use strict";function n(e,t){var n=e.length;e.push(t);e:for(;0<n;){var a=n-1>>>1,r=e[a];if(!(0<s(r,t)))break e;e[a]=t,e[n]=r,n=a}}function a(e){return 0===e.length?null:e[0]}function r(e){if(0===e.length)return null;var t=e[0],n=e.pop();if(n!==t){e[0]=n;e:for(var a=0,r=e.length,o=r>>>1;a<o;){var i=2*(a+1)-1,c=e[i],l=i+1,u=e[l];if(0>s(c,n))l<r&&0>s(u,c)?(e[a]=u,e[l]=n,a=l):(e[a]=c,e[i]=n,a=i);else{if(!(l<r&&0>s(u,n)))break e;e[a]=u,e[l]=n,a=l}}}return t}function s(e,t){var n=e.sortIndex-t.sortIndex;return 0!==n?n:e.id-t.id}if("object"===typeof performance&&"function"===typeof performance.now){var o=performance;t.unstable_now=function(){return o.now()}}else{var i=Date,c=i.now();t.unstable_now=function(){return i.now()-c}}var l=[],u=[],h=1,d=null,p=3,f=!1,m=!1,g=!1,y="function"===typeof setTimeout?setTimeout:null,b="function"===typeof clearTimeout?clearTimeout:null,v="undefined"!==typeof setImmediate?setImmediate:null;function x(e){for(var t=a(u);null!==t;){if(null===t.callback)r(u);else{if(!(t.startTime<=e))break;r(u),t.sortIndex=t.expirationTime,n(l,t)}t=a(u)}}function w(e){if(g=!1,x(e),!m)if(null!==a(l))m=!0,F(k);else{var t=a(u);null!==t&&O(w,t.startTime-e)}}function k(e,n){m=!1,g&&(g=!1,b(T),T=-1),f=!0;var s=p;try{for(x(n),d=a(l);null!==d&&(!(d.expirationTime>n)||e&&!R());){var o=d.callback;if("function"===typeof o){d.callback=null,p=d.priorityLevel;var i=o(d.expirationTime<=n);n=t.unstable_now(),"function"===typeof i?d.callback=i:d===a(l)&&r(l),x(n)}else r(l);d=a(l)}if(null!==d)var c=!0;else{var h=a(u);null!==h&&O(w,h.startTime-n),c=!1}return c}finally{d=null,p=s,f=!1}}"undefined"!==typeof navigator&&void 0!==navigator.scheduling&&void 0!==navigator.scheduling.isInputPending&&navigator.scheduling.isInputPending.bind(navigator.scheduling);var S,I=!1,N=null,T=-1,E=5,C=-1;function R(){return!(t.unstable_now()-C<E)}function A(){if(null!==N){var e=t.unstable_now();C=e;var n=!0;try{n=N(!0,e)}finally{n?S():(I=!1,N=null)}}else I=!1}if("function"===typeof v)S=function(){v(A)};else if("undefined"!==typeof MessageChannel){var _=new MessageChannel,D=_.port2;_.port1.onmessage=A,S=function(){D.postMessage(null)}}else S=function(){y(A,0)};function F(e){N=e,I||(I=!0,S())}function O(e,n){T=y((function(){e(t.unstable_now())}),n)}t.unstable_IdlePriority=5,t.unstable_ImmediatePriority=1,t.unstable_LowPriority=4,t.unstable_NormalPriority=3,t.unstable_Profiling=null,t.unstable_UserBlockingPriority=2,t.unstable_cancelCallback=function(e){e.callback=null},t.unstable_continueExecution=function(){m||f||(m=!0,F(k))},t.unstable_forceFrameRate=function(e){0>e||125<e?console.error("forceFrameRate takes a positive int between 0 and 125, forcing frame rates higher than 125 fps is not supported"):E=0<e?Math.floor(1e3/e):5},t.unstable_getCurrentPriorityLevel=function(){return p},t.unstable_getFirstCallbackNode=function(){return a(l)},t.unstable_next=function(e){switch(p){case 1:case 2:case 3:var t=3;break;default:t=p}var n=p;p=t;try{return e()}finally{p=n}},t.unstable_pauseExecution=function(){},t.unstable_requestPaint=function(){},t.unstable_runWithPriority=function(e,t){switch(e){case 1:case 2:case 3:case 4:case 5:break;default:e=3}var n=p;p=e;try{return t()}finally{p=n}},t.unstable_scheduleCallback=function(e,r,s){var o=t.unstable_now();switch("object"===typeof s&&null!==s?s="number"===typeof(s=s.delay)&&0<s?o+s:o:s=o,e){case 1:var i=-1;break;case 2:i=250;break;case 5:i=1073741823;break;case 4:i=1e4;break;default:i=5e3}return e={id:h++,callback:r,priorityLevel:e,startTime:s,expirationTime:i=s+i,sortIndex:-1},s>o?(e.sortIndex=s,n(u,e),null===a(l)&&e===a(u)&&(g?(b(T),T=-1):g=!0,O(w,s-o))):(e.sortIndex=i,n(l,e),m||f||(m=!0,F(k))),e},t.unstable_shouldYield=R,t.unstable_wrapCallback=function(e){var t=p;return function(){var n=p;p=t;try{return e.apply(this,arguments)}finally{p=n}}}},853:(e,t,n)=>{"use strict";e.exports=n(234)},334:(e,t,n)=>{var a=n(359),r=n(66),s=n(16),o=n(538),i=n(288),c=n(262),l=n(430);l.alea=a,l.xor128=r,l.xorwow=s,l.xorshift7=o,l.xor4096=i,l.tychei=c,e.exports=l},359:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n=function(){var e=4022871197,t=function(t){t=String(t);for(var n=0;n<t.length;n++){var a=.02519603282416938*(e+=t.charCodeAt(n));a-=e=a>>>0,e=(a*=e)>>>0,e+=4294967296*(a-=e)}return 2.3283064365386963e-10*(e>>>0)};return t}();t.next=function(){var e=2091639*t.s0+2.3283064365386963e-10*t.c;return t.s0=t.s1,t.s1=t.s2,t.s2=e-(t.c=0|e)},t.c=1,t.s0=n(" "),t.s1=n(" "),t.s2=n(" "),t.s0-=n(e),t.s0<0&&(t.s0+=1),t.s1-=n(e),t.s1<0&&(t.s1+=1),t.s2-=n(e),t.s2<0&&(t.s2+=1),n=null}function i(e,t){return t.c=e.c,t.s0=e.s0,t.s1=e.s1,t.s2=e.s2,t}function c(e,t){var n=new o(e),a=t&&t.state,r=n.next;return r.int32=function(){return 4294967296*n.next()|0},r.double=function(){return r()+11102230246251565e-32*(2097152*r()|0)},r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.alea=c}(0,e=n.nmd(e),n.amdD)},262:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n="";t.next=function(){var e=t.b,n=t.c,a=t.d,r=t.a;return e=e<<25^e>>>7^n,n=n-a|0,a=a<<24^a>>>8^r,r=r-e|0,t.b=e=e<<20^e>>>12^n,t.c=n=n-a|0,t.d=a<<16^n>>>16^r,t.a=r-e|0},t.a=0,t.b=0,t.c=-1640531527,t.d=1367130551,e===Math.floor(e)?(t.a=e/4294967296|0,t.b=0|e):n+=e;for(var a=0;a<n.length+20;a++)t.b^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.a=e.a,t.b=e.b,t.c=e.c,t.d=e.d,t}function c(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.tychei=c}(0,e=n.nmd(e),n.amdD)},66:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n="";t.x=0,t.y=0,t.z=0,t.w=0,t.next=function(){var e=t.x^t.x<<11;return t.x=t.y,t.y=t.z,t.z=t.w,t.w^=t.w>>>19^e^e>>>8},e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t}function c(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xor128=c}(0,e=n.nmd(e),n.amdD)},288:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this;t.next=function(){var e,n,a=t.w,r=t.X,s=t.i;return t.w=a=a+1640531527|0,n=r[s+34&127],e=r[s=s+1&127],n^=n<<13,e^=e<<17,n^=n>>>15,e^=e>>>12,n=r[s]=n^e,t.i=s,n+(a^a>>>16)|0},function(e,t){var n,a,r,s,o,i=[],c=128;for(t===(0|t)?(a=t,t=null):(t+="\0",a=0,c=Math.max(c,t.length)),r=0,s=-32;s<c;++s)t&&(a^=t.charCodeAt((s+32)%t.length)),0===s&&(o=a),a^=a<<10,a^=a>>>15,a^=a<<4,a^=a>>>13,s>=0&&(o=o+1640531527|0,r=0==(n=i[127&s]^=a+o)?r+1:0);for(r>=128&&(i[127&(t&&t.length||0)]=-1),r=127,s=512;s>0;--s)a=i[r+34&127],n=i[r=r+1&127],a^=a<<13,n^=n<<17,a^=a>>>15,n^=n>>>12,i[r]=a^n;e.w=o,e.X=i,e.i=r}(t,e)}function i(e,t){return t.i=e.i,t.w=e.w,t.X=e.X.slice(),t}function c(e,t){null==e&&(e=+new Date);var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.X&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xor4096=c}(0,e=n.nmd(e),n.amdD)},538:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this;t.next=function(){var e,n,a=t.x,r=t.i;return e=a[r],n=(e^=e>>>7)^e<<24,n^=(e=a[r+1&7])^e>>>10,n^=(e=a[r+3&7])^e>>>3,n^=(e=a[r+4&7])^e<<7,e=a[r+7&7],n^=(e^=e<<13)^e<<9,a[r]=n,t.i=r+1&7,n},function(e,t){var n,a=[];if(t===(0|t))a[0]=t;else for(t=""+t,n=0;n<t.length;++n)a[7&n]=a[7&n]<<15^t.charCodeAt(n)+a[n+1&7]<<13;for(;a.length<8;)a.push(0);for(n=0;n<8&&0===a[n];++n);for(8==n?a[7]=-1:a[n],e.x=a,e.i=0,n=256;n>0;--n)e.next()}(t,e)}function i(e,t){return t.x=e.x.slice(),t.i=e.i,t}function c(e,t){null==e&&(e=+new Date);var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&(a.x&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xorshift7=c}(0,e=n.nmd(e),n.amdD)},16:function(e,t,n){var a;!function(e,r,s){function o(e){var t=this,n="";t.next=function(){var e=t.x^t.x>>>2;return t.x=t.y,t.y=t.z,t.z=t.w,t.w=t.v,(t.d=t.d+362437|0)+(t.v=t.v^t.v<<4^e^e<<1)|0},t.x=0,t.y=0,t.z=0,t.w=0,t.v=0,e===(0|e)?t.x=e:n+=e;for(var a=0;a<n.length+64;a++)t.x^=0|n.charCodeAt(a),a==n.length&&(t.d=t.x<<10^t.x>>>4),t.next()}function i(e,t){return t.x=e.x,t.y=e.y,t.z=e.z,t.w=e.w,t.v=e.v,t.d=e.d,t}function c(e,t){var n=new o(e),a=t&&t.state,r=function(){return(n.next()>>>0)/4294967296};return r.double=function(){do{var e=((n.next()>>>11)+(n.next()>>>0)/4294967296)/(1<<21)}while(0===e);return e},r.int32=n.next,r.quick=r,a&&("object"==typeof a&&i(a,n),r.state=function(){return i(n,{})}),r}r&&r.exports?r.exports=c:n.amdD&&n.amdO?void 0===(a=function(){return c}.call(t,n,t,r))||(r.exports=a):this.xorwow=c}(0,e=n.nmd(e),n.amdD)},430:function(e,t,n){var a;!function(r,s,o){var i,c=256,l=o.pow(c,6),u=o.pow(2,52),h=2*u,d=c-1;function p(e,t,n){var a=[],d=y(g((t=1==t?{entropy:!0}:t||{}).entropy?[e,b(s)]:null==e?function(){try{var e;return i&&(e=i.randomBytes)?e=e(c):(e=new Uint8Array(c),(r.crypto||r.msCrypto).getRandomValues(e)),b(e)}catch(a){var t=r.navigator,n=t&&t.plugins;return[+new Date,r,n,r.screen,b(s)]}}():e,3),a),p=new f(a),v=function(){for(var e=p.g(6),t=l,n=0;e<u;)e=(e+n)*c,t*=c,n=p.g(1);for(;e>=h;)e/=2,t/=2,n>>>=1;return(e+n)/t};return v.int32=function(){return 0|p.g(4)},v.quick=function(){return p.g(4)/4294967296},v.double=v,y(b(p.S),s),(t.pass||n||function(e,t,n,a){return a&&(a.S&&m(a,p),e.state=function(){return m(p,{})}),n?(o.random=e,t):e})(v,d,"global"in t?t.global:this==o,t.state)}function f(e){var t,n=e.length,a=this,r=0,s=a.i=a.j=0,o=a.S=[];for(n||(e=[n++]);r<c;)o[r]=r++;for(r=0;r<c;r++)o[r]=o[s=d&s+e[r%n]+(t=o[r])],o[s]=t;(a.g=function(e){for(var t,n=0,r=a.i,s=a.j,o=a.S;e--;)t=o[r=d&r+1],n=n*c+o[d&(o[r]=o[s=d&s+t])+(o[s]=t)];return a.i=r,a.j=s,n})(c)}function m(e,t){return t.i=e.i,t.j=e.j,t.S=e.S.slice(),t}function g(e,t){var n,a=[],r=typeof e;if(t&&"object"==r)for(n in e)try{a.push(g(e[n],t-1))}catch(s){}return a.length?a:"string"==r?e:e+"\0"}function y(e,t){for(var n,a=e+"",r=0;r<a.length;)t[d&r]=d&(n^=19*t[d&r])+a.charCodeAt(r++);return b(t)}function b(e){return String.fromCharCode.apply(0,e)}if(y(o.random(),s),e.exports){e.exports=p;try{i=n(996)}catch(v){}}else void 0===(a=function(){return p}.call(t,n,t,e))||(e.exports=a)}("undefined"!==typeof self?self:this,[],Math)},817:()=>{},590:()=>{},78:()=>{},905:()=>{},637:()=>{},279:()=>{},222:()=>{},996:()=>{}},t={};function n(a){var r=t[a];if(void 0!==r)return r.exports;var s=t[a]={id:a,loaded:!1,exports:{}};return e[a].call(s.exports,s,s.exports,n),s.loaded=!0,s.exports}n.m=e,n.amdD=function(){throw new Error("define cannot be used indirect")},n.amdO={},n.n=e=>{var t=e&&e.__esModule?()=>e.default:()=>e;return n.d(t,{a:t}),t},n.d=(e,t)=>{for(var a in t)n.o(t,a)&&!n.o(e,a)&&Object.defineProperty(e,a,{enumerable:!0,get:t[a]})},n.f={},n.e=e=>Promise.all(Object.keys(n.f).reduce(((t,a)=>(n.f[a](e,t),t)),[])),n.u=e=>"static/js/"+e+".194d3cc9.chunk.js",n.miniCssF=e=>{},n.g=function(){if("object"===typeof globalThis)return globalThis;try{return this||new Function("return this")()}catch(e){if("object"===typeof window)return window}}(),n.o=(e,t)=>Object.prototype.hasOwnProperty.call(e,t),(()=>{var e={},t="mediapipe-react:";n.l=(a,r,s,o)=>{if(e[a])e[a].push(r);else{var i,c;if(void 0!==s)for(var l=document.getElementsByTagName("script"),u=0;u<l.length;u++){var h=l[u];if(h.getAttribute("src")==a||h.getAttribute("data-webpack")==t+s){i=h;break}}i||(c=!0,(i=document.createElement("script")).charset="utf-8",i.timeout=120,n.nc&&i.setAttribute("nonce",n.nc),i.setAttribute("data-webpack",t+s),i.src=a),e[a]=[r];var d=(t,n)=>{i.onerror=i.onload=null,clearTimeout(p);var r=e[a];if(delete e[a],i.parentNode&&i.parentNode.removeChild(i),r&&r.forEach((e=>e(n))),t)return t(n)},p=setTimeout(d.bind(null,void 0,{type:"timeout",target:i}),12e4);i.onerror=d.bind(null,i.onerror),i.onload=d.bind(null,i.onload),c&&document.head.appendChild(i)}}})(),n.r=e=>{"undefined"!==typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.nmd=e=>(e.paths=[],e.children||(e.children=[]),e),n.p="/tensorflow-reactjs/",(()=>{var e={792:0};n.f.j=(t,a)=>{var r=n.o(e,t)?e[t]:void 0;if(0!==r)if(r)a.push(r[2]);else{var s=new Promise(((n,a)=>r=e[t]=[n,a]));a.push(r[2]=s);var o=n.p+n.u(t),i=new Error;n.l(o,(a=>{if(n.o(e,t)&&(0!==(r=e[t])&&(e[t]=void 0),r)){var s=a&&("load"===a.type?"missing":a.type),o=a&&a.target&&a.target.src;i.message="Loading chunk "+t+" failed.\n("+s+": "+o+")",i.name="ChunkLoadError",i.type=s,i.request=o,r[1](i)}}),"chunk-"+t,t)}};var t=(t,a)=>{var r,s,o=a[0],i=a[1],c=a[2],l=0;if(o.some((t=>0!==e[t]))){for(r in i)n.o(i,r)&&(n.m[r]=i[r]);if(c)c(n)}for(t&&t(a);l<o.length;l++)s=o[l],n.o(e,s)&&e[s]&&e[s][0](),e[s]=0},a=self.webpackChunkmediapipe_react=self.webpackChunkmediapipe_react||[];a.forEach(t.bind(null,0)),a.push=t.bind(null,a.push.bind(a))})(),(()=>{"use strict";var e={};n.r(e),n.d(e,{assertParamsValid:()=>oi,computeFlatOffset:()=>vi,computeOutShape:()=>ci,getNormalizedAxes:()=>di,isSliceContinous:()=>bi,maskToAxes:()=>ii,parseSliceParams:()=>xi,sliceInfo:()=>wi,startForAxis:()=>gi,startIndicesWithElidedDims:()=>pi,stopForAxis:()=>yi,stopIndicesWithElidedDims:()=>fi,stridesForAxis:()=>mi,stridesWithElidedDims:()=>li});var t={};n.r(t),n.d(t,{collectGatherOpShapeInfo:()=>Bh,computeOutShape:()=>Ph,segOpComputeOptimalWindowSize:()=>zh});var a={};n.r(a),n.d(a,{ERF_A1:()=>th,ERF_A2:()=>nh,ERF_A3:()=>ah,ERF_A4:()=>rh,ERF_A5:()=>sh,ERF_P:()=>eh,PARALLELIZE_THRESHOLD:()=>Wu,RowPartitionType:()=>Mu,SELU_SCALE:()=>$u,SELU_SCALEALPHA:()=>Zu,applyActivation:()=>Pl,assertAndGetBroadcastShape:()=>Go,assertAxesAreInnerMostDims:()=>_c,assertParamsConsistent:()=>Fu,assignToTypedArray:()=>hh,axesAreInnerMostDims:()=>Ec,calculateShapes:()=>Ju,checkEinsumDimSizes:()=>xh,checkPadOnDimRoundingMode:()=>Wi,combineLocations:()=>Cc,combineRaggedTensorToTensorShapes:()=>Lu,complexWithEvenIndex:()=>ch,complexWithOddIndex:()=>lh,computeConv2DInfo:()=>Ri,computeConv3DInfo:()=>Ai,computeDefaultPad:()=>_i,computeDilation2DInfo:()=>Ti,computeOptimalWindowSize:()=>Vu,computeOutAndReduceShapes:()=>Rc,computeOutShape:()=>Ou,computePool2DInfo:()=>Ei,computePool3DInfo:()=>Ci,convertConv2DDataFormat:()=>Bi,decodeEinsumEquation:()=>bh,eitherStridesOrDilationsAreOne:()=>zi,expandShapeToKeepDim:()=>Ac,exponent:()=>ph,exponents:()=>dh,fromStringArrayToUint8:()=>Vh,fromUint8ToStringArray:()=>Wh,getAxesPermutation:()=>Dc,getBroadcastDims:()=>Vo,getComplexWithIndex:()=>uh,getEinsumComputePath:()=>wh,getEinsumPermutation:()=>vh,getFusedBiasGradient:()=>zl,getFusedDyActivation:()=>Ll,getImageCenter:()=>Uu,getInnerMostAxes:()=>Oc,getPermuted:()=>Hu,getRaggedRank:()=>Pu,getReductionAxes:()=>Uo,getReshaped:()=>Gu,getReshapedPermuted:()=>ju,getRowPartitionTypesHelper:()=>zu,getSliceBeginCoords:()=>Ku,getSliceSize:()=>qu,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>Nh,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>Th,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>Eh,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>Ah,getSparseReshapeInputOutputMismatchErrorMessage:()=>Dh,getSparseReshapeInputOutputMultipleErrorMessage:()=>_h,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>Ch,getSparseReshapeNegativeOutputDimErrorMessage:()=>Rh,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>Lh,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>Fh,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>Oh,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>Mh,getUndoAxesPermutation:()=>Fc,isIdentityPermutation:()=>kh,log:()=>Ya,mergeRealAndImagArrays:()=>oh,prepareAndValidate:()=>Xu,prepareSplitSize:()=>Ih,segment_util:()=>t,shouldFuse:()=>Bl,slice_util:()=>e,splitRealAndImagArrays:()=>ih,stridesOrDilationsArePositive:()=>Pi,tupleValuesAreOne:()=>Li,upcastType:()=>Jr,validateDefaultValueShape:()=>Bu,validateInput:()=>Qu,validateUpdateShape:()=>Yu,warn:()=>Xa});var r={};n.r(r),n.d(r,{addImpl:()=>Aw,bincountImpl:()=>kk,bincountReduceImpl:()=>Sk,bitwiseAndImpl:()=>Nk,castImpl:()=>Nw,ceilImpl:()=>Ck,concatImpl:()=>Ok,equalImpl:()=>bS,expImpl:()=>RS,expm1Impl:()=>OS,floorImpl:()=>JS,gatherNdImpl:()=>sI,gatherV2Impl:()=>iI,greaterEqualImpl:()=>dI,greaterImpl:()=>lI,lessEqualImpl:()=>NI,lessImpl:()=>kI,linSpaceImpl:()=>CI,logImpl:()=>AI,maxImpl:()=>jI,maximumImpl:()=>XI,minimumImpl:()=>rN,multiplyImpl:()=>uS,negImpl:()=>fN,notEqualImpl:()=>kN,prodImpl:()=>MN,raggedGatherImpl:()=>WN,raggedRangeImpl:()=>GN,raggedTensorToTensorImpl:()=>YN,rangeImpl:()=>JN,rsqrtImpl:()=>lT,scatterImpl:()=>dT,sigmoidImpl:()=>gw,simpleAbsImpl:()=>Bw,sliceImpl:()=>bk,sparseFillEmptyRowsImpl:()=>DT,sparseReshapeImpl:()=>OT,sparseSegmentReductionImpl:()=>LT,sqrtImpl:()=>VT,staticRegexReplaceImpl:()=>XT,stridedSliceImpl:()=>$T,stringNGramsImpl:()=>nE,stringSplitImpl:()=>sE,stringToHashBucketFastImpl:()=>iE,subImpl:()=>WS,tileImpl:()=>pE,topKImpl:()=>yE,transposeImpl:()=>Kw,uniqueImpl:()=>IE});var s={};n.r(s),n.d(s,{arraysEqual:()=>_z,assert:()=>Nz,assertNonNegativeIntegerDimensions:()=>iP,assertNonNull:()=>Ez,assertShapesMatch:()=>Tz,bytesFromStringArray:()=>Xz,bytesPerElement:()=>qz,checkConversionForErrors:()=>Gz,clamp:()=>vz,computeStrides:()=>tP,createScalarValue:()=>aU,createShuffledIndices:()=>Mz,decodeString:()=>cU,distSquared:()=>Iz,encodeString:()=>iU,fetch:()=>oU,fingerPrint64:()=>nU,flatten:()=>Cz,getArrayFromDType:()=>Uz,getTypedArrayFromDType:()=>Vz,hasEncodingLoss:()=>jz,hexToLong:()=>jV,indexToLoc:()=>lP,inferDtype:()=>Zz,inferFromImplicitShape:()=>Pz,isBoolean:()=>Qz,isFunction:()=>$z,isInt:()=>Dz,isNumber:()=>Jz,isPromise:()=>uP,isScalarShape:()=>Az,isString:()=>Yz,isTypedArray:()=>Kz,isValidDtype:()=>Hz,locToIndex:()=>cP,makeOnesTypedArray:()=>rP,makeZerosNestedTypedArray:()=>oP,makeZerosTypedArray:()=>sP,nearestDivisor:()=>eP,nearestLargerEven:()=>xz,now:()=>sU,parseAxisParam:()=>Bz,randUniform:()=>Sz,repeatedTry:()=>zz,rightPad:()=>Lz,shuffle:()=>yz,shuffleCombo:()=>bz,sizeFromShape:()=>Rz,sizeToSquarishShape:()=>Oz,squeezeShape:()=>Wz,sum:()=>kz,swap:()=>wz,tanh:()=>Fz,toNestedArray:()=>aP,toTypedArray:()=>rU});var o={};n.r(o),n.d(o,{assertTypesMatch:()=>MU,getTensorsInContainer:()=>zU,isTensorInList:()=>LU,makeTypesMatch:()=>OU});var i={};n.r(i),n.d(i,{isBrowser:()=>XU,isMobile:()=>qU,mockIsMobile:()=>KU});var c={};n.r(c),n.d(c,{browserFiles:()=>dH,browserHTTPRequest:()=>wH,concatenateArrayBuffers:()=>pG,copyModel:()=>$G,decodeWeights:()=>lG,encodeWeights:()=>cG,fromMemory:()=>NH,fromMemorySync:()=>TH,getLoadHandlers:()=>NG,getModelArtifactsForJSON:()=>yG,getModelArtifactsForJSONSync:()=>gG,getModelArtifactsInfoForJSON:()=>bG,getSaveHandlers:()=>IG,getWeightSpecs:()=>vG,http:()=>xH,isHTTPScheme:()=>bH,listModels:()=>JG,loadWeights:()=>mH,moveModel:()=>eH,registerLoadRouter:()=>SG,registerSaveRouter:()=>kG,removeModel:()=>ZG,weightsLoaderFactory:()=>gH,withSaveHandler:()=>EH,withSaveHandlerSync:()=>CH});var l={};n.r(l),n.d(l,{confusionMatrix:()=>nj});var u={};n.r(u),n.d(u,{assertAndGetBroadcastShape:()=>sj,getBroadcastDims:()=>aj,getReductionAxes:()=>rj});var h={};n.r(h),n.d(h,{fromPixels:()=>dj,fromPixelsAsync:()=>uj,toPixels:()=>hj});var d={};n.r(d),n.d(d,{prepareAndValidate:()=>pj});var p={};n.r(p),n.d(p,{calculateShapes:()=>gj,validateInput:()=>mj,validateUpdateShape:()=>fj});var f={};n.r(f),n.d(f,{assertParamsValid:()=>vj,computeFlatOffset:()=>Dj,computeOutShape:()=>wj,getNormalizedAxes:()=>Nj,isSliceContinous:()=>_j,maskToAxes:()=>xj,parseSliceParams:()=>Fj,sliceInfo:()=>Oj,startForAxis:()=>Rj,startIndicesWithElidedDims:()=>Tj,stopForAxis:()=>Aj,stopIndicesWithElidedDims:()=>Ej,stridesForAxis:()=>Cj,stridesWithElidedDims:()=>kj});var m={};n.r(m),n.d(m,{Serializable:()=>Lj,SerializationMap:()=>zj,registerClass:()=>Pj});var g={};n.r(g),n.d(g,{TEST_EPSILON_FLOAT16:()=>Wj,createVideoElement:()=>Jj,encodeStrings:()=>Qj,expectArrayBuffersEqual:()=>Yj,expectArraysClose:()=>Vj,expectArraysEqual:()=>jj,expectNumbersClose:()=>Kj,expectPromiseToFail:()=>Hj,expectValuesInRange:()=>Xj,play:()=>Zj,testEpsilon:()=>Uj});var y={};n.r(y),n.d(y,{conv2d:()=>IQ,depthwiseConv2d:()=>EQ,matMul:()=>CQ});var b={};n.r(b),n.d(b,{collectGatherOpShapeInfo:()=>LZ,computeOutShape:()=>MZ,segOpComputeOptimalWindowSize:()=>OZ});var v={};n.r(v),n.d(v,{ERF_A1:()=>ZJ,ERF_A2:()=>$J,ERF_A3:()=>eZ,ERF_A4:()=>tZ,ERF_A5:()=>nZ,ERF_P:()=>JJ,PARALLELIZE_THRESHOLD:()=>VJ,RowPartitionType:()=>LJ,SELU_SCALE:()=>QJ,SELU_SCALEALPHA:()=>YJ,applyActivation:()=>kQ,assertAndGetBroadcastShape:()=>sj,assertAxesAreInnerMostDims:()=>Qq,assertParamsConsistent:()=>OJ,assignToTypedArray:()=>cZ,axesAreInnerMostDims:()=>Kq,calculateShapes:()=>gj,checkEinsumDimSizes:()=>yZ,checkPadOnDimRoundingMode:()=>eq,combineLocations:()=>qq,combineRaggedTensorToTensorShapes:()=>zJ,complexWithEvenIndex:()=>sZ,complexWithOddIndex:()=>oZ,computeConv2DInfo:()=>HK,computeConv3DInfo:()=>jK,computeDefaultPad:()=>KK,computeDilation2DInfo:()=>VK,computeOptimalWindowSize:()=>UJ,computeOutAndReduceShapes:()=>Xq,computeOutShape:()=>MJ,computePool2DInfo:()=>UK,computePool3DInfo:()=>GK,convertConv2DDataFormat:()=>$K,decodeEinsumEquation:()=>mZ,eitherStridesOrDilationsAreOne:()=>ZK,expandShapeToKeepDim:()=>Yq,exponent:()=>uZ,exponents:()=>lZ,fromStringArrayToUint8:()=>PZ,fromUint8ToStringArray:()=>zZ,getAxesPermutation:()=>Jq,getBroadcastDims:()=>aj,getComplexWithIndex:()=>iZ,getEinsumComputePath:()=>bZ,getEinsumPermutation:()=>gZ,getFusedBiasGradient:()=>wQ,getFusedDyActivation:()=>xQ,getImageCenter:()=>GJ,getInnerMostAxes:()=>$q,getPermuted:()=>jJ,getRaggedRank:()=>BJ,getReductionAxes:()=>rj,getReshaped:()=>HJ,getReshapedPermuted:()=>KJ,getRowPartitionTypesHelper:()=>PJ,getSliceBeginCoords:()=>qJ,getSliceSize:()=>XJ,getSparseFillEmptyRowsIndicesDenseShapeMismatch:()=>kZ,getSparseFillEmptyRowsNegativeIndexErrorMessage:()=>SZ,getSparseFillEmptyRowsOutOfRangeIndexErrorMessage:()=>IZ,getSparseReshapeEmptyTensorZeroOutputDimErrorMessage:()=>EZ,getSparseReshapeInputOutputMismatchErrorMessage:()=>RZ,getSparseReshapeInputOutputMultipleErrorMessage:()=>CZ,getSparseReshapeMultipleNegativeOneOutputDimErrorMessage:()=>NZ,getSparseReshapeNegativeOutputDimErrorMessage:()=>TZ,getSparseSegmentReductionIndicesOutOfRangeErrorMessage:()=>FZ,getSparseSegmentReductionNegativeSegmentIdsErrorMessage:()=>AZ,getSparseSegmentReductionNonIncreasingSegmentIdsErrorMessage:()=>_Z,getSparseSegmentReductionSegmentIdOutOfRangeErrorMessage:()=>DZ,getUndoAxesPermutation:()=>Zq,isIdentityPermutation:()=>vZ,log:()=>DV,mergeRealAndImagArrays:()=>aZ,prepareAndValidate:()=>pj,prepareSplitSize:()=>wZ,segment_util:()=>b,shouldFuse:()=>SQ,slice_util:()=>f,splitRealAndImagArrays:()=>rZ,tupleValuesAreOne:()=>JK,upcastType:()=>DU,validateDefaultValueShape:()=>WJ,validateInput:()=>mj,validateUpdateShape:()=>fj,warn:()=>_V});var x={};n.r(x),n.d(x,{nonMaxSuppressionV3Impl:()=>VQ,nonMaxSuppressionV4Impl:()=>UQ,nonMaxSuppressionV5Impl:()=>GQ,whereImpl:()=>cQ});var w={};n.r(w),n.d(w,{Abs:()=>vP,Acos:()=>xP,Acosh:()=>wP,AdadeltaOptimizer:()=>gK,AdagradOptimizer:()=>bK,AdamOptimizer:()=>wK,AdamaxOptimizer:()=>IK,Add:()=>kP,AddN:()=>SP,All:()=>IP,Any:()=>NP,ArgMax:()=>TP,ArgMin:()=>EP,Asin:()=>CP,Asinh:()=>RP,Atan:()=>AP,Atan2:()=>DP,Atanh:()=>_P,AvgPool:()=>FP,AvgPool3D:()=>MP,AvgPool3DGrad:()=>LP,AvgPoolGrad:()=>OP,BatchMatMul:()=>zP,BatchToSpaceND:()=>PP,Bincount:()=>BP,BroadcastArgs:()=>VP,BroadcastTo:()=>WP,Cast:()=>UP,Ceil:()=>GP,ClipByValue:()=>HP,Complex:()=>jP,ComplexAbs:()=>KP,Concat:()=>qP,Conv2D:()=>XP,Conv2DBackpropFilter:()=>YP,Conv2DBackpropInput:()=>QP,Conv3D:()=>JP,Conv3DBackpropFilterV2:()=>ZP,Conv3DBackpropInputV2:()=>$P,Cos:()=>eB,Cosh:()=>tB,CropAndResize:()=>rB,Cumprod:()=>nB,Cumsum:()=>aB,DataStorage:()=>fz,DenseBincount:()=>sB,DepthToSpace:()=>oB,DepthwiseConv2dNative:()=>iB,DepthwiseConv2dNativeBackpropFilter:()=>cB,DepthwiseConv2dNativeBackpropInput:()=>lB,Diag:()=>uB,Dilation2D:()=>hB,Dilation2DBackpropFilter:()=>pB,Dilation2DBackpropInput:()=>dB,ENV:()=>gP,Einsum:()=>mB,Elu:()=>gB,EluGrad:()=>yB,Environment:()=>dP,Equal:()=>vB,Erf:()=>bB,Exp:()=>xB,ExpandDims:()=>wB,Expm1:()=>kB,FFT:()=>SB,Fill:()=>IB,FlipLeftRight:()=>NB,Floor:()=>TB,FloorDiv:()=>EB,FromPixels:()=>TV,FusedBatchNorm:()=>CB,FusedConv2D:()=>RV,FusedDepthwiseConv2D:()=>AV,GatherNd:()=>AB,GatherV2:()=>RB,Greater:()=>_B,GreaterEqual:()=>DB,IFFT:()=>OB,Identity:()=>FB,Imag:()=>MB,IsFinite:()=>LB,IsInf:()=>zB,IsNan:()=>PB,KernelBackend:()=>mz,LRN:()=>JB,LRNGrad:()=>ZB,LeakyRelu:()=>BB,Less:()=>WB,LessEqual:()=>VB,LinSpace:()=>UB,Log:()=>GB,Log1p:()=>HB,LogSoftmax:()=>YB,LogicalAnd:()=>jB,LogicalNot:()=>KB,LogicalOr:()=>qB,LogicalXor:()=>XB,LowerBound:()=>QB,Max:()=>$B,MaxPool:()=>tW,MaxPool3D:()=>aW,MaxPool3DGrad:()=>rW,MaxPoolGrad:()=>nW,MaxPoolWithArgmax:()=>sW,Maximum:()=>eW,Mean:()=>oW,Min:()=>iW,Minimum:()=>cW,MirrorPad:()=>lW,Mod:()=>uW,MomentumOptimizer:()=>TK,Multinomial:()=>hW,Multiply:()=>dW,Neg:()=>pW,NonMaxSuppressionV3:()=>mW,NonMaxSuppressionV4:()=>gW,NonMaxSuppressionV5:()=>yW,NotEqual:()=>fW,OP_SCOPE_SUFFIX:()=>tG,OneHot:()=>vW,OnesLike:()=>bW,Optimizer:()=>mK,OptimizerConstructors:()=>CK,Pack:()=>xW,PadV2:()=>wW,Pool:()=>kW,Pow:()=>SW,Prelu:()=>IW,Prod:()=>NW,RMSPropOptimizer:()=>EK,RaggedGather:()=>TW,RaggedTensorToTensor:()=>EW,Range:()=>CW,Rank:()=>TU,Real:()=>RW,RealDiv:()=>fB,Reciprocal:()=>AW,Reduction:()=>iJ,Relu:()=>_W,Relu6:()=>zW,Reshape:()=>DW,ResizeBilinear:()=>MW,ResizeBilinearGrad:()=>LW,ResizeNearestNeighbor:()=>FW,ResizeNearestNeighborGrad:()=>OW,Reverse:()=>PW,RotateWithOffset:()=>EV,Round:()=>BW,Rsqrt:()=>WW,SGDOptimizer:()=>NK,ScatterNd:()=>VW,SearchSorted:()=>UW,Select:()=>GW,Selu:()=>HW,Sigmoid:()=>YW,Sign:()=>XW,Sin:()=>KW,Sinh:()=>qW,Slice:()=>jW,Softmax:()=>tV,Softplus:()=>QW,SpaceToBatchND:()=>$W,SparseFillEmptyRows:()=>nV,SparseReshape:()=>aV,SparseSegmentMean:()=>rV,SparseSegmentSum:()=>sV,SparseToDense:()=>oV,SplitV:()=>eV,Sqrt:()=>JW,Square:()=>cV,SquaredDifference:()=>iV,Step:()=>NV,StridedSlice:()=>lV,StringNGrams:()=>uV,StringSplit:()=>hV,StringToHashBucketFast:()=>dV,Sub:()=>pV,Sum:()=>ZW,Tan:()=>fV,Tanh:()=>mV,Tensor:()=>IU,TensorBuffer:()=>xU,Tile:()=>gV,TopK:()=>yV,Transform:()=>bV,Transpose:()=>vV,Unique:()=>xV,Unpack:()=>wV,UnsortedSegmentSum:()=>kV,UpperBound:()=>SV,Variable:()=>NU,ZerosLike:()=>IV,_FusedMatMul:()=>CV,abs:()=>kK,acos:()=>RK,acosh:()=>AK,add:()=>eK,addN:()=>_K,all:()=>DK,any:()=>FK,argMax:()=>OK,argMin:()=>MK,asin:()=>LK,asinh:()=>zK,atan:()=>PK,atan2:()=>BK,atanh:()=>WK,avgPool:()=>nq,avgPool3d:()=>aq,backend:()=>QH,backend_util:()=>v,basicLSTMCell:()=>cq,batchNorm:()=>uq,batchNorm2d:()=>hq,batchNorm3d:()=>dq,batchNorm4d:()=>pq,batchToSpaceND:()=>lq,bincount:()=>fq,booleanMaskAsync:()=>uQ,broadcastArgs:()=>mq,broadcastTo:()=>gq,broadcast_util:()=>u,browser:()=>h,buffer:()=>sH,cast:()=>oH,ceil:()=>yq,clipByValue:()=>bq,clone:()=>iH,complex:()=>aG,concat:()=>rq,concat1d:()=>vq,concat2d:()=>xq,concat3d:()=>wq,concat4d:()=>kq,conv1d:()=>Iq,conv2d:()=>Sq,conv2dTranspose:()=>Tq,conv3d:()=>Eq,conv3dTranspose:()=>Rq,copyRegisteredKernels:()=>UV,cos:()=>Aq,cosh:()=>_q,cosineWindow:()=>yQ,cumprod:()=>Dq,cumsum:()=>Fq,customGrad:()=>dK,denseBincount:()=>Oq,deprecationWarn:()=>OH,depthToSpace:()=>Mq,depthwiseConv2d:()=>Lq,device_util:()=>i,diag:()=>zq,dilation2d:()=>Pq,disableDeprecationWarnings:()=>FH,dispose:()=>WH,disposeVariables:()=>MH,div:()=>nK,divNoNan:()=>Vq,dot:()=>Uq,dropout:()=>mQ,einsum:()=>Gq,elu:()=>Hq,enableDebugMode:()=>DH,enableProdMode:()=>_H,enclosingPowerOfTwo:()=>gQ,engine:()=>LH,env:()=>fP,equal:()=>Bq,erf:()=>jq,euclideanNorm:()=>sX,exp:()=>oX,expandDims:()=>iX,expm1:()=>cX,eye:()=>uX,fft:()=>BY,fill:()=>yK,findBackend:()=>qH,findBackendFactory:()=>XH,floor:()=>hX,floorDiv:()=>tK,fused:()=>y,gather:()=>dX,gatherND:()=>fQ,gather_util:()=>d,getBackend:()=>jH,getGradient:()=>LV,getKernel:()=>MV,getKernelsForBackend:()=>zV,grad:()=>iK,grads:()=>cK,greater:()=>pX,greaterEqual:()=>fX,ifft:()=>WY,imag:()=>ZH,image:()=>TJ,inTopKAsync:()=>bQ,io:()=>c,irfft:()=>VY,isFinite:()=>mX,isInf:()=>gX,isNaN:()=>yX,keep:()=>VH,kernel_impls:()=>x,leakyRelu:()=>bX,less:()=>vX,lessEqual:()=>xX,linalg:()=>EJ,linspace:()=>wX,localResponseNormalization:()=>kX,log:()=>SX,log1p:()=>IX,logSigmoid:()=>TX,logSoftmax:()=>EX,logSumExp:()=>CX,logicalAnd:()=>RX,logicalNot:()=>AX,logicalOr:()=>_X,logicalXor:()=>DX,losses:()=>CJ,lowerBound:()=>MX,matMul:()=>RH,math:()=>l,max:()=>eX,maxPool:()=>LX,maxPool3d:()=>zX,maxPoolWithArgmax:()=>PX,maximum:()=>SK,mean:()=>BX,memory:()=>zH,meshgrid:()=>UX,min:()=>tX,minimum:()=>GX,mirrorPad:()=>HX,mod:()=>jX,moments:()=>KX,movingAverage:()=>hQ,mul:()=>aK,multiRNNCell:()=>qX,multinomial:()=>XX,neg:()=>$H,nextFrame:()=>FJ,norm:()=>rX,notEqual:()=>YX,oneHot:()=>AH,ones:()=>VX,onesLike:()=>QX,op:()=>nG,outerProduct:()=>JX,pad:()=>ZX,pad1d:()=>$X,pad2d:()=>eY,pad3d:()=>tY,pad4d:()=>nY,pool:()=>rY,pow:()=>vK,prelu:()=>sY,print:()=>cH,prod:()=>oY,profile:()=>PH,raggedGather:()=>iY,raggedTensorToTensor:()=>cY,rand:()=>lY,randomGamma:()=>pY,randomNormal:()=>fY,randomStandardNormal:()=>mY,randomUniform:()=>gY,range:()=>yY,ready:()=>HH,real:()=>ej,reciprocal:()=>bY,registerBackend:()=>YH,registerGradient:()=>BV,registerKernel:()=>PV,relu:()=>vY,relu6:()=>xY,removeBackend:()=>KH,reshape:()=>tq,reverse:()=>wY,reverse1d:()=>kY,reverse2d:()=>SY,reverse3d:()=>IY,reverse4d:()=>NY,rfft:()=>GY,round:()=>TY,rsqrt:()=>EY,scalar:()=>fK,scatterND:()=>dQ,scatter_util:()=>p,searchSorted:()=>OX,selu:()=>CY,separableConv2d:()=>RY,serialization:()=>m,setBackend:()=>GH,setPlatform:()=>JH,setdiff1dAsync:()=>AY,sigmoid:()=>sq,sign:()=>_Y,signal:()=>NJ,sin:()=>DY,sinh:()=>FY,slice:()=>oq,slice1d:()=>OY,slice2d:()=>MY,slice3d:()=>LY,slice4d:()=>zY,slice_util:()=>f,softmax:()=>PY,softplus:()=>NX,spaceToBatchND:()=>aY,sparse:()=>RJ,sparseToDense:()=>pQ,spectral:()=>IJ,split:()=>UY,sqrt:()=>rK,square:()=>sK,squaredDifference:()=>HY,squeeze:()=>jY,stack:()=>KY,step:()=>qY,stridedSlice:()=>XY,string:()=>AJ,sub:()=>xK,sum:()=>nX,sumOutType:()=>FU,tan:()=>YY,tanh:()=>iq,tensor:()=>sG,tensor1d:()=>QY,tensor2d:()=>JY,tensor3d:()=>oj,tensor4d:()=>ZY,tensor5d:()=>$Y,tensor6d:()=>eQ,tensor_util:()=>o,test_util:()=>g,tidy:()=>BH,tile:()=>lX,time:()=>UH,topk:()=>tQ,train:()=>_J,transpose:()=>tj,truncatedNormal:()=>nQ,unique:()=>aQ,unregisterGradient:()=>VV,unregisterKernel:()=>WV,unsortedSegmentSum:()=>rQ,unstack:()=>sQ,upcastType:()=>DU,upperBound:()=>oQ,util:()=>s,valueAndGrad:()=>lK,valueAndGrads:()=>uK,variable:()=>iQ,variableGrads:()=>hK,version_core:()=>$j,where:()=>Wq,whereAsync:()=>lQ,zeros:()=>WX,zerosLike:()=>oK});var k={};n.r(k),n.d(k,{json:()=>QZ});var S={};n.r(S),n.d(S,{json:()=>JZ});var I={};n.r(I),n.d(I,{json:()=>ZZ});var N={};n.r(N),n.d(N,{json:()=>$Z});var T={};n.r(T),n.d(T,{json:()=>e$});var E={};n.r(E),n.d(E,{json:()=>t$});var C={};n.r(C),n.d(C,{json:()=>n$});var R={};n.r(R),n.d(R,{json:()=>a$});var A={};n.r(A),n.d(A,{json:()=>r$});var _={};n.r(_),n.d(_,{json:()=>s$});var D={};n.r(D),n.d(D,{json:()=>o$});var F={};n.r(F),n.d(F,{json:()=>i$});var O={};n.r(O),n.d(O,{json:()=>c$});var M={};n.r(M),n.d(M,{json:()=>l$});var L={};n.r(L),n.d(L,{json:()=>u$});var z={};n.r(z),n.d(z,{json:()=>h$});var P={};n.r(P),n.d(P,{json:()=>d$});var B={};n.r(B),n.d(B,{json:()=>p$});var W={};n.r(W),n.d(W,{json:()=>f$});var V={};n.r(V),n.d(V,{OP_SCOPE_SUFFIX:()=>tG,abs:()=>kK,acos:()=>RK,acosh:()=>AK,add:()=>eK,addN:()=>_K,all:()=>DK,any:()=>FK,argMax:()=>OK,argMin:()=>MK,asin:()=>LK,asinh:()=>zK,atan:()=>PK,atan2:()=>BK,atanh:()=>WK,avgPool:()=>nq,avgPool3d:()=>aq,basicLSTMCell:()=>cq,batchNorm:()=>uq,batchNorm2d:()=>hq,batchNorm3d:()=>dq,batchNorm4d:()=>pq,batchToSpaceND:()=>lq,bincount:()=>fq,booleanMaskAsync:()=>uQ,broadcastArgs:()=>mq,broadcastTo:()=>gq,buffer:()=>sH,cast:()=>oH,ceil:()=>yq,clipByValue:()=>bq,clone:()=>iH,complex:()=>aG,concat:()=>rq,concat1d:()=>vq,concat2d:()=>xq,concat3d:()=>wq,concat4d:()=>kq,conv1d:()=>Iq,conv2d:()=>Sq,conv2dTranspose:()=>Tq,conv3d:()=>Eq,conv3dTranspose:()=>Rq,cos:()=>Aq,cosh:()=>_q,cosineWindow:()=>yQ,cumprod:()=>Dq,cumsum:()=>Fq,denseBincount:()=>Oq,depthToSpace:()=>Mq,depthwiseConv2d:()=>Lq,diag:()=>zq,dilation2d:()=>Pq,div:()=>nK,divNoNan:()=>Vq,dot:()=>Uq,dropout:()=>mQ,einsum:()=>Gq,elu:()=>Hq,enclosingPowerOfTwo:()=>gQ,equal:()=>Bq,erf:()=>jq,euclideanNorm:()=>sX,exp:()=>oX,expandDims:()=>iX,expm1:()=>cX,eye:()=>uX,fft:()=>BY,fill:()=>yK,floor:()=>hX,floorDiv:()=>tK,fused:()=>y,gather:()=>dX,gatherND:()=>fQ,greater:()=>pX,greaterEqual:()=>fX,ifft:()=>WY,imag:()=>ZH,image:()=>TJ,inTopKAsync:()=>bQ,irfft:()=>VY,isFinite:()=>mX,isInf:()=>gX,isNaN:()=>yX,leakyRelu:()=>bX,less:()=>vX,lessEqual:()=>xX,linalg:()=>EJ,linspace:()=>wX,localResponseNormalization:()=>kX,log:()=>SX,log1p:()=>IX,logSigmoid:()=>TX,logSoftmax:()=>EX,logSumExp:()=>CX,logicalAnd:()=>RX,logicalNot:()=>AX,logicalOr:()=>_X,logicalXor:()=>DX,losses:()=>CJ,lowerBound:()=>MX,matMul:()=>RH,max:()=>eX,maxPool:()=>LX,maxPool3d:()=>zX,maxPoolWithArgmax:()=>PX,maximum:()=>SK,mean:()=>BX,meshgrid:()=>UX,min:()=>tX,minimum:()=>GX,mirrorPad:()=>HX,mod:()=>jX,moments:()=>KX,movingAverage:()=>hQ,mul:()=>aK,multiRNNCell:()=>qX,multinomial:()=>XX,neg:()=>$H,norm:()=>rX,notEqual:()=>YX,oneHot:()=>AH,ones:()=>VX,onesLike:()=>QX,op:()=>nG,outerProduct:()=>JX,pad:()=>ZX,pad1d:()=>$X,pad2d:()=>eY,pad3d:()=>tY,pad4d:()=>nY,pool:()=>rY,pow:()=>vK,prelu:()=>sY,print:()=>cH,prod:()=>oY,raggedGather:()=>iY,raggedTensorToTensor:()=>cY,rand:()=>lY,randomGamma:()=>pY,randomNormal:()=>fY,randomStandardNormal:()=>mY,randomUniform:()=>gY,range:()=>yY,real:()=>ej,reciprocal:()=>bY,relu:()=>vY,relu6:()=>xY,reshape:()=>tq,reverse:()=>wY,reverse1d:()=>kY,reverse2d:()=>SY,reverse3d:()=>IY,reverse4d:()=>NY,rfft:()=>GY,round:()=>TY,rsqrt:()=>EY,scalar:()=>fK,scatterND:()=>dQ,searchSorted:()=>OX,selu:()=>CY,separableConv2d:()=>RY,setdiff1dAsync:()=>AY,sigmoid:()=>sq,sign:()=>_Y,signal:()=>NJ,sin:()=>DY,sinh:()=>FY,slice:()=>oq,slice1d:()=>OY,slice2d:()=>MY,slice3d:()=>LY,slice4d:()=>zY,softmax:()=>PY,softplus:()=>NX,spaceToBatchND:()=>aY,sparse:()=>RJ,sparseToDense:()=>pQ,spectral:()=>IJ,split:()=>UY,sqrt:()=>rK,square:()=>sK,squaredDifference:()=>HY,squeeze:()=>jY,stack:()=>KY,step:()=>qY,stridedSlice:()=>XY,string:()=>AJ,sub:()=>xK,sum:()=>nX,tan:()=>YY,tanh:()=>iq,tensor:()=>sG,tensor1d:()=>QY,tensor2d:()=>JY,tensor3d:()=>oj,tensor4d:()=>ZY,tensor5d:()=>$Y,tensor6d:()=>eQ,tile:()=>lX,topk:()=>tQ,transpose:()=>tj,truncatedNormal:()=>nQ,unique:()=>aQ,unsortedSegmentSum:()=>rQ,unstack:()=>sQ,upperBound:()=>oQ,variable:()=>iQ,where:()=>Wq,whereAsync:()=>lQ,zeros:()=>WX,zerosLike:()=>oK});var U=n(43),G=n(391);n.p;class H{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class j{refCount(e){return K("refCount")}incRef(e){return K("incRef")}timerAvailable(){return!0}time(e){return K("time")}read(e){return K("read")}readSync(e){return K("readSync")}readToGPU(e,t){return K("readToGPU")}numDataIds(){return K("numDataIds")}disposeData(e,t){return K("disposeData")}write(e,t,n){return K("write")}move(e,t,n,a,r){return K("move")}createTensorFromGPUData(e,t,n){return K("createTensorFromGPUData")}memory(){return K("memory")}floatPrecision(){return K("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return K("dispose")}}function K(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function q(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,Q(e,t,n)}function X(e,t,n){return Math.max(e,Math.min(t,n))}function Y(e){return e%2===0?e:e+1}function Q(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function J(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function Z(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";J(te(e,t),(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}function $(e){J(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function ee(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function te(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function ne(e){return e%1===0}function ae(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function re(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function se(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return new Promise(((r,s)=>{let o=0;const i=()=>{if(e())return void r();o++;const c=t(o);null!=n&&o>=n?s():null!=a?a(i,c):setTimeout(i,c)};i()}))}function oe(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(s));a=s}else if(e[s]<0)throw Error("Shapes can not be < 0. Found ".concat(e[s]," at dim ").concat(s));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const r=e.slice();return r[a]=t/n,r}function ie(e,t){const n=t.length;return J((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e))),J(e.every((e=>ne(e))),(()=>"All values in axis param must be integers but "+"got axis ".concat(e))),e.map((e=>e<0?n+e:e))}function ce(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||r?null:ie(t,e).sort();let o=0;for(let i=0;i<e.length;++i){if(null!=s){if(s[o]===i&&1!==e[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(e[i],"' is not 1"));(null==s[o]||s[o]>i)&&1===e[i]&&(n.push(e[i]),a.push(i)),s[o]<=i&&o++}1!==e[i]&&(n.push(e[i]),a.push(i))}return{newShape:n,keptDims:a}}function le(e,t){return ue(e,t)}function ue(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function he(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function de(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function pe(e){return"string"===typeof e||e instanceof String}function fe(e){return"number"===typeof e}function me(e){return Array.isArray(e)?me(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":fe(e)?"float32":pe(e)?"string":"boolean"===typeof e?"bool":"float32"}function ge(e){return!!(e&&e.constructor&&e.call&&e.apply)}function ye(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function be(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function ve(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=new Array;if(1===t.length){const s=t[0]*(a?2:1);for(let t=0;t<s;t++)r[t]=n[e+t]}else{const s=t[0],o=t.slice(1),i=o.reduce(((e,t)=>e*t))*(a?2:1);for(let t=0;t<s;t++)r[t]=ve(e+t*i,o,n,a)}return r}function xe(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return ve(0,e,t,n)}function we(e,t){const n=ke(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function ke(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function Se(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return xe(e,new Float32Array(n));if("int32"===t)return xe(e,new Int32Array(n));if("bool"===t)return xe(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function Ie(e){e.forEach((t=>{J(Number.isInteger(t)&&t>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"].")))}))}function Ne(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function Te(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function Ee(e){return e&&e.then&&"function"===typeof e.then}const Ce="tfjsflags";class Re{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=Ae,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(_e().getBool("IS_TEST")||_e().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];_e().getBool("IS_TEST")||_e().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(Ee(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getString(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(Ce in e){e[Ce].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){const n=t.toLowerCase();return"true"===n||"false"===n?"true"===n:"".concat(+n)===n?+n:t}(0,n)}))}}}function Ae(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,a[0],a[1]),a.join("=")})),t}function _e(){return Fe}let De,Fe=null;function Oe(){if(null==De){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}De=e}return De}function Me(e,t){const n=function(){const e=Oe();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const Le="Abs",ze="Acos",Pe="Acosh",Be="Add",We="AddN",Ve="All",Ue="Any",Ge="ArgMax",He="ArgMin",je="Asin",Ke="Asinh",qe="Atan",Xe="Atanh",Ye="Atan2",Qe="AvgPool",Je="AvgPoolGrad",Ze="AvgPool3D",$e="AvgPool3DGrad",et="BatchMatMul",tt="BatchToSpaceND",nt="Bincount",at="BitwiseAnd",rt="BroadcastArgs",st="Cast",ot="Ceil",it="ClipByValue",ct="Complex",lt="ComplexAbs",ut="Concat",ht="Conv2D",dt="Conv2DBackpropFilter",pt="Conv2DBackpropInput",ft="Conv3D",mt="Conv3DBackpropFilterV2",gt="Conv3DBackpropInputV2",yt="Cos",bt="Cosh",vt="Cumprod",xt="Cumsum",wt="CropAndResize",kt="DenseBincount",St="DepthToSpace",It="DepthwiseConv2dNative",Nt="DepthwiseConv2dNativeBackpropFilter",Tt="DepthwiseConv2dNativeBackpropInput",Et="Diag",Ct="Dilation2D",Rt="Dilation2DBackpropInput",At="Dilation2DBackpropFilter",_t="Draw",Dt="RealDiv",Ft="Einsum",Ot="Elu",Mt="EluGrad",Lt="Erf",zt="Equal",Pt="Exp",Bt="ExpandDims",Wt="Expm1",Vt="FFT",Ut="Fill",Gt="FlipLeftRight",Ht="Floor",jt="FloorDiv",Kt="FusedBatchNorm",qt="GatherV2",Xt="GatherNd",Yt="Greater",Qt="GreaterEqual",Jt="Identity",Zt="IFFT",$t="Imag",en="IsFinite",tn="IsInf",nn="IsNan",an="LeakyRelu",rn="Less",sn="LessEqual",on="LinSpace",cn="Log",ln="Log1p",un="LogicalAnd",hn="LogicalNot",dn="LogicalOr",pn="LRN",fn="LRNGrad",mn="Max",gn="Maximum",yn="MaxPool",bn="MaxPoolGrad",vn="MaxPool3D",xn="MaxPool3DGrad",wn="MaxPoolWithArgmax",kn="Mean",Sn="Min",In="Minimum",Nn="MirrorPad",Tn="Mod",En="Multinomial",Cn="Multiply",Rn="Neg",An="NotEqual",_n="NonMaxSuppressionV3",Dn="NonMaxSuppressionV4",Fn="NonMaxSuppressionV5",On="OnesLike",Mn="OneHot",Ln="Pack",zn="PadV2",Pn="Pow",Bn="Prelu",Wn="Prod",Vn="RaggedGather",Un="RaggedRange",Gn="RaggedTensorToTensor",Hn="Range",jn="Real",Kn="Reciprocal",qn="Relu",Xn="Reshape",Yn="ResizeNearestNeighbor",Qn="ResizeNearestNeighborGrad",Jn="ResizeBilinear",Zn="ResizeBilinearGrad",$n="Relu6",ea="Reverse",ta="Round",na="Rsqrt",aa="ScatterNd",ra="TensorScatterUpdate",sa="SearchSorted",oa="Select",ia="Selu",ca="Slice",la="Sin",ua="Sinh",ha="Sign",da="Sigmoid",pa="Softplus",fa="Sqrt",ma="Sum",ga="SpaceToBatchND",ya="SplitV",ba="Softmax",va="SparseFillEmptyRows",xa="SparseReshape",wa="SparseSegmentMean",ka="SparseSegmentSum",Sa="SparseToDense",Ia="SquaredDifference",Na="Square",Ta="StaticRegexReplace",Ea="StridedSlice",Ca="StringNGrams",Ra="StringSplit",Aa="StringToHashBucketFast",_a="Sub",Da="Tan",Fa="Tanh",Oa="Tile",Ma="TopK",La="Transform",za="Transpose",Pa="Unique",Ba="Unpack",Wa="UnsortedSegmentSum",Va="ZerosLike",Ua="Step",Ga="FromPixels",Ha="RotateWithOffset",ja="_FusedMatMul",Ka="FusedConv2D",qa="FusedDepthwiseConv2D";function Xa(){_e().getBool("IS_TEST")||_e().getBool("PROD")||console.warn(...arguments)}function Ya(){_e().getBool("IS_TEST")||_e().getBool("PROD")||console.log(...arguments)}const Qa=Me("kernelRegistry",(()=>new Map)),Ja=Me("gradRegistry",(()=>new Map));function Za(e,t){const n=ar(e,t);return Qa.get(n)}function $a(e){return Ja.get(e)}function er(e){const t=Qa.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[s,o]=r,[i]=s.split("_");i===e&&n.push(o)}return n}function tr(e){const{kernelName:t,backendName:n}=e,a=ar(t,n);Qa.has(a)&&Xa("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),Qa.set(a,e)}function nr(e){const{kernelName:t}=e;Ja.has(t)&&_e().getBool("DEBUG")&&Xa("Overriding the gradient for '".concat(t,"'")),Ja.set(t,e)}function ar(e,t){return"".concat(t,"_").concat(e)}function rr(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}var sr=n(353),or=n.n(sr);const ir=or()||sr;function cr(e){return ir.fromString(e,!0,16)}const lr=cr("c3a5c85c97cb3127"),ur=cr("b492b66fbe98f273"),hr=cr("9ae16a3b2f90404f");function dr(e){return e.xor(e.shru(47))}function pr(e,t,n){const a=e.slice(t,t+n);return ir.fromBytes(Array.from(a),!0,!0)}function fr(e,t){return pr(e,t,8)}function mr(e,t){return pr(e,t,4)}function gr(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function yr(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:cr("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function br(e,t,n,a){return function(e,t,n,a,r,s){r=r.add(e),s=gr(s.add(r).add(a),21);const o=r;return r=(r=r.add(t)).add(n),s=s.add(gr(r,44)),[r.add(a),s.add(o)]}(fr(e,t),fr(e,t+8),fr(e,t+16),fr(e,t+24),n,a)}function vr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=ir.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=hr.add(2*t),a=fr(e,0).add(hr),r=fr(e,t-8);return yr(gr(r,37).mul(n).add(a),gr(a,25).add(r).mul(n),n)}if(t>=4){const n=hr.add(2*t);return yr(mr(e,0).shl(3).add(t),mr(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return dr(hr.mul(n).xor(lr.mul(a))).mul(hr)}return hr}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=hr.add(2*t),a=fr(e,0).mul(ur),r=fr(e,8),s=fr(e,t-8).mul(n),o=fr(e,t-16).mul(hr);return yr(gr(a.add(r),43).add(gr(s,30)).add(o),a.add(gr(r.add(hr),18)).add(s),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=hr.add(2*t),a=fr(e,0).mul(hr),r=fr(e,8),s=fr(e,t-8).mul(n),o=fr(e,t-16).mul(hr),i=gr(a.add(r),43).add(gr(s,30)).add(o),c=yr(i,a.add(gr(r.add(hr),18)).add(s),n),l=fr(e,16).mul(n),u=fr(e,24),h=i.add(fr(e,t-32)).mul(n),d=c.add(fr(e,t-24)).mul(n);return yr(gr(l.add(u),43).add(gr(h,30)).add(d),l.add(gr(u.add(a),18)).add(h),n)}(e,t);let a=n,r=n.mul(ur).add(113),s=dr(r.mul(hr).add(113)).mul(hr),o=[ir.UZERO,ir.UZERO],i=[ir.UZERO,ir.UZERO];a=a.mul(hr).add(fr(e,0));let c=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{a=gr(a.add(r).add(o[0]).add(fr(e,c+8)),37).mul(ur),r=gr(r.add(o[1]).add(fr(e,c+48)),42).mul(ur),a=a.xor(i[1]),r=r.add(o[0]).add(fr(e,c+40)),s=gr(s.add(i[0]),33).mul(ur),o=br(e,c,o[1].mul(ur),a.add(i[0])),i=br(e,c+32,s.add(i[1]),r.add(fr(e,c+16))),[s,a]=[a,s],c+=64}while(c!==l);const h=ur.add(s.and(255).shl(1));return c=u,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),a=gr(a.add(r).add(o[0]).add(fr(e,c+8)),37).mul(h),r=gr(r.add(o[1]).add(fr(e,c+48)),42).mul(h),a=a.xor(i[1].mul(9)),r=r.add(o[0].mul(9).add(fr(e,c+40))),s=gr(s.add(i[0]),33).mul(h),o=br(e,c,o[1].mul(h),a.add(i[0])),i=br(e,c+32,s.add(i[1]),r.add(fr(e,c+16))),[s,a]=[a,s],yr(yr(o[0],i[0],h).add(dr(r).mul(lr)).add(s),yr(o[1],i[1],h).add(a),h)}function xr(e,t){return"string"===t?Sr(e):wr([e],t)}function wr(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Tr(e)),_e().getBool("DEBUG")&&function(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function kr(){return _e().platform.now()}function Sr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",_e().platform.encode(e,t)}function Ir(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",_e().platform.decode(e,t)}function Nr(e){return null!=_e().platform.isTypedArray?_e().platform.isTypedArray(e):rr(e)}function Tr(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),"boolean"===typeof e||"number"===typeof e||"string"===typeof e||Ee(e)||null==e||Nr(e)&&n)t.push(e);else if(Array.isArray(e)||Nr(e))for(let a=0;a<e.length;++a)Tr(e[a],t,n);else{let a=-1;for(const t of Object.keys(e))/^([1-9]+[0-9]*|0)$/.test(t)&&(a=Math.max(a,Number(t)));for(let r=0;r<=a;r++)Tr(e[r],t,n)}return t}class Er{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new Rr)}profileKernel(e,t,n){let a;const r=()=>{a=n()};let s;const o=kr();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(const e of a)e.dataSync();s=Promise.resolve({kernelMs:kr()-o})}if(_e().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<a.length;i++){const t=a[i];t.data().then((n=>{Cr(n,t.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),a,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}}function Cr(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class Rr{logKernelProfile(e,t,n,a,r,s){const o="number"===typeof a?re("".concat(a,"ms"),9):a.error,i=re(e,25),c=t.rank,l=t.size,u=re(t.shape.toString(),14);let h="";for(const d in r){const e=r[d];if(null!=e){const n=e.shape||t.shape,a=n.length;h+="".concat(d,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(o,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(h,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const Ar=20,_r=3,Dr=7;function Fr(e,t,n,a){const r=be(t),s=function(e,t,n,a){const r=ee(t),s=a[a.length-1],o=new Array(s).fill(0),i=t.length,c="complex64"===n?zr(e):e;if(i>1)for(let l=0;l<r/s;l++){const e=l*s;for(let t=0;t<s;t++)o[t]=Math.max(o[t],Or(c[e+t],0,n).length)}return o}(e,t,n,r),o=t.length,i=Lr(e,t,n,r,s),c=["Tensor"];return a&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(o)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(i.map((e=>"    "+e)).join("\n")),c.join("\n")}function Or(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(Dr))," + ")+"".concat(parseFloat(e[1].toFixed(Dr)),"j"):pe(e)?"'".concat(e,"'"):"bool"===n?Mr(e):parseFloat(e.toFixed(Dr)).toString(),re(a,t)}function Mr(e){return 0===e?"false":"true"}function Lr(e,t,n,a,r){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const o="complex64"===n?2:1,i=t[0],c=t.length;if(0===c){if("complex64"===n){return[Or(zr(e)[0],0,n)]}return"bool"===n?[Mr(e[0])]:[e[0].toString()]}if(1===c){if(i>Ar){const t=_r*o;let a=Array.from(e.slice(0,t)),s=Array.from(e.slice((i-_r)*o,i*o));return"complex64"===n&&(a=zr(a),s=zr(s)),["["+a.map(((e,t)=>Or(e,r[t],n))).join(", ")+", ..., "+s.map(((e,t)=>Or(e,r[i-_r+t],n))).join(", ")+"]"]}return["["+("complex64"===n?zr(e):Array.from(e)).map(((e,t)=>Or(e,r[t],n))).join(", ")+"]"]}const l=t.slice(1),u=a.slice(1),h=a[0]*o,d=[];if(i>Ar){for(let t=0;t<_r;t++){const a=t*h,s=a+h;d.push(...Lr(e.slice(a,s),l,n,u,r,!1))}d.push("...");for(let t=i-_r;t<i;t++){const a=t*h,s=a+h;d.push(...Lr(e.slice(a,s),l,n,u,r,t===i-1))}}else for(let m=0;m<i;m++){const t=m*h,a=t+h;d.push(...Lr(e.slice(t,a),l,n,u,r,m===i-1))}const p=2===c?",":"";d[0]="["+(i>0?d[0]+p:"");for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<c;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function zr(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class Pr{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=ee(e),null!=n){const e=n.length;J(e===this.size,(()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||ue(t,this.size),this.strides=be(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),J(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const r=this.locToIndex(n);this.values[r]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const s of t){if(s<0||s>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return Br().makeTensor(this.values,this.shape,this.dtype)}}let Br=null,Wr=null,Vr=null;class Ur{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=ee(e),this.strides=be(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return Wr.buffer(this.shape,this.dtype,e)}bufferSync(){return Wr.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return xe(this.shape,e,"complex64"===this.dtype)}arraySync(){return xe(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=Br().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>Ir(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),Br().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=Br().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>Ir(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await Br().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(this.kerasMask&&this.kerasMask.dispose(),Br().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Wr.print(this,e)}clone(){return this.throwIfDisposed(),Wr.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return Fr(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),Wr.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),Br().makeVariable(this,e,t,n)}}function Gr(){return Me("Tensor",(()=>Ur))}Object.defineProperty(Ur,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),Gr();class Hr extends Ur{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!te(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));Br().disposeTensor(this),this.dataId=e.dataId,Br().incRef(this,null)}dispose(){Br().disposeVariable(this),this.isDisposedInternal=!0}}var jr,Kr,qr,Xr,Yr;Object.defineProperty(Hr,Symbol.hasInstance,{value:e=>e instanceof Ur&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(jr||(jr={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(Kr||(Kr={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(qr||(qr={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(Xr||(Xr={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(Yr||(Yr={}));const Qr={float32:Xr,int32:Kr,bool:qr,complex64:Yr};function Jr(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return Qr[e][t]}function Zr(e){return Jr(e,"int32")}function $r(e){return null!=e&&"object"===typeof e&&"texture"in e&&e.texture instanceof WebGLTexture}function es(e){return"undefined"!==typeof GPUBuffer&&null!=e&&"object"===typeof e&&"buffer"in e&&e.buffer instanceof GPUBuffer}function ts(e,t){if(e.dtype===t.dtype)return[e,t];const n=Jr(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function ns(e,t){return t.some((t=>t.id===e.id))}function as(e){const t=[];return rs(e,t,new Set),t}function rs(e,t,n){if(null==e)return;if(e instanceof Ur)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const r=e;for(const s in r){const e=r[s];n.has(e)||(n.add(e),rs(e,t,n))}}function ss(e){return null!=e.kernelName}class os{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class is{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new os}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(Xa("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new Er(this.backendInstance),!0}setupRegisteredKernels(){er(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){er(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof j||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,Xa("Initialization of backend ".concat(e," failed")),Xa(n.stack||n.message)),!1)));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(n){return Xa("Initialization of backend ".concat(e," failed")),Xa(n.stack||n.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),s=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun((()=>this.startScope(a)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return is.nextTensorId++}nextVariableId(){return is.nextVariableId++}clone(e){const t=ls.runKernel(Jt,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return ls.runKernel(st,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=Za(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=a-t-r-s;if(o>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(o," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=ss(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(ss(e)){const{kernelName:t,inputs:r,attrs:s}=e;null==this.backendName&&this.backend;const c=Za(t,this.backendName);J(null!=c,(()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'"))),o=()=>{const e=this.backend.numDataIds();i=c.kernelFunc({inputs:r,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,o);const l=o.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){const e=this.getTensorsForGradient(t,r,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map((e=>this.keep(this.clone(e)))))};o=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:l,attrs:u}=e,h=ss(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(c,l,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=o()})),a&&this.addTapeNode(c,l,t,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const a=$a(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let s;a.saveAllInputs?(J(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const o=n.filter(((e,t)=>r[t]));return s.concat(o)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&pe(e[0])&&(r=e.map((e=>Sr(e))));const s=a.write(r,t,n),o=new Ur(t,n,s,this.nextTensorId());if(this.trackTensor(o,a),"string"===n){const e=this.state.tensorInfo.get(s),t=function(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,a){const r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:r}=e,s=new Ur(a,r,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new Hr(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error("Variable with name ".concat(r.name," was already registered"));return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*de(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof Hr||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*de(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,s){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=$a(e);null!=i&&(a=i.gradFunc),null!=a&&(o.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],a=ke(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e})),a(e.length>1?e:e[0],r,s))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=as(e),n=new Set(t.map((e=>e.id)));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==a.id||this.track(e)}))}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(J(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));J(r instanceof Ur,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const a={},r={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],s=n.inputs;for(const e in s){const o=s[e];let i=!1;for(let e=0;e<t.length;e++)if(a[o.id]){n.outputs.forEach((e=>a[e.id]=!0)),i=!0,r[n.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(const e in n)s[n[e].id]=!0,o[t.id]=!0;break}}const i=[];for(let c=0;c<e.length;c++){const t=e[c];if(r[t.id]&&o[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];a[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,i.push(n)}}return i}(this.state.activeTape,t,r);if(!a&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?function(e){const t=we(ee(e),"float32");return ls.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){const s=t[r],o=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(s.kernelName,"."));const i=s.gradient(o);for(const t in s.inputs){if(!(t in i))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const r=n((()=>i[t]()));if("float32"!==r.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(r.dtype,"'"));const o=s.inputs[t];if(!te(r.shape,o.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(r.shape,"', which does not match ")+"the shape of the input '".concat(o.shape,"'"));if(null==e[o.id])e[o.id]=r;else{const t=e[o.id];e[o.id]=a(t,r),t.dispose()}}}}(e,s,(e=>this.tidy(e)),us);const a=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:a}}))}customGrad(e){var t=this;return J(ge(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];let s;J(a.every((e=>e instanceof Ur)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const o={};a.forEach(((e,t)=>{o[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(s=e(...a,n),J(s.value instanceof Ur,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),J(ge(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(e,t)=>{const n=s.gradFunc(e,t),r=Array.isArray(n)?n:[n];J(r.length===a.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),J(r.every((e=>e instanceof Ur)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return r.forEach(((e,t)=>{o[t]=()=>e})),o},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=kr(),n=await this.backend.time(e);return n.wallMs=kr()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new os;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function cs(){const e=Oe();if(null==e._tfengine){const t=new Re(e);e._tfengine=new is(t)}var t;return t=e._tfengine.ENV,Fe=t,Br=()=>e._tfengine,e._tfengine}is.nextTensorId=0,is.nextVariableId=0;const ls=cs();function us(e,t){const n={a:e,b:t};return ls.runKernel(Be,n)}let hs;function ds(e){if(void 0!==hs)return hs;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function ps(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const fs=_e();function ms(e,t){let n=e;if(Nr(e))return"string"===t?[]:[e.length];if($r(e)){const t=e.channels||"RGBA";return[e.height,e.width*t.length]}if(es(e))return[e.buffer.size/(null==t?4:de(t))];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||Nr(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&_e().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&gs(e,a,[]),a}function gs(e,t,n){if(n=n||[],!Array.isArray(e)&&!Nr(e))return void J(0===t.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements")));J(t.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements"))),J(e.length===t[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements")));const a=t.slice(1);for(let r=0;r<e.length;++r)gs(e[r],a,n.concat(r))}function ys(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function bs(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof Gr())return ys(a,e.dtype,t,n),e;let r=me(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),ys(a,r,t,n),null==e||!Nr(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const s=ms(e,r);Nr(e)||Array.isArray(e)||(e=[e]);const o="string"!==r?wr(e,r):Tr(e,[],!0);return ls.makeTensor(o,s,r)}function vs(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map(((e,r)=>bs(e,"".concat(t,"[").concat(r,"]"),n,a)))}fs.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),fs.registerFlag("IS_BROWSER",(()=>ps())),fs.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),fs.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),fs.registerFlag("IS_SAFARI",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Safari/.test(navigator.userAgent)&&/Apple/.test(navigator.vendor))),fs.registerFlag("PROD",(()=>!1)),fs.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>fs.getBool("DEBUG"))),fs.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),fs.registerFlag("IS_TEST",(()=>!1)),fs.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>fs.getBool("DEBUG"))),fs.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),fs.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),fs.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));function xs(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+="__op";const r=function(){ls.startScope(n);try{const e=a(...arguments);return Ee(e)&&console.error("Cannot return a Promise inside of tidy."),ls.endScope(e),e}catch(e){throw ls.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}const ws=xs({complex_:function(e,t){const n=bs(e,"real","complex"),a=bs(t,"imag","complex");Z(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", ")+"must match in call to tf.complex().");const r={real:n,imag:a};return ls.runKernel(ct,r)}});function ks(e,t,n,a){if(null==a)a=me(e);else if("complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(es(e)||$r(e)){if("float32"!==a&&"int32"!==a)throw new Error("Creating tensor from GPU data only supports "+"'float32'|'int32' dtype, while the dtype is ".concat(a,"."));return ls.backend.createTensorFromGPUData(e,t||n,a)}if(!Nr(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){Ie(t);const e=ee(t),a=ee(n);J(e===a,(()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a)));for(let r=0;r<n.length;++r){const e=n[r],a=r!==n.length-1||e!==ee(t.slice(r));J(n[r]===t[r]||!a,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). ")))}}return Nr(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?wr(e,a):Tr(e,[],!0),ls.makeTensor(e,t,a)}function Ss(e,t,n){return ks(e,t,ms(e,n),n)}class Is{static join(e){return new Is(e).slice()}constructor(e){if(this.shards=[],this.previousShardIndex=0,null==e)return;if(e instanceof Array||(e=[e]),0===(e=e.map((e=>Nr(e)?e.buffer:e))).length)return;this.bufferUniformSize=e[0].byteLength;let t=0;for(let n=0;n<e.length;n++){const a=e[n];n!==e.length-1&&a.byteLength!==this.bufferUniformSize&&(this.bufferUniformSize=void 0);const r=t+a.byteLength;this.shards.push({buffer:a,start:t,end:r}),t=r}0===this.shards.length&&(this.byteLength=0),this.byteLength=this.shards[this.shards.length-1].end}slice(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:this.byteLength;if(0===this.shards.length)return new ArrayBuffer(0);if(e=isNaN(Number(e))?0:e,t=isNaN(Number(t))?0:t,e=Math.max(0,e),t=Math.min(this.byteLength,t),t<=e)return new ArrayBuffer(0);const n=this.findShardForByte(e);if(-1===n)throw new Error("Could not find start shard for byte ".concat(e));const a=new ArrayBuffer(t-e),r=new Uint8Array(a);let s=0;for(let o=n;o<this.shards.length;o++){const n=this.shards[o],a=e+s-n.start,i=s,c=Math.min(t,n.end)-n.start,l=new Uint8Array(n.buffer,a,c-a);if(r.set(l,i),s+=l.length,t<n.end)break}return a}findShardForByte(e){if(0===this.shards.length||e<0||e>=this.byteLength)return-1;if(null!=this.bufferUniformSize)return this.previousShardIndex=Math.floor(e/this.bufferUniformSize),this.previousShardIndex;function t(t){return e<t.start?-1:e>=t.end?1:0}if(0===t(this.shards[this.previousShardIndex]))return this.previousShardIndex;const n=function(e,t){let n=0,a=e.length;for(;n<=a;){const r=Math.floor((a-n)/2)+n,s=t(e[r]);if(0===s)return r;s<0?a=r:n=r+1}return-1}(this.shards,t);return-1===n?-1:(this.previousShardIndex=n,this.previousShardIndex)}}function Ns(){return ls}function Ts(){return ls.memory()}function Es(e,t){return ls.tidy(e,t)}function Cs(e){as(e).forEach((e=>e.dispose()))}function Rs(e){return ls.keep(e)}function As(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return ls.registerBackend(e,t,n)}function _s(){return ls.backend}Vr=function(e){_e().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")};const Ds=4;async function Fs(e,t){const n=[],a=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<r.length;++s){const o=r[s],i=Array.isArray(e)?e[s].tensor:e[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(o,"': ").concat(i.dtype));const c={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise((async e=>{const t=await i.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+Ds*t.length,a=new Uint8Array(n);let r=0;for(let s=0;s<t.length;s++){const e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,r),r+=Ds,a.set(e,r),r+=e.length}e(a)}));a.push(e)}else a.push(i.data());null!=t&&(c.group=t),n.push(c)}return{data:Os(await Promise.all(a)),specs:n}}function Os(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))}));const a=new Uint8Array(t);let r=0;return n.forEach((e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),a.buffer}const Ms="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function Ls(e){return Ms?Buffer.byteLength(e,"utf8"):new Blob([e]).size}function zs(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(n.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}async function Ps(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),function(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(a.initializerSignature=e.initializerSignature),a}(e,n,a)}function Bs(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:Ls(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:Ls(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:new Is(e.weightData).byteLength}}function Ws(e){const t=[];for(const n of e)t.push(...n.weights);return t}class Vs{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==Vs.instance&&(Vs.instance=new Vs),Vs.instance}static registerSaveRouter(e){Vs.getInstance().saveRouters.push(e)}static registerLoadRouter(e){Vs.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return Vs.getHandlers(e,"save")}static getLoadHandlers(e,t){return Vs.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?Vs.getInstance().loadRouters:Vs.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&a.push(r)})),a}}const Us="tensorflowjs",Gs="models_store",Hs="model_info_store";function js(){if(!_e().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function Ks(e){const t=e.result;t.createObjectStore(Gs,{keyPath:"modelPath"}),t.createObjectStore(Hs,{keyPath:"modelPath"})}class qs{constructor(e){if(this.indexedDB=js(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const a=this.indexedDB.open(Us,1);a.onupgradeneeded=()=>Ks(a),a.onsuccess=()=>{const r=a.result;if(null==t){const t=r.transaction(Gs,"readonly"),a=t.objectStore(Gs).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{t.weightData=Is.join(t.weightData);const a=Bs(t),o=r.transaction(Hs,"readwrite");let i,c,l=o.objectStore(Hs);try{i=l.put({modelPath:this.modelPath,modelArtifactsInfo:a})}catch(s){return n(s)}i.onsuccess=()=>{c=r.transaction(Gs,"readwrite");const i=c.objectStore(Gs);let u;try{u=i.put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a})}catch(s){return n(s)}u.onsuccess=()=>e({modelArtifactsInfo:a}),u.onerror=e=>{l=o.objectStore(Hs);const t=l.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(u.error)),t.onerror=e=>(r.close(),n(u.error))}},i.onerror=e=>(r.close(),n(i.error)),o.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)}))}}qs.URL_SCHEME="indexeddb://";const Xs=e=>{return _e().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(qs.URL_SCHEME)?(t=e.slice(qs.URL_SCHEME.length),new qs(t)):null;var t};Vs.registerSaveRouter(Xs),Vs.registerLoadRouter(Xs);class Ys{constructor(){this.indexedDB=js()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(Us,1);n.onupgradeneeded=()=>Ks(n),n.onsuccess=()=>{const a=n.result,r=a.transaction(Hs,"readonly"),s=r.objectStore(Hs).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(qs.URL_SCHEME)?t.slice(qs.URL_SCHEME.length):t,new Promise(((t,n)=>{const a=this.indexedDB.open(Us,1);a.onupgradeneeded=()=>Ks(a),a.onsuccess=()=>{const r=a.result,s=r.transaction(Hs,"readwrite"),o=s.objectStore(Hs),i=o.get(e);let c;i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=o.delete(e),s=()=>{c=r.transaction(Gs,"readwrite");const a=c.objectStore(Gs).delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo),a.onerror=e=>n(i.error)};a.onsuccess=s,a.onerror=e=>(s(),r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)}))}}const Qs="/",Js="tensorflowjs_models",Zs="info",$s="model_topology",eo="weight_specs",to="weight_data",no="model_metadata";function ao(e){return{info:[Js,e,Zs].join(Qs),topology:[Js,e,$s].join(Qs),weightSpecs:[Js,e,eo].join(Qs),weightData:[Js,e,to].join(Qs),modelMetadata:[Js,e,no].join(Qs)}}function ro(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function so(e){const t=e.split(Qs);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(Qs)}class oo{constructor(e){if(!_e().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=ao(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const n=JSON.stringify(e.modelTopology),a=JSON.stringify(e.weightSpecs),r=Bs(e),s=Is.join(e.weightData);try{this.LS.setItem(this.keys.info,JSON.stringify(r)),this.LS.setItem(this.keys.topology,n),this.LS.setItem(this.keys.weightSpecs,a),this.LS.setItem(this.keys.weightData,function(e){if(Ms)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(s));const t={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,initializerSignature:null!=e.initializerSignature?e.initializerSignature:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(t)),{modelArtifactsInfo:r}}catch(t){throw ro(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(r.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(r.weightSpecsBytes,", ")+"weightDataBytes=".concat(r.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.initializerSignature&&(t.initializerSignature=e.initializerSignature),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(Ms){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(s),t}}oo.URL_SCHEME="localstorage://";const io=e=>{return _e().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(oo.URL_SCHEME)?(t=e.slice(oo.URL_SCHEME.length),new oo(t)):null;var t};Vs.registerSaveRouter(io),Vs.registerLoadRouter(io);class co{constructor(){J(_e().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),J("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=Js+Qs,n=Qs+Zs;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[so(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=ao(e=(t=e).startsWith(oo.URL_SCHEME)?t.slice(oo.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return ro(n),a}}const lo="://";class uo{constructor(){this.managers={}}static getInstance(){return null==uo.instance&&(uo.instance=new uo),uo.instance}static registerManager(e,t){J(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(lo)&&(e=e.slice(0,e.indexOf(lo))),J(e.length>0,(()=>"scheme must not be an empty string."));const n=uo.getInstance();J(null==n.managers[e],(()=>"A model store manager is already registered for scheme '".concat(e,"'."))),n.managers[e]=t}static getManager(e){const t=uo.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(uo.getInstance().managers)}}class ho{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){"undefined"!==typeof window&&_e().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}isTypedArray(e){return rr(e)}}if(_e().get("IS_BROWSER")){_e().setPlatform("browser",new ho);try{uo.registerManager(oo.URL_SCHEME,new co)}catch(o1){}try{uo.registerManager(qs.URL_SCHEME,new Ys)}catch(o1){}}const po=()=>n(78);let fo;class mo{constructor(){this.util=n(905),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=_e().global.fetch?_e().global.fetch(e,t):(null==fo&&(fo=po()),fo(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}isTypedArray(e){return this.util.types.isFloat32Array(e)||this.util.types.isInt32Array(e)||this.util.types.isUint8Array(e)||this.util.types.isUint8ClampedArray(e)}}function go(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",Ie(e),new Pr(e,t,n)}_e().get("IS_NODE")&&!_e().get("IS_BROWSER")&&_e().setPlatform("node",new mo);const yo=xs({cast_:function(e,t){const n=bs(e,"x","cast");if(!function(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return ls.runKernel(st,a,r)}});const bo=xs({clone_:function(e){const t={x:bs(e,"x","clone","string_or_numeric")};return ls.runKernel(Jt,t)}});cs();Wr={buffer:go,cast:yo,clone:bo,print:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}};const vo=xs({add_:function(e,t){let n=bs(e,"a","add"),a=bs(t,"b","add");[n,a]=ts(n,a);const r={a:n,b:a};return ls.runKernel(Be,r)}});const xo=xs({floorDiv_:function(e,t){let n=bs(e,"a","floorDiv"),a=bs(t,"b","floorDiv");[n,a]=ts(n,a);const r={a:n,b:a};return ls.runKernel(jt,r)}});const wo=xs({div_:function(e,t){let n=bs(e,"a","div"),a=bs(t,"b","div");if([n,a]=ts(n,a),"int32"===n.dtype&&"int32"===a.dtype)return xo(n,a);const r={a:n,b:a};return ls.runKernel(Dt,r,{})}});const ko=xs({mul_:function(e,t){let n=bs(e,"a","mul"),a=bs(t,"b","mul");[n,a]=ts(n,a);const r={a:n,b:a};return ls.runKernel(Cn,r)}});const So=xs({sqrt_:function(e){const t={x:bs(e,"x","sqrt","float32")};return ls.runKernel(fa,t)}});const Io=xs({square_:function(e){const t=bs(e,"x","square");return ls.runKernel("Square",{x:t},{})}});const No=xs({zerosLike_:function(e){const t={x:bs(e,"x","zerosLike")};return ls.runKernel(Va,t)}});function To(e){return ls.customGrad(e)}function Eo(e,t){if((Nr(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Nr(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return ks(e,[],[],t)}const Co=new Map,Ro=new Map;class Ao{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class _o{constructor(){this.classNameMap={}}static getMap(){return null==_o.instance&&(_o.instance=new _o),_o.instance}static register(e){_o.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Do(e,t,n){J(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),J("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),J(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),"undefined"===typeof t&&(t="Custom"),"undefined"===typeof n&&(n=e.className);const a=t+">"+n;return _o.register(e),Co.set(a,e),Ro.set(e,a),e}class Fo extends Ao{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:r[e.name]})));this.applyGradients(e)}else this.applyGradients(r);return Cs(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return function(e,t){J(ge(e),(()=>"The f passed in variableGrads(f) must be a function")),J(null==t||Array.isArray(t)&&t.every((e=>e instanceof Hr)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in ls.registeredVariables)t.push(ls.registeredVariables[e])}const a=n?t.filter((e=>!e.trainable)):null,r=t.length;t=t.filter((e=>e.trainable)),J(t.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(r," variables is ")+"trainable."));const{value:s,grads:o}=ls.gradients(e,t,null,!0);J(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),J(0===s.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(s.rank," tensor")));const i={};return t.forEach(((e,t)=>{null!=o[t]&&(i[e.name]=o[t])})),null!=a&&a.forEach((e=>i[e.name]=null)),{value:s,grads:i}}(e,t)}dispose(){null!=this.iterations_&&Cs(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:Eo(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(Fo,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class Oo extends Fo{static get className(){return"Adadelta"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=ls.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=ls.registeredVariables[t],r=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:Es((()=>No(a).variable(r)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:Es((()=>No(a).variable(r)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const o=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;Es((()=>{const e=vo(ko(o,this.rho),ko(Io(s),1-this.rho)),t=ko(wo(So(vo(i,this.epsilon)),So(vo(o,this.epsilon))),s),n=vo(ko(i,this.rho),ko(Io(t),1-this.rho));o.assign(e),i.assign(n);const r=vo(ko(t,-this.learningRate),a);a.assign(r)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(Cs(this.accumulatedGrads.map((e=>e.variable))),Cs(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function Mo(e,t,n){Ie(e);const a={shape:e,value:t,dtype:n=n||me(t)};return ls.runKernel(Ut,{},a)}class Lo extends Fo{static get className(){return"Adagrad"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=ls.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:Es((()=>Mo(a.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=this.accumulatedGrads[n].variable;Es((()=>{const e=vo(s,Io(r));s.assign(e);const t=vo(ko(wo(r,So(vo(e,ls.backend.epsilon()))),-this.learningRate),a);a.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&Cs(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}const zo=xs({pow_:function(e,t){let n=bs(e,"base","pow"),a=bs(t,"exp","pow");[n,a]=ts(n,a);const r={a:n,b:a};return ls.runKernel(Pn,r)}});const Po=xs({sub_:function(e,t){let n=bs(e,"a","sub"),a=bs(t,"b","sub");[n,a]=ts(n,a);const r={a:n,b:a};return ls.runKernel(_a,r)}});class Bo extends Fo{static get className(){return"Adam"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],Es((()=>{this.accBeta1=Eo(t).variable(),this.accBeta2=Eo(n).variable()})),null==a&&(this.epsilon=ls.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Es((()=>{const n=Po(1,this.accBeta1),a=Po(1,this.accBeta2);t.forEach(((t,r)=>{const s=ls.registeredVariables[t],o=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:Es((()=>No(s).variable(o)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:"".concat(t,"/v"),variable:Es((()=>No(s).variable(o)))});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=vo(ko(c,this.beta1),ko(i,1-this.beta1)),h=vo(ko(l,this.beta2),ko(Io(i),1-this.beta2)),d=wo(u,n),p=wo(h,a);c.assign(u),l.assign(h);const f=vo(ko(wo(d,vo(So(p),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(ko(this.accBeta1,this.beta1)),this.accBeta2.assign(ko(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&Cs(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&Cs(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),Es((()=>{this.accBeta1.assign(zo(this.beta1,this.iterations_+1)),this.accBeta2.assign(zo(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}const Wo=xs({abs_:function(e){const t=bs(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return ls.runKernel(lt,e)}{const e={x:t};return ls.runKernel(Le,e)}}});function Vo(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const s=n-1-r,o=e[s]||1;(t[t.length-1-r]||1)>1&&1===o&&a.unshift(s)}return a}function Uo(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],s=t.length-a-1,o=t[s];(null==r||1===r&&o>1)&&n.unshift(s)}return n}function Go(e,t){const n=Math.max(e.length,t.length),a=new Array(n);for(let r=0;r<n;r++){let s=e[e.length-r-1];null==s&&(s=1);let o=t[t.length-r-1];if(null==o&&(o=1),1===s)a[n-r-1]=o;else if(1===o)a[n-r-1]=s;else{if(s!==o){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}a[n-r-1]=s}}return a}const Ho=xs({maximum_:function(e,t){let n=bs(e,"a","maximum"),a=bs(t,"b","maximum");[n,a]=ts(n,a),"bool"===n.dtype&&(n=yo(n,"int32"),a=yo(a,"int32")),Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(gn,r)}});class jo extends Fo{static get className(){return"Adamax"}constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],Es((()=>{this.iteration=Eo(0).variable(),this.accBeta1=Eo(t).variable()})),null==a&&(this.epsilon=ls.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);Es((()=>{const n=Po(1,this.accBeta1),a=wo(-this.learningRate,vo(ko(this.iteration,this.decay),1));t.forEach(((t,r)=>{const s=ls.registeredVariables[t],o=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:No(s).variable(o)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:"".concat(t,"/v"),variable:No(s).variable(o)});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=vo(ko(c,this.beta1),ko(i,1-this.beta1)),h=ko(l,this.beta2),d=Wo(i),p=Ho(h,d);c.assign(u),l.assign(p);const f=vo(ko(wo(a,n),wo(u,vo(p,this.epsilon))),s);s.assign(f)})),this.iteration.assign(vo(this.iteration,1)),this.accBeta1.assign(ko(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&Cs(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&Cs(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}class Ko extends Fo{static get className(){return"SGD"}constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const r=ls.registeredVariables[t];Es((()=>{const e=vo(ko(this.c,a),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=Rs(Eo(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}class qo extends Ko{static get className(){return"Momentum"}constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=Eo(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=ls.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:Es((()=>No(a).variable(e)))}}const r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&Es((()=>{let e;const t=vo(ko(this.m,r),s);e=this.useNesterov?vo(ko(this.c,vo(s,ko(t,this.m))),a):vo(ko(this.c,t),a),r.assign(t),a.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&Cs(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}class Xo extends Fo{static get className(){return"RMSProp"}constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=ls.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=ls.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:Es((()=>No(a).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:Es((()=>No(a).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:Es((()=>No(a).variable(r)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;Es((()=>{const e=vo(ko(o,this.decay),ko(Io(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=vo(ko(t,this.decay),ko(s,1-this.decay)),c=wo(ko(s,this.learningRate),So(Po(e,vo(Io(r),this.epsilon)))),l=vo(ko(i,this.momentum),c);o.assign(e),t.assign(r),i.assign(l);const u=Po(a,l);a.assign(u)}else{const e=vo(ko(o,this.decay),ko(Io(s),1-this.decay)),t=vo(ko(i,this.momentum),wo(ko(s,this.learningRate),So(vo(e,this.epsilon))));o.assign(e),i.assign(t);const n=Po(a,t);a.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&Cs(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&Cs(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&Cs(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}const Yo=[Oo,Lo,Bo,jo,qo,Xo,Ko];function Qo(e){return new Promise((e=>setTimeout(e))).then(e)}class Jo{constructor(e){if(!_e().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(Jo.URL_SCHEME)&&(e=e.slice(Jo.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=Is.join(e.weightData),n=window.URL.createObjectURL(new Blob([t],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const t=zs(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(t)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=a,await Qo((()=>r.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=n,await Qo((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:Bs(e)}}}}Jo.URL_SCHEME="downloads://";function Zo(e,t,n,a){!function(e){J(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){J(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e))),J(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t))),J(t>=e,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t)))}(n=null==n?0:n,a=null==a?1:a);let r=0;return Promise.all(e.map((s=>(s.then((s=>{const o=n+ ++r/e.length*(a-n);return t(o),s})),s))))}async function $o(e,t){null==t&&(t={});const n=null==t.fetchFunc?_e().platform.fetch:t.fetchFunc,a=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(a):await Zo(a,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await Zo(r,t.onProgress,.5,1)}Vs.registerSaveRouter((e=>_e().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(Jo.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new Jo(e)}(e.slice(Jo.URL_SCHEME.length)):null));class ei{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(J("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=_e().platform.fetch,J(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&J(2===e.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,")."))),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{},this.loadOptions=t}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=zs(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);if(t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData){const n=Is.join(e.weightData);t.body.append("model.weights.bin",new Blob([n],{type:"application/octet-stream"}),"model.weights.bin")}const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:Bs(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(a.status,"."))}async loadModelJSON(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(r){let e="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return t}async load(){if(this.loadOptions.streamWeights)return this.loadStream();return Ps(await this.loadModelJSON(),(e=>this.loadWeights(e)))}async loadStream(){const e=await this.loadModelJSON(),t=await this.getWeightUrls(e.weightsManifest),n=Ws(e.weightsManifest);return Object.assign(Object.assign({},e),{weightSpecs:n,getWeightStream:()=>function(e,t){var n;const a=null==t.fetchFunc?_e().platform.fetch:t.fetchFunc;let r,s=0;return null===(n=t.onProgress)||void 0===n||n.call(t,0),new ReadableStream({pull:async n=>{for(var o;s<e.length;){if(!r){const n=(await a(e[s],t.requestInit,{isBinary:!0})).body;r=n.getReader()}const{done:i,value:c}=await r.read();if(!i)return void n.enqueue(c);s++,r=void 0,null===(o=t.onProgress)||void 0===o||o.call(t,s/e.length)}n.close()}})}(t,this.loadOptions)})}async getWeightUrls(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}(t),r=this.weightPathPrefix||n,s=[],o=[];for(const i of e)for(const e of i.paths)null!=this.weightUrlConverter?o.push(this.weightUrlConverter(e)):s.push(r+e+a);return this.weightUrlConverter&&s.push(...await Promise.all(o)),s}async loadWeights(e){const t=await this.getWeightUrls(e);return[Ws(e),await $o(t,this.loadOptions)]}}function ti(e){return null!=e.match(ei.URL_SCHEME_REGEX)}ei.URL_SCHEME_REGEX=/^https?:\/\//;const ni=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>ti(e))):ti(e),n)return ai(e,t)}return null};function ai(e,t){return new ei(e,t)}Vs.registerSaveRouter(ni),Vs.registerLoadRouter(ni);const ri=-2,si=-1;function oi(e,t,n){const a=e.shape.length;J(a===t.length,(()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(a,")."))),J(a===n.length,(()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(a,").")));for(let r=0;r<a;++r)J(t[r]+n[r]<=e.shape[r],(()=>"Error in slice".concat(a,"D: begin[").concat(r,"] + size[").concat(r,"] ")+"(".concat(t[r]+n[r],") would overflow input.shape[").concat(r,"] (").concat(e.shape[r],")")))}function ii(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function ci(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function li(e,t,n,a){const r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)0===s?r[t]=1:(r.splice(t,0,1),r.pop());return r}function ui(e,t,n){return n<=e?n:n-(t-1)}function hi(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function di(e,t,n,a,r,s,o,i,c){const l=e.length;let u=new Array(l),h=new Array(l),d=new Array(l);if(t.length&&n>0){const c=t[0],l=n+1;u=pi(o,c,l,a,e),h=fi(i,c,l,r,e),d=li(s,c,l,e)}else for(let p=0;p<l;p++)u[p]=gi(o,a,s,e,p,c),h[p]=yi(i,r,s,e,p,c),d[p]=mi(s,p,c);return{begin:u,end:h,strides:d}}function pi(e,t,n,a,r){const s=[...r],o=hi(n,t);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=0;else{const r=ui(t,n,i);let o=a[r];e&1<<r&&(o=0),s[i]=o}return s}function fi(e,t,n,a,r){const s=[...r],o=hi(n,t);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{const r=ui(t,n,i);let o=a[r];e&1<<r&&(o=Number.MAX_SAFE_INTEGER),s[i]=o}for(let i=0;i<s.length;i++){const e=r[i];s[i]<0&&(s[i]+=e),s[i]=X(0,s[i],r[i])}return s}function mi(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function gi(e,t,n,a,r,s){let o=t[r];const i=n[r]||1;(e&1<<r||s&1<<r||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=a[r];return o<0&&(o+=c),o=X(0,o,c-1),o}function yi(e,t,n,a,r,s){let o=t[r];const i=n[r]||1;(e&1<<r||s&1<<r||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=a[r];return o<0&&(o+=c),o=i>0?X(0,o,c):X(-1,o,c-1),o}function bi(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function vi(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function xi(e,t,n){let a;const r=e.shape.length;let s;return a="number"===typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),a.forEach((e=>{J(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(r).fill(-1):"number"===typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:(J(-1===t,(()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,"."))),e.shape[n]-a[n]))),[a,s]}function wi(e,t,n,a,r,s,o,i,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=o&&0!==(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:c};for(let b=0;b<h.dims;b++)u&&0!==(1<<b&i)&&h.numAddAxisAfterEllipsis++,1<<b&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(ri),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(si),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===d.strides[b])throw Error("strides[".concat(b,"] must be non-zero"));const t=!!(d.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}const a=[d.beginMask&1<<b,d.endMask&1<<b],r=[d.strides[b]>0?0:-1,d.strides[b]>0?n:n-1];if(t&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[b];const s=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(t){const e=d.begin[b]<0?n+d.begin[b]:d.begin[b];if(d.begin[b]=e,d.end[b]=d.begin[b]+1,e<0||e>=n)throw Error("slice index ".concat(d.begin[b]," of dimension ").concat(b," out of bounds."))}else d.begin[b]=ki(d.begin[b],0,d.strides[b],n,a,r),d.end[b]=ki(d.end[b],1,d.strides[b],n,a,r);const e=1===d.strides[b]&&0===d.begin[b]&&d.end[b]===n;p=p&&e,f=f&&(0===b&&1===d.strides[b]||e)}else p=p&&1===d.strides[b]&&s,f=f&&(0===b&&1===d.strides[b]||s);let o,i=!1;if(d.beginValid&&d.endValid?(o=d.end[b]-d.begin[b],i=!0):t?(o=1,i=!0):s&&n>=0&&(o=d.strides[b]<0?-n:n,i=!0),i){let e;e=0===o||o<0!==d.strides[b]<0?0:Math.trunc(o/d.strides[b])+(o%d.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const e=d.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===ri&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>d.finalShapeGatherIndices[t]!==ri)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function ki(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{const t=e<0?a+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}const Si=xs({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:bs(e,"x","all","bool")},r={axis:t,keepDims:n};return ls.runKernel(Ve,a,r)}});const Ii=xs({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:bs(e,"x","any","bool")},r={axis:t,keepDims:n};return ls.runKernel(Ue,a,r)}});const Ni=xs({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:bs(e,"x","argMax")},a={axis:t};return ls.runKernel(Ge,n,a)}});function Ti(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return Ri(e,[...t,e[3]],n,s,a,null,null,Bi(r))}function Ei(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,c]=Di(t);let l;if("channelsLast"===o)l=[i,c,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));l=[i,c,e[1],e[1]]}return Ri(e,l,n,a,r,s,!1,o)}function Ci(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,c,l]=Fi(t);let u,h;if("NDHWC"===o)h="channelsLast",u=[i,c,l,e[4],e[4]];else{if("NCDHW"!==o)throw new Error("Unknown dataFormat ".concat(o));h="channelsFirst",u=[i,c,l,e[1],e[1]]}return Ai(e,u,n,a,r,!1,h,s)}function Ri(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,h]=[-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,h]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,h,l,u]=e}const[d,p,,f]=t,[m,g]=Di(n),[y,b]=Di(a),v=Oi(d,y),x=Oi(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,a,r,s,o,i,c){let l,u,h;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,a,r){null==a&&(a=_i(e,t,n));const s=e[0],o=e[1],i=Mi((s-t+2*a)/n+1,r),c=Mi((o-t+2*a)/n+1,r);return[i,c]}([t,n],s,a,e,i);u=r[0],h=r[1]}else if("same"===e){u=Math.ceil(t/a),h=Math.ceil(n/r);const e=Math.max(0,(u-1)*a+s-t),i=Math.max(0,(h-1)*r+o-n),c=Math.floor(e/2),d=e-c,p=Math.floor(i/2);l={top:c,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-s+1)/a),h=Math.ceil((n-o+1)/r);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const d="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],m="channelsLast"===c?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=Mi((t-s+d+p)/a+1,i),h=Mi((n-o+f+m)/r+1,i)}}return{padInfo:l,outHeight:u,outWidth:h}}(r,l,u,m,g,v,x,s,i),I=o?f*h:f;let N;return"channelsFirst"===i?N=[c,I,k,S]:"channelsLast"===i&&(N=[c,k,S,I]),{batchSize:c,dataFormat:i,inHeight:l,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:e,outShape:N,filterShape:t}}function Ai(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[c,l,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[c,l,u,h,d]=e;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));[c,d,l,u,h]=e}const[p,f,m,,g]=t,[y,b,v]=Fi(n),[x,w,k]=Fi(a),S=Oi(p,x),I=Oi(f,w),N=Oi(m,k),{padInfo:T,outDepth:E,outHeight:C,outWidth:R}=function(e,t,n,a,r,s,o,i,c,l,u){let h,d,p,f;"valid"===e&&(e=0);if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const m=function(e,t,n,a,r,s){null==r&&(r=_i(e,t[0],a[0]));const o=[0,0,0,n];for(let i=0;i<3;i++)e[i]+2*r>=t[i]&&(o[i]=Mi((e[i]-t[i]+2*r)/a[i]+1,s));return o}([t,n,a,1],[i,c,l],1,[r,s,o],e,u);d=m[0],p=m[1],f=m[2]}else{if("same"!==e)throw Error("Unknown padding parameter: ".concat(e));{d=Math.ceil(t/r),p=Math.ceil(n/s),f=Math.ceil(a/o);const e=(d-1)*r+i-t,u=(p-1)*s+c-n,m=(f-1)*o+l-a,g=Math.floor(e/2),y=e-g,b=Math.floor(u/2),v=u-b,x=Math.floor(m/2);h={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,l,u,h,y,b,v,S,I,N,i),A=s?g*d:g;let _;return"channelsFirst"===o?_=[c,A,E,C,R]:"channelsLast"===o&&(_=[c,E,C,R,A]),{batchSize:c,dataFormat:o,inDepth:l,inHeight:u,inWidth:h,inChannels:d,outDepth:E,outHeight:C,outWidth:R,outChannels:A,padInfo:T,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:_,filterShape:t}}function _i(e,t,n){const a=Oi(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+a)/2)}function Di(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function Fi(e){return"number"===typeof e?[e,e,e]:e}function Oi(e,t){return t<=1?e:e+(e-1)*(t-1)}function Mi(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function Li(e){const[t,n,a]=Di(e);return 1===t&&1===n&&1===a}function zi(e,t){return Li(e)||Li(t)}function Pi(e){return Di(e).every((e=>e>0))}function Bi(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function Wi(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)J(ne(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach((t=>{t.forEach((t=>{J(ne(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")))}))}))}}}const Vi=xs({reshape_:function(e,t){const n={x:bs(e,"x","reshape","string_or_numeric")},a={shape:t};return ls.runKernel(Xn,n,a)}});const Ui=xs({avgPool_:function(e,t,n,a,r){const s=bs(e,"x","avgPool","float32");J(zi(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let o=s,i=!1;3===s.rank&&(i=!0,o=Vi(s,[1,s.shape[0],s.shape[1],s.shape[2]])),J(4===o.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(o.rank,"."))),Wi("avgPool",a,r);const c={x:o},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let u=ls.runKernel(Qe,c,l);return u=yo(u,s.dtype),i?Vi(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Gi=xs({avgPool3d_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=bs(e,"x","avgPool3d","float32");let i=o,c=!1;4===o.rank&&(c=!0,i=Vi(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),J("NDHWC"===s,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),J("number"===typeof n&&n>0||Array.isArray(n)&&n[0]>0&&n[1]>0&&n[2]>0,(()=>"Error in avgPool3d: Stride must be > 0, but got '".concat(n,"'"))),Wi("avgPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s};let h=ls.runKernel(Ze,l,u);return h=yo(h,i.dtype),c?Vi(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Hi=xs({batchNorm_:function(e,t,n,a,r,s){null==s&&(s=.001);const o=bs(e,"x","batchNorm"),i=bs(t,"mean","batchNorm"),c=bs(n,"variance","batchNorm");let l,u;null!=r&&(l=bs(r,"scale","batchNorm")),null!=a&&(u=bs(a,"offset","batchNorm")),J(i.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),J(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),J(null==l||i.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(e){let t;return t=0===e.rank||1===e.rank?Vi(e,[1,1,1,e.size]):2===e.rank?Vi(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?Vi(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(o),scale:l,offset:u,mean:i,variance:c},d={varianceEpsilon:s},p=ls.runKernel(Kt,h,d);return Vi(p,o.shape)}});const ji=xs({batchNorm2d_:function(e,t,n,a,r,s){const o=bs(e,"x","batchNorm"),i=bs(t,"mean","batchNorm"),c=bs(n,"variance","batchNorm");let l,u;return null!=r&&(l=bs(r,"scale","batchNorm")),null!=a&&(u=bs(a,"offset","batchNorm")),J(2===o.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(o.rank,"."))),J(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),J(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&J(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&J(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),Hi(o,i,c,u,l,s)}});const Ki=xs({batchNorm3d_:function(e,t,n,a,r,s){const o=bs(e,"x","batchNorm"),i=bs(t,"mean","batchNorm"),c=bs(n,"variance","batchNorm");let l,u;return null!=r&&(l=bs(r,"scale","batchNorm")),null!=a&&(u=bs(a,"offset","batchNorm")),J(3===o.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(o.rank,"."))),J(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),J(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&J(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&J(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),Hi(o,i,c,u,l,s)}});const qi=xs({batchNorm4d_:function(e,t,n,a,r,s){const o=bs(e,"x","batchNorm"),i=bs(t,"mean","batchNorm"),c=bs(n,"variance","batchNorm");let l,u;return null!=r&&(l=bs(r,"scale","batchNorm")),null!=a&&(u=bs(a,"offset","batchNorm")),J(4===o.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(o.rank,"."))),J(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),J(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&J(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&J(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),Hi(o,i,c,u,l,s)}});const Xi=xs({broadcastTo_:function(e,t){let n=bs(e,"broadcastTo","x");const a=n.shape;if(Ie(t),t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=Vi(n,e)}const r=n.shape,s=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])s[c]=1;else if(1!==n.shape[c])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return bo(n);const o={x:n},i={reps:s};return ls.runKernel(Oa,o,i)}});const Yi=xs({clipByValue_:function(e,t,n){const a=bs(e,"x","clipByValue");if(J(t<=n,(()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,")."))),t===n)return Mo(a.shape,t,a.dtype);const r={x:a},s={clipValueMin:t,clipValueMax:n};return ls.runKernel(it,r,s)}});const Qi=xs({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;J(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=vs(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))})),1===n.length)return bo(n[0]);const a=n,r={axis:t};return ls.runKernel(ut,a,r)}});const Ji=xs({concat1d_:function(e){return Qi(e,0)}});const Zi=xs({concat2d_:function(e,t){return Qi(e,t)}});const $i=xs({concat3d_:function(e,t){return Qi(e,t)}});const ec=xs({concat4d_:function(e,t){return Qi(e,t)}});const tc=xs({conv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=bs(e,"x","conv2d","float32"),c=bs(t,"filter","conv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=Vi(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J(4===l.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,"."))),J(4===c.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(c.rank,"."))),Wi("conv2d",a,o);const h="NHWC"===r?l.shape[3]:l.shape[1];J(h===c.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(c.shape[2],"."))),J(zi(n,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),J(Pi(s),(()=>"Error in conv2D: Dilated rates should be larger than 0.")),J(Pi(n),(()=>"Error in conv2D: Strides should be larger than 0."));const d={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o},f=ls.runKernel(ht,d,p);return u?Vi(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const nc=xs({conv1d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0;const i=bs(e,"x","conv1d"),c=bs(t,"filter","conv1d");let l=i,u=!1;2===i.rank&&(u=!0,l=Vi(i,[1,i.shape[0],i.shape[1]])),J(3===l.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,"."))),J(3===c.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(c.rank,"."))),Wi("conv1d",a,o),J(l.shape[2]===c.shape[1],(()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match ")+"input depth for filter ".concat(c.shape[1],"."))),J(zi(n,s),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(s,"'"))),J(Pi(s),(()=>"Error in conv1D: Dilated rates should be larger than 0.")),J(Pi(n),(()=>"Error in conv1D: Stride should be larger than 0.")),J("NWC"===r,(()=>"Error in conv1d: got dataFormat of ".concat(r," but only NWC is currently supported.")));const h=Vi(c,[1,c.shape[0],c.shape[1],c.shape[2]]),d=Vi(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=tc(d,h,[1,n],a,"NHWC",[1,s],o);return Vi(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const ac=xs({conv2DBackpropInput_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0;J(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let i=e,c=t,l=!1;3===t.rank&&(l=!0,c=Vi(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),J(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),J(4===c.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(c.rank))),J(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===s?i[3]:i[1],h="NHWC"===s?c.shape[3]:c.shape[1];J(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),J(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),Wi("conv2dDerInput",r,o);const d={dy:c,filter:n},p={strides:a,pad:r,dataFormat:s,dimRoundingMode:o,inputShape:i},f=ls.runKernel(pt,d,p);return l?Vi(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const rc=xs({conv2dTranspose_:function(e,t,n,a,r,s){const o=bs(e,"x","conv2dTranspose"),i=bs(t,"filter","conv2dTranspose");return ac(n,o,i,a,r,"NHWC",s)}});const sc=xs({conv3d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const o=bs(e,"x","conv3d"),i=bs(t,"filter","conv3d");let c=o,l=!1;4===o.rank&&(l=!0,c=Vi(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(5===c.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,"."))),J(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),J(c.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),J(zi(n,s),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),J("NDHWC"===r,(()=>"Error in conv3d: got dataFormat of ".concat(r," but only NDHWC is currently supported."))),J(Pi(s),(()=>"Error in conv3D: Dilated rates should be larger than 0.")),J(Pi(n),(()=>"Error in conv3D: Strides should be larger than 0."));const u={x:c,filter:i},h={strides:n,pad:a,dataFormat:r,dilations:s},d=ls.runKernel(ft,u,h);return l?Vi(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const oc=xs({conv3DBackpropInput_:function(e,t,n,a,r){J(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let s=e,o=t,i=!1;4===t.rank&&(i=!0,o=Vi(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);const c=s[4],l=o.shape[4];J(5===s.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(s.length,"."))),J(5===o.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(o.rank))),J(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),J(c===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(c,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),J(l===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(l,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:o,filter:n},h={pad:r,strides:a,inputShape:s},d=ls.runKernel(gt,u,h);return i?Vi(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const ic=xs({conv3dTranspose_:function(e,t,n,a,r){const s=bs(e,"x","conv3dTranspose"),o=bs(t,"filter","conv3dTranspose");return oc(n,s,o,a,r)}});const cc=xs({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=bs(e,"x","denseBincount"),s=bs(t,"weights","denseBincount");J("int32"===r.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(r.dtype))),J(r.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(r.rank,"."))),J(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),J(s.size===r.size||0===s.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(r.shape,", weights shape: ")+"".concat(s.shape,".")));const o={x:r,weights:s},i={size:n,binaryOutput:a};return ls.runKernel(kt,o,i)}});const lc=xs({depthwiseConv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=bs(e,"x","depthwiseConv2d","float32"),c=bs(t,"filter","depthwiseConv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=Vi(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J(4===l.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,"."))),J(4===c.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(c.rank,".")));const h="NHWC"===r?l.shape[3]:l.shape[1];J(h===c.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(c.shape[2],"."))),Wi("depthwiseConv2d",a,o);const d={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o},f=ls.runKernel(It,d,p);return u?Vi(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const uc=xs({elu_:function(e){const t={x:bs(e,"x","elu","float32")};return ls.runKernel(Ot,t)}});const hc=xs({equal_:function(e,t){let n=bs(e,"a","equal","string_or_numeric"),a=bs(t,"b","equal","string_or_numeric");[n,a]=ts(n,a),Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(zt,r)}});const dc=xs({erf_:function(e){let t=bs(e,"x","erf");J("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=yo(t,"float32"));const n={x:t};return ls.runKernel(Lt,n)}});const pc=xs({exp_:function(e){const t={x:bs(e,"x","exp")};return ls.runKernel(Pt,t)}});const fc=xs({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=bs(e,"x","expandDims","string_or_numeric");J(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const a={input:n},r={dim:t};return ls.runKernel(Bt,a,r)}});const mc=xs({tile_:function(e,t){const n=bs(e,"x","tile","string_or_numeric");J(n.rank===t.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,".")));const a={x:n},r={reps:t};return ls.runKernel(Oa,a,r)}});const gc=xs({eye_:function(e,t,n){null==t&&(t=e);const a=go([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),r=e<=t?e:t;for(let o=0;o<r;++o)a.set(1,o,o);const s=Vi(a.toTensor(),[e,t]);if(null==n)return s;if(1===n.length)return mc(fc(s,0),[n[0],1,1]);if(2===n.length)return mc(fc(fc(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return mc(fc(fc(fc(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const yc=xs({floor_:function(e){const t={x:bs(e,"x","floor","float32")};return ls.runKernel(Ht,t)}});const bc=xs({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r={x:bs(e,"x","gather"),indices:bs(t,"indices","gather","int32")},s={axis:n,batchDims:a};return ls.runKernel(qt,r,s)}});const vc=xs({greater_:function(e,t){let n=bs(e,"a","greater","string_or_numeric"),a=bs(t,"b","greater","string_or_numeric");[n,a]=ts(n,a),Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(Yt,r)}});const xc=xs({greaterEqual_:function(e,t){let n=bs(e,"a","greaterEqual","string_or_numeric"),a=bs(t,"b","greaterEqual","string_or_numeric");[n,a]=ts(n,a),Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(Qt,r)}});const wc=xs({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:bs(e,"x","leakyRelu")},a={alpha:t};return ls.runKernel(an,n,a)}});const kc=xs({log_:function(e){const t={x:bs(e,"x","log","float32")};return ls.runKernel(cn,t)}});const Sc=xs({log1p_:function(e){const t={x:bs(e,"x","log1p")};return ls.runKernel(ln,t)}});const Ic=xs({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:bs(e,"x","max")},r={reductionIndices:t,keepDims:n};return ls.runKernel(mn,a,r)}});const Nc=xs({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=bs(e,"x","sum");"bool"===a.dtype&&(a=yo(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return ls.runKernel(ma,r,s)}});const Tc=xs({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=bs(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const a=To(((e,n)=>{const a=Ic(e,t,!0),r=Po(e,a),s=Po(yo(r,"float32"),kc(Nc(pc(r),t,!0)));n([s]);return{value:s,gradFunc:(e,n)=>{const[a]=n,r=pc(a);return Po(e,ko(Nc(e,t,!0),r))}}}));return a(n)}});function Ec(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function Cc(e,t,n){const a=e.length+t.length,r=[];let s=0,o=0;for(let i=0;i<a;i++)-1===n.indexOf(i)?r.push(e[s++]):r.push(t[o++]);return r}function Rc(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function Ac(e,t){return Cc(e,t.map((e=>1)),t)}function _c(e,t,n){J(Ec(t,n),(()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input.")))}function Dc(e,t){if(Ec(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach((e=>n.push(e))),n}function Fc(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function Oc(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const Mc=xs({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=bs(e,"x","logSumExp"),r=ie(t,a.shape),s=Ic(a,r,!0),o=Po(a,s),i=pc(o),c=Nc(i,r),l=kc(c),u=vo(Vi(s,l.shape),l);if(n){const e=Ac(u.shape,r);return Vi(u,e)}return u}});const Lc=xs({logicalAnd_:function(e,t){const n=bs(e,"a","logicalAnd","bool"),a=bs(t,"b","logicalAnd","bool");Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(un,r)}});const zc=xs({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=bs(e,"a","matMul"),s=bs(t,"b","matMul");[r,s]=ts(r,s);const o={a:r,b:s},i={transposeA:n,transposeB:a};return ls.runKernel(et,o,i)}});const Pc=xs({maxPool_:function(e,t,n,a,r){const s=bs(e,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=Vi(s,[1,s.shape[0],s.shape[1],s.shape[2]])),J(4===o.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(o.rank,"."))),J(zi(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),Wi("maxPool",a,r);const c={x:o},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r},u=ls.runKernel(yn,c,l);return i?Vi(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const Bc=xs({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=bs(e,"x","maxPool3d");let i=o,c=!1;4===o.rank&&(c=!0,i=Vi(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),J(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),J("NDHWC"===s,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),Wi("maxPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},h=ls.runKernel(vn,l,u);return c?Vi(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const Wc=xs({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:bs(e,"x","mean")},r={axis:t,keepDims:n};return ls.runKernel(kn,a,r)}});const Vc=xs({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:bs(e,"x","min")},r={axis:t,keepDims:n};return ls.runKernel(Sn,a,r)}});const Uc=xs({minimum_:function(e,t){let n=bs(e,"a","minimum"),a=bs(t,"b","minimum");[n,a]=ts(n,a),"bool"===n.dtype&&(n=yo(n,"int32"),a=yo(a,"int32")),Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(In,r)}});const Gc=xs({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=ie(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=bs(e,"x","moments")).shape),a=Wc(e,n,t);let r=a.shape;t||(r=Ac(a.shape,n));const s=Io(Po(yo(e,"float32"),Vi(a,r)));return{mean:a,variance:Wc(s,n,t)}}});const Hc=xs({neg_:function(e){const t={x:bs(e,"x","neg")};return ls.runKernel(Rn,t)}});const jc=xs({notEqual_:function(e,t){let n=bs(e,"a","notEqual","string_or_numeric"),a=bs(t,"b","notEqual","string_or_numeric");[n,a]=ts(n,a),Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(An,r)}});const Kc=xs({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const s={indices:bs(e,"indices","oneHot","int32")},o={dtype:r,depth:t,onValue:n,offValue:a};return ls.runKernel(Mn,s,o)}});function qc(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Ie(e),"complex64"===t){const t=qc(e,"float32"),n=qc(e,"float32");return ws(t,n)}const n=ke(ee(e),t);return ls.makeTensor(n,e,t)}function Xc(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if(Ie(e),"complex64"===t){const t=Xc(e,"float32"),n=qc(e,"float32");return ws(t,n)}const n=we(ee(e),t);return ls.makeTensor(n,e,t)}const Yc=xs({onesLike_:function(e){const t={x:bs(e,"x","onesLike")};return ls.runKernel(On,t)}});const Qc=xs({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=bs(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},s={x:a};return ls.runKernel(zn,s,r)}});const Jc=xs({prelu_:function(e,t){const n={x:bs(e,"x","prelu"),alpha:bs(t,"alpha","prelu")};return ls.runKernel(Bn,n)}});var Zc=n(334);class $c{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=r||Math.random();this.random=Zc.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,s;do{a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*o,t=this.mean+this.stdDev*r*o,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class el{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=Zc.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const tl=xs({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(Ie(e),null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const s=new $c(t,n,a,!1,r),o=go(e,a);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const nl=xs({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;Ie(e);const s=go(e,a),o=new el(t,n,null,r);for(let i=0;i<s.values.length;i++)s.values[i]=o.nextValue();return s.toTensor()}});function al(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return ls.runKernel(Hn,{},r)}const rl=xs({relu_:function(e){const t={x:bs(e,"x","relu")};return ls.runKernel(qn,t)}});const sl=xs({reverse_:function(e,t){const n={x:bs(e,"x","reverse")},a={dims:t};return ls.runKernel(ea,n,a)}});const ol=xs({selu_:function(e){const t={x:bs(e,"x","selu")};return ls.runKernel(ia,t)}});const il=xs({separableConv2d_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=bs(e,"x","separableConv2d"),c=bs(t,"depthwiseFilter","separableConv2d"),l=bs(n,"pointwiseFilter","separableConv2d");let u=i,h=!1;if(3===i.rank&&(h=!0,u=Vi(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");J(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),J(4===c.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),J(4===l.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),J(1===l.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(l.shape[0],"."))),J(1===l.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(l.shape[1],".")));const d=c.shape[2],p=c.shape[3];J(l.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(l.shape[2],".")));const f=lc(u,c,a,r,o,s),m=tc(f,l,1,"valid",o);return h?Vi(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const cl=xs({sigmoid_:function(e){const t={x:bs(e,"x","sigmoid","float32")};return ls.runKernel(da,t)}});const ll=xs({slice_:function(e,t,n){const a=bs(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const r={x:a},s={begin:t,size:n};return ls.runKernel(ca,r,s)}});const ul=xs({slice1d_:function(e,t,n){const a=bs(e,"x","slice1d");return J(1===a.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor"))),ll(a,[t],[n])}});const hl=xs({slice2d_:function(e,t,n){const a=bs(e,"x","slice2d");return J(2===a.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor"))),ll(a,t,n)}});const dl=xs({slice3d_:function(e,t,n){const a=bs(e,"x","slice3d");return J(3===a.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor"))),ll(a,t,n)}});const pl=xs({slice4d_:function(e,t,n){const a=bs(e,"x","slice4d");return J(4===a.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor"))),ll(a,t,n)}});const fl=xs({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=bs(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const a={logits:n},r={dim:t};return ls.runKernel(ba,a,r)}});const ml=xs({softplus_:function(e){const t={x:bs(e,"x","softplus")};return ls.runKernel(pa,t)}});const gl=xs({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a={x:bs(e,"x","split")},r={numOrSizeSplits:t,axis:n};return ls.runKernel(ya,a,r)}});const yl=xs({squeeze_:function(e,t){const n=bs(e,"x","squeeze","string_or_numeric");return Vi(n,ce(n.shape,t).newShape)}});const bl=xs({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=vs(e,"tensors","stack","string_or_numeric");J(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&J(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const a=n,r={axis:t};return ls.runKernel(Ln,a,r)}});const vl=xs({tanh_:function(e){const t={x:bs(e,"x","tanh","float32")};return ls.runKernel(Fa,t)}});function xl(e,t){$(e);const n=ms(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return ks(e,null,n,t)}function wl(e,t,n){if($(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=ms(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return ks(e,t,a,n)}const kl=xs({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(Ie(e),null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const s=new $c(t,n,a,!0,r),o=go(e,a);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const Sl=xs({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=bs(e,"x","unstack","string_or_numeric");J(t>=-n.shape.length&&t<n.shape.length,(()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const a={value:n},r={axis:t};return ls.runKernel(Ba,a,r)}});const Il=xs({where_:function(e,t,n){const a=bs(t,"a","where"),r=bs(n,"b","where"),s=bs(e,"condition","where","bool"),o=Go(Go(s.shape,a.shape),r.shape),i={condition:Xi(s,o),t:Xi(a,o),e:Xi(r,o)};return ls.runKernel(oa,i)}});const Nl=xs({imag_:function(e){const t={input:bs(e,"input","imag")};return ls.runKernel($t,t)}});const Tl=xs({real_:function(e){const t={input:bs(e,"input","real")};return ls.runKernel(jn,t)}});const El=xs({transpose_:function(e,t,n){const a=bs(e,"x","transpose");if(null==t&&(t=a.shape.map(((e,t)=>t)).reverse()),J(a.rank===t.length,(()=>"Error in transpose: rank of input ".concat(a.rank," ")+"must match length of perm ".concat(t,"."))),t.forEach((e=>{J(e>=0&&e<a.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1)+" but got ".concat(t)))})),a.rank<=1)return a.clone();const r={x:a},s={perm:t};return"complex64"===a.dtype?Es((()=>{let e=Tl(a),t=Nl(a);return e=ls.runKernel(za,{x:e},s),t=ls.runKernel(za,{x:t},s),n&&(t=Hc(t)),ws(e,t)})):ls.runKernel(za,r,s)}});const Cl=xs({dropout_:function(e,t,n,a){const r=bs(e,"x","dropout");if(J("float32"===r.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(r.dtype," tensor instead."))),J(t>=0&&t<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(t,"."))),0===t)return e instanceof Ur?r.clone():r;const s=function(e,t){if(null==t)return e.shape.slice();if(te(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(r,n),o=1-t,i=wo(yc(vo(nl(s,0,1,"float32",a),o)),o);return ko(r,i)}});const Rl=xs({fft_:function(e){J("complex64"===e.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return ls.runKernel(Vt,t)}});const Al=xs({rfft_:function(e,t){J("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(e.dtype)));let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(null!=t&&t<n){const a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,r=ll(e,a,s),n=t}else if(null!=t&&t>n){const a=e.shape.map((e=>e));a[e.shape.length-1]=t-n,r=Qi([e,qc(a)],e.shape.length-1),n=t}else r=e;const s=No(r),o=Vi(ws(r,s),[a,n]),i=Rl(o),c=Math.floor(n/2)+1,l=Tl(i),u=Nl(i),h=gl(l,[c,n-c],l.shape.length-1),d=gl(u,[c,n-c],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=c,Vi(ws(h[0],d[0]),p)}});const _l=xs({ifft_:function(e){J("complex64"===e.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return ls.runKernel(Zt,t)}});const Dl=xs({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=Vi(e,[n,t]);a=_l(r)}else{const r=[n,2*(t-1)],s=Vi(Tl(e),[n,t]),o=Vi(Nl(e),[n,t]),i=sl(ll(s,[0,1],[n,t-2]),1),c=ko(sl(ll(o,[0,1],[n,t-2]),1),Eo(-1)),l=Qi([s,i],1),u=Qi([o,c],1),h=Vi(ws(l,u),[r[0],r[1]]);a=_l(h)}if(a=Tl(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=Vi(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});const Fl=xs({conv2DBackpropFilter_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=Vi(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=Vi(t,[1,t.shape[0],t.shape[1],t.shape[2]])),J(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),J(4===c.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(c.shape,"."))),J(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const l="NHWC"===s?i.shape[3]:i.shape[1],u="NHWC"===s?c.shape[3]:c.shape[1];J(l===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must ")+"match input depth in filter (".concat(n[2],"."))),J(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),Wi("conv2dDerFilter",r,o);const h={x:i,dy:c},d={strides:a,pad:r,dataFormat:s,dimRoundingMode:o,filterShape:n};return ls.runKernel(dt,h,d)}});const Ol=xs({relu6_:function(e){const t={x:bs(e,"x","relu6")};return ls.runKernel($n,t)}});const Ml=xs({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:bs(e,"x","step")},a={alpha:t};return ls.runKernel(Ua,n,a)}});function Ll(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return ko(e,Ml(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function zl(e,t){let n=t;const a=Uo(e.shape,t.shape);return a.length>0&&(n=Nc(n,a)),Vi(n,e.shape)}function Pl(e,t,n,a){if("linear"===t)return e;if("relu"===t)return rl(e);if("elu"===t)return uc(e);if("relu6"===t)return Ol(e);if("prelu"===t)return Jc(e,n);if("leakyrelu"===t)return wc(e,a);if("sigmoid"===t)return cl(e);throw new Error("Unknown fused activation ".concat(t,"."))}const Bl=(e,t)=>!(e>0)||"linear"===t;const Wl=xs({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}=e;if(l=l||"linear",!1===Bl(ls.state.gradientDepth,l)){J("NHWC"===s,(()=>"Error in fused conv2d: got dataFormat of ".concat(s," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=tc(t,n,a,r,s,o,i);return null!=c&&(e=vo(e,c)),Pl(e,l,u,h)}const d=bs(t,"x","conv2d","float32"),p=bs(n,"filter","conv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=Vi(d,[1,d.shape[0],d.shape[1],d.shape[2]])),J(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),J(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),Wi("fused conv2d",r,i);const g="NHWC"===s?f.shape[3]:f.shape[1];J(p.shape[2]===g,(()=>"Error in conv2d: depth of input (".concat(g,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),J(zi(a,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(o,"'")));const y=Ri(f.shape,p.shape,a,o,r,i);let b,v;if(null!=c&&(b=bs(c,"bias","fused conv2d"),[b]=ts(b,d),"NHWC"===s?Go(y.outShape,b.shape):(J(b.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(b.shape.length,"."))),J(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(b.shape,") is not ")+"compatible with the number of output channels "+"(".concat(y.outChannels,")"))))),null!=u){const e=u.shape;if(J(e.length<=1||3===e.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,"."))),1===e.length)J(1===e[0]||e[0]===y.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(y.outChannels,").")));else if(3===e.length)try{Go(e,y.outShape)}catch(S){const t="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(y.outShape,").");throw Error(t)}v=bs(u,"prelu weights","fused conv2d")}const x=(e,t)=>{J("NHWC"===s,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported.")));const[n,i,c,u]=t,h=Ll(e,c,l);J(Li(o),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'")));const d=[ac(i.shape,h,n,a,r),Fl(i,h,n.shape,a,r)];if(null!=u){const e=zl(u,h);d.push(e)}return d},w={x:f,filter:p,bias:b,preluActivationWeights:v},k={strides:a,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:h};if(null==c){const e=To(((e,t,n)=>{let a=ls.runKernel(Ka,w,k);return n([t,e,a]),m&&(a=Vi(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}));return e(f,p)}{const e=To(((e,t,n,a)=>{let r=ls.runKernel(Ka,w,k);return a([t,e,r,n]),m&&(r=Vi(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p,b)}}});const Vl=xs({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=Vi(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=Vi(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:i,dy:c},u={strides:a,pad:r,dimRoundingMode:o,dilations:s,filterShape:n};return ls.runKernel(Nt,l,u)}});const Ul=xs({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=t,c=!1;3===t.rank&&(c=!0,i=Vi(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:i,filter:n},u={strides:a,pad:r,dimRoundingMode:o,dilations:s,inputShape:e},h=ls.runKernel(Tt,l,u);return c?Vi(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const Gl=xs({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:c=.2}=e;if(!1===Bl(ls.state.gradientDepth,o)){let e=zc(t,n,a,r);return null!=s&&(e=vo(e,s)),Pl(e,o,i,c)}let l=bs(t,"a","fused matMul"),u=bs(n,"b","fused matMul");[l,u]=ts(l,u);const h=a?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),y=ee(m),b=ee(g);J(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(l.shape," and ")+"".concat(u.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const v=Go(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),x=Vi(l,a?[y,h,p]:[y,p,h]),w=Vi(u,r?[b,f,d]:[b,d,f]);let k,S;null!=s&&(k=bs(s,"bias","fused matMul"),[k]=ts(k,l),Go(v,k.shape)),null!=i&&(S=bs(i,"prelu weights","fused matMul"));const I=(e,t)=>{const[n,i,c,l]=t,u=Ll(Vi(e,c.shape),c,o);let h,d;if(a||r?!a&&r?(h=zc(u,i,!1,!1),d=zc(u,n,!0,!1)):a&&!r?(h=zc(i,u,!1,!0),d=zc(n,u,!1,!1)):(h=zc(i,u,!0,!0),d=zc(u,n,!0,!0)):(h=zc(u,i,!1,!0),d=zc(n,u,!0,!1)),null!=s){return[h,d,zl(l,u)]}return[h,d]},N={a:x,b:w,bias:k,preluActivationWeights:S},T={transposeA:a,transposeB:r,activation:o,leakyreluAlpha:c};if(null==s){const e=To(((e,t,n)=>{const a=ls.runKernel(ja,N,T);return n([e,t,a]),{value:Vi(a,v),gradFunc:I}}));return e(x,w)}{const e=To(((e,t,n,a)=>{const r=ls.runKernel(ja,N,T);return a([e,t,r,n]),{value:Vi(r,v),gradFunc:I}}));return e(x,w,k)}}});const Hl=xs({cropAndResize_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=bs(e,"image","cropAndResize"),i=bs(t,"boxes","cropAndResize","float32"),c=bs(n,"boxInd","cropAndResize","int32"),l=i.shape[0];J(4===o.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),J(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] ")+"but had shape ".concat(i.shape,"."))),J(1===c.rank&&c.shape[0]===l,(()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] ")+"but had shape ".concat(i.shape,"."))),J(2===a.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,"."))),J(a[0]>=1&&a[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(a))),J("bilinear"===r||"nearest"===r,(()=>"method must be bilinear or nearest, but was ".concat(r)));const u={image:o,boxes:i,boxInd:c},h={method:r,extrapolationValue:s,cropSize:a};return ls.runKernel(wt,u,h)}});const jl=xs({flipLeftRight_:function(e){const t=bs(e,"image","flipLeftRight","float32");J(4===t.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,".")));const n={image:t};return ls.runKernel(Gt,n,{})}});const Kl=xs({grayscaleToRGB_:function(e){const t=bs(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];J(t.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),J(1===a,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,".")));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,mc(t,r)}});const ql=xs({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r=n.map(((e,t)=>bs(e,"tensors".concat(t),"einsum"))),s={equation:e};return ls.runKernel(Ft,r,s)}});const Xl=xs({rgbToGrayscale_:function(e){const t=bs(e,"image","RGBToGrayscale"),n=t.rank-1,a=t.shape[n];J(t.rank>=2,(()=>"Error in RGBToGrayscale: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),J(3===a,(()=>"Error in RGBToGrayscale: last dimension of an RGB image "+"should be size 3, but got size ".concat(a,".")));const r=t.dtype,s=yo(t,"float32"),o=xl([.2989,.587,.114]);let i;switch(t.rank){case 2:i=ql("ij,j->i",s,o);break;case 3:i=ql("ijk,k->ij",s,o);break;case 4:i=ql("ijkl,l->ijk",s,o);break;case 5:i=ql("ijklm,m->ijkl",s,o);break;case 6:i=ql("ijklmn,n->ijklm",s,o);break;default:throw new Error("Not a valid tensor rank.")}return i=fc(i,-1),yo(i,r)}});const Yl=xs({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=bs(e,"image","rotateWithOffset","float32");J(4===r.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(r.rank,".")));const s={image:r},o={radians:t,fillValue:n,center:a};return ls.runKernel(Ha,s,o)}});function Ql(e,t,n,a,r,s){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=e.shape[0];return n=Math.min(n,o),J(0<=a&&a<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'"))),J(2===e.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'"))),J(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]))),J(1===t.rank,(()=>"scores must be a 1D tensor")),J(t.shape[0]===o,(()=>"scores has incompatible shape with boxes. Expected ".concat(o,", ")+"but was ".concat(t.shape[0]))),J(0<=s&&s<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'"))),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}const Jl=xs({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=bs(e,"boxes","nonMaxSuppression","float32"),o=bs(t,"scores","nonMaxSuppression","float32"),i=Ql(s,o,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return ls.runKernel(_n,{boxes:s,scores:o},c)}});function Zl(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,s=0,o=!1;for(;a<r;){s=a+(r-a>>>1);const i=n(t,e[s]);i>0?a=s+1:(r=s,o=!i)}return o?a:-a-1}(e,t,n||$l)}(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function $l(e,t){return e>t?1:e<t?-1:0}function eu(e,t,n,a,r){return au(e,t,n,a,r,0)}function tu(e,t,n,a,r,s){return au(e,t,n,a,r,0,!1,s,!0)}function nu(e,t,n,a,r,s){return au(e,t,n,a,r,s,!0)}function au(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let g=0;g<t.length;g++)t[g]>r&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(ou);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=t;if(n<r)break;let i=!1;for(let c=h.length-1;c>=o;--c){const n=ru(e,s,h[c]);if(n>=a){i=!0;break}if(t.score=t.score*su(a,u,n),t.score<=r)break}t.suppressBeginIndex=h.length,i||(t.score===n?(h.push(s),d.push(t.score)):t.score>r&&Zl(l,t,ou))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=d),c&&(m.validOutputs=p),m}function ru(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),s=Math.min(a[0],a[2]),o=Math.min(a[1],a[3]),i=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(i-s)*(c-o),f=(h-l)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(s,l),g=Math.max(o,u),y=Math.min(i,h),b=Math.min(c,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function su(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function ou(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const iu=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=bs(e,"boxes","nonMaxSuppressionAsync"),o=bs(t,"scores","nonMaxSuppressionAsync"),i=Ql(s,o,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c=await Promise.all([s.data(),o.data()]),l=c[0],u=c[1],{selectedIndices:h}=eu(l,u,n,a,r);return s!==e&&s.dispose(),o!==t&&o.dispose(),xl(h,"int32")};const cu=xs({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=bs(e,"boxes","nonMaxSuppression"),i=bs(t,"scores","nonMaxSuppression"),c=Ql(o,i,n,a,r,s);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,s=c.softNmsSigma;const l={boxes:o,scores:i},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},h=ls.runKernel(Fn,l,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const lu=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=bs(e,"boxes","nonMaxSuppressionAsync"),i=bs(t,"scores","nonMaxSuppressionAsync"),c=Ql(o,i,n,a,r,s);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,s=c.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),u=l[0],h=l[1],{selectedIndices:d,selectedScores:p}=nu(u,h,n,a,r,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:xl(d,"int32"),selectedScores:xl(p)}};const uu=xs({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=bs(e,"boxes","nonMaxSuppression"),i=bs(t,"scores","nonMaxSuppression"),c=Ql(o,i,n,a,r,null),l={boxes:o,scores:i},u={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:s},h=ls.runKernel(Dn,l,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const hu=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=bs(e,"boxes","nonMaxSuppressionAsync"),i=bs(t,"scores","nonMaxSuppressionAsync"),c=Ql(o,i,n,a,r,null),l=c.maxOutputSize,u=c.iouThreshold,h=c.scoreThreshold,[d,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:m}=tu(d,p,l,u,h,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:xl(f,"int32"),validOutputs:Eo(m,"int32")}};const du=xs({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=bs(e,"images","resizeBilinear");J(3===r.rank||4===r.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),J(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,"."))),J(!1===a||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=Vi(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:s},c={alignCorners:n,halfPixelCenters:a,size:t},l=ls.runKernel(Jn,i,c);return o?Vi(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const pu=xs({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=bs(e,"images","resizeNearestNeighbor");J(3===r.rank||4===r.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),J(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,"."))),J("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),J(!1===a||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=Vi(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:s},c={alignCorners:n,halfPixelCenters:a,size:t},l=ls.runKernel(Yn,i,c);return o?Vi(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const fu=xs({bincount_:function(e,t,n){const a=bs(e,"x","bincount"),r=bs(t,"weights","bincount");J("int32"===a.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype))),J(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),J(r.size===a.size||0===r.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(r.shape,".")));const s={x:a,weights:r},o={size:n};return ls.runKernel(nt,s,o)}});const mu=xs({lessEqual_:function(e,t){let n=bs(e,"a","lessEqual","string_or_numeric"),a=bs(t,"b","lessEqual","string_or_numeric");[n,a]=ts(n,a),Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(sn,r)}});const gu=xs({round_:function(e){const t={x:bs(e,"x","round")};return ls.runKernel(ta,t)}});const yu=xs({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=bs(e,"image","threshold"),s=r.shape[0]*r.shape[1];let o,i,c,l,u=ko(xl([a]),255);if(J(3===r.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(r.rank,"."))),J(3===r.shape[2]||1===r.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(r.shape[2],"."))),J("int32"===r.dtype||"float32"===r.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(r.dtype,"."))),J("otsu"===t||"binary"===t,(()=>"Method must be binary or otsu, but was ".concat(t))),3===r.shape[2]){[o,i,c]=gl(r,[1,1,1],-1);const e=ko(o,.2989),t=ko(i,.587),n=ko(c,.114);l=vo(vo(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,a,r,s,o,i,c=xl([-1]),l=xl([0]),u=xl([0]);for(let h=0;h<e.size-1;h++){n=ll(e,0,h+1),a=ll(e,h+1),o=wo(Nc(n),t),i=wo(Nc(a),t);const d=Nc(ko(n,al(0,n.size)));r=wo(d,Nc(n));const p=Mo(a.shape,n.size),f=vo(al(0,a.size),p),m=ko(a,f);s=wo(Nc(m),Nc(a));const g=Po(r,s),y=Po(r,s),b=ko(o,i);u=ko(ko(b,g),y);const v=vc(u,l);l=Il(v,u,l),c=Il(v,xl([h]),c)}return c}(fu(yo(gu(l),"int32"),Ss([]),256),s)}const h=n?mu(l,u):vc(l,u);return yo(ko(h,255),"int32")}});const bu=xs({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const o=bs(e,"image","transform","float32"),i=bs(t,"transforms","transform","float32");J(4===o.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),J(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),J(null==s||2===s.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(s,".")));const c={image:o,transforms:i},l={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return ls.runKernel(La,c,l)}});const vu=xs({less_:function(e,t){let n=bs(e,"a","less","string_or_numeric"),a=bs(t,"b","less","string_or_numeric");[n,a]=ts(n,a),Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(rn,r)}});const xu=xs({bandPart_:function(e,t,n){const a=bs(e,"a","bandPart");J(a.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,".")));const r=a.shape,[s,o]=a.shape.slice(-2);let i,c;"number"===typeof t?(J(t%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(t,"."))),J(t<=s,(()=>"bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(s,")."))),i=bs(t<0?s:t,"numLower","bandPart")):(J("int32"===t.dtype,(()=>"bandPart(): numLower's dtype must be an int32.")),i=Il(vu(t,0),s,Uc(t,s))),"number"===typeof n?(J(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,"."))),J(n<=o,(()=>"bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(o,")."))),c=bs(n<0?o:n,"numUpper","bandPart")):(J("int32"===n.dtype,(()=>"bandPart(): numUpper's dtype must be an int32.")),c=Il(vu(n,0),o,Uc(n,o)));const l=Vi(al(0,s,1,"int32"),[-1,1]),u=al(0,o,1,"int32"),h=Po(l,u),d=Lc(mu(h,i),xc(h,Hc(c))),p=qc([s,o],a.dtype);return Vi(bl(Sl(Vi(a,[-1,s,o])).map((e=>Il(d,e,p)))),r)}});function wu(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return Wo(e);if(1!==e.rank&&null===n)return wu(Vi(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return Nc(Wo(e),n);if(t===1/0)return Ic(Wo(e),n);if(t===-1/0)return Vc(Wo(e),n);if("euclidean"===t||2===t)return So(Nc(zo(Wo(e),Eo(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return Ic(Nc(Wo(e),n[0]),n[1]-1);if(t===1/0)return Ic(Nc(Wo(e),n[1]),n[0]);if(t===-1/0)return Vc(Nc(Wo(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return So(Nc(Io(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const ku=xs({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=wu(e=bs(e,"x","norm"),t,n);let s=r.shape;if(a){const t=ie(n,e.shape);s=Ac(r.shape,t)}return Vi(r,s)}});const Su=xs({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,J(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)J(e[t].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")")))}else t=!0,e=gl(e,e.shape[0],0).map((e=>yl(e,[0])));J(e.length<=e[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],").")));const n=[],a=e;for(let r=0;r<e.length;++r)n.push(ls.tidy((()=>{let e=a[r];if(r>0)for(let t=0;t<r;++t){const a=ko(Nc(ko(n[t],e)),n[t]);e=Po(e,a)}return wo(e,ku(e,"euclidean"))})));return t?bl(n,0):n}});function Iu(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return ls.tidy((()=>{J(2===e.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor.")));const n=e.shape[0],a=e.shape[1];let r=gc(n),s=bo(e);const o=wl([[1]],[1,1]);let i=bo(o);const c=n>=a?a:n;for(let e=0;e<c;++e){const t=s,c=i,l=r;[i,s,r]=ls.tidy((()=>{const t=ll(s,[e,e],[n-e,1]),c=ku(t),l=ll(s,[e,e],[1,1]),u=Il(vc(l,0),wl([[-1]]),wl([[1]])),h=Po(l,ko(u,c)),d=wo(t,h);i=1===d.shape[0]?bo(o):Qi([o,ll(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=Hc(wo(zc(u,h),c)),f=ll(s,[e,0],[n-e,a]),m=ko(p,i),g=El(i);if(0===e)s=Po(f,zc(m,zc(g,f)));else{const t=Po(f,zc(m,zc(g,f)));s=Qi([ll(s,[0,0],[e,a]),t],0)}const y=El(m),b=ll(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=Po(b,zc(zc(b,i),y));else{const t=Po(b,zc(zc(b,i),y));r=Qi([ll(r,[0,0],[n,e]),t],1)}return[i,s,r]})),Cs([t,c,l])}return!t&&n>a&&(r=ll(r,[0,0],[n,a]),s=ll(s,[0,0],[a,a])),[r,s]}))}const Nu=xs({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(J(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank))),2===e.rank)return Iu(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),a=Sl(Vi(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach((e=>{const[n,a]=Iu(e,t);r.push(n),s.push(a)}));return[Vi(bl(r,0),e.shape),Vi(bl(s,0),e.shape)]}}});var Tu;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(Tu||(Tu={}));const Eu=xs({squaredDifference_:function(e,t){let n=bs(e,"a","squaredDifference"),a=bs(t,"b","squaredDifference");[n,a]=ts(n,a),Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(Ia,r,{})}});const Cu={flipLeftRight:jl,grayscaleToRGB:Kl,resizeNearestNeighbor:pu,resizeBilinear:du,rgbToGrayscale:Xl,rotateWithOffset:Yl,cropAndResize:Hl,nonMaxSuppression:Jl,nonMaxSuppressionAsync:iu,nonMaxSuppressionWithScore:cu,nonMaxSuppressionWithScoreAsync:lu,nonMaxSuppressionPadded:uu,nonMaxSuppressionPaddedAsync:hu,threshold:yu,transform:bu},Ru={bandPart:xu,gramSchmidt:Su,qr:Nu};const Au=class{static sgd(e){return new Ko(e)}static momentum(e,t){return new qo(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new Xo(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new Bo(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new Oo(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new jo(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new Lo(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}},_u="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function Du(){return new Promise((e=>_u((()=>e()))))}function Fu(e,t){const n=e[0].length;e.forEach(((e,t)=>{J(e.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),J(t>=0&&t<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const a=e[0];e.forEach(((e,r)=>{for(let s=0;s<n;s++)J(s===t||e[s]===a[s],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(r,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(r,".")))}))}function Ou(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var Mu;function Lu(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let r=1;r<n.length;++r){const s=n[r],o=a[a.length-n.length+r],i=a[o];if(s>=0)if(i>=0){if(i!==s)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(r+e,"] = ").concat(s," but shape[").concat(r+e,"] = ").concat(i))}else a[o]=s}return a}function zu(e){const t={FIRST_DIM_SIZE:Mu.FIRST_DIM_SIZE,VALUE_ROWIDS:Mu.VALUE_ROWIDS,ROW_LENGTHS:Mu.ROW_LENGTHS,ROW_SPLITS:Mu.ROW_SPLITS,ROW_LIMITS:Mu.ROW_LIMITS,ROW_STARTS:Mu.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function Pu(e){return 0===e.length?0:e[0]===Mu.FIRST_DIM_SIZE?e.length-1:e.length}function Bu(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let r=0;r<Math.min(n,a-1);++r){const n=e[r],a=t[r+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(r-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(r-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(Mu||(Mu={}));const Wu=30;function Vu(e){return e<=Wu?e:ye(e,Math.floor(Math.sqrt(e)))}function Uu(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function Gu(e,t,n){let a=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function Hu(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let a=t+1;a<e;++a)a<=2*t?(n.push(a),n.push(a-(t+1))):n.push(a)}else{const a=[],r=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?r.push(n):a.push(n);n.push(...a),n.push(0),n.push(...r)}return n}function ju(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function Ku(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function qu(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}function Xu(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===ee(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const r=t.shape,s=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const i=e.shape,c=r.slice();c.pop();let l=1;for(let h=s;h<n;++h)l*=i[h],c.push(i[h]);const u=[...be(e.shape).map((e=>e/l)),1].slice(0,s);return[c,o,l,u]}function Yu(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(r,".");if(n.rank<r)throw new Error(s+" update.rank < ".concat(r,". "));if(e.length<a+(n.rank-r))throw new Error(s+" Output shape length < ".concat(a+(n.rank-r)));if(n.rank!==r+e.length-a)throw new Error(s+" update.rank != ".concat(r+e.length-a));for(let o=0;o<r;++o)if(n.shape[o]!==t.shape[o])throw new Error(s+" updates.shape[".concat(o,"] (").concat(n.shape[o],") != indices.shape[").concat(o,"] (").concat(t.shape[o],")."));for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==e[o+a])throw new Error(s+" updates.shape[".concat(o+r,"] (").concat(n.shape[o+r],") != shape[").concat(o+r,"] (").concat(e[o+r],")"))}function Qu(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}Yu(n,t,e)}function Ju(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length;let o=1;for(let c=r;c<s;++c)o*=n[c];const i=r<1?1:r;return{sliceRank:r,numUpdates:ee(t.shape)/i,sliceSize:o,strides:[...be(n.slice(0,r)),1],outputSize:ee(n)}}const Zu=1.7580993408473768,$u=1.0507009873554805,eh=.3275911,th=.254829592,nh=-.284496736,ah=1.421413741,rh=-1.453152027,sh=1.061405429;function oh(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function ih(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function ch(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function lh(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function uh(e,t){return{real:e[2*t],imag:e[2*t+1]}}function hh(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function dh(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function ph(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const fh="->",mh=/->/g,gh=",",yh="...";function bh(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(mh,"").length)/fh.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(fh,'").'));const[a,r]=e.split(fh);J(-1===a.indexOf(yh),(()=>'The ellipsis notation ("'.concat(yh,'") is not supported yet.')));const s=a.split(gh),o=s.length;if(t!==o)throw new Error("Expected ".concat(o," input tensors, received ").concat(t));if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let h=0;h<r.length;++h){const e=r[h];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===i.indexOf(e)&&i.push(e)}for(let h=0;h<a.length;++h){const e=a[h];-1===i.indexOf(e)&&e!==gh&&i.push(e)}const c=new Array(s.length);for(let h=0;h<o;++h){if(new Set(s[h].split("")).size!==s[h].length)throw new Error("Found duplicate axes in input component ".concat(s[h],". ")+"Support for duplicate axes in input is not implemented yet.");c[h]=[];for(let e=0;e<s[h].length;++e)c[h].push(i.indexOf(s[h][e]))}const l=i.length,u=[];for(let h=r.length;h<l;++h)u.push(h);return{allDims:i,summedDims:u,idDims:c}}function vh(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const a=[];for(let r=0;r<e;++r)-1===n[r]&&a.push(r);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:a}}function xh(e,t,n){const a=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===a[t[r][n]]?a[t[r][n]]=e[n]:J(a[t[r][n]]===e[n],(()=>"Expected dimension ".concat(a[t[r][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n])))}}function wh(e,t){const n=e,a=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let o=0;o<r;++o)a.push([]);const s=[];for(let o=0;o<n.length;++o){const e=Sh(t,n[o]);for(const t of e)-1===s.indexOf(t)&&(a[o].push(t),s.push(t))}return{path:n,steps:a}}function kh(e){return e.every(((e,t)=>e===t))}function Sh(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function Ih(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)J(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);J(r<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const a=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-a}J(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}function Nh(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function Th(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function Eh(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function Ch(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function Rh(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function Ah(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function _h(e,t){const n=ee(e),a=ee(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function Dh(e,t){const n=ee(e),a=ee(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function Fh(){return"segment ids must be >= 0"}function Oh(){return"segment ids are not increasing"}function Mh(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function Lh(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function zh(e,t){let n,a=!1;for(e<=Wu?(n=e,a=!0):n=ye(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=ye(e,n+1);return n}function Ph(e,t,n){const a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function Bh(e,t,n,a){const r=t.shape.length,s=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error("Expect batchDims in the range of [-".concat(r,", ").concat(r,"], but got ").concat(a));if(a<0&&(a+=r),a>s)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(s,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let h=0;h<a;++h)if(e.shape[h]!==t.shape[h])throw new Error("x.shape[".concat(h,"]: ").concat(e.shape[h]," should be equal to indices.shape[").concat(h,"]: ").concat(t.shape[h],"."));const o=e.shape[n],i=[];let c=1,l=1,u=1;for(let h=0;h<a;++h)i.push(e.shape[h]),c*=e.shape[h];for(let h=a;h<n;h++)i.push(e.shape[h]),l*=e.shape[h];for(let h=a;h<r;h++)i.push(t.shape[h]);for(let h=n+1;h<s;h++)i.push(e.shape[h]),u*=e.shape[h];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:o,outputShape:i}}function Wh(e){try{return e.map((e=>Ir(e)))}catch(o1){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(o1))}}function Vh(e){return e.map((e=>Sr(e)))}function Uh(e,t){const n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);const a=go(e,"int32"),r=go([n.length,e.length],"int32");for(let s=0;s<n.length;s++){const t=a.indexToLoc(n[s]),o=s*e.length;r.values.set(t,o)}return r.toTensor()}!function(){for(const e of Yo)Do(e)}();const Gh={kernelName:Le,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(e,Ml(yo(n,"float32"),-1))}}},Hh={kernelName:ze,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=Io(yo(n,"float32")),a=So(Po(Eo(1),t));return Hc(wo(e,a))}}}},jh={kernelName:Pe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=So(Po(Io(yo(n,"float32")),1));return wo(e,t)}}}},Kh={kernelName:Be,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Go(n.shape,a.shape);return{a:()=>{let t=e;const a=Uo(n.shape,r);return a.length>0&&(t=Nc(t,a)),Vi(t,n.shape)},b:()=>{let t=e;const n=Uo(a.shape,r);return n.length>0&&(t=Nc(t,n)),Vi(t,a.shape)}}}},qh={kernelName:We,saveAllInputs:!0,gradFunc:(e,t)=>{const n={};return t.forEach(((t,a)=>{n[a]=()=>e.clone()})),n}},Xh={kernelName:Ge,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>No(n)}}},Yh={kernelName:He,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>No(n)}}},Qh={kernelName:je,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wo(e,So(Po(Eo(1),Io(yo(n,"float32")))))}}},Jh={kernelName:Ke,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=So(vo(Eo(1),Io(yo(n,"float32"))));return wo(e,t)}}}},Zh={kernelName:Ye,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Go(n.shape,a.shape);return{a:()=>{const t=vo(Io(n),Io(a));let s=ko(e,wo(a,t));const o=Uo(n.shape,r);return o.length>0&&(s=Nc(s,o)),Vi(s,n.shape)},b:()=>{const t=vo(Io(n),Io(a));let s=Hc(ko(e,wo(n,t)));const o=Uo(a.shape,r);return o.length>0&&(s=Nc(s,o)),Vi(s,a.shape)}}}},$h={kernelName:qe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wo(e,vo(Io(yo(n,"float32")),1))}}},ed={kernelName:Xe,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wo(e,Po(Eo(1),Io(yo(n,"float32"))))}}};const td=xs({avgPool3dGrad_:function(e,t,n,a,r,s){const o=bs(e,"dy","avgPool3dGrad"),i=bs(t,"input","avgPool3dGrad");let c=o,l=i,u=!1;4===i.rank&&(u=!0,c=Vi(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]]),l=Vi(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]])),J(5===c.rank,(()=>"Error in avgPool3dGrad: dy must be rank 5 but got rank "+"".concat(c.rank,"."))),J(5===l.rank,(()=>"Error in avgPool3dGrad: input must be rank 5 but got rank "+"".concat(l.rank,"."))),Wi("avgPool3dGrad",r,s);const h={dy:c,input:l},d={filterSize:n,strides:a,pad:r,dimRoundingMode:s},p=ls.runKernel($e,h,d);return u?Vi(p,[p.shape[1],p.shape[2],p.shape[3],p.shape[4]]):p}}),nd={kernelName:Ze,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:s,pad:o,dimRoundingMode:i}=n;return{x:()=>td(e,a,r,s,o,i)}}};const ad=xs({avgPoolGrad_:function(e,t,n,a,r){const s=bs(e,"dy","avgPoolGrad"),o=bs(t,"input","avgPoolGrad");J(o.rank===s.rank,(()=>"Rank of input (".concat(o.rank,") does not match rank of dy (").concat(s.rank,")")));let i=o,c=s,l=!1;3===o.rank&&(l=!0,i=Vi(o,[1,o.shape[0],o.shape[1],o.shape[2]]),c=Vi(s,[1,s.shape[0],s.shape[1],s.shape[2]])),J(4===c.rank,(()=>"Error in avgPoolGrad: dy must be rank 4 but got rank "+"".concat(c.rank,"."))),J(4===i.rank,(()=>"Error in avgPoolGrad: input must be rank 4 but got rank "+"".concat(i.rank,".")));const u={dy:c,input:i},h={filterSize:n,strides:a,pad:r},d=ls.runKernel(Je,u,h);return l?Vi(d,[d.shape[1],d.shape[2],d.shape[3]]):d}}),rd={kernelName:Qe,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{filterSize:r,strides:s,pad:o}=n;return{x:()=>ad(e,a,r,s,o)}}},sd={kernelName:et,inputsToSave:["a","b"],gradFunc:(e,t,n)=>{const[a,r]=t,{transposeA:s,transposeB:o}=n;return s||o?!s&&o?{a:()=>zc(e,r,!1,!1),b:()=>zc(e,a,!0,!1)}:s&&!o?{a:()=>zc(r,e,!1,!0),b:()=>zc(a,e,!1,!1)}:{a:()=>zc(r,e,!0,!0),b:()=>zc(e,a,!0,!0)}:{a:()=>zc(e,r,!1,!0),b:()=>zc(a,e,!0,!1)}}};const od=xs({spaceToBatchND_:function(e,t,n){const a=bs(e,"x","spaceToBatchND");J(a.rank>=1+t.length,(()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length))),J(n.length===t.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length))),J(a.shape.reduce(((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]===0:e),!0),(()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString())));const r={x:a},s={blockShape:t,paddings:n};return ls.runKernel(ga,r,s)}}),id={kernelName:tt,gradFunc:(e,t,n)=>{const{blockShape:a,crops:r}=n;return{x:()=>od(e,a,r)}}},cd={kernelName:"BroadcastTo",gradFunc:(e,t,n)=>{const a=n,r=a.inputShape,s=a.shape,o=Array.from(s);for(let c=r.length-1;c>=0;c--)if(r[c]===s[c])o[c]=1;else if(1!==r[c])throw new Error("broadcastTo(): [".concat(r,"] cannot be broadcast to [").concat(s,"]."));const i=[];for(let c=0;c<o.length;c++)o[c]>1&&i.push(c);return{x:()=>Nc(e,i,!0)}}},ld={kernelName:st,gradFunc:e=>({x:()=>e.clone()})},ud={kernelName:ot,gradFunc:e=>({x:()=>No(e)})},hd={kernelName:it,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{clipValueMin:r,clipValueMax:s}=n;return{x:()=>Il(Lc(xc(a,r),mu(a,s)),e,No(e))}}},dd={kernelName:lt,inputsToSave:["x"],gradFunc:Gh.gradFunc},pd={kernelName:ut,saveAllInputs:!0,gradFunc:(e,t,n)=>{const a=t.map((e=>e.shape)),{axis:r}=n,s=ie(r,t[0].shape)[0],o=a.map((e=>e[s]));return gl(e,o,s).map((e=>()=>e))}},fd={kernelName:ht,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{dilations:s,strides:o,pad:i,dataFormat:c}=n;return J(Li(s),(()=>"Error in gradient of conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(s,"'"))),{x:()=>ac(a.shape,e,r,o,i,c),filter:()=>Fl(a,e,r.shape,o,i,c)}}},md={kernelName:pt,inputsToSave:["dy","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,{strides:s,pad:o,dataFormat:i,dimRoundingMode:c}=n;return{dy:()=>tc(e,r,s,o,i,1,c),filter:()=>Fl(e,a,r.shape,s,o,i,c)}}};const gd=xs({conv3DBackpropFilter_:function(e,t,n,a,r){let s=e;4===e.rank&&(s=Vi(e,[1,e.shape[0],e.shape[1],e.shape[2],e.shape[3]]));let o=t;4===o.rank&&(o=Vi(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]])),J(5===s.rank,(()=>"Error in conv3dDerFilter: input must be rank 5, but got shape "+"".concat(s.shape,"."))),J(5===o.rank,(()=>"Error in conv3dDerFilter: dy must be rank 5, but got shape "+"".concat(o.shape,"."))),J(5===n.length,(()=>"Error in conv3dDerFilter: filterShape must be length 5, but got "+"".concat(n,"."))),J(s.shape[4]===n[3],(()=>"Error in conv3dDerFilter: depth of input ".concat(s.shape[4],") must ")+"match input depth in filter (".concat(n[3],"."))),J(o.shape[4]===n[4],(()=>"Error in conv3dDerFilter: depth of dy (".concat(o.shape[4],") must ")+"match output depth for filter (".concat(n[4],").")));const i={x:s,dy:o},c={strides:a,pad:r,filterShape:n};return ls.runKernel(mt,i,c)}}),yd={kernelName:ft,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:s}=n;J(Li(a),(()=>"Error in gradient of conv3D: dilation rates greater than 1 are "+"not yet supported in gradients. Got dilations '".concat(a,"'")));const[o,i]=t;return{x:()=>oc(o.shape,e,i,r,s),filter:()=>gd(o,e,i.shape,r,s)}}};const bd=xs({sin_:function(e){const t={x:bs(e,"x","sin","float32")};return ls.runKernel(la,t)}}),vd={kernelName:yt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(Hc(bd(yo(n,"float32"))),e)}}};const xd=xs({sinh_:function(e){const t={x:bs(e,"x","sinh")};return ls.runKernel(ua,t)}}),wd={kernelName:bt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(xd(yo(n,"float32")),e)}}};const kd=xs({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:bs(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:a};return ls.runKernel(xt,r,s)}}),Sd={kernelName:xt,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r,exclusive:s,reverse:o}=n;return{x:()=>{const t=Dc([r],a.rank);let n=kd(e,r,s,!o);return null!=t&&(n=El(n,t)),n}}}},Id={kernelName:It,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const{dilations:a,strides:r,pad:s,dimRoundingMode:o}=n,i=null==a?[1,1]:a;J(Li(i),(()=>"Error in gradient of depthwiseConv2dNative: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(i,"'")));const[c,l]=t;return J(4===c.rank,(()=>"Error in gradient of depthwiseConv2dNative: input must be "+"rank 4, but got rank ".concat(c.rank,"."))),J(4===l.rank,(()=>"Error in gradient of depthwiseConv2dNative: filter must be "+"rank 4, but got rank ".concat(l.rank,"."))),J(c.shape[3]===l.shape[2],(()=>"Error in gradient of depthwiseConv2d: number of input "+"channels (".concat(c.shape[3],") must match the inChannels dimension ")+"in filter ".concat(l.shape[2],"."))),J(zi(r,i),(()=>"Error in gradient of depthwiseConv2d: Either strides or "+"dilations must be  1. Got strides ".concat(r," and dilations ")+"'".concat(i,"'."))),Wi("depthwiseConv2d",s,o),{x:()=>Ul(c.shape,e,l,r,s,i,o),filter:()=>Vl(c,e,l.shape,r,s,i,o)}}},Nd={kernelName:Ct,inputsToSave:["x","filter"],gradFunc:(e,t,n)=>{const[a,r]=t,s={x:a,filter:r,dy:e},o={x:a,filter:r,dy:e};return{x:()=>ls.runKernel(Rt,s,n),filter:()=>ls.runKernel(At,o,n)}}},Td={kernelName:Ot,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t,a={dy:e,y:n};return{x:()=>ls.runKernel(Mt,a)}}},Ed={kernelName:Lt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=ko(pc(Hc(Io(n))),2/Math.sqrt(Math.PI));return{x:()=>ko(e,a)}}},Cd={kernelName:Pt,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(e,n)}}},Rd={kernelName:Bt,inputsToSave:["input"],gradFunc:(e,t)=>{const[n]=t;return{input:()=>Vi(e,n.shape)}}},Ad={kernelName:Wt,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(e,pc(n))}}},_d={kernelName:Ht,gradFunc:e=>({x:()=>No(e)})},Dd={kernelName:jt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Go(n.shape,a.shape);return{a:()=>{const t=wo(e,yo(a,"float32")),s=Uo(n.shape,r);return s.length>0?Vi(Nc(t,s),n.shape):t},b:()=>{let t=ko(e,yo(n,"float32"));const s=Uo(a.shape,r);s.length>0&&(t=Vi(Nc(t,s),a.shape));const o=Io(a);return Hc(wo(t,yo(o,"float32")))}}}};const Fd=xs({rsqrt_:function(e){const t={x:bs(e,"x","rsqrt","float32")};return ls.runKernel(na,t)}}),Od={kernelName:Kt,inputsToSave:["x","mean","variance","scale"],gradFunc:(e,t,n)=>{const{varianceEpsilon:a}=n,[r,s,o,i]=t,c=null==i?Eo(1):i,l=Uo(s.shape,r.shape),u=[];if(1===s.rank){for(let e=0;e<r.shape.length-1;++e)u.push(r.shape[e]);u.push(1)}const h=Po(r,s),d=ko(e,c),p=Fd(vo(o,Eo(a))),f=ko(ko(ko(p,p),p),Eo(-.5));return{x:()=>1===s.rank?Vi(ko(ko(e,mc(Vi(p,[1,1,1,s.shape[0]]),u)),c),r.shape):Vi(ko(ko(e,p),c),r.shape),mean:()=>{let e=ko(ko(p,Eo(-1)),d);return 1===s.rank&&(e=Nc(e,l)),Vi(e,s.shape)},variance:()=>{let e=ko(ko(f,h),d);return 1===s.rank&&(e=Nc(e,l)),Vi(e,s.shape)},scale:()=>{const t=ko(h,p);let n=ko(e,t);return 1===s.rank&&(n=Nc(n,l)),Vi(n,s.shape)},offset:()=>{let t=e;return 1===s.rank&&(t=Nc(t,l)),Vi(t,s.shape)}}}};const Md=xs({unsortedSegmentSum_:function(e,t,n){const a=bs(e,"x","unsortedSegmentSum"),r=bs(t,"segmentIds","unsortedSegmentSum","int32");J(ne(n),(()=>"numSegments must be of dtype int"));const s={x:a,segmentIds:r},o={numSegments:n};return ls.runKernel(Wa,s,o)}}),Ld={kernelName:qt,inputsToSave:["x","indices"],gradFunc:(e,t,n)=>{const[a,r]=t,{axis:s,batchDims:o}=n,i=ie(s,a.shape)[0],c=(e,t,n)=>()=>{const a=e.shape,r=t.size,o=a.slice(0,i),c=o.length,l=a.slice(s,a.length).slice(1),u=l.length,h=zd(0,c),d=zd(c+1,c+1+u),p=Pd([o,[r],l]),f=Vi(n,p),m=Vi(t,[r]),g=Pd([[c],h,d]),y=El(f,g);let b=Md(y,m,e.shape[i]);const v=Fc(g);return b=El(b,v),b};if(1===o){const t=a.shape[0],n=a.split(t,0);return{x:()=>{const t=bl(n.map(((t,n)=>c(t,r.slice(n,1),e.slice(n,1))())));return t.reshape(a.shape)},indices:()=>r}}return{x:c(a,r,e),indices:()=>r}}};function zd(e,t){const n=[];for(let a=e;a<t;++a)n.push(a);return n}function Pd(e){const t=[];for(let n=0;n<e.length;++n)for(let a=0;a<e[n].length;++a)t.push(e[n][a]);return t}const Bd={kernelName:Qt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>No(n),b:()=>No(a)}}},Wd={kernelName:Jt,gradFunc:e=>({x:()=>yo(e,"float32")})},Vd={kernelName:en,gradFunc:e=>({x:()=>No(e)})},Ud={kernelName:tn,gradFunc:e=>({x:()=>No(e)})},Gd={kernelName:nn,gradFunc:e=>({x:()=>No(e)})},Hd={kernelName:an,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{alpha:r}=n,s=vc(a,0);return{x:()=>Il(s,e,ko(e,r))}}},jd={kernelName:ln,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wo(e,vo(n,1))}}},Kd={kernelName:cn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wo(e,yo(n,"float32"))}}},qd={kernelName:"LogSoftmax",inputsToSave:[],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;return{logits:()=>{const t=pc(a);return Po(e,ko(Nc(e,r,!0),t))}}}};const Xd=xs({localResponseNormalizationBackprop_:function(e,t,n){const a={x:e,y:t,dy:n},r={depthRadius:arguments.length>3&&void 0!==arguments[3]?arguments[3]:5,bias:arguments.length>4&&void 0!==arguments[4]?arguments[4]:1,alpha:arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,beta:arguments.length>6&&void 0!==arguments[6]?arguments[6]:.5};return ls.runKernel(fn,a,r)}}),Yd={kernelName:pn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{depthRadius:s,bias:o,alpha:i,beta:c}=n;return{x:()=>Xd(a,r,e,s,o,i,c)}}};function Qd(e,t,n,a){return t.rank<n.rank&&(t=Vi(t,Ac(t.shape,a))),e.rank<n.rank&&(e=Vi(e,Ac(e.shape,a))),{x:()=>ko(e,yo(hc(n,t),e.dtype))}}const Jd={kernelName:mn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{reductionIndices:r}=a,s=t[0],o=Qd(e,t[1],s,ie(r,s.shape));return{x:()=>o.x()}}},Zd={kernelName:gn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>ko(e,yo(xc(n,a),"float32")),b:()=>ko(e,yo(vu(n,a),"float32"))}}};const $d=xs({maxPool3dGrad_:function(e,t,n,a,r,s,o){const i=bs(e,"dy","maxPool3dGrad"),c=bs(t,"input","maxPool3dGrad"),l=bs(n,"output","maxPool3dGrad");let u=i,h=c,d=l,p=!1;4===c.rank&&(p=!0,u=Vi(i,[1,i.shape[0],i.shape[1],i.shape[2],i.shape[3]]),h=Vi(c,[1,c.shape[0],c.shape[1],c.shape[2],c.shape[3]]),d=Vi(l,[1,l.shape[0],l.shape[1],l.shape[2],l.shape[3]])),J(5===u.rank,(()=>"Error in maxPool3dGrad: dy must be rank 5 but got rank "+"".concat(u.rank,"."))),J(5===h.rank,(()=>"Error in maxPool3dGrad: input must be rank 5 but got rank "+"".concat(h.rank,"."))),J(5===d.rank,(()=>"Error in maxPool3dGrad: output must be rank 5 but got rank "+"".concat(d.rank,"."))),Wi("maxPool3dGrad",s,o);const f={dy:u,input:h,output:d},m={filterSize:a,strides:r,pad:s,dimRoundingMode:o},g=ls.runKernel(xn,f,m);return p?Vi(g,[g.shape[1],g.shape[2],g.shape[3],g.shape[4]]):g}}),ep={kernelName:vn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:c}=n;return{x:()=>$d(e,a,r,s,o,i,c)}}};const tp=xs({maxPoolGrad_:function(e,t,n,a,r,s,o){const i=bs(e,"dy","maxPoolGrad"),c=bs(t,"input","maxPoolGrad"),l=bs(n,"output","maxPoolGrad");J(c.rank===i.rank,(()=>"Rank of input (".concat(c.rank,") does not match rank of dy ")+"(".concat(i.rank,")"))),J(4===i.rank,(()=>"Error in maxPoolGrad: dy must be rank 4 but got rank "+"".concat(i.rank,"."))),J(4===c.rank,(()=>"Error in maxPoolGrad: input must be rank 4 but got rank "+"".concat(c.rank,"."))),Wi("maxPoolGrad",s,o);const u={dy:i,input:c,output:l},h={filterSize:a,strides:r,pad:s,dimRoundingMode:o};return ls.runKernel(bn,u,h)}}),np={kernelName:yn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a,r]=t,{filterSize:s,strides:o,pad:i}=n;return{x:()=>tp(e,a,r,s,o,i)}}},ap={kernelName:kn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n,s=ie(r,a.shape),o=ee(Rc(a.shape,s)[1]);return{x:()=>{const t=a.shape.slice();s.forEach((e=>{t[e]=1}));const n=Vi(e,t);return wo(ko(n,Xc(a.shape,"float32")),o)}}}},rp={kernelName:Sn,inputsToSave:["x"],outputsToSave:[!0],gradFunc:(e,t,n)=>{const a=n,{axis:r}=a,[s,o]=t,i=Qd(e,o,s,ie(r,s.shape));return{x:()=>i.x()}}},sp={kernelName:In,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t;return{a:()=>ko(e,yo(mu(n,a),"float32")),b:()=>ko(e,yo(vc(n,a),"float32"))}}},op={kernelName:Nn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,s=r.map((e=>e[0]));return{x:()=>ll(e,s,a.shape)}}},ip={kernelName:Tn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Go(n.shape,a.shape);return{a:()=>{const t=Uo(n.shape,r);return t.length>0?Vi(Nc(e,t),n.shape):e},b:()=>{const t=ko(e,Hc(yc(wo(n,a)))),s=Uo(a.shape,r);return s.length>0?Vi(Nc(t,s),a.shape):t}}}},cp={kernelName:Cn,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Go(n.shape,a.shape);return{a:()=>{const t=ko(e,yo(a,"float32")),s=Uo(n.shape,r);return s.length>0?Vi(Nc(t,s),n.shape):t},b:()=>{const t=ko(e,yo(n,"float32")),s=Uo(a.shape,r);return s.length>0?Vi(Nc(t,s),a.shape):t}}}},lp={kernelName:Rn,gradFunc:e=>({x:()=>Hc(e)})},up={kernelName:Mn,inputsToSave:["indices"],gradFunc:(e,t)=>{const n=t[0];return{indices:()=>qc(n.shape,"float32")}}},hp={kernelName:On,gradFunc:e=>({x:()=>No(e)})},dp={kernelName:Ln,saveAllInputs:!0,gradFunc:(e,t,n)=>{const{axis:a}=n;return Sl(e,a).map((e=>()=>e))}},pp={kernelName:zn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const a=t[0],{paddings:r}=n,s=r.map((e=>e[0]));return{x:()=>ll(e,s,a.shape)}}},fp={kernelName:Pn,inputsToSave:["a","b"],outputsToSave:[!0],gradFunc:(e,t)=>{const[n,a,r]=t,s=n,o=a,i=Go(s.shape,o.shape);return{a:()=>{const t=yo(o,"float32");let n=ko(e,ko(t,zo(s,Po(t,Eo(1)))));const a=Uo(s.shape,i);return a.length>0&&(n=Nc(n,a)),Vi(n,s.shape)},b:()=>{const t=vc(s,0),n=Il(t,kc(s),No(s));let a=ko(e,ko(r,n));const c=Uo(o.shape,i);return c.length>0&&(a=Nc(a,c)),Vi(a,o.shape)}}}},mp={kernelName:Bn,inputsToSave:["x","alpha"],gradFunc:(e,t)=>{const[n,a]=t,r=vc(n,0);return{x:()=>Il(r,e,ko(e,a)),alpha:()=>{let t=Il(r,No(e),ko(e,n));const s=Uo(a.shape,e.shape);return s.length>0&&(t=Nc(t,s)),Vi(t,a.shape)}}}};const gp=xs({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:bs(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:a};return ls.runKernel(vt,r,s)}});function yp(e,t,n){const a=e.shape.length,r=a-n.length,s=Dc(n,a);let o=e;null!=s&&(o=El(e,s));const i=o.shape.slice(),c=i.splice(a-n.length,n.length).reduce(((e,t)=>e*t),1);i.push(c);let l=function(e,t,n){const a=e.shape.slice();a[n]=1;const r=Vi(t,a),s=gp(e,n,!0,!1),o=gp(e,n,!0,!0),i=ko(s,o);return ko(r,i)}(o.reshape(i),t,r);if(l=l.reshape(o.shape),null!=s){const e=Fc(s);l=El(l,e)}return l}const bp={kernelName:Wn,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{axis:r}=n;let s=[];return s=void 0===r||null===r?a.shape.map(((e,t)=>t)):"number"===typeof r?[r]:r,{x:()=>yp(a,e,s)}}},vp={kernelName:Dt,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Go(n.shape,a.shape);return{a:()=>{const t=wo(e,yo(a,"float32")),s=Uo(n.shape,r);return s.length>0?Vi(Nc(t,s),n.shape):t},b:()=>{let t=ko(e,yo(n,"float32"));const s=Uo(a.shape,r);s.length>0&&(t=Vi(Nc(t,s),a.shape));const o=Io(a);return Hc(wo(t,yo(o,"float32")))}}}},xp={kernelName:Kn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wo(e,Hc(Io(n)))}}},wp={kernelName:$n,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t,a=ko(mu(n,6),Ml(n));return{x:()=>ko(e,yo(a,"float32"))}}},kp={kernelName:qn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(e,yo(Ml(n),"float32"))}}},Sp={kernelName:Xn,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Vi(e,n.shape)}}},Ip={kernelName:Jn,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>ls.runKernel(Zn,r,n)}}},Np={kernelName:Yn,inputsToSave:["images"],gradFunc:(e,t,n)=>{const[a]=t,r={dy:e,images:a};return{images:()=>ls.runKernel(Qn,r,n)}}},Tp={kernelName:ea,gradFunc:(e,t,n)=>{const{dims:a}=n,r=ie(a,e.shape);return{x:()=>sl(e,r)}}},Ep={kernelName:ta,gradFunc:e=>({x:()=>No(e)})},Cp={kernelName:na,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>Hc(wo(e,ko(zo(n,1.5),2)))}}};const Rp=xs({logicalNot_:function(e){const t={x:bs(e,"x","logicalNot","bool")};return ls.runKernel(hn,t)}}),Ap={kernelName:oa,inputsToSave:["condition"],gradFunc:(e,t)=>{const[n]=t;return{condition:()=>yo(No(n),"float32"),t:()=>ko(e,yo(n,e.dtype)),e:()=>ko(e,yo(Rp(n),e.dtype))}}},_p={kernelName:ia,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>{const t=vc(n,Eo(0)),a=Eo(Zu),r=Eo($u),s=ko(e,r),o=ko(ko(e,a),pc(yo(n,"float32")));return Il(t,s,o)}}}},Dp={kernelName:da,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(e,ko(n,Po(Eo(1),n)))}}},Fp={kernelName:ha,gradFunc:e=>({x:()=>No(e)})};const Op=xs({cos_:function(e){const t={x:bs(e,"x","cos","float32")};return ls.runKernel(yt,t)}}),Mp={kernelName:la,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(Op(yo(n,"float32")),e)}}};const Lp=xs({cosh_:function(e){const t={x:bs(e,"x","cosh","float32")};return ls.runKernel(bt,t)}}),zp={kernelName:ua,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(Lp(yo(n,"float32")),e)}}},Pp={kernelName:ca,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{begin:r,size:s}=n,o=a.shape,[i,c]=xi(a,r,s),l=[];for(let u=0;u<e.rank;u++)l.push([i[u],o[u]-i[u]-c[u]]);return{x:()=>Qc(e,l)}}},Bp={kernelName:ba,outputsToSave:[!0],gradFunc:(e,t,n)=>{const[a]=t,{dim:r}=n,s=ko(e,a);return{logits:()=>Po(s,ko(Nc(s,[r],true),a))}}},Wp={kernelName:pa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(e,cl(n))}}};const Vp=xs({batchToSpaceND_:function(e,t,n){const a=bs(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));J(a.rank>=1+t.length,(()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length))),J(n.length===t.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length))),J(a.shape[0]%r===0,(()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(r)));const s={x:a},o={blockShape:t,crops:n};return ls.runKernel(tt,s,o)}}),Up={kernelName:ga,gradFunc:(e,t,n)=>{const{blockShape:a,paddings:r}=n;return{x:()=>Vp(e,a,r)}}},Gp={kernelName:ya,gradFunc:(e,t,n)=>{const{axis:a}=n;return{x:()=>Qi(e,a)}}};const Hp=[Gh,Hh,jh,Kh,qh,Xh,Yh,Qh,Jh,Zh,$h,ed,nd,rd,sd,id,cd,ld,ud,hd,dd,pd,md,fd,yd,vd,wd,Sd,Id,Nd,vp,Td,Ed,Cd,Rd,Ad,Dd,_d,Od,Ld,Bd,Wd,Vd,Ud,Gd,Hd,jd,Kd,qd,Yd,Jd,Jd,Zd,ep,np,ap,rp,sp,op,ip,cp,lp,up,hp,dp,pp,pp,fp,mp,bp,xp,wp,kp,Sp,Ip,Np,Tp,Ep,Cp,Ap,_p,Dp,Fp,Mp,zp,Pp,Bp,Wp,Up,Up,Gp,Gp,{kernelName:fa,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wo(e,ko(So(yo(n,"float32")),2))}}},{kernelName:Ia,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Eo(2);return{a:()=>ko(e,ko(r,Po(n,a))),b:()=>ko(e,ko(r,Po(a,n)))}}},{kernelName:Na,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(e,ko(yo(n,"float32"),2))}}},{kernelName:Ua,gradFunc:e=>({x:()=>No(e)})},{kernelName:_a,inputsToSave:["a","b"],gradFunc:(e,t)=>{const[n,a]=t,r=Go(n.shape,a.shape);return{a:()=>{let t=e;const a=Uo(n.shape,r);return a.length>0&&(t=Nc(t,a)),Vi(t,n.shape)},b:()=>{let t=e;const n=Uo(a.shape,r);return n.length>0&&(t=Nc(t,n)),Vi(Hc(t),a.shape)}}}},{kernelName:ma,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,r=a.shape.slice(),{axis:s}=n;ie(s,a.shape).forEach((e=>{r[e]=1}));const o=Vi(e,r),i=ko(o,Xc(a.shape,"float32"));return{x:()=>i}}},{kernelName:Da,inputsToSave:["x"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>wo(e,Io(Op(n)))}}},{kernelName:Fa,outputsToSave:[!0],gradFunc:(e,t)=>{const[n]=t;return{x:()=>ko(Po(Eo(1),Io(n)),e)}}},{kernelName:Oa,inputsToSave:["x"],gradFunc:(e,t,n)=>{const[a]=t,{reps:r}=n;return{x:()=>{let t=No(a);if(1===a.rank)for(let n=0;n<r[0];++n)t=vo(t,ll(e,[n*a.shape[0]],[a.shape[0]]));else if(2===a.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)t=vo(t,ll(e,[n*a.shape[0],s*a.shape[1]],[a.shape[0],a.shape[1]]));else if(3===a.rank)for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let o=0;o<r[2];++o)t=vo(t,ll(e,[n*a.shape[0],s*a.shape[1],o*a.shape[2]],[a.shape[0],a.shape[1],a.shape[2]]));else{if(4!==a.rank)throw new Error("Gradient for tile operation is not implemented for rank-"+"".concat(a.rank," tensors yet."));for(let n=0;n<r[0];++n)for(let s=0;s<r[1];++s)for(let o=0;o<r[2];++o)for(let i=0;i<r[3];++i)t=vo(t,ll(e,[n*a.shape[0],s*a.shape[1],o*a.shape[2],i*a.shape[3]],[a.shape[0],a.shape[1],a.shape[2],a.shape[3]]))}return t}}}},{kernelName:za,gradFunc:(e,t,n)=>{const a=n,{perm:r}=a,s=Fc(r);return{x:()=>El(e,s)}}},{kernelName:Ba,gradFunc:(e,t,n)=>{const a=n,{axis:r}=a;return{value:()=>bl(e,r)}}},{kernelName:Wa,inputsToSave:["segmentIds"],gradFunc:(e,t)=>{const[n]=t;return{x:()=>function(e,t){const n=Ho(t,No(t)),a=bc(e,n);let r=xc(t,Eo(0,"int32"));const s=a.rank-r.rank;for(let i=0;i<s;++i)r=fc(r,i+1);r=Lc(r,Xc(a.shape,"bool"));const o=No(a);return Il(r,a,o)}(e,n)}}},{kernelName:Va,gradFunc:e=>({x:()=>No(e)})}];for(const n of Hp)nr(n);Gr().prototype.abs=function(){return this.throwIfDisposed(),Wo(this)};const jp=xs({acos_:function(e){const t={x:bs(e,"x","acos")};return ls.runKernel(ze,t)}});Gr().prototype.acos=function(){return this.throwIfDisposed(),jp(this)};const Kp=xs({acosh_:function(e){const t={x:bs(e,"x","acosh")};return ls.runKernel(Pe,t)}});Gr().prototype.acosh=function(){return this.throwIfDisposed(),Kp(this)},Gr().prototype.add=function(e){return this.throwIfDisposed(),vo(this,e)},Gr().prototype.all=function(e,t){return this.throwIfDisposed(),Si(this,e,t)},Gr().prototype.any=function(e,t){return this.throwIfDisposed(),Ii(this,e,t)},Gr().prototype.argMax=function(e){return this.throwIfDisposed(),Ni(this,e)};const qp=xs({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:bs(e,"x","argMin")},a={axis:t};return ls.runKernel(He,n,a)}});Gr().prototype.argMin=function(e){return this.throwIfDisposed(),qp(this,e)},Gr().prototype.asScalar=function(){return this.throwIfDisposed(),J(1===this.size,(()=>"The array must have only 1 element.")),Vi(this,[])},Gr().prototype.asType=function(e){return this.throwIfDisposed(),yo(this,e)},Gr().prototype.as1D=function(){return this.throwIfDisposed(),Vi(this,[this.size])},Gr().prototype.as2D=function(e,t){return this.throwIfDisposed(),Vi(this,[e,t])},Gr().prototype.as3D=function(e,t,n){return this.throwIfDisposed(),Vi(this,[e,t,n])},Gr().prototype.as4D=function(e,t,n,a){return this.throwIfDisposed(),Vi(this,[e,t,n,a])},Gr().prototype.as5D=function(e,t,n,a,r){return this.throwIfDisposed(),Vi(this,[e,t,n,a,r])};const Xp=xs({asin_:function(e){const t={x:bs(e,"x","asin")};return ls.runKernel(je,t)}});Gr().prototype.asin=function(){return this.throwIfDisposed(),Xp(this)};const Yp=xs({asinh_:function(e){const t={x:bs(e,"x","asinh")};return ls.runKernel(Ke,t)}});Gr().prototype.asinh=function(){return this.throwIfDisposed(),Yp(this)};const Qp=xs({atan_:function(e){const t={x:bs(e,"x","atan")};return ls.runKernel(qe,t)}});Gr().prototype.atan=function(){return this.throwIfDisposed(),Qp(this)};const Jp=xs({atan2_:function(e,t){let n=bs(e,"a","atan2"),a=bs(t,"b","atan2");[n,a]=ts(n,a);const r={a:n,b:a};return ls.runKernel(Ye,r)}});Gr().prototype.atan2=function(e){return this.throwIfDisposed(),Jp(this,e)};const Zp=xs({atanh_:function(e){const t={x:bs(e,"x","atanh")};return ls.runKernel(Xe,t)}});Gr().prototype.atanh=function(){return this.throwIfDisposed(),Zp(this)},Gr().prototype.avgPool=function(e,t,n,a){return this.throwIfDisposed(),Ui(this,e,t,n,a)},Gr().prototype.batchToSpaceND=function(e,t){return this.throwIfDisposed(),Vp(this,e,t)},Gr().prototype.batchNorm=function(e,t,n,a,r){return this.throwIfDisposed(),Hi(this,e,t,n,a,r)},Gr().prototype.broadcastTo=function(e){return this.throwIfDisposed(),Xi(this,e)},Gr().prototype.cast=function(e){return this.throwIfDisposed(),yo(this,e)};const $p=xs({ceil_:function(e){const t={x:bs(e,"x","ceil","float32")};return ls.runKernel(ot,t)}});Gr().prototype.ceil=function(){return this.throwIfDisposed(),$p(this)},Gr().prototype.clipByValue=function(e,t){return this.throwIfDisposed(),Yi(this,e,t)},Gr().prototype.concat=function(e,t){return this.throwIfDisposed(),e instanceof Ur&&(e=[e]),Qi([this,...e],t)},Gr().prototype.conv1d=function(e,t,n,a,r,s){return this.throwIfDisposed(),nc(this,e,t,n,a,r,s)},Gr().prototype.conv2dTranspose=function(e,t,n,a,r){return this.throwIfDisposed(),rc(this,e,t,n,a,r)},Gr().prototype.conv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),tc(this,e,t,n,a,r,s)},Gr().prototype.cos=function(){return this.throwIfDisposed(),Op(this)},Gr().prototype.cosh=function(){return this.throwIfDisposed(),Lp(this)},Gr().prototype.cumprod=function(e,t,n){return this.throwIfDisposed(),gp(this,e,t,n)},Gr().prototype.cumsum=function(e,t,n){return this.throwIfDisposed(),kd(this,e,t,n)};const ef=xs({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const a=bs(e,"x","depthToSpace","float32"),r="NHWC"===n?a.shape[1]:a.shape[2],s="NHWC"===n?a.shape[2]:a.shape[3],o="NHWC"===n?a.shape[3]:a.shape[1];J(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t))),J(r*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape))),J(s*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(s," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape))),J(o%(t*t)===0,(()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(o," for depthToSpace with input shape ").concat(a.shape)));const i={x:a},c={blockSize:t,dataFormat:n};return ls.runKernel(St,i,c)}});Gr().prototype.depthToSpace=function(e,t){return this.throwIfDisposed(),ef(this,e,t)},Gr().prototype.depthwiseConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),lc(this,e,t,n,a,r,s)};const tf=xs({dilation2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const o=bs(e,"x","dilation2d"),i=bs(t,"filter","dilation2d");J(3===o.rank||4===o.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(o.rank,"."))),J(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),J("NHWC"===s,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(s)));let c=o,l=!1;3===o.rank&&(c=Vi(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0),J(c.shape[3]===i.shape[2],(()=>"Error in dilation2d:  input and filter must have the same depth: ".concat(c.shape[3]," vs ").concat(i.shape[2])));const u={x:c,filter:i},h={strides:n,pad:a,dilations:r},d=ls.runKernel(Ct,u,h);return l?Vi(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});Gr().prototype.dilation2d=function(e,t,n,a,r){return this.throwIfDisposed(),tf(this,e,t,n,a,r)};const nf=xs({divNoNan_:function(e,t){let n=bs(e,"a","div"),a=bs(t,"b","div");[n,a]=ts(n,a);const r=wo(n,a),s=No(r),o=hc(a,s);return Il(o,s,r)}});Gr().prototype.divNoNan=function(e){return this.throwIfDisposed(),nf(this,e)},Gr().prototype.div=function(e){return this.throwIfDisposed(),wo(this,e)};const af=xs({dot_:function(e,t){const n=bs(e,"t1","dot"),a=bs(t,"t2","dot");J((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=1===n.rank?n.size:n.shape[1],s=1===a.rank?a.size:a.shape[0];if(J(r===s,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(r," and ").concat(s,"."))),1===n.rank&&1===a.rank){const e=Vi(n,[1,-1]),t=Vi(a,[-1,1]),r=zc(e,t);return Vi(r,[])}if(1===n.rank&&2===a.rank){const e=Vi(n,[1,-1]),t=Vi(a,[a.shape[0],a.shape[1]]),r=zc(e,t);return Vi(r,[r.size])}if(2===n.rank&&1===a.rank){const e=Vi(a,[-1,1]),t=zc(n,e);return Vi(t,[t.size])}{const e=Vi(a,[a.shape[0],a.shape[1]]);return zc(n,e)}}});Gr().prototype.dot=function(e){return this.throwIfDisposed(),af(this,e)},Gr().prototype.elu=function(){return this.throwIfDisposed(),uc(this)},Gr().prototype.equal=function(e){return this.throwIfDisposed(),hc(this,e)},Gr().prototype.erf=function(){return this.throwIfDisposed(),dc(this)};const rf=xs({euclideanNorm_:function(e){return ku(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});Gr().prototype.euclideanNorm=function(e,t){return this.throwIfDisposed(),rf(this,e,t)},Gr().prototype.exp=function(){return this.throwIfDisposed(),pc(this)},Gr().prototype.expandDims=function(e){return this.throwIfDisposed(),fc(this,e)};const sf=xs({expm1_:function(e){const t={x:bs(e,"x","expm1")};return ls.runKernel(Wt,t)}});Gr().prototype.expm1=function(){return this.throwIfDisposed(),sf(this)},Gr().prototype.fft=function(){return this.throwIfDisposed(),Rl(this)},Gr().prototype.flatten=function(){return this.throwIfDisposed(),Vi(this,[this.size])},Gr().prototype.floor=function(){return this.throwIfDisposed(),yc(this)},Gr().prototype.floorDiv=function(e){return this.throwIfDisposed(),xo(this,e)},Gr().prototype.gather=function(e,t,n){return this.throwIfDisposed(),bc(this,e,t,n)},Gr().prototype.greaterEqual=function(e){return this.throwIfDisposed(),xc(this,e)},Gr().prototype.greater=function(e){return this.throwIfDisposed(),vc(this,e)},Gr().prototype.ifft=function(){return this.throwIfDisposed(),_l(this)},Gr().prototype.irfft=function(){return this.throwIfDisposed(),Dl(this)};const of=xs({isFinite_:function(e){const t={x:bs(e,"x","isFinite")};return ls.runKernel(en,t)}});Gr().prototype.isFinite=function(){return this.throwIfDisposed(),of(this)};const cf=xs({isInf_:function(e){const t={x:bs(e,"x","isInf")};return ls.runKernel(tn,t)}});Gr().prototype.isInf=function(){return this.throwIfDisposed(),cf(this)};const lf=xs({isNaN_:function(e){const t={x:bs(e,"x","isNaN")};return ls.runKernel(nn,t)}});Gr().prototype.isNaN=function(){return this.throwIfDisposed(),lf(this)},Gr().prototype.leakyRelu=function(e){return this.throwIfDisposed(),wc(this,e)},Gr().prototype.lessEqual=function(e){return this.throwIfDisposed(),mu(this,e)},Gr().prototype.less=function(e){return this.throwIfDisposed(),vu(this,e)};const uf=xs({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const s=bs(e,"x","localResponseNormalization");J(4===s.rank||3===s.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(s.rank,"."))),J(ne(t),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,".")));let o=s,i=!1;3===s.rank&&(i=!0,o=Vi(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const c={x:o},l={depthRadius:t,bias:n,alpha:a,beta:r},u=ls.runKernel(pn,c,l);return i?Vi(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});Gr().prototype.localResponseNormalization=function(e,t,n,a){return this.throwIfDisposed(),uf(this,e,t,n,a)};const hf=xs({logSigmoid_:function(e){const t=bs(e,"x","logSigmoid");return To((e=>({value:Hc(ml(Hc(e))),gradFunc:t=>ko(t,cl(Hc(e)))})))(t)}});Gr().prototype.logSigmoid=function(){return this.throwIfDisposed(),hf(this)},Gr().prototype.logSoftmax=function(e){return this.throwIfDisposed(),Tc(this,e)},Gr().prototype.logSumExp=function(e,t){return this.throwIfDisposed(),Mc(this,e,t)},Gr().prototype.log=function(){return this.throwIfDisposed(),kc(this)},Gr().prototype.log1p=function(){return this.throwIfDisposed(),Sc(this)},Gr().prototype.logicalAnd=function(e){return this.throwIfDisposed(),Lc(this,e)},Gr().prototype.logicalNot=function(){return this.throwIfDisposed(),Rp(this)};const df=xs({logicalOr_:function(e,t){const n=bs(e,"a","logicalOr","bool"),a=bs(t,"b","logicalOr","bool");Go(n.shape,a.shape);const r={a:n,b:a};return ls.runKernel(dn,r)}});Gr().prototype.logicalOr=function(e){return this.throwIfDisposed(),df(this,e)};const pf=xs({logicalXor_:function(e,t){const n=bs(e,"a","logicalXor","bool"),a=bs(t,"b","logicalXor","bool");return Go(n.shape,a.shape),Lc(df(e,t),Rp(Lc(e,t)))}});Gr().prototype.logicalXor=function(e){return this.throwIfDisposed(),pf(this,e)},Gr().prototype.matMul=function(e,t,n){return this.throwIfDisposed(),zc(this,e,t,n)},Gr().prototype.maxPool=function(e,t,n,a){return this.throwIfDisposed(),Pc(this,e,t,n,a)},Gr().prototype.max=function(e,t){return this.throwIfDisposed(),Ic(this,e,t)},Gr().prototype.maximum=function(e){return this.throwIfDisposed(),Ho(this,e)},Gr().prototype.mean=function(e,t){return this.throwIfDisposed(),Wc(this,e,t)},Gr().prototype.min=function(e,t){return this.throwIfDisposed(),Vc(this,e,t)},Gr().prototype.minimum=function(e){return this.throwIfDisposed(),Uc(this,e)};const ff=xs({mirrorPad_:function(e,t,n){J("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const a=bs(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");J(t.length===a.rank,(()=>"Padding doesn't match input. Must be ".concat(a.rank,". ")+"Got ".concat(t.length,".")));const r="reflect"===n?1:0;for(let i=0;i<a.rank;i++)J(2===t[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),J(t[i][0]>=0&&t[i][0]<=a.shape[i]-r&&t[i][1]>=0&&t[i][1]<=a.shape[i]-r,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(a.shape[i]-r," or less than 0 for input of ")+"shape ".concat(a.shape)));const s={paddings:t,mode:n},o={x:a};return ls.runKernel(Nn,o,s)}});Gr().prototype.mirrorPad=function(e,t){return this.throwIfDisposed(),ff(this,e,t)};const mf=xs({mod_:function(e,t){let n=bs(e,"a","mod"),a=bs(t,"b","mod");[n,a]=ts(n,a);const r={a:n,b:a};return ls.runKernel(Tn,r)}});Gr().prototype.mod=function(e){return this.throwIfDisposed(),mf(this,e)},Gr().prototype.mul=function(e){return this.throwIfDisposed(),ko(this,e)},Gr().prototype.neg=function(){return this.throwIfDisposed(),Hc(this)},Gr().prototype.norm=function(e,t,n){return this.throwIfDisposed(),ku(this,e,t,n)},Gr().prototype.notEqual=function(e){return this.throwIfDisposed(),jc(this,e)},Gr().prototype.oneHot=function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return this.throwIfDisposed(),Kc(this,e,t,n)},Gr().prototype.onesLike=function(){return this.throwIfDisposed(),Yc(this)},Gr().prototype.pad=function(e,t){return this.throwIfDisposed(),Qc(this,e,t)};const gf=xs({pool_:function(e,t,n,a,r,s,o){null==r&&(r=[1,1]),null==s&&(s=1),0===a&&(a="valid");const i=bs(e,"x","maxPool");let c=i,l=!1;3===i.rank&&(l=!0,c=Vi(i,[1,i.shape[0],i.shape[1],i.shape[2]])),J(zi(s,r),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(r,"'")));const u=Ei(c.shape,t,s,r,a),h=[u.dilationHeight,u.dilationWidth];let d;d="same"===a?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),a=n.map((e=>e-1)),r=a.map((e=>Math.floor(e/2))),s=a.map(((e,t)=>e-r[t]));return a.map(((e,t)=>[r[t],s[t]]))}([u.filterHeight,u.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){const a=n.map((e=>e[0])),r=n.map((e=>e[1])),s=e.concat(a,r),o=t.map(((e,t)=>(e-s[t]%e)%e)),i=r.map(((e,t)=>e+o[t])),c=t.map(((e,t)=>[a[t],i[t]])),l=t.map(((e,t)=>[0,o[t]]));return[c,l]}([u.inHeight,u.inWidth],h,d),g=p?a:"valid",y=p?c:od(c,h,f),b=("avg"===n?()=>Ui(y,t,s,g,o):()=>Pc(y,t,s,g,o))(),v=p?b:Vp(b,h,m);return l?Vi(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});Gr().prototype.pool=function(e,t,n,a,r,s){return this.throwIfDisposed(),gf(this,e,t,n,a,r,s)},Gr().prototype.pow=function(e){return this.throwIfDisposed(),zo(this,e)},Gr().prototype.prelu=function(e){return this.throwIfDisposed(),Jc(this,e)};const yf=xs({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=bs(e,"x","prod");"bool"===a.dtype&&(a=yo(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return ls.runKernel(Wn,r,s)}});Gr().prototype.prod=function(e,t){return this.throwIfDisposed(),yf(this,e,t)};const bf=xs({reciprocal_:function(e){const t={x:bs(e,"x","reciprocal")};return ls.runKernel(Kn,t)}});Gr().prototype.reciprocal=function(){return this.throwIfDisposed(),bf(this)},Gr().prototype.relu=function(){return this.throwIfDisposed(),rl(this)},Gr().prototype.relu6=function(){return this.throwIfDisposed(),Ol(this)},Gr().prototype.reshapeAs=function(e){return this.throwIfDisposed(),Vi(this,e.shape)},Gr().prototype.reshape=function(e){return this.throwIfDisposed(),Vi(this,e)},Gr().prototype.resizeBilinear=function(e,t,n){return this.throwIfDisposed(),du(this,e,t,n)},Gr().prototype.resizeNearestNeighbor=function(e,t,n){return this.throwIfDisposed(),pu(this,e,t,n)},Gr().prototype.reverse=function(e){return this.throwIfDisposed(),sl(this,e)},Gr().prototype.rfft=function(){return this.throwIfDisposed(),Al(this)},Gr().prototype.round=function(){return this.throwIfDisposed(),gu(this)},Gr().prototype.rsqrt=function(){return this.throwIfDisposed(),Fd(this)},Gr().prototype.selu=function(){return this.throwIfDisposed(),ol(this)},Gr().prototype.separableConv2d=function(e,t,n,a,r,s){return this.throwIfDisposed(),il(this,e,t,n,a,r,s)},Gr().prototype.sigmoid=function(){return this.throwIfDisposed(),cl(this)};const vf=xs({sign_:function(e){const t={x:bs(e,"x","sign")};return ls.runKernel(ha,t)}});Gr().prototype.sign=function(){return this.throwIfDisposed(),vf(this)},Gr().prototype.sin=function(){return this.throwIfDisposed(),bd(this)},Gr().prototype.sinh=function(){return this.throwIfDisposed(),xd(this)},Gr().prototype.slice=function(e,t){return this.throwIfDisposed(),ll(this,e,t)},Gr().prototype.softmax=function(e){return this.throwIfDisposed(),fl(this,e)},Gr().prototype.softplus=function(){return this.throwIfDisposed(),ml(this)},Gr().prototype.spaceToBatchND=function(e,t){return this.throwIfDisposed(),od(this,e,t)},Gr().prototype.split=function(e,t){return this.throwIfDisposed(),gl(this,e,t)},Gr().prototype.sqrt=function(){return this.throwIfDisposed(),So(this)},Gr().prototype.square=function(){return this.throwIfDisposed(),Io(this)},Gr().prototype.squaredDifference=function(e){return this.throwIfDisposed(),Eu(this,e)},Gr().prototype.squeeze=function(e){return this.throwIfDisposed(),yl(this,e)},Gr().prototype.stack=function(e,t){this.throwIfDisposed();const n=e instanceof Ur?[this,e]:[this,...e];return bl(n,t)},Gr().prototype.step=function(e){return this.throwIfDisposed(),Ml(this,e)};const xf=xs({stridedSlice_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:bs(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:c};return ls.runKernel(Ea,l,u)}});Gr().prototype.stridedSlice=function(e,t,n,a,r,s,o,i){return this.throwIfDisposed(),xf(this,e,t,n,a,r,s,o,i)},Gr().prototype.sub=function(e){return this.throwIfDisposed(),Po(this,e)},Gr().prototype.sum=function(e,t){return this.throwIfDisposed(),Nc(this,e,t)};const wf=xs({tan_:function(e){const t={x:bs(e,"x","tan","float32")};return ls.runKernel(Da,t)}});Gr().prototype.tan=function(){return this.throwIfDisposed(),wf(this)},Gr().prototype.tanh=function(){return this.throwIfDisposed(),vl(this)},Gr().prototype.tile=function(e){return this.throwIfDisposed(),mc(this,e)},Gr().prototype.toBool=function(){return this.throwIfDisposed(),yo(this,"bool")},Gr().prototype.toFloat=function(){return this.throwIfDisposed(),yo(this,"float32")},Gr().prototype.toInt=function(){return this.throwIfDisposed(),yo(this,"int32")};const kf=xs({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=bs(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>r)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r,") ")+"but got ".concat(t));const s={x:a},o={k:t,sorted:n},[i,c]=ls.runKernel(Ma,s,o);return{values:i,indices:c}}});Gr().prototype.topk=function(e,t){return this.throwIfDisposed(),kf(this,e,t)},Gr().prototype.transpose=function(e){return this.throwIfDisposed(),El(this,e)};const Sf=xs({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=bs(e,"x","unique","string_or_numeric");J(n.rank>0,(()=>"The input tensor must be at least 1D"));const a={x:n},r={axis:t},[s,o]=ls.runKernel(Pa,a,r);return{values:s,indices:o}}});Gr().prototype.unique=function(e){return this.throwIfDisposed(),Sf(this,e)},Gr().prototype.unsortedSegmentSum=function(e,t){return this.throwIfDisposed(),Md(this,e,t)},Gr().prototype.unstack=function(e){return this.throwIfDisposed(),Sl(this,e)},Gr().prototype.where=function(e,t){return this.throwIfDisposed(),Il(e,this,t)},Gr().prototype.zerosLike=function(){return this.throwIfDisposed(),No(this)};class If extends Error{constructor(e){super(e),Object.setPrototypeOf(this,If.prototype)}}class Nf extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Nf.prototype)}}class Tf extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Tf.prototype)}}class Ef extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Ef.prototype)}}class Cf extends Error{constructor(e){super(e),Object.setPrototypeOf(this,Cf.prototype)}}Error;class Rf{constructor(e){this.maxEntries=e||100,this.cache=new Map}get(e){let t;return this.cache.has(e)&&(t=this.cache.get(e),this.cache.delete(e),this.cache.set(e,t)),t}put(e,t){if(this.cache.has(e))this.cache.delete(e);else if(this.cache.size>=this.maxEntries){const e=this.cache.keys().next().value;this.cache.delete(e)}this.cache.set(e,t)}getMaxEntries(){return this.maxEntries}setMaxEntries(e){if(e<0)throw new Error("The maxEntries of LRU caches must be at least 0, but got ".concat(e,"."));if(this.maxEntries>e)for(let t=0;t<this.maxEntries-e;t++){const e=this.cache.keys().next().value;this.cache.delete(e)}this.maxEntries=e}}function Af(e,t){if(Array.isArray(e)){let n=[];for(let a=0;a<t;a++)n=n.concat(e);return n}{const n=new Array(t);return n.fill(e),n}}function _f(e,t){if(!e)throw new Cf(t)}function Df(e,t){let n=0;for(const a of e)a===t&&n++;return n}function Ff(e){return 1===e.length?e[0]:e}function Of(e){return Array.isArray(e)?e:[e]}function Mf(e){const t=e.replace(/(.)([A-Z][a-z0-9]+)/g,"$1_$2").replace(/([a-z])([A-Z])/g,"$1_$2").toLowerCase();return"_"!==t[0]?t:"private"+t}function Lf(e){return e.length<=1||-1===e.indexOf("_")?e:e.replace(/[_]+(\w|$)/g,((e,t)=>t.toUpperCase()))}let zf={};function Pf(e){if(null===e||void 0===e)return null;const t={};return t.className=e.getClassName(),t.config=e.getConfig(),t}function Bf(e){if(null!=e&&"object"===typeof e)if(Array.isArray(e))e.forEach((e=>Bf(e)));else{const t=Object.keys(e);for(const n of t){const t=e[n];null!=t&&"object"===typeof t&&(Array.isArray(t)||"ndarray"!==t.type||"number"!==typeof t.value?Bf(t):e[n]=t.value)}}}function Wf(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"object",r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if("string"===typeof e){const r=e;let s;if(r in n)s=n[r];else if(r in zf)s=zf[r];else if(s=t[r],null==s)throw new Tf("Unknown ".concat(a,": ").concat(e,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");return s}{const s=e;if(null==s.className||null==s.config)throw new Tf("".concat(a,": Improper config format: ")+"".concat(JSON.stringify(s),".\n")+"'className' and 'config' must set.");const o=s.className;let i,c;if(o in n?[i,c]=n[o]:o in zf?[i,c]=zf.className:o in t&&([i,c]=t[o]),null==i)throw new Tf("Unknown ".concat(a,": ").concat(o,". ")+"This may be due to one of the following reasons:\n"+"1. The ".concat(a," is defined in Python, in which ")+"case it needs to be ported to TensorFlow.js or your JavaScript code.\n"+"2. The custom ".concat(a," is defined in JavaScript, ")+"but is not registered properly with tf.serialization.registerClass().");if(null!=c){const e={};for(const n of Object.keys(zf))e[n]=zf[n];for(const r of Object.keys(n))e[r]=n[r];s.config.customObjects=e;const t=Object.assign({},zf);for(const r of Object.keys(n))zf[r]=n[r];Bf(s.config);const a=c(i,s.config,n,r);return zf=Object.assign({},t),a}{const e=Object.assign({},zf);for(const a of Object.keys(n))zf[a]=n[a];const t=new i(s.config);return zf=Object.assign({},e),t}}}function Vf(e,t){return-1*function(e,t){return e<t?-1:e>t?1:0}(e,t)}function Uf(e){if(null==e)return e;const t=[];for(const n of e)-1===t.indexOf(n)&&t.push(n);return t}function Gf(e){if(null==e)throw new Tf("Invalid value in obj: ".concat(JSON.stringify(e)));for(const t in e)if(e.hasOwnProperty(t))return!1;return!0}function Hf(e,t,n){if(null!=n&&e.indexOf(n)<0)throw new Tf("".concat(n," is not a valid ").concat(t,".  Valid values are ").concat(e," or null/undefined."))}function jf(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1/0;return _f(n>=0),_f(a>=n),Array.isArray(e)&&e.length>=n&&e.length<=a&&e.every((e=>typeof e===t))}function Kf(e,t){Array.isArray(e)?(J(e.length>0,(()=>"".concat(t," is unexpectedly an empty array."))),e.forEach(((e,n)=>Kf(e,"element ".concat(n+1," of ").concat(t))))):J(Number.isInteger(e)&&e>0,(()=>"Expected ".concat(t," to be a positive integer, but got ")+"".concat(qf(e),".")))}function qf(e){return null===e?"null":Array.isArray(e)?"["+e.map((e=>qf(e))).join(",")+"]":"string"===typeof e?'"'.concat(e,'"'):"".concat(e)}function Xf(e){return"relu"===e?"relu":"linear"===e?"linear":"elu"===e?"elu":null}let Yf=0;function Qf(){return Yf++}const Jf={};function Zf(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"";return e in Jf||(Jf[e]=0),Jf[e]+=1,e+Jf[e].toString()}const $f=["channelsFirst","channelsLast"],em=["nearest","bilinear"],tm=["valid","same","causal"],nm=["max","avg"],am=["sum","mul","concat","ave"],rm=new Map;function sm(e){Hf($f,"DataFormat",e)}function om(e){Hf(tm,"PaddingMode",e)}function im(e){Hf(nm,"PoolMode",e)}const cm=[],lm="/";function um(e,t){cm.push(e);try{const e=t();return cm.pop(),e}catch(n){throw cm.pop(),n}}function hm(e){if(!fm(e))throw new Error("Not a valid tensor name: '"+e+"'");return(0===cm.length?"":cm.join(lm)+lm)+e}function dm(e){if(!fm(e))throw new Error("Not a valid tensor name: '"+e+"'");rm.has(e)||rm.set(e,0);const t=rm.get(e);if(rm.set(e,rm.get(e)+1),t>0){const n="".concat(e,"_").concat(t);return rm.set(n,1),n}return e}const pm=new RegExp(/^[A-Za-z0-9][-A-Za-z0-9\._\/]*$/);function fm(e){return!!e.match(pm)}function mm(e,t,n){null==t&&(t=0),null==n&&(n=e.length);let a=1;for(let r=t;r<n;++r)a*=e[r];return a}function gm(e){if(0===e.length)return Number.NaN;let t=Number.POSITIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a<t&&(t=a)}return t}function ym(e){if(0===e.length)return Number.NaN;let t=Number.NEGATIVE_INFINITY;for(let n=0;n<e.length;n++){const a=e[n];a>t&&(t=a)}return t}function bm(e,t){if(t<e)throw new Tf("end (".concat(t,") < begin (").concat(e,") is forbidden."));const n=[];for(let a=e;a<t;++a)n.push(a);return n}let vm;function xm(){return null==vm&&(vm=_s().epsilon()),vm}function wm(e,t){return yo(e,t)}function km(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=e.shape.slice();return t<0&&(t=n.length+t+1),n.splice(t,0,1),Vi(e,n)}function Sm(e,t,n){return Es((()=>{switch(e.rank){case 1:return ul(e,t,n);case 2:return hl(e,[t,0],[n,e.shape[1]]);case 3:return dl(e,[t,0,0],[n,e.shape[1],e.shape[2]]);case 4:return pl(e,[t,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3]]);case 5:return ll(e,[t,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4]]);case 6:return ll(e,[t,0,0,0,0,0],[n,e.shape[1],e.shape[2],e.shape[3],e.shape[4],e.shape[5]]);default:throw new Tf("sliceAlongFirstAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function Im(e,t,n){return Es((()=>{switch(e.rank){case 1:return ul(e,t,n);case 2:return hl(e,[0,t],[e.shape[0],n]);case 3:return dl(e,[0,0,t],[e.shape[0],e.shape[1],n]);case 4:return pl(e,[0,0,0,t],[e.shape[0],e.shape[1],e.shape[2],n]);default:throw new Tf("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function Nm(e,t,n,a){return Es((()=>{switch(e.rank){case 1:return ul(e,t,n);case 2:switch(a){case 1:return Sm(e,t,n);case 2:return Im(e,t,n);default:throw new Tf("The axis is not within the rank of the tensor "+"".concat(a))}case 3:switch(a){case 1:return Sm(e,t,n);case 2:return dl(e,[0,t,0],[e.shape[0],n,e.shape[2]]);case 3:return Im(e,t,n);default:throw new Tf("The axis is not within the rank of the tensor "+"".concat(a))}case 4:switch(a){case 1:return Sm(e,t,n);case 2:return pl(e,[0,t,0,0],[e.shape[0],n,e.shape[2],e.shape[3]]);case 3:return pl(e,[0,0,t,0],[e.shape[0],e.shape[1],n,e.shape[3]]);case 4:return Im(e,t,n);default:throw new Tf("The axis is not within the rank of the tensor "+"".concat(a))}default:throw new Tf("sliceAlongLastAxis() received an unsupported tensor rank: "+"".concat(e.rank))}}))}function Tm(e){let t,n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;return n<0&&(t=e[0].rank,n=0!==t?t:0),n===e[0].rank&&(n=-1),Qi(e,n)}function Em(e,t){switch(e.rank){case 1:return Ji([e,t]);case 2:return Zi([e,t],0);case 3:return $i([e,t],0);case 4:return ec([e,t],0);default:throw new Tf("concatAlongFirstAxis() received an unsupported "+"tensor rank: ".concat(e.rank))}}function Cm(e,t){if(Array.isArray(t)||(t=[t]),e.rank!==t.length)throw new Tf("The length of input n (".concat(t.length,") does not match ")+"the number of dimensions in input x (".concat(e.rank,")"));return mc(e,t)}function Rm(e){return tl(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,arguments.length>3?arguments[3]:void 0,arguments.length>4?arguments[4]:void 0)}function Am(e,t,n,a){if(e.rank<2||t.rank<2)throw new Ef("dot requires both inputs to be rank >= 2"+" but got x shape = ".concat(e.shape," and y shape = ").concat(t.shape));if(t.rank>=3){if(e.shape.slice(-1)[0]!==t.shape.slice(-2)[0])throw new Ef("If rank y >= 3, then the second last dim"+" of y must equal the last dim of x but got x shape = ".concat(e.shape," and ")+" y shape = ".concat(t.shape))}if(2===e.rank&&2===t.rank){return Gl({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?Fm(e.rank,a,"channelsLast"):null,activation:n})}{const r=e.shape.slice(),s=r.pop();e=Vi(e,[-1,s]);const o=t.shape.slice(),i=o.pop(),c=o.pop(),l=[...o,i],u=Array.from({length:t.rank},((e,n)=>0===n?t.rank-2:n<=t.rank-2?n-1:n));t=Vi(El(t,u),[c,-1]);const h=[...r,...l];return Vi(Gl({a:e,b:t,transposeA:!1,transposeB:!1,bias:a?Fm(e.rank,a,"channelsLast"):null,activation:n}),h)}}function _m(e,t,n){return Es((()=>(t=Array.isArray(t)?xl(t,"int32"):yo(t,"int32"),bc(e,t,n))))}function Dm(e){return ko(e,e)}function Fm(e,t,n){const a=t.shape;if(1!==t.rank&&t.rank!==e)throw new Tf("Unexpected bias dimensions: ".concat(t.rank)+"; expected it to be 1 or ".concat(e));if(5===e){if("channelsFirst"===n)return 1===a.length?Vi(t,[1,a[0],1,1,1]):Vi(t,[1,a[3],a[0],a[1],a[2]]);if("channelsLast"===n)return 1===a.length?Vi(t,[1,1,1,1,a[0]]):Vi(t,[1].concat(a))}else if(4===e){if("channelsFirst"===n)return 1===a.length?Vi(t,[1,a[0],1,1]):Vi(t,[1,a[2],a[0],a[1]]);if("channelsLast"===n)return 1===a.length?Vi(t,[1,1,1,a[0]]):Vi(t,[1].concat(a))}else if(3===e){if("channelsFirst"===n)return 1===a.length?Vi(t,[1,a[0],1]):Vi(t,[1,a[1],a[0]]);if("channelsLast"===n)return 1===a.length?Vi(t,[1,1,a[0]]):Vi(t,[1].concat(a))}else if(e<3)return t;throw new Tf("Unsupported input rank by biasAdd: ".concat(t.rank))}function Om(e,t,n){return Es((()=>(null==n&&(n="channelsLast"),sm(n),vo(e,Fm(e.rank,t,n)))))}function Mm(e,t,n,a){return Es((()=>Cl(e,t,n,a)))}function Lm(e,t){return arguments.length>2&&void 0!==arguments[2]&&arguments[2]?e():t()}const zm=["fanIn","fanOut","fanAvg"],Pm=["normal","uniform","truncatedNormal"];class Bm extends Ao{fromConfigUsesCustomObjects(){return!1}getConfig(){return{}}}class Wm extends Bm{apply(e,t){return qc(e,t)}}Wm.className="Zeros",Do(Wm);class Vm extends Bm{apply(e,t){return Xc(e,t)}}Vm.className="Ones",Do(Vm);class Um extends Bm{constructor(e){if(super(),"object"!==typeof e)throw new Tf("Expected argument of type ConstantConfig but got ".concat(e));if(void 0===e.value)throw new Tf("config must have value set but got ".concat(e));this.value=e.value}apply(e,t){return Es((()=>ko(Eo(this.value),Xc(e,t))))}getConfig(){return{value:this.value}}}Um.className="Constant",Do(Um);class Gm extends Bm{constructor(e){super(),this.DEFAULT_MINVAL=-.05,this.DEFAULT_MAXVAL=.05,this.minval=e.minval||this.DEFAULT_MINVAL,this.maxval=e.maxval||this.DEFAULT_MAXVAL,this.seed=e.seed}apply(e,t){return nl(e,this.minval,this.maxval,t,this.seed)}getConfig(){return{minval:this.minval,maxval:this.maxval,seed:this.seed}}}Gm.className="RandomUniform",Do(Gm);class Hm extends Bm{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Ef("randomNormal does not support dType ".concat(t,"."));return Rm(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}Hm.className="RandomNormal",Do(Hm);class jm extends Bm{constructor(e){super(),this.DEFAULT_MEAN=0,this.DEFAULT_STDDEV=.05,this.mean=e.mean||this.DEFAULT_MEAN,this.stddev=e.stddev||this.DEFAULT_STDDEV,this.seed=e.seed}apply(e,t){if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Ef("truncatedNormal does not support dType ".concat(t,"."));return kl(e,this.mean,this.stddev,t,this.seed)}getConfig(){return{mean:this.mean,stddev:this.stddev,seed:this.seed}}}jm.className="TruncatedNormal",Do(jm);class Km extends Bm{constructor(e){super(),this.gain=null!=e.gain?e.gain:1}apply(e,t){return Es((()=>{if(2!==e.length||e[0]!==e[1])throw new Tf("Identity matrix initializer can only be used for 2D square matrices.");return ko(this.gain,gc(e[0]))}))}getConfig(){return{gain:this.gain}}}Km.className="Identity",Do(Km);class qm extends Bm{constructor(e){if(super(),e.scale<0)throw new Tf("scale must be a positive float. Got: ".concat(e.scale));var t;this.scale=null==e.scale?1:e.scale,this.mode=null==e.mode?"fanIn":e.mode,t=this.mode,Hf(zm,"FanMode",t),this.distribution=null==e.distribution?"normal":e.distribution,function(e){Hf(Pm,"Distribution",e)}(this.distribution),this.seed=e.seed}apply(e,t){const n=function(e){let t,n,a=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"channelsLast";if(sm(a),2===e.length)t=e[0],n=e[1];else if(-1!==[3,4,5].indexOf(e.length)){if("channelsFirst"===a){const a=mm(e,2);t=e[1]*a,n=e[0]*a}else if("channelsLast"===a){const a=mm(e,0,e.length-2);t=e[e.length-2]*a,n=e[e.length-1]*a}}else{const a=mm(e);t=Math.sqrt(a),n=Math.sqrt(a)}return[t,n]}(e),a=n[0],r=n[1];let s=this.scale;if("fanIn"===this.mode?s/=Math.max(1,a):"fanOut"===this.mode?s/=Math.max(1,r):s/=Math.max(1,(a+r)/2),"normal"===this.distribution){const n=Math.sqrt(s);if("float32"!==(t=t||"float32")&&"int32"!==t)throw new Ef("".concat(this.getClassName()," does not support dType ").concat(t,"."));return kl(e,0,n,t,this.seed)}{const n=Math.sqrt(3*s);return nl(e,-n,n,t,this.seed)}}getConfig(){return{scale:this.scale,mode:this.mode,distribution:this.distribution,seed:this.seed}}}qm.className="VarianceScaling",Do(qm);class Xm extends qm{constructor(e){super({scale:1,mode:"fanAvg",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return qm.className}}Xm.className="GlorotUniform",Do(Xm);class Ym extends qm{constructor(e){super({scale:1,mode:"fanAvg",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return qm.className}}Ym.className="GlorotNormal",Do(Ym);class Qm extends qm{constructor(e){super({scale:2,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return qm.className}}Qm.className="HeNormal",Do(Qm);class Jm extends qm{constructor(e){super({scale:2,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return qm.className}}Jm.className="HeUniform",Do(Jm);class Zm extends qm{constructor(e){super({scale:1,mode:"fanIn",distribution:"normal",seed:null==e?null:e.seed})}getClassName(){return qm.className}}Zm.className="LeCunNormal",Do(Zm);class $m extends qm{constructor(e){super({scale:1,mode:"fanIn",distribution:"uniform",seed:null==e?null:e.seed})}getClassName(){return qm.className}}$m.className="LeCunUniform",Do($m);class eg extends Bm{constructor(e){super(),this.DEFAULT_GAIN=1,this.ELEMENTS_WARN_SLOW=2e3,this.gain=null==e.gain?this.DEFAULT_GAIN:e.gain,this.seed=e.seed}apply(e,t){return Es((()=>{if(e.length<2)throw new Ef("Shape must be at least 2D.");if("int32"!==t&&"float32"!==t&&void 0!==t)throw new TypeError("Unsupported data type ".concat(t,"."));const n=ee(e.slice(0,-1)),a=e[e.length-1],r=n*a;r>this.ELEMENTS_WARN_SLOW&&console.warn("Orthogonal initializer is being called on a matrix with more "+"than ".concat(this.ELEMENTS_WARN_SLOW," (").concat(r,") elements: ")+"Slowness may result.");const s=Rm([Math.max(a,n),Math.min(a,n)],0,1,t,this.seed),o=Ru.qr(s,!1);let i=o[0];const c=o[1].flatten().stridedSlice([0],[Math.min(a,n)*Math.min(a,n)],[Math.min(a,n)+1]);return i=ko(i,c.sign()),n<a&&(i=i.transpose()),ko(Eo(this.gain),i.reshape(e))}))}getConfig(){return{gain:this.gain,seed:this.seed}}}eg.className="Orthogonal",Do(eg);const tg={constant:"Constant",glorotNormal:"GlorotNormal",glorotUniform:"GlorotUniform",heNormal:"HeNormal",heUniform:"HeUniform",identity:"Identity",leCunNormal:"LeCunNormal",leCunUniform:"LeCunUniform",ones:"Ones",orthogonal:"Orthogonal",randomNormal:"RandomNormal",randomUniform:"RandomUniform",truncatedNormal:"TruncatedNormal",varianceScaling:"VarianceScaling",zeros:"Zeros"};function ng(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Wf(e,_o.getMap().classNameMap,t,"initializer")}function ag(e){return Pf(e)}function rg(e){if("string"===typeof e){const t=e in tg?tg[e]:e;if("GlorotNormal"===t)return new Ym;if("GlorotUniform"===t)return new Xm;if("HeNormal"===t)return new Qm;if("HeUniform"===t)return new Jm;if("LeCunNormal"===t)return new Zm;if("LeCunUniform"===t)return new $m;{const e={};return e.className=t,e.config={},ng(e)}}return e instanceof Bm?e:ng(e)}function sg(e){return Array.isArray(e)&&Array.isArray(e[0])}function og(e){return 0===e.length?[]:Array.isArray(e[0])?e:[e]}function ig(e){let t;if(Array.isArray(e)){if(1!==e.length)throw new Tf("Expected Tensor length to be 1; got ".concat(e.length));t=e[0]}else t=e;return t}function cg(e){if(Array.isArray(e)&&Array.isArray(e[0])){if(1===e.length)return e[0];throw new Tf("Expected exactly 1 Shape; got ".concat(e.length))}return e}function lg(e){let t=0;for(const n of e)0===n.shape.length?t+=1:t+=n.shape.reduce(((e,t)=>e*t));return t}const ug="Variable";class hg{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:ug,a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;this.dtype=null==t?"float32":t,this.shape=e.shape,this.id=Qf(),n=null==n?ug:n,this.originalName=hm(n),this.name=dm(this.originalName),this.trainable_=a,this.constraint=r,this.val=function(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return ls.makeVariable(e,t,n,a)}(e,this.trainable_,this.name,this.dtype)}read(){return this.assertNotDisposed(),this.val}write(e){return this.assertNotDisposed(),function(e,t){if(e.shape.toString()!==t.shape.toString())throw new Error("Shape mismatch: "+JSON.stringify(e.shape)+" vs. "+JSON.stringify(t.shape))}(this.val,e),this.val.id!==e.id&&(this.val.assign(e),null!=this.constraint&&this.val.assign(this.constraint.apply(this.val))),this}dispose(){this.assertNotDisposed(),this.val.dispose()}assertNotDisposed(){if(this.val.isDisposed)throw new Error("LayersVariable ".concat(this.name," is already disposed."))}get trainable(){return this.trainable_}set trainable(e){this.trainable_=e,this.val.trainable=e}}function dg(e){return e.map((e=>e.read()))}function pg(e){e.forEach((e=>{e[0].write(e[1])}))}class fg{constructor(e){this.dtype=e.dtype,this.shape=e.shape,null!=e.shape?this.ndim=e.shape.length:this.ndim=e.ndim,this.maxNDim=e.maxNDim,this.minNDim=e.minNDim,this.axes=e.axes||{}}}class mg{constructor(e,t,n,a,r,s,o){this.dtype=e,this.shape=t,this.sourceLayer=n,this.inputs=a,this.callArgs=r,this.outputTensorIndex=o,this.id=Qf(),null!=s&&(this.originalName=hm(s),this.name=dm(this.originalName)),this.rank=t.length}}let gg=0;class yg{constructor(e,t){this.callArgs=t,this.id=gg++,this.outboundLayer=e.outboundLayer,this.inboundLayers=e.inboundLayers,this.nodeIndices=e.nodeIndices,this.tensorIndices=e.tensorIndices,this.inputTensors=e.inputTensors,this.outputTensors=e.outputTensors,this.inputMasks=e.inputMasks,this.outputMasks=e.outputMasks,this.inputShapes=e.inputShapes,this.outputShapes=e.outputShapes;for(const n of e.inboundLayers)null!=n&&n.outboundNodes.push(this);e.outboundLayer.inboundNodes.push(this)}getConfig(){const e=[];for(const t of this.inboundLayers)null!=t?e.push(t.name):e.push(null);return{outboundLayer:this.outboundLayer?this.outboundLayer.name:null,inboundLayers:e,nodeIndices:this.nodeIndices,tensorIndices:this.tensorIndices}}}let bg=0;class vg extends Ao{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{};super(),this._callHook=null,this._addedWeightNames=[],this._stateful=!1,this.id=bg++,this.activityRegularizer=null,this.inputSpec=null,this.supportsMasking=!1,this._trainableWeights=[],this._nonTrainableWeights=[],this._losses=[],this._updates=[],this._built=!1,this.inboundNodes=[],this.outboundNodes=[];let t=e.name;if(!t){const e=this.getClassName();t=Mf(e)+"_"+Zf(e)}if(this.name=t,this.trainable_=null==e.trainable||e.trainable,null!=e.inputShape||null!=e.batchInputShape){let t;if(null!=e.batchInputShape)t=e.batchInputShape;else if(null!=e.inputShape){let n=null;null!=e.batchSize&&(n=e.batchSize),t=[n].concat(e.inputShape)}this.batchInputShape=t;let n=e.dtype;null==n&&(n=e.inputDType),null==n&&(n="float32"),this.dtype=n}null!=e.weights?this.initialWeights=e.weights:this.initialWeights=null,this._refCount=null,this.fastWeightInitDuringBuild=!1}static nodeKey(e,t){return e.name+"_ib-"+t.toString()}getNodeAtIndex(e,t){if(0===this.inboundNodes.length)throw new Nf("The layer has never been called "+"and thus has no defined ".concat(t,"."));if(this.inboundNodes.length<=e)throw new Tf("Asked to get ".concat(t," at node ").concat(e,", ")+"but the layer has only ".concat(this.inboundNodes.length," inbound nodes."));return this.inboundNodes[e]}getInputAt(e){return Ff(this.getNodeAtIndex(e,"input").inputTensors)}getOutputAt(e){return Ff(this.getNodeAtIndex(e,"output").outputTensors)}get input(){if(this.inboundNodes.length>1)throw new If("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer input" is ill-defined. Use `getInputAt(nodeIndex)` instead.');if(0===this.inboundNodes.length)throw new If("Layer ".concat(this.name)+" is not connected, no input to return.");return Ff(this.getNodeAtIndex(0,"input").inputTensors)}get output(){if(0===this.inboundNodes.length)throw new If("Layer ".concat(this.name)+" has no inbound nodes.");if(this.inboundNodes.length>1)throw new If("Layer ".concat(this.name)+' has multiple inbound nodes, hence the notion of "layer output" is ill-defined. Use `getOutputAt(nodeIndex)` instead.');return Ff(this.getNodeAtIndex(0,"output").outputTensors)}get losses(){return this._losses}calculateLosses(){return this.losses.map((e=>e()))}get updates(){return this._updates}get built(){return this._built}set built(e){this._built=e}get trainable(){return this.trainable_}set trainable(e){this._trainableWeights.forEach((t=>t.trainable=e)),this.trainable_=e}get trainableWeights(){return this.trainable_?this._trainableWeights.filter((e=>e.trainable)):[]}set trainableWeights(e){this._trainableWeights=e}get nonTrainableWeights(){return this.trainable?this._trainableWeights.filter((e=>!e.trainable)).concat(this._nonTrainableWeights):this._trainableWeights.concat(this._nonTrainableWeights)}set nonTrainableWeights(e){this._nonTrainableWeights=e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}get stateful(){return this._stateful}resetStates(){if(!this.stateful)throw new Error("Cannot call the resetStates() method of a non-stateful Layer object.")}assertInputCompatibility(e){const t=Of(e);if(null==this.inputSpec||0===this.inputSpec.length)return;const n=Of(this.inputSpec);if(t.length!==n.length)throw new Tf("Layer ".concat(this.name," expects ").concat(n.length," inputs, ")+"but it received ".concat(t.length," input tensors. ")+"Input received: ".concat(e));for(let a=0;a<t.length;a++){const e=t[a],r=n[a];if(null==r)continue;const s=e.rank;if(null!=r.ndim&&s!==r.ndim)throw new Tf("Input ".concat(a," is incompatible with layer ").concat(this.name,": ")+"expected ndim=".concat(r.ndim,", found ndim=").concat(s));if(null!=r.maxNDim&&s>r.maxNDim)throw new Tf("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected max_ndim=".concat(r.maxNDim,", found ndim=").concat(s));if(null!=r.minNDim&&s<r.minNDim)throw new Tf("Input ".concat(a," is incompatible with layer ").concat(this.name)+": expected min_ndim=".concat(r.minNDim,", found ndim=").concat(s,"."));if(null!=r.dtype&&e.dtype!==r.dtype)throw new Tf("Input ".concat(a," is incompatible with layer ").concat(this.name," ")+": expected dtype=".concat(r.dtype,", found dtype=").concat(e.dtype,"."));if(r.axes){const t=e.shape;for(const e in r.axes){const n=Number(e),s=r.axes[e],o=n>=0?t[n]:t[t.length+n];if(null!=s&&-1===[s,null].indexOf(o))throw new Tf("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected axis ").concat(n," of input shape to ")+"have value ".concat(s," but got shape ").concat(t,"."))}}if(null!=r.shape)for(let t=0;t<r.shape.length;++t){const n=r.shape[t],s=e.shape[t];if(null!=n&&null!=s&&n!==s)throw new Tf("Input ".concat(a," is incompatible with layer ")+"".concat(this.name,": expected shape=").concat(r.shape,", ")+"found shape=".concat(e.shape,"."))}}}call(e,t){return e}invokeCallHook(e,t){null!=this._callHook&&this._callHook(e,t)}setCallHook(e){this._callHook=e}clearCallHook(){this._callHook=null}apply(e,t){t=t||{},this.assertNotDisposed();const n=Of(e),a=function(e){let t=!0;for(const n of Of(e))if(!(n instanceof mg)){t=!1;break}return t}(e),r=function(e){let t=!0;for(const n of Of(e))if(n instanceof mg){t=!1;break}return t}(e);if(a===r)throw new Tf("Arguments to apply() must be all SymbolicTensors or all Tensors");return um(this.name,(()=>{if(!this.built){this.assertInputCompatibility(e);const t=[];for(const n of Of(e))t.push(n.shape);this.build(Ff(t)),this.built=!0,this.initialWeights&&this.setWeights(this.initialWeights),null===this._refCount&&r&&(this._refCount=1)}if(this.assertInputCompatibility(e),r){let a=this.call(e,t);this.supportsMasking&&this.setMaskMetadata(e,a);const r=Of(a),s=[];for(let e of r)-1!==n.indexOf(e)&&(e=e.clone()),s.push(e);if(a=Ff(s),null!=this.activityRegularizer)throw new Ef("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return a}{const n=function(e){e=Of(e);const t=[];for(const n of e)t.push(n.shape);return Ff(t)}(e),a=this.computeOutputShape(n);let r;const s="float32";if(this.warnOnIncompatibleInputShape(Array.isArray(e)?n[0]:n),r=null!=a&&a.length>0&&Array.isArray(a[0])?a.map(((n,a)=>new mg(s,n,this,Of(e),t,this.name,a))):new mg(s,a,this,Of(e),t,this.name),this.addInboundNode(e,r,null,null,n,a,t),this._refCount++,null!=this.activityRegularizer)throw new Ef("Layer invocation in the presence of activity regularizer(s) is not supported yet.");return r}}))}warnOnIncompatibleInputShape(e){if(null!=this.batchInputShape)if(e.length!==this.batchInputShape.length)console.warn("The rank of the input tensor provided (shape: "+"".concat(JSON.stringify(e),") does not match that of the ")+"batchInputShape (".concat(JSON.stringify(this.batchInputShape),") ")+"of the layer ".concat(this.name));else{let t=!1;this.batchInputShape.forEach(((n,a)=>{null!=n&&null!=e[a]&&e[a]!==n&&(t=!0)})),t&&console.warn("The shape of the input tensor "+"(".concat(JSON.stringify(e),") does not ")+"match the expectation of layer ".concat(this.name,": ")+"".concat(JSON.stringify(this.batchInputShape)))}}get outputShape(){if(null==this.inboundNodes||0===this.inboundNodes.length)throw new If("The layer ".concat(this.name," has never been called and thus has no ")+"defined output shape.");const e=[];for(const t of this.inboundNodes){const n=JSON.stringify(t.outputShapes);-1===e.indexOf(n)&&e.push(n)}if(1===e.length){const e=this.inboundNodes[0].outputShapes;return Array.isArray(e)&&Array.isArray(e[0])&&1===e.length?e[0]:e}throw new If("The layer ".concat(this.name," has multiple inbound nodes with different ")+'output shapes. Hence the notion of "output shape" is ill-defined for the layer.')}countParams(){if(!this.built)throw new Nf("You tried to call countParams() on ".concat(this.name,", ")+"but the layer is not built yet. Build it first by calling build(batchInputShape).");return lg(this.weights)}build(e){this.built=!0}getWeights(){return dg(arguments.length>0&&void 0!==arguments[0]&&arguments[0]?this.trainableWeights:this.weights)}setWeights(e){Es((()=>{const t=this.weights;if(t.length!==e.length)throw new Tf('You called setWeights(weights) on layer "'.concat(this.name,'" ')+"with a weight list of length ".concat(e.length,", ")+"but the layer was expecting ".concat(t.length," weights. ")+"Provided weights: ".concat(e,"..."));if(0===t.length)return;const n=[],a=dg(t);for(let r=0;r<a.length;++r){const s=a[r],o=t[r],i=e[r];if(!te(s.shape,i.shape))throw new Tf("Layer weight shape ".concat(s.shape," ")+"not compatible with provided weight shape ".concat(i.shape));n.push([o,i])}pg(n)}))}addWeight(e,t,n,a,r,s,o,i){if(-1!==this._addedWeightNames.indexOf(e))throw new Tf("Duplicate weight name ".concat(e," for layer ").concat(this.name));this._addedWeightNames.push(e),null==n&&(n="float32"),this.fastWeightInitDuringBuild&&(a=null!=i?i():rg("zeros"));const c=a.apply(t,n),l=new hg(c,n,e,s,o);return c.dispose(),null!=r&&this.addLoss((()=>r.apply(l.read()))),null==s&&(s=!0),s?this._trainableWeights.push(l):this._nonTrainableWeights.push(l),l}setFastWeightInitDuringBuild(e){this.fastWeightInitDuringBuild=e}addLoss(e){null==e||Array.isArray(e)&&0===e.length||(e=Of(e),void 0!==this._losses&&null!==this._losses&&this.losses.push(...e))}computeOutputShape(e){return e}computeMask(e,t){if(!this.supportsMasking){if(null!=t){if(!Array.isArray(t))throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.");t.forEach((e=>{if(null!=e)throw new TypeError("Layer ".concat(this.name," does not support masking, ")+"but was passed an inputMask.")}))}return null}return t}setMaskMetadata(e,t,n){if(!this.supportsMasking)return;const a=this.computeMask(e,n),r=Of(t),s=Of(a);if(r.length!==s.length)throw new Error("".concat(this.name," outputs ").concat(r.length," tensors ")+"but ".concat(r.length," masks for those tensors"));for(let o=0;o<r.length;o++)r[o].kerasMask=s[o]}addInboundNode(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const i=Of(e);t=Of(t),n=Of(n),a=Of(a),r=og(r),s=og(s);const c=[],l=[],u=[];for(const h of i)c.push(h.sourceLayer),l.push(h.nodeIndex),u.push(h.tensorIndex);new yg({outboundLayer:this,inboundLayers:c,nodeIndices:l,tensorIndices:u,inputTensors:i,outputTensors:t,inputMasks:n,outputMasks:a,inputShapes:r,outputShapes:s},o);for(let h=0;h<t.length;h++)t[h].sourceLayer=this,t[h].nodeIndex=this.inboundNodes.length-1,t[h].tensorIndex=h}getConfig(){const e={name:this.name,trainable:this.trainable};return null!=this.batchInputShape&&(e.batchInputShape=this.batchInputShape),null!=this.dtype&&(e.dtype=this.dtype),e}disposeWeights(){return this.weights.forEach((e=>e.dispose())),this.weights.length}assertNotDisposed(){if(0===this._refCount)throw new Error("Layer '".concat(this.name,"' is already disposed."))}dispose(){if(!this.built)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been ")+"built yet.");if(null===this._refCount)throw new Error("Cannot dispose Layer ".concat(this.name," because it has not been used ")+"yet.");this.assertNotDisposed();let e=0;return 0===--this._refCount&&(e=this.disposeWeights()),{refCountAfterDispose:this._refCount,numDisposedVariables:e}}}function xg(e,t,n){if((null==t||null!=n&&n>0)&&(t=e.sourceLayer,n=e.nodeIndex),0===t.inboundNodes.length)return[e];{const e=t.inboundNodes[n];if(0===e.inboundLayers.length)return e.inputTensors;{const t=[];for(let n=0;n<e.inboundLayers.length;n++){const a=xg(e.inputTensors[n],e.inboundLayers[n],e.nodeIndices[n]);for(const e of a)-1===t.indexOf(e)&&t.push(e)}return t}}}class wg extends vg{constructor(e){if(super({dtype:e.dtype,name:null!=e.name?e.name:Zf("input").toString()}),null==e.batchSize&&(e.batchSize=null),null==e.sparse&&(e.sparse=!1),this.trainable=!1,this.built=!0,this.sparse=e.sparse,null!=e.inputShape&&null!=e.batchInputShape)throw new Tf("Only provide the inputShape OR batchInputShape argument to inputLayer, not both at the same time.");let t=e.batchInputShape;if(null==t){if(null==e.inputShape)throw new Tf("An InputLayer should be passed either a `batchInputShape` or an `inputShape`.");t=[e.batchSize].concat(e.inputShape)}else if(null!=e.batchSize)throw new Tf("Cannot specify batchSize if batchInputShape is specified when creating an InputLayer.");const n=e.dtype||"float32";this.batchInputShape=t,this.dtype=n,this.inputSpec=[{shape:t}];const a=new mg(this.dtype,this.batchInputShape,this,[],{},this.name);a.nodeIndex=0,a.tensorIndex=0,new yg({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:[a],outputTensors:[a],inputMasks:[null],outputMasks:[null],inputShapes:[t],outputShapes:[t]})}apply(e,t){throw new Tf("Cannot pass any input to an "+"InputLayer's apply() method. InputLayer name: ".concat(this.name))}dispose(){return{refCountAfterDispose:this._refCount,numDisposedVariables:0}}getConfig(){return{batchInputShape:this.batchInputShape,dtype:this.dtype,sparse:this.sparse,name:this.name}}}wg.className="InputLayer",Do(wg);class kg{constructor(e){if(this.id2Value={},this.id2Mask={},this.name2Id={},e instanceof kg)for(const t in e.id2Value)this.id2Value[t]=e.id2Value[t],t in e.id2Mask&&(this.id2Mask[t]=e.id2Mask[t]);else{if(null==e)return;for(const t of e)this.add(t.key,t.value)}}add(e,t,n){if(null!=this.id2Value[e.id])throw new Tf("Duplicate key: name=".concat(e.name,", id=").concat(e.id));return this.id2Value[e.id]=function(e,t){if(null==e.dtype||e.dtype===t.dtype)return t;try{return yo(t,e.dtype)}catch(o1){throw new Tf("The dtype of the feed (".concat(t.dtype,") can not be cast to the dtype ")+"of the key '".concat(e.name,"' (").concat(e.dtype,")."))}}(e,t),this.name2Id[e.name]=e.id,null!=n&&(this.id2Mask[e.id]=n),this}addFeed(e){this.add(e.key,e.value)}hasKey(e){return null!=this.id2Value[e.id]}names(){return Object.keys(this.name2Id)}getValue(e){if(e instanceof mg){if(null==this.id2Value[e.id])throw new Tf("Nonexistent key: ".concat(e.name));return this.id2Value[e.id]}{const t=this.name2Id[e];if(null==t)throw new Tf("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Value[t]}}getMask(e){if(e instanceof mg){if(null==this.id2Value[e.id])throw new Tf("Nonexistent key: ".concat(e.name));return this.id2Mask[e.id]}{const t=this.name2Id[e];if(null==t)throw new Tf("Feed dict has no SymbolicTensor name: ".concat(e));return this.id2Mask[t]}}disposeMasks(){null!=this.id2Mask&&Cs(this.id2Mask)}}const Sg=new Rf,Ig=new Rf;function Ng(e,t,n,a){const r=null!=n&&n.training,s=Array.isArray(e),o=s?e:[e],i=o.map((e=>e.name)),c=[],l=t.names();for(const f of i)-1!==l.indexOf(f)?c.push(t.getValue(f)):c.push(null);null!=a&&(a.maxNumTensors=-1/0,a.minNumTensors=1/0);const u=i.join(",")+"|"+t.names().sort().join(",");let h,d=Sg.get(u);if(null==d){const e=function(e,t){J(null!=e&&e.length>0,(()=>"Expected at least one fetch, got none"));let n=[],a={};if(1===e.length){const r=Eg(e[0],t);n=r.sorted,a=r.recipientMap}else{const r=new Set;for(const s of e){const{sorted:e,recipientMap:o}=Eg(s,t);for(const t of e)r.has(t.name)||(n.push(t),r.add(t.name));for(const t in o)null==a[t]&&(a[t]=new Set),o[t].forEach((e=>a[t].add(e)))}}return{sorted:n,recipientCounts:Tg(a)}}(o,t);d=e.sorted,h=e.recipientCounts,Sg.put(u,d),Ig.put(u,h)}h={},r||Object.assign(h,Ig.get(u));const p=new kg(t);for(let f=0;f<d.length;++f){if(null!=a){const e=Ts().numTensors;e>a.maxNumTensors&&(a.maxNumTensors=e),e<a.minNumTensors&&(a.minNumTensors=e)}const e=d[f],s=e.sourceLayer;if(s instanceof wg)continue;const o=[],l=[],u=[];let m=!1;for(const n of e.inputs){const e=p.getValue(n),a=p.getMask(n);o.push(e),l.push(a),null!=a&&(m=!0),r||(h[n.name]--,0!==h[n.name]||t.hasKey(n)||-1!==i.indexOf(n.name)||e.isDisposed||!0===n.sourceLayer.stateful||u.push(e))}m&&((n=n||{}).mask=l[0]);const g=Of(s.apply(o,n));let y=null;s.supportsMasking&&(y=s.computeMask(o,l));const b=Cg(e),v=Array.isArray(b)?b:[b];for(let t=0;t<v.length;++t){p.hasKey(v[t])||p.add(v[t],g[t],Array.isArray(y)?y[0]:y);const e=i.indexOf(v[t].name);-1!==e&&(c[e]=g[t])}r||Cs(u)}return p.disposeMasks(),s?c:c[0]}function Tg(e){const t={};for(const n in e)t[n]=e[n].size;return t}function Eg(e,t){const n=new Set,a=[],r={};for(const i of t.names())n.add(i);const s=[],o=[];for(s.push(e);s.length>0;){const e=s[s.length-1];if(n.has(e.name)){s.pop();continue}const t=o[o.length-1]===s.length-1;if(0===e.inputs.length||t)s.pop(),a.push(e),n.add(e.name),t&&o.pop();else{o.push(s.length-1);for(const t of e.inputs)null==r[t.name]&&(r[t.name]=new Set),r[t.name].add(e.name),n.has(t.name)||s.push(t)}}return{sorted:a,recipientMap:r}}function Cg(e){let t;if(1===e.sourceLayer.inboundNodes.length)t=e.sourceLayer.output;else{let n=null;for(let t=0;t<e.sourceLayer.inboundNodes.length;++t)for(const a of e.sourceLayer.inboundNodes[t].outputTensors)if(a.id===e.id){n=t;break}t=e.sourceLayer.getOutputAt(n)}return t}function Rg(e,t){return Es((()=>So(Nc(ko(e,e),t,!0))))}_e().registerFlag("TOPOLOGICAL_SORT_CACHE_MAX_ENTRIES",(()=>100),(function(e){null!=Sg&&Sg.setMaxEntries(e),null!=Ig&&Ig.setMaxEntries(e)}));class Ag extends Ao{getConfig(){return{}}}class _g extends Ag{constructor(e){super(),this.defaultMaxValue=2,this.defaultAxis=0,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Es((()=>{const t=Rg(e,this.axis),n=Yi(t,0,this.maxValue);return ko(e,wo(n,vo(xm(),t)))}))}getConfig(){return{maxValue:this.maxValue,axis:this.axis}}}_g.className="MaxNorm",Do(_g);class Dg extends Ag{constructor(e){super(),this.defaultAxis=0,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Es((()=>wo(e,vo(xm(),Rg(e,this.axis)))))}getConfig(){return{axis:this.axis}}}Dg.className="UnitNorm",Do(Dg);class Fg extends Ag{apply(e){return rl(e)}}Fg.className="NonNeg",Do(Fg);class Og extends Ag{constructor(e){super(),this.defaultMinValue=0,this.defaultMaxValue=1,this.defaultRate=1,this.defaultAxis=0,this.minValue=null!=e.minValue?e.minValue:this.defaultMinValue,this.maxValue=null!=e.maxValue?e.maxValue:this.defaultMaxValue,this.rate=null!=e.rate?e.rate:this.defaultRate,this.axis=null!=e.axis?e.axis:this.defaultAxis}apply(e){return Es((()=>{const t=Rg(e,this.axis),n=vo(ko(this.rate,Yi(t,this.minValue,this.maxValue)),ko(1-this.rate,t));return ko(e,wo(n,vo(xm(),t)))}))}getConfig(){return{minValue:this.minValue,maxValue:this.maxValue,rate:this.rate,axis:this.axis}}}Og.className="MinMaxNorm",Do(Og);const Mg={maxNorm:"MaxNorm",minMaxNorm:"MinMaxNorm",nonNeg:"NonNeg",unitNorm:"UnitNorm"};function Lg(e){return Pf(e)}function zg(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Wf(e,_o.getMap().classNameMap,t,"constraint")}function Pg(e){if(null==e)return null;if("string"===typeof e){return zg({className:e in Mg?Mg[e]:e,config:{}})}return e instanceof Ag?e:zg(e)}async function Bg(e){if(null==e)return;const t=[],n=[],a=[];for(const r in e){const s=e[r];if("number"!==typeof s){const e=s;t.push(e.data()),n.push(r),a.push(e)}}if(t.length>0){const r=await Promise.all(t);for(let t=0;t<r.length;++t)e[n[t]]=r[t][0];Cs(a)}}function Wg(e){if(null!=e)for(const t in e){const n=e[t];"number"!==typeof n&&n.dispose()}}var Vg;!function(e){e[e.SILENT=0]="SILENT",e[e.VERBOSE=1]="VERBOSE"}(Vg||(Vg={}));class Ug{constructor(){this.validationData=null}setParams(e){this.params=e}async onEpochBegin(e,t){}async onEpochEnd(e,t){}async onBatchBegin(e,t){}async onBatchEnd(e,t){}async onTrainBegin(e){}async onTrainEnd(e){}setModel(e){}}class Gg{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:10;null==e&&(e=[]),this.callbacks=e,this.queueLength=t}append(e){this.callbacks.push(e)}setParams(e){for(const t of this.callbacks)t.setParams(e)}setModel(e){for(const t of this.callbacks)t.setModel(e)}async onEpochBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochBegin(e,t)}async onEpochEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onEpochEnd(e,t)}async onBatchBegin(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchBegin(e,t)}async onBatchEnd(e,t){null==t&&(t={});for(const n of this.callbacks)await n.onBatchEnd(e,t)}async onTrainBegin(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainBegin(e)}async onTrainEnd(e){null==e&&(e={});for(const t of this.callbacks)await t.onTrainEnd(e)}}class Hg extends Ug{constructor(){super()}async onEpochBegin(e){this.seen=0,this.totals={}}async onBatchEnd(e,t){null==t&&(t={});const n=null==t.size?0:t.size;this.seen+=n;for(const a in t){const e=t[a];if("number"===typeof e)this.totals.hasOwnProperty(a)||(this.totals[a]=0),this.totals[a]=this.totals[a]+e*n;else{let t;a in this.totals?t=this.totals[a]:this.totals[a]=0;const r=Es((()=>vo(this.totals[a],ko(e,n))));this.totals[a]=r,null!=t&&t.dispose()}}}async onEpochEnd(e,t){if(null!=t)for(const n of this.params.metrics)null!=this.totals[n]&&("number"===typeof this.totals[n]?t[n]=this.totals[n]/this.seen:Es((()=>{const e=ko(wo(1,this.seen),this.totals[n]);t[n]=e,this.totals[n].dispose(),Rs(t[n])})))}}class jg extends Ug{async onTrainBegin(e){this.epoch=[],this.history={}}async onEpochEnd(e,t){null==t&&(t={}),this.epoch.push(e);for(const n in t)null==this.history[n]&&(this.history[n]=[]),this.history[n].push(t[n])}async syncData(){const e=[],t=[],n=[];for(const r in this.history){const a=this.history[r];for(let s=0;s<a.length;++s)if("number"!==typeof a[s]){const o=a[s];e.push(o.data()),t.push(r),n.push(s)}}const a=await Promise.all(e);for(let r=0;r<a.length;++r){this.history[t[r]][n[r]].dispose(),this.history[t[r]][n[r]]=a[r][0]}}}class Kg extends Ug{constructor(e,t){if(super(),this.currentEpoch=0,this.nowFunc=e.nowFunc,this.nextFrameFunc=e.nextFrameFunc||Du,this.yieldEvery=t||"auto","auto"===this.yieldEvery&&(this.yieldEvery=125),"never"===this.yieldEvery&&null!=e.onYield)throw new Error("yieldEvery is `never` but you provided an `onYield` callback. Either change `yieldEvery` or remove the callback");fe(this.yieldEvery)&&(this.maybeWait=function(e,t,n){let a,r=null!=n?n():kr();return function(){const s=null!=n?n():kr();return s-r<t||(r=s,a=e(...arguments)),a}}(this.maybeWait.bind(this),this.yieldEvery,this.nowFunc)),this.trainBegin=e.onTrainBegin,this.trainEnd=e.onTrainEnd,this.epochBegin=e.onEpochBegin,this.epochEnd=e.onEpochEnd,this.batchBegin=e.onBatchBegin,this.batchEnd=e.onBatchEnd,this.yield=e.onYield}async maybeWait(e,t,n){const a=[];null!=this.yield&&(await Bg(n),a.push(this.yield(e,t,n))),a.push(this.nextFrameFunc()),await Promise.all(a)}async onEpochBegin(e,t){this.currentEpoch=e,null!=this.epochBegin&&(await Bg(t),await this.epochBegin(e,t))}async onEpochEnd(e,t){const n=[];null!=this.epochEnd&&(await Bg(t),n.push(this.epochEnd(e,t))),"epoch"===this.yieldEvery&&n.push(this.nextFrameFunc()),await Promise.all(n)}async onBatchBegin(e,t){null!=this.batchBegin&&(await Bg(t),await this.batchBegin(e,t))}async onBatchEnd(e,t){const n=[];null!=this.batchEnd&&(await Bg(t),n.push(this.batchEnd(e,t))),"batch"===this.yieldEvery?n.push(this.nextFrameFunc()):fe(this.yieldEvery)&&n.push(this.maybeWait(this.currentEpoch,e,t)),await Promise.all(n)}async onTrainBegin(e){null!=this.trainBegin&&(await Bg(e),await this.trainBegin(e))}async onTrainEnd(e){null!=this.trainEnd&&(await Bg(e),await this.trainEnd(e))}}function qg(e,t){if(null==e&&(e={}),e instanceof Ug)return[e];if(Array.isArray(e)&&e[0]instanceof Ug)return e;return Of(e).map((e=>new Kg(e,t)))}class Xg{constructor(){}static registerCallbackConstructor(e,t){J(e>=0&&Number.isInteger(e),(()=>"Verbosity level is expected to be an integer >= 0, "+"but got ".concat(e))),Xg.checkForDuplicate(t),null==Xg.constructors[e]&&(Xg.constructors[e]=[]),Xg.constructors[e].push(t)}static checkForDuplicate(e){for(const t in Xg.constructors){Xg.constructors[+t].forEach((t=>{if(t===e)throw new Tf("Duplicate callback constructor.")}))}}static clear(){Xg.constructors={}}static createCallbacks(e){const t=[];for(const n in Xg.constructors){const a=+n;e>=a&&t.push(...Xg.constructors[a])}return t.map((e=>new e))}}function Yg(e,t,n,a,r,s,o,i,c){const l=new jg,u=[new Hg,...Xg.createCallbacks(t)];null!=e&&u.push(...e),u.push(l);const h=new Gg(u);return h.setParams({epochs:n,initialEpoch:a,samples:r,steps:s,batchSize:o,verbose:t,doValidation:i,metrics:c}),{callbackList:h,history:l}}function Qg(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Wf(e,_o.getMap().classNameMap,t,"layer",n)}function Jg(e,t){return Es((()=>{"float32"!==e.dtype&&(e=yo(e,"float32"));const n=Nc(Dm(e),t,!0),a=Mo(n.shape,xm()),r=So(Ho(n,a));return wo(e,r)}))}function Zg(e,t){return Es((()=>Wc(Dm(Po(t,e)),-1)))}function $g(e,t){return Es((()=>Wc(Wo(Po(t,e)),-1)))}function ey(e,t){return Es((()=>{const n=Po(e,t),a=Yi(Wo(e),xm(),Number.MAX_VALUE),r=Wo(wo(n,a));return ko(100,Wc(r,-1))}))}function ty(e,t){return Es((()=>{const n=Yi(t,xm(),Number.MAX_VALUE),a=kc(vo(1,n)),r=Yi(e,xm(),Number.MAX_VALUE),s=kc(vo(1,r));return Wc(Dm(Po(a,s)),-1)}))}function ny(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Es((()=>{if(n)t=fl(t);else{const e=Nc(t,t.shape.length-1,!0);t=wo(t,e)}return t=Yi(t,xm(),1-xm()),Hc(Nc(ko(yo(e,"float32"),kc(t)),t.shape.length-1))}))}function ay(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Es((()=>{const a=yo(yc(function(e){const t=[mm(e.shape)];return Vi(e,t)}(e)),"int32"),r=(t=Yi(t,xm(),1-xm())).shape;return ny(Vi(Kc(a,r[r.length-1]),r),t,n)}))}function ry(e,t){return Es((()=>{let n;return n=Yi(t,xm(),1-xm()),n=kc(wo(n,Po(1,n))),Wc(function(e,t){if(!te(e.shape,t.shape))throw new Tf("logits and labels must have the same shape, but got shapes "+"".concat(JSON.stringify(e.shape)," and ").concat(JSON.stringify(t.shape)));return Es((()=>{const n=rl(t),a=Hc(Wo(t));return vo(Po(n,ko(t,e)),Sc(pc(a)))}))}(e,n),-1)}))}function sy(e,t){return Es((()=>{const n=Yi(e,xm(),1),a=Yi(t,xm(),1);return Nc(ko(e,kc(wo(n,a))),-1)}))}function oy(e,t){return Es((()=>{const n=Jg(e,-1),a=Jg(t,-1),r=ko(n,a);return Hc(Nc(r,-1))}))}Xg.constructors={};const iy={meanSquaredError:Zg,meanAbsoluteError:$g,meanAbsolutePercentageError:ey,meanSquaredLogarithmicError:ty,squaredHinge:function(e,t){return Es((()=>{const n=Ho(0,Po(1,ko(e,t)));return Wc(Dm(n),-1)}))},hinge:function(e,t){return Es((()=>{const n=Ho(0,Po(1,ko(e,t)));return Wc(n,-1)}))},categoricalHinge:function(e,t){return Es((()=>{const n=Nc(ko(e,t),-1),a=Ic(ko(Po(1,e),t),-1);return Ho(0,vo(1,Po(a,n)))}))},logcosh:function(e,t){return Es((()=>{const n=Math.log(2),a=Po(t,e),r=Po(vo(a,ml(ko(-2,a))),n);return Wc(r,-1)}))},categoricalCrossentropy:ny,sparseCategoricalCrossentropy:ay,binaryCrossentropy:ry,kullbackLeiblerDivergence:sy,poisson:function(e,t){return Es((()=>{const n=kc(vo(xm(),t));return Wc(Po(t,ko(e,n)),-1)}))},cosineProximity:oy};function cy(e){if("string"===typeof e){if(e in iy)return iy[e];let t="Unknown loss ".concat(e);throw e.toLowerCase().includes("softmaxcrossentropy")&&(t="Unknown loss ".concat(e,". ")+'Use "categoricalCrossentropy" as the string name for tf.losses.softmaxCrossEntropy'),new Tf(t)}return e}function ly(e,t){return Es((()=>{const n=ko(.5,Yc(t)),a=wm(vc(t,n),e.dtype);return Wc(hc(e,a),-1)}))}function uy(e,t){return Es((()=>wm(hc(Ni(e,-1),Ni(t,-1)),"float32")))}function hy(e,t){return Es((()=>yo(Nc(Lc(hc(e,1),hc(t,1))),"float32")))}function dy(e,t){return ry(e,t)}function py(e,t){return e.rank===t.rank&&(e=yl(e,[e.rank-1])),(t=Ni(t,-1)).dtype!==e.dtype&&(t=yo(t,e.dtype)),yo(hc(e,t),"float32")}const fy=ny,my=ay,gy={binaryAccuracy:ly,categoricalAccuracy:uy,precision:function(e,t){return Es((()=>{const n=hy(e,t),a=function(e,t){return Es((()=>yo(Nc(Lc(hc(e,0),hc(t,1))),"float32")))}(e,t),r=vo(n,a);return yo(Il(vc(r,0),wo(n,r),0),"float32")}))},categoricalCrossentropy:fy,sparseCategoricalCrossentropy:my,mse:Zg,MSE:Zg,mae:$g,MAE:$g,mape:ey,MAPE:ey,cosine:oy};function yy(e){if("string"===typeof e&&e in gy)return gy[e];if("string"!==typeof e&&null!=e)return e;throw new Tf("Unknown metric ".concat(e))}function by(e){if(_f(null!==e,"Unknown LossOrMetricFn ".concat(e)),"string"===typeof e)return e;{let t;for(const n of Object.keys(iy))if(iy[n]===e){t=n;break}if(void 0!==t)return t;for(const n of Object.keys(gy))if(gy[n]===e){t=n;break}return void 0!==t?t:e.name}}const vy=1048576;function xy(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==e||"object"!==typeof e||Object.getPrototypeOf(e)!==Object.prototype||!wy(e))throw new Error("User-defined metadata is expected to be a JSON object, but is not.");if(n){const n=JSON.stringify(e);n.length>vy&&console.warn('User-defined metadata of model "'.concat(t,'" is too large in ')+"size (length=".concat(n.length," when serialized). It is not ")+"recommended to store such large objects in user-defined metadata. Please make sure its serialized length is <= "+"".concat(vy,"."))}}function wy(e){if(null===e)return!0;if("object"===typeof e){if(Object.getPrototypeOf(e)===Object.prototype){const t=Object.keys(e);for(const n of t){if("string"!==typeof n)return!1;if(!wy(e[n]))return!1}return!0}if(Array.isArray(e)){for(const t of e)if(!wy(t))return!1;return!0}return!1}{const t=typeof e;return"string"===t||"number"===t||"boolean"===t}}function ky(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:console.log;const r=function(e){let t=!0;const n=[],a=[];for(const r in e.nodesByDepth)n.push(e.nodesByDepth[r]);for(const r of n){if(r.length>1||1===r.length&&r[0].inboundLayers.length>1){t=!1;break}a.push(...r)}if(t)for(const r of e.layers){let e=!1;for(const n of r.inboundNodes)if(-1!==a.indexOf(n)){if(e){t=!1;break}e=!0}if(!t)break}return t}(e),s=["Layer (type)","Input Shape","Output shape","Param #"];let o;if(r?(t=t||90,n=n||[.32,.61,.89,1]):(t=t||115,n=n||[.24,.48,.7,.8,1]),n[n.length-1]<=1&&(n=n.map((e=>Math.floor(t*e)))),!r){s.push("Receives inputs"),o=[];for(const t in e.nodesByDepth)o.push(...e.nodesByDepth[t])}a("_".repeat(t)),Sy(s,n,a),a("=".repeat(t));const i=e.layers;for(let u=0;u<i.length;++u)r?Iy(i[u],n,a):Ny(i[u],n,o,a),a((u===i.length-1?"=":"_").repeat(t));e.checkTrainableWeightsConsistency();const c=function(e){let t;t=null!=e.collectedTrainableWeights?lg(e.collectedTrainableWeights):lg(e.trainableWeights);return t}(e),l=lg(e.nonTrainableWeights);a("Total params: ".concat(c+l)),a("Trainable params: ".concat(c)),a("Non-trainable params: ".concat(l)),a("_".repeat(t))}function Sy(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log,a="";for(let r=0;r<e.length;++r)r>0&&(a=a.slice(0,a.length-1)+" "),a+=e[r],a=a.slice(0,t[r]),a+=" ".repeat(t[r]-a.length);n(a)}function Iy(e,t,n){let a,r;try{r=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(o1){r="multiple"}try{a=JSON.stringify(e.outputShape)}catch(o1){a="multiple"}const s=e.name,o=e.getClassName();Sy(["".concat(s," (").concat(o,")"),r,a,e.countParams().toString()],t,n)}function Ny(e,t,n,a){let r,s;try{s=e.inboundNodes.map((e=>JSON.stringify(e.inputShapes))).join(",")}catch(o1){s="multiple"}try{r=JSON.stringify(e.outputShape)}catch(o1){r="multiple"}const o=[];for(const u of e.inboundNodes)if(!(null!=n&&n.length>0&&-1===n.indexOf(u)))for(let e=0;e<u.inboundLayers.length;++e){const t=u.inboundLayers[e].name,n=u.nodeIndices[e],a=u.tensorIndices[e];o.push("".concat(t,"[").concat(n,"][").concat(a,"]"))}const i=e.name,c=e.getClassName(),l=0===o.length?"":o[0];Sy(["".concat(i," (").concat(c,")"),s,r,e.countParams().toString(),l],t,a);for(let u=1;u<o.length;++u)Sy(["","","","",o[u]],t,a)}function Ty(e,t,n){return("inboundNodes"===e||"outputLayers"===e||"inputLayers"===e)&&0===t&&"string"===typeof n}function Ey(e,t){if(null===e)return null;if("string"===typeof e)return Lf(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];Ty(t,r,a)?n.push(a):n.push(Ey(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n];if("name"===n&&"string"===typeof a)t[n]=a;else{const e=Lf(n);t[e]=Ey(a,e)}}return t}}function Cy(e,t){if(null===e||void 0===e)return null;if("string"===typeof e)return Mf(e);if("number"===typeof e||"boolean"===typeof e)return e;if(e instanceof Array){const n=[],a=e.length;for(let r=0;r<a;++r){const a=e[r];Ty(t,r,a)?n.push(a):n.push(Cy(a,t))}return n}{const t={};for(const n of Object.keys(e)){const a=e[n],r=Mf(n);t[r]="name"!==n&&"className"!==n||"string"!==typeof a?Cy(a,n):a}return t}}const Ry="4.19.0";class Ay extends vg{constructor(e){if(super({}),this.containerNodes=new Set,this.name=e.name,null==this.name){const e=this.getClassName().toLowerCase();this.name=Zf(e)}if(this.supportsMasking=!1,this.trainable_=!0,Array.isArray(e.inputs)?this.inputs=e.inputs.slice():this.inputs=[e.inputs],Array.isArray(e.outputs)?this.outputs=e.outputs.slice():this.outputs=[e.outputs],Uf(this.inputs).length!==this.inputs.length)throw new Tf("The list of inputs passed to the model is redundant. All inputs should only appear once. Found: "+"".concat(this.inputs.map((e=>e.name))));Uf(this.outputs).length!==this.outputs.length&&console.warn("The list of outputs passed to the model is redundant. All outputs should only appear once. Found: "+"".concat(this.outputs.map((e=>e.name)))),this.inputLayers=[],this.inputLayersNodeIndices=[],this.inputLayersTensorIndices=[],this.outputLayers=[],this.outputLayersNodeIndices=[],this.outputLayersTensorIndices=[],this.layers=[],this.internalContainerRefs=[];for(const y of this.outputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;this.outputLayers.push(e),this.outputLayersNodeIndices.push(t),this.outputLayersTensorIndices.push(n)}for(const y of this.inputs){const e=y.sourceLayer,t=y.nodeIndex,n=y.tensorIndex;_f(0===t,"input layer has >1 nodes"),_f(0===n,"input layer has >1 tensors"),this.inputLayers.push(e),this.inputLayersNodeIndices.push(t),this.inputLayersTensorIndices.push(n)}this.inputNames=[],this.outputNames=[],this.feedInputShapes=[],this.feedInputNames=[],this.feedOutputNames=[];for(let y=0;y<this.inputLayers.length;y++){const t=this.inputLayers[y];if(!(t instanceof wg))throw new TypeError("Input layers to a LayersModel must be InputLayer objects. "+"Received inputs: ".concat(e.inputs,". ")+"Input ".concat(y," (0-based) originates ")+"from layer type ".concat(t.getClassName(),"."));this.inputNames.push(t.name),this.feedInputShapes.push(t.batchInputShape),this.feedInputNames.push(t.name)}for(const y of this.outputLayers)this.outputNames.push(y.name);this.internalInputShapes=this.inputs.map((e=>e.shape)),this.internalOutputShapes=this.outputs.map((e=>e.shape));const t={},n={},a={},r={},s={},o=[],i=(e,t,n,a,r,c)=>{null!=a&&null!=r&&null!=c||(a=e.sourceLayer,r=e.nodeIndex,c=e.tensorIndex);const l=a.inboundNodes[r];if(-1!==n.indexOf(l))throw new Nf("The tensor ".concat(e.name,' at layer "').concat(a.name,'" ')+"is part of a cycle.");if(-1!==t.indexOf(l))return;this.containerNodes.add(Ay.nodeKey(a,r)),a.id in s||(s[a.id]=Object.keys(s).length),-1===n.indexOf(l)&&n.push(l);const u=l.inboundLayers.length;for(let s=0;s<u;s++){const e=l.inputTensors[s],a=l.inboundLayers[s],r=l.nodeIndices[s],o=l.tensorIndices[s];i(e,t,n,a,r,o)}for(t.push(l);n.indexOf(l)>=0;)n.splice(n.indexOf(l),1);o.push(l)},c=[],l=[];for(const y of this.outputs)i(y,c,l);const u=o.slice().reverse();for(const y of u){n[y.id]=y,y.id in t||(t[y.id]=0);let e=t[y.id];const s=null==a[y.outboundLayer.id]?0:a[y.outboundLayer.id];e=Math.max(e,s),a[y.outboundLayer.id]=e,r[y.outboundLayer.id]=y.outboundLayer,t[y.id]=e;for(let a=0;a<y.inboundLayers.length;a++){const r=y.inboundLayers[a],s=y.nodeIndices[a],o=r.inboundNodes[s],i=null==t[o.id]?0:t[o.id];t[o.id]=Math.max(e+1,i),n[o.id]=o}}const h={};for(const y in t){const e=t[y];e in h||(h[e]=[]),h[e].push(n[y])}const d={};for(const y in a){const e=a[y];e in d||(d[e]=[]),d[e].push(r[y])}let p=Object.keys(d).map((e=>parseInt(e,10))).sort(Vf);this.layers=[];for(const y of p){const e=d[y];e.sort(((e,t)=>{const n=s[e.id],a=s[t.id];return n<a?-1:n>a?1:0}));for(const t of e)t instanceof Ay&&this.internalContainerRefs.push(t),this.layers.push(t)}this.layersByDepth=d,p=Object.keys(h).map((e=>parseInt(e,10))).sort(Vf);const f=this.inputs.slice(),m=[];for(const y of p)for(const e of h[y]){const t=e.outboundLayer;if(null!=t){for(const n of e.inputTensors)if(-1===f.indexOf(n))throw new Nf("Graph disconnected: cannot obtain value for tensor ".concat(n)+' at layer "'.concat(t.name,'". ')+"The following previous layers were accessed without "+"issue: ".concat(m));for(const t of e.outputTensors)f.push(t);m.push(t.name)}}this.nodesByDepth=h;const g=this.layers.map((e=>e.name));for(const y of g){const e=g.filter((e=>e===y)).length;if(1!==e)throw new Nf('The name "'.concat(y,'" is used ').concat(e," times ")+"in the model. All layer names should be unique. Layer names: "+JSON.stringify(g))}this.outboundNodes=[],this.inboundNodes=[],new yg({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:this.inputs.map((e=>null)),outputMasks:this.outputs.map((e=>null)),inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs.map((e=>e.shape))}),this.built=!0,this._refCount=1}assertNotDisposed(){if(0===this._refCount)throw new Error("Container '".concat(this.name,"' is already disposed."))}dispose(){this.assertNotDisposed();const e={refCountAfterDispose:null,numDisposedVariables:0};if(0===--this._refCount){for(const t of this.layers)e.numDisposedVariables+=t.dispose().numDisposedVariables;for(const t of this.internalContainerRefs)e.numDisposedVariables+=t.dispose().numDisposedVariables}return e.refCountAfterDispose=this._refCount,e}get trainable(){return this.trainable_}set trainable(e){this.layers.forEach((t=>{t._trainableWeights.forEach((t=>t.trainable=e))})),this.trainable_=e}get trainableWeights(){if(this._trainableWeights.length>0)throw new Tf("Container instance unexpectedly contains _trainableWeights.The trainable weights of a Container are a union of the trainable weights of its consituent Layers. Its own _trainableWeights must remain an empty Array.");if(!this.trainable)return[];let e=[];for(const t of this.layers)e=e.concat(t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.layers)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.layers)t.push(...e.trainableWeights);return t.concat(e)}return e}get weights(){return this.trainableWeights.concat(this.nonTrainableWeights)}loadWeights(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n={};let a=0;const r=(e=>{const t=Object.keys(e);if(0===t.length)return!1;const n=t[0].split("/");return!isNaN(parseInt(n[n.length-1],10))})(e);r&&this.parseWeights(e);for(const o of this.layers)for(const[e,t]of o.weights.entries()){const s=r?"".concat(t.name.split("/").slice(0,-1).join("/")+"/").concat(e):t.originalName;if(null!=n[s])throw new Tf("Duplicate weight name: ".concat(s));n[s]=t,a++}const s=[];for(const o in e){let a=o;if(null==n[o]){const e=o.split("/");a=e.slice(0,-2).concat([e[e.length-1]]).join("/")}if(null!=n[a])s.push([n[a],e[o]]);else if(t)throw new Tf("Provided weight data has no target variable: ".concat(o));delete n[a]}if(t){const e=[];for(const t in n)e.push(t);if(e.length>0)throw new Tf("".concat(e.length," of ").concat(a," weights are not set: ")+"".concat(e))}pg(s)}parseWeights(e){for(const t in Object.keys(e)){const n=t.split("/"),a=["vars","layer_checkpoint_dependencies"],r=n.map((e=>e.startsWith("_")?e.slice(1):e)).filter((e=>!a.includes(e))).join("/");r!==t&&(e[r]=e[t],delete e[t])}}updatedConfig(){const e=this.getConfig(),t={};return t.className=this.getClassName(),t.config=e,t.kerasVersion="tfjs-layers ".concat(Ry),t.backend="TensorFlow.js",t}toJSON(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=Cy(this.updatedConfig());return t?JSON.stringify(n):n}call(e,t){return Es((()=>{e=Of(e);const n=new kg;for(let t=0;t<this.inputs.length;++t)n.add(this.inputs[t],e[t]);return Ng(this.outputs,n,t)}))}computeMask(e,t){return Es((()=>{let n;return e=Of(e),n=null==t?Af(null,e.length):Of(t),this.runInternalGraph(e,n)[1]}))}computeOutputShape(e){const t=og(e);if(t.length!==this.inputLayers.length)throw new Tf("Invalid inputShape argument ".concat(e,": ")+"model has ".concat(this.inputLayers.length," tensor inputs."));const n={};for(let o=0;o<t.length;o++){const e=this.inputLayers[o],a=t[o];n[e.name+"_0_0"]=a}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Vf);if(a.length>1)for(const o of a){const e=this.nodesByDepth[o];for(const t of e){const e=t.outboundLayer;if(-1!==this.inputLayers.map((e=>e.id)).indexOf(e.id))continue;const a=[];for(let o=0;o<t.inboundLayers.length;o++){const e=t.inboundLayers[o],r=t.nodeIndices[o],s=t.tensorIndices[o],i=n["".concat(e.name,"_").concat(r,"_").concat(s)];a.push(i)}const r=og(e.computeOutputShape(Ff(a))),s=e.inboundNodes.indexOf(t);for(let t=0;t<r.length;t++){n["".concat(e.name,"_").concat(s,"_").concat(t)]=r[t]}}}const r=[],s=[];for(let o=0;o<this.outputLayers.length;o++){const e=this.outputLayers[o],t=this.outputLayersNodeIndices[o],n=this.outputLayersTensorIndices[o],a="".concat(e.name,"_").concat(t,"_").concat(n);s.push(a)}for(let o=0;o<s.length;o++){const e=s[o];_f(e in n),r.push(n[e])}return Ff(r)}runInternalGraph(e,t){null==t&&(t=Af(null,e.length));const n={};for(let i=0;i<this.inputs.length;++i){const a=this.inputs[i],r=e[i],s=t[i];n[a.id]=[r,s]}const a=Object.keys(this.nodesByDepth).map((e=>parseInt(e,10))).sort(Vf);for(const i of a){const e=this.nodesByDepth[i];for(const t of e){const e=t.outboundLayer,a=t.inputTensors,r=t.outputTensors,s=new Array;for(const t of a)t.id in n&&s.push(n[t.id]);if(s.length===a.length){let a,o,i,c,l={};if(null!=t.callArgs&&(l=t.callArgs),1===s.length){const[t,n]=s[0];null==l.mask&&(l.mask=n),i=Of(e.call(t,l)),c=Of(e.computeMask(t,n)),a=[t],o=[n]}else a=s.map((e=>e[0])),o=s.map((e=>e[1])),null==l.mask&&(l.mask=o),i=Of(e.call(a,l)),c=Of(e.computeMask(a,o));if(e.activityRegularizer)throw new Ef("LayersModel invocation with concrete Tensor value(s) in the presence of activity regularizer(s) is not supported yet.");for(let e=0;e<r.length;++e){const t=r[e],a=i[e],s=c[e];n[t.id]=[a,s]}}}}const r=[],s=[],o=[];for(const i of this.outputs){_f(i.id in n,"Could not compute output ".concat(i.name," : ").concat(i.id));const[e,t]=n[i.id];o.push(e.shape),r.push(e),s.push(t)}return[r,s,o]}buildNodeConversionMap(e){const t={};let n;for(const a of this.layers){n=a instanceof Ay?1:0;for(let e=0;e<a.inboundNodes.length;e++){const r=Ay.nodeKey(a,e);this.containerNodes.has(r)&&(t[r]=n,n+=1)}}return t}getLayer(e,t){if(null!=t)return this.findLayer(t);if(null==e)throw new Tf("Provide either a layer name or layer index");if("number"===typeof e)return this.findLayer(e);for(const n of this.layers)if(n.name===e)return n;throw new Tf("No such layer: ".concat(e))}findLayer(e){if(this.layers.length<=e)throw new Tf("Was asked to retrieve layer at index ".concat(e,", but model only ")+"has ".concat(this.layers.length," layer(s)."));return this.layers[e]}calculateLosses(){return Es((()=>{const e=[];for(const t of this.layers)for(let n=0;n<t.inboundNodes.length;++n){const a=Ay.nodeKey(t,n);this.containerNodes.has(a)&&e.push(...t.calculateLosses())}return e}))}getConfig(){const e={name:this.name},t=this.buildNodeConversionMap(this.layers),n=[];for(const s of this.layers){const e=s.getClassName(),a=s.getConfig(),r=[];for(let n=0;n<s.inboundNodes.length;n++){const e=s.inboundNodes[n],a=Ay.nodeKey(s,n);let o={};if(this.containerNodes.has(a)){if(e.callArgs)try{JSON.stringify(e.callArgs),o=e.callArgs}catch(o1){console.warn("Layer ".concat(s.name," was passed ")+"non-serializable keyword arguments: "+"".concat(e.callArgs,". They will not be included ")+"in the serialized model (and thus will be missing at deserialization time)."),o={}}if(e.inboundLayers.length>0){const n=[];for(let a=0;a<e.inboundLayers.length;a++){const r=e.inboundLayers[a],s=e.nodeIndices[a],i=e.tensorIndices[a];let c=t[Ay.nodeKey(r,s)];null==c&&(c=0),n.push([r.name,c,i,o])}r.push(n)}}}const o={};o.name=s.name,o.className=e,o.config=a,o.inboundNodes=r,n.push(o)}e.layers=n;const a=[];for(let s=0;s<this.inputLayers.length;s++){const e=this.inputLayers[s],n=this.inputLayersNodeIndices[s],r=Ay.nodeKey(e,n);if(!this.containerNodes.has(r))continue;let o=t[r];null!==o&&void 0!==o||(o=0);const i=this.inputLayersTensorIndices[s];a.push([e.name,o,i])}e.inputLayers=a;const r=[];for(let s=0;s<this.outputLayers.length;s++){const e=this.outputLayers[s],n=this.outputLayersNodeIndices[s],a=Ay.nodeKey(e,n);if(!this.containerNodes.has(a))continue;let o=t[a];null!==o&&void 0!==o||(o=0);const i=this.outputLayersTensorIndices[s];r.push([e.name,o,i])}return e.outputLayers=r,e}static fromConfig(e,t){let n=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a={},r={};function s(e,t){e.name in r?r[e.name].push(t):r[e.name]=[t]}function o(e,t){const n=[];let r;for(const o of t){const i=o[0],c=o[1],l=o[2];if(r=null==o[3]?{}:o[3],!(i in a))return void s(e,t);const u=a[i];if(u.inboundNodes.length<=c)return void s(e,t);const h=u.inboundNodes[c];n.push(h.outputTensors[l])}n.length>0&&e.apply(Ff(n),r)}function i(e){const r=e.name,o=Qg(e,null!=t.customObjects?t.customObjects:{});o.setFastWeightInitDuringBuild(n),a[r]=o;e.inboundNodes.forEach((e=>{if(!(e instanceof Array))throw new Tf("Corrupted configuration, expected array for nodeData: ".concat(e));s(o,e)}))}const c=t.name,l=t.layers;for(const f of l)i(f);for(;!Gf(r);)for(const e of l){const t=a[e.name];if(t.name in r){const e=r[t.name];delete r[t.name];for(const n of e)o(t,n)}}const u=[],h=[],d=t.inputLayers;for(const f of d){const e=f[0],t=f[1],n=f[2];_f(e in a);const r=a[e].inboundNodes[t].outputTensors;u.push(r[n])}const p=t.outputLayers;for(const f of p){const e=f[0],t=f[1],n=f[2];_f(e in a);const r=a[e].inboundNodes[t].outputTensors;h.push(r[n])}return new e({inputs:u,outputs:h,name:c})}get stateful(){if(this._stateful)throw new Tf("Container instance unexpectedly has _stateful = true. The statefulness of a Container is determined by the Layers it contains. Its _stateful property must remain the default false.");for(const e of this.layers)if(e.stateful)return!0;return!1}resetStates(){Es((()=>{this.layers.forEach((e=>{e.stateful&&e.resetStates()}))}))}}function _y(e,t,n){const a=t.length;if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>null));if(1===a)return Array.isArray(e)&&1===e.length?e:"object"===typeof e&&t[0]in e?[e[t[0]]]:[e];if(Array.isArray(e)){if(e.length!==a)throw new Error("Provided ".concat(n," is an array of ").concat(e.length," ")+"element(s), but the model has ".concat(a," outputs. ")+"Make sure a set of weights is provided for each model output.");return e}if("object"===typeof e&&Object.keys(e).length>0&&"object"===typeof e[Object.keys(e)[0]]){const n=[];return t.forEach((t=>{t in e?n.push(e[t]):n.push(null)})),n}throw new Error("The model has multiple (".concat(a,") outputs, ")+"so ".concat(n," must be either an array with ")+"".concat(a," elements or an object with ").concat(t," keys. ")+"Provided ".concat(n," not understood: ").concat(JSON.stringify(e)))}function Dy(e,t){return _y(e,t,"classWeight")}async function Fy(e,t,n,a){if(null!=t||null!=a)throw new Error("Support sampleWeight is not implemented yet");if(null!=n){const t=Es((()=>{if(1===e.shape.length)return bo(e);if(2===e.shape.length){if(e.shape[1]>1){return Ni(e,1)}if(1===e.shape[1])return Vi(e,[e.shape[0]]);throw new Error("Encountered unexpected last-dimension size (".concat(e.shape[1],") ")+"during handling of class weights. The size is expected to be >= 1.")}throw new Error("Unexpected rank of target (y) tensor (".concat(e.rank,") during ")+"handling of class weights. The rank is expected to be 1 or 2.")})),a=Array.from(await t.data());Cs(t);const r=[];return a.forEach((e=>{if(null==n[e])throw new Error("classWeight must contain all classes in the training data. "+"The class ".concat(e," exists in the data but not in ")+"classWeight");r.push(n[e])})),xl(r,"float32")}return null}function Oy(e,t){return ko(e,t)}function My(e,t){let n,a;const r=t;n=r.xs,a=r.ys,J(null!=n&&null!=a,(()=>"A Dataset iterator for fitDataset() is expected to generate objects of the form `{xs: xVal, ys: yVal}`, where the two values may be `tf.Tensor`, an array of Tensors, or a map of string to Tensor.  The provided Dataset instead generates "+"".concat(t)));const s=Ly("input",e.inputNames,n),o=Ly("output",e.outputNames,a),i=s[0].shape[0];J(s.length===e.inputs.length,(()=>"LayersModel has ".concat(e.inputs.length," inputs, but the dataset ")+"provides ".concat(s.length," inputs.  (Expected input keys: ")+"".concat(JSON.stringify(e.inputNames),")"))),J(o.length===e.outputs.length,(()=>"LayersModel has ".concat(e.outputs.length," outputs, but the dataset ")+"provides ".concat(o.length," outputs.  (Expected output keys: ")+"".concat(JSON.stringify(e.outputNames),")")));for(let c=0;c<s.length;c++)J(s[c].shape[0]===i,(()=>"Batch size mismatch: input "+"".concat(e.inputNames[c]," has ").concat(s[c].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(e.inputNames[0],".")));for(let c=0;c<o.length;c++)J(o[c].shape[0]===i,(()=>"Batch size mismatch: output "+"".concat(e.outputNames[c]," has ").concat(o[c].shape[0],"; ")+"expected  ".concat(i," based on input ").concat(e.inputNames[0],".")));return{xs:s,ys:o}}function Ly(e,t,n){if(n instanceof Ur)return[n];if(Array.isArray(n))return J(n.length===t.length,(()=>"Received an array of ".concat(n.length," Tensors, but expected ").concat(t.length," to match the ").concat(e," keys ").concat(t,"."))),n;{const a=[];for(const r of t){if(null==n[r])throw new Tf("The feature data generated by the dataset lacks the required "+"".concat(e," key '").concat(r,"'."));a.push(n[r])}return a}}async function zy(e,t,n){const a=null!=n.batchesPerEpoch;if(J(null!=e.optimizer,(()=>"You must compile a model before training/testing. Use LayersModel.compile(modelCompileConfig).")),J(null!=n,(()=>"For fitDataset(), the 2nd argument (config) is required, but it is not provided in this call.")),J(null!=n.epochs&&n.epochs>0&&Number.isInteger(n.epochs),(()=>"For fitDataset(), config.epochs is expected to be a positive "+"integer, but got ".concat(n.epochs))),J(!a||n.batchesPerEpoch>0&&Number.isInteger(n.batchesPerEpoch),(()=>"For fitDataset(), config.batchesPerEpoch is expected to be a "+"positive integer if specified, but got ".concat(n.batchesPerEpoch))),J(null==n.validationSplit,(()=>"`validationSplit` is not supported by `fitDataset()`. Use validationData instead.")),e.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");e.isTraining=!0;try{const r=null!=n.validationData;let s,o;if(r)if(Py(n.validationData))J(null==n.validationBatches||n.validationBatches>0&&Number.isInteger(n.validationBatches),(()=>"For fitDataset() with dataset-based validation, config.validationBatches is expected not to be provided, or to be a positive integer, "+"but got ".concat(n.validationBatches)));else{const e=function(e){if(3===e.length)throw new Ef("Validation with sample weights is not implemented yet.");return{xs:e[0],ys:e[1]}}(n.validationData);s=e.xs,o=e.ys}const i=e.makeTrainFunction(),c=e.getDedupedMetricsNames();let l;l=r?c.slice().concat(c.map((e=>"val_"+e))):c.slice();const u=qg(n.callbacks,n.yieldEvery),h=null==n.verbose?1:n.verbose,{callbackList:d,history:p}=Yg(u,h,n.epochs,null,null,function(e,t){let n=null;null!=t.batchesPerEpoch?n=t.batchesPerEpoch:Number.isFinite(e.size)&&(n=e.size);return n}(t,n),null,r,l);d.setModel(e),e.history=p,await d.onTrainBegin(),e.stopTraining_=!1;let f=null==n.initialEpoch?0:n.initialEpoch,m=await t.iterator();for(;f<n.epochs;){const l={};await d.onEpochBegin(f);let u=0,h=0;for(a||(m=await t.iterator());!a||u<n.batchesPerEpoch;){const t=await m.next();if(a&&t.done){console.warn("You provided `batchesPerEpoch` as "+"".concat(n.batchesPerEpoch,", ")+"but your dataset iterator ran out of data after "+"".concat(u," batches; ")+"interrupting training. Make sure that your dataset can generate at least `batchesPerEpoch * epochs` batches (in this case, "+"".concat(n.batchesPerEpoch*n.epochs," batches). ")+"You may need to use the repeat() function when building your dataset.");break}if(null!=t.value){const{xs:a,ys:r}=My(e,t.value),s={};s.batch=h,s.size=a[0].shape[0],await d.onBatchBegin(h,s);const o=[];if(null!=n.classWeight){const t=Dy(n.classWeight,e.outputNames);for(let e=0;e<t.length;++e)o.push(await Fy(r[e],null,t[e]))}const l=a.concat(r).concat(o),p=i(l);Cs(l);for(let e=0;e<c.length;++e){const t=c[e],n=p[e];s[t]=n,Rs(n)}await d.onBatchEnd(h,s),Wg(s),h++,u++}if(a?u>=n.batchesPerEpoch:t.done){if(r){let t;t=Py(n.validationData)?Of(await e.evaluateDataset(n.validationData,{batches:n.validationBatches})):Of(e.evaluate(s,o,{batchSize:null==n.validationBatchSize?32:n.validationBatchSize,verbose:0}));for(let n=0;n<e.metricsNames.length;++n)l["val_".concat(e.metricsNames[n])]=t[n]}break}if(e.stopTraining_)break}if(await d.onEpochEnd(f,l),f++,e.stopTraining_)break}return await d.onTrainEnd(),await e.history.syncData(),e.history}finally{e.isTraining=!1}}function Py(e){return"function"===typeof e.iterator}function By(e){J(e>0&&Number.isInteger(e),(()=>"batchSize is required to be a positive integer, but got ".concat(e)))}function Wy(e,t,n){return null==e?[null]:Array.isArray(e)?e.map((e=>Sm(e,t,n-t))):Sm(e,t,n-t)}function Vy(e,t){return Es((()=>null==e?null:Array.isArray(e)?e.map((e=>Vy(e,t))):_m(e,"int32"===t.dtype?t:yo(t,"int32"))))}function Uy(e,t){const n=[];let a=0,r=null;for(;a<e;)r=a+t,r>=e&&(r=e),n.push([a,r]),a=r;return n}function Gy(e){const t=[];e instanceof Ur&&(e=[e]);for(let n=0;n<e.length;++n){const a=e[n];if(1===a.rank)t.push(km(a,1));else{if(0===a.rank)throw new Error("Expected tensor to be at least 1D, but received a 0D tensor (scalar).");t.push(a)}}return t}function Hy(e,t){if(null==e)return;const n=[];if(t instanceof Ur)n.push(t.id);else if(Array.isArray(t))t.forEach((e=>n.push(e.id)));else if(null!=t)for(const r in t){const e=t[r];n.push(e.id)}const a=[];if(e instanceof Ur)-1===n.indexOf(e.id)&&a.push(e);else if(Array.isArray(e))e.forEach((e=>{-1===n.indexOf(e.id)&&a.push(e)}));else if(null!=e)for(const r in e){const t=e[r];-1===n.indexOf(t.id)&&a.push(t)}a.forEach((e=>{e.isDisposed||e.dispose()}))}function jy(e){return Array.isArray(e)}function Ky(e){return!function(e){return e instanceof Ur}(e)&&!jy(e)}function qy(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(null==t||0===t.length){if(null!=e){let t=!1;if(jy(e)&&e.length>0)t=!0;else if(Ky(e)){for(const n in e)if(e.hasOwnProperty(n)){t=!0;break}}else t=!0;if(t)throw new Tf("Error when checking model ".concat(s," expected no data, ")+"but got ".concat(e))}return[]}if(null==e)return t.map((e=>null));if(Ky(e)){a=[];for(const n of t){if(null==e[n])throw new Tf('No data provided for "'.concat(n,'". Need data for each key in: ')+"".concat(t));a.push(e[n])}}else if(jy(e)){if(e.length!==t.length)throw new Tf("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"model expected. Expected to see ".concat(t.length," Tensor(s), but ")+"instead got the following list of Tensor(s): ".concat(e));a=e}else{if(t.length>1)throw new Tf("The model ".concat(s," expects ").concat(t.length," Tensor(s), ")+"but only received one Tensor. Found: Tensor with shape ".concat(e.shape));a=[e]}if(a=Gy(a),null!=n)for(let o=0;o<t.length;++o){if(null==n[o])continue;const e=a[o];if(e.shape.length!==n[o].length)throw new Tf("Error when checking ".concat(s,": expected ").concat(t[o]," ")+"to have ".concat(n[o].length," dimension(s). but got array with ")+"shape ".concat(e.shape));for(let t=0;t<n[o].length;++t){if(0===t&&!r)continue;const a=e.shape[t],i=n[o][t];if(null!=i&&i>=0&&a!==i)throw new Tf("".concat(s," expected a batch of elements where each ")+"example has shape [".concat(n[o].slice(1,n[o].length),"] ")+"(i.e.,tensor shape [*,".concat(n[o].slice(1,n[o].length),"])")+" but the ".concat(s," received an input with ").concat(e.shape[0])+" examples, each with shape [".concat(e.shape.slice(1,e.shape.length),"]")+" (tensor shape [".concat(e.shape,"])"))}}return a}function Xy(e,t,n){let a,r=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],s=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"";if(Array.isArray(e)){if(e.length!==t.length)throw new Tf("Error when checking model ".concat(s,": the Array of ")+"Tensors that you are passing to your model is not the size the "+"the model expected. Expected to see ".concat(t.length," Tensor(s),")+" but instead got ".concat(e.length," Tensors(s)."));a=e}else{if(t.length>1)throw new Tf("The model expects ".concat(t.length," ").concat(s," Tensors, ")+"but only received one Tensor. Found: array with shape "+"".concat(JSON.stringify(e.shape),"."));a=[e]}if(null!=n)for(let o=0;o<t.length;++o){if(null==n[o])continue;const e=a[o];if(e.shape.length!==n[o].length)throw new Tf("Error when checking ".concat(s,": expected ").concat(t[o]," ")+"to have ".concat(n[o].length," dimension(s), but got array with ")+"shape ".concat(JSON.stringify(e.shape)));for(let a=0;a<n[o].length;++a){if(0===a&&!r)continue;const i=e.shape[a],c=n[o][a];if(null!=c&&c!==i)throw new Tf("Error when checking ".concat(s,": expected ")+"".concat(t[o]," to have shape ").concat(JSON.stringify(n[o])," but ")+"got array with shape ".concat(JSON.stringify(e.shape),"."))}}}class Yy extends Ay{constructor(e){super(e),this.isTraining=!1}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;if(!this.built)throw new Tf("This model has never been called, thus its weights have not been created yet. So no summary can be displayed. Build the model first (e.g., by calling it on some test data).");ky(this,e,t,n)}compile(e){if(null==e.loss&&(e.loss=[]),this.loss=e.loss,"string"===typeof e.optimizer)this.optimizer_=function(e){const t={Adagrad:()=>Au.adagrad(.01),Adadelta:()=>Au.adadelta(1,.95,xm()),Adam:()=>Au.adam(.001,.9,.999,xm()),Adamax:()=>Au.adamax(.002,.9,.999,xm(),0),RMSProp:()=>Au.rmsprop(.001,.9,0,xm()),SGD:()=>Au.sgd(.01)};if(t.adagrad=t.Adagrad,t.adadelta=t.Adadelta,t.adam=t.Adam,t.adamax=t.Adamax,t.rmsprop=t.RMSProp,t.sgd=t.SGD,e in t)return t[e]();throw new Tf("Unknown Optimizer ".concat(e))}(e.optimizer),this.isOptimizerOwned=!0;else{if(!(e.optimizer instanceof Fo))throw new Tf("User-defined optimizer must be an instance of tf.Optimizer.");this.optimizer_=e.optimizer,this.isOptimizerOwned=!1}let t=[];if(Array.isArray(e.loss)||"string"===typeof e.loss||"function"===typeof e.loss)if(Array.isArray(e.loss)){if(e.loss.length!==this.outputs.length)throw new Tf("When passing an Array as loss, it should have one entry per "+"model output. The model has ".concat(this.outputs.length," output(s), ")+"but you passed loss=".concat(e.loss,"."));const n=e.loss;t=n.map((e=>cy(e)))}else{const n=cy(e.loss);this.outputs.forEach((e=>{t.push(n)}))}else{e.loss=e.loss;for(const t in e.loss)if(-1===this.outputNames.indexOf(t))throw new Tf('Unknown entry in loss dictionary: "'.concat(t,'". ')+"Only expected the following keys: ".concat(this.outputNames));for(const n of this.outputNames)null==e.loss[n]&&console.warn('Output "'.concat(n,'" is missing from loss dictionary. We assume ')+"this was done on purpose, and we will not be expecting data "+"to be passed to ".concat(n," during training")),t.push(cy(e.loss[n]))}this.lossFunctions=t,this.feedOutputNames=[],this.feedOutputShapes=[],this.feedLossFns=[];for(let s=0;s<this.outputs.length;++s){const e=this.internalOutputShapes[s],t=this.outputNames[s];this.feedOutputNames.push(t),this.feedOutputShapes.push(e),this.feedLossFns.push(this.lossFunctions[s])}const n=[];this.metrics=e.metrics,this.metricsNames=["loss"],this.metricsTensors=[],um("loss",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;const t=this.lossFunctions[e];this.outputs.length>1&&(this.metricsTensors.push([t,e]),this.metricsNames.push(this.outputNames[e]+"_loss"))}}));const a=function(e,t){if(null==e||Array.isArray(e)&&0===e.length)return t.map((e=>[]));let n;if("string"===typeof e||"function"===typeof e)n=[e];else{if(!Array.isArray(e)&&"object"!==typeof e)throw new TypeError("Type of metrics argument not understood. Expected an string,"+"function, Array, or Object, found: ".concat(e));n=e}if(Array.isArray(n))return t.map((e=>n));{const e=[];for(const a of t){let t=n.hasOwnProperty(a)?n[a]:[];Array.isArray(t)||(t=[t]),e.push(t)}return e}}(e.metrics,this.outputNames),r=(e,t,n)=>{this.outputNames.length>1&&(t=this.outputNames[e]+"_"+t),this.metricsNames.push(t),this.metricsTensors.push([n,e])};um("metric",(()=>{for(let e=0;e<this.outputs.length;++e){if(-1!==n.indexOf(e))continue;(t=>{let n,a,s;for(const o of t){if("string"===typeof o&&-1!==["accuracy","acc","crossentropy","ce"].indexOf(o)){const t=this.internalOutputShapes[e];let r;1===t[t.length-1]||this.lossFunctions[e]===ry?-1!==["accuracy","acc"].indexOf(o)?a=ly:-1!==["crossentropy","ce"].indexOf(o)&&(a=dy):this.lossFunctions[e]===ay?-1!==["accuracy","acc"].indexOf(o)?a=py:-1!==["crossentropy","ce"].indexOf(o)&&(a=my):-1!==["accuracy","acc"].indexOf(o)?a=uy:-1!==["crossentropy","ce"].indexOf(o)&&(a=fy),-1!==["accuracy","acc"].indexOf(o)?r="acc":-1!==["crossentropy","ce"].indexOf(o)&&(r="ce"),s=a,n=""+r}else{const e=yy(o);s=e,n=""+by(o)}let t;um(n,(()=>{t=s})),r(e,n,t)}})(a[e])}})),this.collectedTrainableWeights=this.trainableWeights}checkTrainableWeightsConsistency(){null!=this.collectedTrainableWeights&&this.trainableWeights.length!==this.collectedTrainableWeights.length&&console.warn("Discrepancy between trainableweights and collected trainable weights. Did you set `model.trainable` without calling `model.compile()` afterwards?")}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=null==n.batchSize?32:n.batchSize;By(a);const r=this.standardizeUserDataXY(e,t,!0,a);try{const e=r[0].concat(r[1]);this.makeTestFunction();const t=this.testFunction;return Ff(this.testLoop(t,e,a,n.verbose,n.steps))}finally{Hy(r[0],e),Hy(r[1],t)}}async evaluateDataset(e,t){return this.makeTestFunction(),async function(e,t,n){const a=null!=(n=n||{}).batches,r=e.testFunction;let s=[];if(n.verbose>0)throw new Ef("Verbose mode is not implemented yet.");J(!a||n.batches>0&&Number.isInteger(n.batches),(()=>"Test loop expects `batches` to be a positive integer, but "+"received ".concat(JSON.stringify(n.batches))));const o="function"===typeof t.next?t:await t.iterator();let i=0,c=0;for(;!a||c<n.batches;){const t=await o.next();if(s=Es((()=>{if(t.value){const{xs:n,ys:a}=My(e,t.value),o=n.concat(a),l=Es((()=>r(o)));if(Cs(o),0===c)for(let e=0;e<l.length;++e)s.push(Eo(0));const u=o[0].shape[0];for(let e=0;e<l.length;++e){const t=l[e],n=s[e];s[e]=Es((()=>vo(s[e],ko(u,t)))),c>0&&Cs(n)}Cs(l),i+=u,++c}return s})),t.done){a&&console.warn("Your dataset iterator ran out of data during evaluateDataset(). Interrupting evalution. Make sure that your dataset can generate at least `batches` "+"batches (in this case, ".concat(n.batches," batches). ")+"You may need to use the repeat() function when building your dataset.");break}}for(let l=0;l<s.length;++l){const e=s[l];s[l]=wo(s[l],i),Cs(e)}return Ff(s)}(this,e,t)}checkNumSamples(e,t,n){let a,r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"steps";if(null!=n){if(a=null,null!=t)throw new Tf("If ".concat(r," is set, batchSize must be null or undefined.")+"Got batchSize = ".concat(t))}else{if(null==e)throw new Tf("Either the input data should have a defined shape, or "+"".concat(r," shoud be specified."));a=Array.isArray(e)?e[0].shape[0]:e.shape[0]}return a}execute(e,t){if(Array.isArray(t)&&0===t.length)throw new Tf("`outputs` is an empty Array, which is not allowed.");const n=Array.isArray(t),a=n?t:[t],r=this.retrieveSymbolicTensors(a),s=new kg;if(e instanceof Ur&&(e=[e]),Array.isArray(e)){if(e.length!==this.inputs.length)throw new Tf("The number of inputs provided (".concat(e.length,") ")+"does not match the number of inputs of this model "+"(".concat(this.inputs.length,")."));for(let t=0;t<this.inputs.length;++t)s.add(this.inputs[t],e[t])}else for(const i of this.inputs){const t=e[i.name];if(null==t)throw new Tf("No value is provided for the model's input ".concat(i.name));s.add(i,t)}const o=Ng(r,s);return n?o:o[0]}retrieveSymbolicTensors(e){const t=Af(null,e.length);let n=e.length;for(const a of this.layers){const r=Array.isArray(a.output)?a.output:[a.output],s=r.map((e=>e.name));for(let a=0;a<e.length;++a){const o=s.indexOf(e[a]);if(-1!==o&&(t[a]=r[o],n--),0===n)break}if(0===n)break}if(n>0){const n=[];throw t.forEach(((t,a)=>{null==t&&n.push(e[a])})),new Tf("Cannot find SymbolicTensors for output name(s): "+"".concat(JSON.stringify(n)))}return t}predictLoop(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:32,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];return Es((()=>{const a=this.checkNumSamples(e);if(n)throw new Ef("Verbose predictLoop() is not implemented yet.");const r=Uy(a,t),s=this.outputs.map((e=>[]));for(let t=0;t<r.length;++t){Es((()=>{const n=r[t][0],a=r[t][1],s=Wy(e,n,a),o=[];if(Array.isArray(s))for(let e=0;e<s.length;++e)o.push({key:this.inputs[e],value:s[e]});else o.push({key:this.inputs[0],value:s});const i=new kg(o);return Ng(this.outputs,i)})).forEach(((e,t)=>s[t].push(e)))}return Ff(s.map((e=>Qi(e,0))))}))}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=Gy(e);Xy(n,this.inputNames,this.feedInputShapes,!1);try{const e=null==t.batchSize?32:t.batchSize;return By(e),this.predictLoop(n,e)}finally{Hy(n,e)}}predictOnBatch(e){Xy(e,this.inputNames,this.feedInputShapes,!0);const t=(Array.isArray(e)?e[0]:e).shape[0];return this.predictLoop(e,t)}standardizeUserDataXY(e,t){let n=arguments.length>3?arguments[3]:void 0;if(null==this.optimizer_)throw new Nf("You must compile a model before training/testing. Use LayersModel.compile(modelCompileArgs).");const a=[];for(let r=0;r<this.feedOutputShapes.length;++r){const e=this.feedOutputShapes[r];this.feedLossFns[r]===ay?a.push(e.slice(0,e.length-1).concat([1])):a.push(e)}if(function(e,t,n){const a=Uf(e.map((e=>e.shape[0])));a.sort();const r=Uf(t.map((e=>e.shape[0])));if(r.sort(),a.length>1)throw new Tf("All input Tensors (x) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(e.map((e=>e.shape)))));if(r.length>1)throw new Tf("All target Tensors (y) should have the same number of samples. Got array shapes: "+"".concat(JSON.stringify(t.map((e=>e.shape)))));if(a.length>0&&r.length>0&&!te(a,r))throw new Tf("Input Tensors should have the same number of samples as target "+"Tensors. Found ".concat(a[0]," input sample(s) and ").concat(r[0]," target ")+"sample(s).")}(e=qy(e,this.feedInputNames,this.feedInputShapes,!1,"input"),t=qy(t,this.feedOutputNames,a,!1,"target")),function(e,t,n){const a=[Zg,ry,ny];for(let r=0;r<e.length;++r){const s=e[r],o=t[r],i=n[r];if(null!=o){if(o===ny&&1===s.shape[s.shape.length-1])throw new Tf("You are passing a target array of shape ".concat(s.shape," while using ")+"a loss 'categorical_crossentropy'. 'categorical_crossentropy'expects targets to be binary matrices (1s and 0s) of shape [samples, classes].");if(-1!==a.indexOf(o)){const e=s.shape.slice(1),t=i.slice(1);for(let n=0;n<e.length;++n){const a=e[n],r=t[n];if(null!=r&&a!==r)throw new Tf("A target Tensor with shape ".concat(s.shape," was passed for an ")+"output of shape ".concat(i,", while using a loss function that ")+"expects targets to have the same shape as the output.")}}}}}(t,this.feedLossFns,this.feedOutputShapes),this.stateful&&null!=n&&n>0&&e[0].shape[0]%n!==0)throw new Tf("In a stateful network, you should only pass inputs with a number of samples that is divisible by the batch size "+"".concat(n,". Found: ").concat(e[0].shape[0]," sample(s)."));return[e,t]}async standardizeUserData(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4],s=arguments.length>5?arguments[5]:void 0;const[o,i]=this.standardizeUserDataXY(e,t,r,s);if(null!=n)throw new Error("sample weight is not supported yet.");let c=null;if(null!=a){const e=Dy(a,this.outputNames);c=[];for(let t=0;t<e.length;++t)c.push(await Fy(i[t],null,e[t]))}return[o,i,c]}testLoop(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4?arguments[4]:void 0;return Es((()=>{const s=this.checkNumSamples(t,n,r,"steps"),o=[];if(a>0)throw new Ef("Verbose mode is not implemented yet.");if(null!=r)throw new Ef("steps mode in testLoop() is not implemented yet");{const a=Uy(s,n),r=xl(bm(0,s));for(let n=0;n<a.length;++n){const s=a[n][0],i=a[n][1],c=Sm(r,s,i-s),l=Vy(t,c),u=e(l);if(0===n)for(let e=0;e<u.length;++e)o.push(Eo(0));for(let e=0;e<u.length;++e){const t=u[e];o[e]=vo(o[e],ko(i-s,t))}}for(let e=0;e<o.length;++e)o[e]=wo(o[e],s)}return o}))}getDedupedMetricsNames(){const e=this.metricsNames,t=[];for(let n=0;n<e.length;++n){const a=e[n];let r=a;if(Df(e,a)>1){const t=Df(e.slice(0,n),a);r+="_".concat(t)}t.push(r)}return t}makeTrainFunction(){return e=>{const t=[],n=e.slice(0,this.inputs.length),a=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),r=e.slice(this.inputs.length+this.outputs.length,this.inputs.length+2*this.outputs.length),s=[],o=this.collectedTrainableWeights.map((e=>e.read()));return[this.optimizer_.minimize((()=>{const e=[];for(let t=0;t<this.inputs.length;++t)e.push({key:this.inputs[t],value:n[t]});const o=new kg(e),i=Ng(this.outputs,o,{training:!0});let c;for(let n=0;n<this.lossFunctions.length;++n){let e=(0,this.lossFunctions[n])(a[n],i[n]);null!=r[n]&&(e=Oy(e,r[n]));const s=Wc(e);t.push(s),c=0===n?e:vo(c,e)}for(let n=0;n<this.metricsTensors.length;++n){let e;if(this.outputs.length>1&&n<this.outputs.length)e=t[n];else{const t=this.metricsTensors[n][0],r=this.metricsTensors[n][1];e=Wc(t(a[r],i[r]))}Rs(e),s.push(e)}return c=Wc(c),this.calculateLosses().forEach((e=>{c=vo(c,e)})),c}),!0,o)].concat(s)}}makeTestFunction(){this.testFunction=e=>Es((()=>{const t=[];let n;const a=e.slice(0,this.inputs.length),r=e.slice(this.inputs.length,this.inputs.length+this.outputs.length),s=[];for(let e=0;e<this.inputs.length;++e)s.push({key:this.inputs[e],value:a[e]});const o=new kg(s),i=Ng(this.outputs,o);for(let e=0;e<this.lossFunctions.length;++e){const a=this.lossFunctions[e],s=Wc(a(r[e],i[e]));n=0===e?s:vo(n,s),t.push(n)}for(let e=0;e<this.metricsTensors.length;++e){const n=this.metricsTensors[e][0],a=this.metricsTensors[e][1],s=Wc(n(r[a],i[a]));t.push(s)}return t}))}async fit(e,t){let n,a,r,s,o,i,c,l,u,h=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(this.isTraining)throw new Error("Cannot start training because another fit() call is ongoing.");this.isTraining=!0;try{const d=null==h.batchSize?32:h.batchSize;By(d);const p=!1,f=await this.standardizeUserData(e,t,h.sampleWeight,h.classWeight,p,d);n=f[0],a=f[1],u=f[2];let m,g=!1;if(null!=h.validationData&&h.validationData.length>0){if(g=!0,2!==h.validationData.length)throw 3===h.validationData.length?new Ef("validationData including sample weights is not supported yet."):new Tf("When passing validation data, it must contain 2 (valX, valY) or 3 (valX, valY, valSampleWeight) items; "+"".concat(h.validationData," is invalid."));o=h.validationData[0],i=h.validationData[1];const e=!0,t=await this.standardizeUserData(o,i,null,null,e,d);c=t[0],l=t[1],m=c.concat(l)}else if(null!=h.validationSplit&&h.validationSplit>0&&h.validationSplit<1){g=!0;const e=Math.floor(n[0].shape[0]*(1-h.validationSplit)),t=n[0].shape[0];c=Wy(n,e,t),r=n,n=Wy(n,0,e),l=Wy(a,e,t),s=a,a=Wy(a,0,e),m=c.concat(l)}else null!=h.validationSteps&&(g=!0);const y=n.concat(a).concat(u);this.checkTrainableWeightsConsistency();const b=this.makeTrainFunction(),v=this.getDedupedMetricsNames();let x,w;g?(this.makeTestFunction(),x=this.testFunction,w=v.slice().concat(v.map((e=>"val_"+e)))):(x=null,m=[],w=v.slice());const k=qg(h.callbacks,h.yieldEvery);return await this.fitLoop(b,y,v,d,h.epochs,h.verbose,k,x,m,h.shuffle,w,h.initialEpoch,null,null)}finally{this.isTraining=!1,Hy(n,e),Hy(a,t),Hy(r,e),Hy(s,t),Hy(c,o),Hy(l,i),null!=u&&Cs(u)}}async fitLoop(e,t,n,a,r,s,o,i,c,l,u,h,d,p){null==a&&(a=32),null==r&&(r=1),null==l&&(l=!0),null==h&&(h=0);let f=!1;if(null!=i&&null!=c&&(f=!0),null!=p&&(f=!0,null==d))throw new Tf("Can only use `validationSteps` when doing step-wise training, i.e., `stepsPerEpoch` must be set.");const m=this.checkNumSamples(t,a,d,"steps_per_epoch");let g;null!=m&&(g=bm(0,m)),null==s&&(s=1);const{callbackList:y,history:b}=Yg(o,s,r,h,m,d,a,f,u);y.setModel(this),this.history=b,await y.onTrainBegin(),this.stopTraining_=!1;for(let v=h;v<r;++v){await y.onEpochBegin(v);const r={};if(null!=d)throw new Ef("stepsPerEpoch mode is not implemented yet.");{if("batch"===l)throw new Ef("batch shuffling is not implemneted yet");l&&q(g);const s=xl(g),o=Uy(m,a);for(let l=0;l<o.length;++l){const u={};if(await y.onBatchBegin(l,u),Es((()=>{const h=o[l][0],d=o[l][1],p=Sm(s,h,d-h);u.batch=l,u.size=d-h;const m=Vy(t,p),g=e(m);for(let e=0;e<n.length;++e){const t=n[e],a=g[e];u[t]=a,Rs(a)}if(l===o.length-1&&f){const e=this.testLoop(i,c,a);for(let t=0;t<n.length;++t){const a=n[t],s=e[t];Rs(s),r["val_"+a]=s}}})),await y.onBatchEnd(l,u),Wg(u),this.stopTraining_)break}s.dispose()}if(await y.onEpochEnd(v,r),this.stopTraining_)break}return await y.onTrainEnd(),await this.history.syncData(),this.history}async fitDataset(e,t){return zy(this,e,t)}async trainOnBatch(e,t){const n=await this.standardizeUserData(e,t),a=n[0],r=n[1],s=this.makeTrainFunction()(a.concat(r)),o=[];for(const i of s){const e=await i.data();o.push(e[0])}return Cs(s),Hy(n[0],e),Hy(n[1],t),Ff(o)}getNamedWeights(e){const t=[],n=null!=e&&e.trainableOnly,a=n?this.trainableWeights:this.weights,r=this.getWeights(n);for(let s=0;s<a.length;++s)n&&!a[s].trainable||t.push({name:a[s].originalName,tensor:r[s]});return t}set stopTraining(e){this.stopTraining_=e}get stopTraining(){return this.stopTraining_}get optimizer(){return this.optimizer_}set optimizer(e){this.optimizer_!==e&&(this.optimizer_=e,this.isOptimizerOwned=!1)}dispose(){const e=super.dispose();if(0===e.refCountAfterDispose&&null!=this.optimizer&&this.isOptimizerOwned){const t=Ts().numTensors;this.optimizer_.dispose(),e.numDisposedVariables+=t-Ts().numTensors}return e}getLossIdentifiers(){let e;if("string"===typeof this.loss)e=Mf(this.loss);else if(Array.isArray(this.loss)){for(const e of this.loss)if("string"!==typeof e)throw new Error("Serialization of non-string loss is not supported.");e=this.loss.map((e=>Mf(e)))}else{const t=Object.keys(this.loss);e={};const n=this.loss;for(const a of t){if("string"!==typeof n[a])throw new Error("Serialization of non-string loss is not supported.");e[a]=Mf(n[a])}}return e}getMetricIdentifiers(){if("string"===typeof this.metrics||"function"===typeof this.metrics)return[Mf(by(this.metrics))];if(Array.isArray(this.metrics))return this.metrics.map((e=>Mf(by(e))));{const e={};for(const t in this.metrics)e[t]=Mf(by(this.metrics[t]));return e}}getTrainingConfig(){return{loss:this.getLossIdentifiers(),metrics:this.getMetricIdentifiers(),optimizer_config:{class_name:this.optimizer.getClassName(),config:this.optimizer.getConfig()}}}loadTrainingConfig(e){if(null!=e.weighted_metrics)throw new Error("Loading weight_metrics is not supported yet.");if(null!=e.loss_weights)throw new Error("Loading loss_weights is not supported yet.");if(null!=e.sample_weight_mode)throw new Error("Loading sample_weight_mode is not supported yet.");const t=Qg(Ey(e.optimizer_config));let n,a;if("string"===typeof e.loss)n=Lf(e.loss);else if(Array.isArray(e.loss))n=e.loss.map((e=>Lf(e)));else if(null!=e.loss){n={};for(const t in e.loss)n[t]=Lf(e.loss[t])}if(Array.isArray(e.metrics))a=e.metrics.map((e=>Lf(e)));else if(null!=e.metrics){a={};for(const t in e.metrics)a[t]=Lf(e.metrics[t])}this.compile({loss:n,metrics:a,optimizer:t})}async save(e,t){if("string"===typeof e){const t=(n=e,Vs.getSaveHandlers(n));if(0===t.length)throw new Tf("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Tf("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}var n;if(null==e.save)throw new Tf("LayersModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");const a=await Fs(this.getNamedWeights(t)),r={modelTopology:this.toJSON(null,!1),format:"layers-model",generatedBy:"TensorFlow.js tfjs-layers v".concat(Ry),convertedBy:null};if(null!=t&&t.includeOptimizer&&null!=this.optimizer){r.trainingConfig=this.getTrainingConfig();const e="optimizer",{data:t,specs:n}=await Fs(await this.optimizer.getWeights(),e);a.specs.push(...n),a.data=(s=[a.data,t],Is.join(s))}var s;if(null!=this.userDefinedMetadata){const e=!0;xy(this.userDefinedMetadata,this.name,e),r.userDefinedMetadata=this.userDefinedMetadata}return r.weightData=a.data,r.weightSpecs=a.specs,e.save(r)}setUserDefinedMetadata(e){xy(e,this.name),this.userDefinedMetadata=e}getUserDefinedMetadata(){return this.userDefinedMetadata}}Yy.className="Model",Do(Yy);class Qy extends Yy{}Qy.className="Functional",Do(Qy);class Jy extends Yy{constructor(e){if(super({inputs:[],outputs:[]}),e=e||{},this.trainable=!0,this.built=!1,this.name=null!=e.name?e.name:Zf("sequential_"),null!=e.layers)for(const t of e.layers)this.add(t)}checkShape(e){if(e.inboundNodes[0].outputTensors[0].shape.some((e=>e<0)))throw new Tf("Negative dimension size caused by adding layer "+"".concat(e.name," with input shape [")+"".concat(e.inboundNodes[0].inputTensors[0].shape,"]"))}add(e){const t=e instanceof Jy||e instanceof Yy;let n;if(t){if(n=e,1!==n.outputs.length)throw new Tf("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");if(1!==n.inputs.length)throw new Tf("All layers in a Sequential model should have a single input tensor. For multi-input layers, use the functional API.")}if(0===this.outputs.length){if(0===e.inboundNodes.length){if(null==e.batchInputShape)throw new Tf("The first layer in a Sequential model must get an `inputShape` or `batchInputShape` argument.");const t=function(e){if(null==e.batchShape&&null==e.shape)throw new Error("Please provide to Input either a `shape` or a `batchShape` argument. Note that `shape` does not include the batch dimension.");if(null!=e.batchShape&&null!=e.shape)throw new Tf("Please provide either a `shape` or `batchShape` argument to Input, but not both.");let t=e.batchShape;null!=e.shape&&null==t&&(t=[null].concat(e.shape));let n=e.dtype;return null==n&&(n="float32"),new wg({batchInputShape:t,name:e.name,dtype:n,sparse:e.sparse}).inboundNodes[0].outputTensors[0]}({batchShape:e.batchInputShape,dtype:e.dtype,name:e.name+"_input"});e.apply(t)}if(t)this.outputs=n.outputs,this.inputs=n.inputs;else{if(1!==e.inboundNodes.length)throw new Tf("A layer added to a Sequential model must not already be "+"connected somewhere else. LayersModel received layer ".concat(e.name," ")+"which has ".concat(e.inboundNodes.length," pre-existing inbound ")+"connections.");if(1!==e.inboundNodes[0].outputTensors.length)throw new Tf("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[e.inboundNodes[0].outputTensors[0]],this.inputs=xg(this.outputs[0])}this.inboundNodes=[],new yg({outboundLayer:this,inboundLayers:[],nodeIndices:[],tensorIndices:[],inputTensors:this.inputs,outputTensors:this.outputs,inputMasks:Af(null,this.inputs.length),outputMasks:[null],inputShapes:this.inputs.map((e=>e.shape)),outputShapes:this.outputs[0].shape})}else{const t=e.apply(this.outputs[0]);if(Array.isArray(t))throw new TypeError("All layers in a Sequential model should have a single output tensor. For multi-output layers, use the functional API.");this.checkShape(e),this.outputs=[t],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}this.layers.push(e),this.built=!1}pop(){if(0===this.layers.length)throw new TypeError("There are no layers in the model.");if(this.layers.pop(),0===this.layers.length)this.outputs=[],this.inboundNodes=[],this.outboundNodes=[];else{const e=this.layers.length-1;this.layers[e].outboundNodes=[],this.outputs=[this.layers[e].output],this.inboundNodes[0].outputTensors=this.outputs,this.inboundNodes[0].outputShapes=[this.outputs[0].shape]}}call(e,t){return null==this.model&&this.build(),this.model.call(e,t)}build(e){if(cg(e),0===this.inputs.length||0===this.outputs.length)throw new TypeError("Sequential model cannot be built: model is empty. Add some layers first.");this.model=new Yy({inputs:this.inputs,outputs:this.outputs[0],name:this.name+"_model"}),this.model.trainable=this.trainable,this.supportsMasking=this.model.supportsMasking,this.inputLayers=this.model.inputLayers,this.inputLayersNodeIndices=this.model.inputLayersNodeIndices,this.inputLayersTensorIndices=this.model.inputLayersTensorIndices,this.outputLayers=this.model.outputLayers,this.outputLayersNodeIndices=this.model.outputLayersNodeIndices,this.outputLayersTensorIndices=this.model.outputLayersTensorIndices,this.nodesByDepth=this.model.nodesByDepth,this.containerNodes=this.model.containerNodes,this.outputNames=this.model.outputNames,this.inputNames=this.model.inputNames,this.built=!0}countParams(){return this.built||this.build(),super.countParams()}summary(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:console.log;this.built||this.build(),super.summary(e,t,n)}setWeights(e){null==this.model&&this.build(),this.model.setWeights(e)}evaluate(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Nf("The model needs to be compiled before being used.");return this.model.evaluate(e,t,n)}async evaluateDataset(e,t){if(!this.built)throw new Nf("The model needs to be compiled before being used.");return this.model.evaluateDataset(e,t)}predict(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return null==this.model&&this.build(),this.model.predict(e,t)}predictOnBatch(e){return null==this.model&&this.build(),this.model.predictOnBatch(e)}compile(e){this.build(),this.model.compile(e),this.optimizer_=this.model.optimizer,this.isOptimizerOwned=this.model.isOptimizerOwned,this.loss=this.model.loss,this.metrics=this.model.metrics,this.metricsTensors=this.model.metricsTensors,this.metricsNames=this.model.metricsNames}get optimizer(){return null==this.model?void 0:this.model.optimizer}set optimizer(e){this.model.optimizer=e}async fit(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if(!this.built)throw new Nf("The model needs to be compiled before being used.");return this.model.fit(e,t,n)}async fitDataset(e,t){if(!this.built)throw new Nf("The model needs to be compiled before being used.");return this.model.fitDataset(e,t)}async trainOnBatch(e,t){return this.model.trainOnBatch(e,t)}static fromConfig(e,t){let n,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r={};if(t instanceof Array){if(null==t[0].className||"Merge"===t[0].className)throw new Tf("Legacy serialization format not supported yet.");n=t}else J(null!=t.layers,(()=>"When the config data for a Sequential model is not an Array, it must be an Object that contains the 'layers' field.")),n=t.layers,delete t.layers,r=t;const s=new e(r);if(!(s instanceof Jy))throw new Ef("Sequential.fromConfig called on non-Sequential input: ".concat(s));for(const o of n){const e=Qg(o,void 0,a);a&&e.setFastWeightInitDuringBuild(!0),s.add(e)}return s}set stopTraining(e){if(null==this.model)throw new Tf("Cannot set the stopTraining property of a sequential model before it is compiled.");this.model.stopTraining=e}get stopTraining(){if(null==this.model)throw new Tf("Cannot get the stopTraining property of a sequential model before it is compiled.");return this.model.stopTraining}getConfig(){const e=[];for(const t of this.layers){const n={};n.className=t.getClassName(),n.config=t.getConfig(),e.push(n)}return{name:this.name,layers:e}}}Jy.className="Sequential",Do(Jy);class Zy extends Ao{getConfig(){return{}}}class $y extends Zy{apply(e){return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;if(1!==t)throw new Ef("Support for alpha values other than 1 (".concat(t,") is not implemented ")+"yet.");return uc(e)}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:1)}}$y.className="elu",Do($y);class eb extends Zy{apply(e){return ol(e)}}eb.className="selu",Do(eb);class tb extends Zy{apply(e){return rl(e)}}tb.className="relu",Do(tb);class nb extends Zy{apply(e){return Es((()=>Uc(6,rl(e))))}}nb.className="relu6",Do(nb);class ab extends Zy{apply(e){return e}}ab.className="linear",Do(ab);class rb extends Zy{apply(e){return cl(e)}}rb.className="sigmoid",Do(rb);class sb extends Zy{apply(e){return function(e){return Es((()=>{const t=vo(.5,ko(.2,e));return Yi(t,0,1)}))}(e)}}sb.className="hardSigmoid",Do(sb);class ob extends Zy{apply(e){return ml(e)}}ob.className="softplus",Do(ob);class ib extends Zy{apply(e){return function(e){return Es((()=>wo(e,vo(Wo(e),1))))}(e)}}ib.className="softsign",Do(ib);class cb extends Zy{apply(e){return vl(e)}}cb.className="tanh",Do(cb);class lb extends Zy{apply(e){return fl(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}lb.className="softmax",Do(lb);class ub extends Zy{apply(e){return Tc(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1)}}ub.className="logSoftmax",Do(ub);class hb extends Zy{apply(e){return Es((()=>Es((()=>{const t=Math.sqrt(2),n=ko(.5,vo(1,dc(wo(e,t))));return ko(e,n)}))))}}hb.className="gelu",Do(hb);class db extends Zy{apply(e){return Es((()=>ko(.5,ko(e,vo(1,vl(ko(So(wo(2,Math.PI)),vo(e,ko(.044715,zo(e,3))))))))))}}db.className="gelu_new",Do(db);class pb extends Zy{apply(e){return Es((()=>ko(e,vl(ml(e)))))}}pb.className="mish",Do(pb);class fb extends Zy{apply(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1;return Es((()=>ko(cl(ko(e,t)),e)))}}function mb(e){return e.getClassName()}function gb(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Wf(e,_o.getMap().classNameMap,t,"activation")}function yb(e){if(null==e){const e={className:"linear",config:{}};return gb(e)}if("string"===typeof e){const t={};return t.className=e,t.config={},gb(t)}return e instanceof Zy?e:gb(e)}function bb(e){if(null!=e&&"object"!==typeof e)throw new Error("Argument to L1L2 regularizer's constructor is expected to be an "+"object, but received: ".concat(e))}fb.className="swish",Do(fb);class vb extends Ao{}class xb extends vb{constructor(e){super(),bb(e),this.l1=null==e||null==e.l1?.01:e.l1,this.l2=null==e||null==e.l2?.01:e.l2,this.hasL1=0!==this.l1,this.hasL2=0!==this.l2}apply(e){return Es((()=>{let t=qc([1]);return this.hasL1&&(t=vo(t,Nc(ko(this.l1,Wo(e))))),this.hasL2&&(t=vo(t,Nc(ko(this.l2,Dm(e))))),Vi(t,[])}))}getConfig(){return{l1:this.l1,l2:this.l2}}static fromConfig(e,t){return new e({l1:t.l1,l2:t.l2})}}xb.className="L1L2",Do(xb);const wb={l1l2:"L1L2"};function kb(e){return Pf(e)}function Sb(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};return Wf(e,_o.getMap().classNameMap,t,"regularizer")}function Ib(e){if(null==e)return null;if("string"===typeof e){return Sb({className:e in wb?wb[e]:e,config:{}})}return e instanceof vb?e:Sb(e)}class Nb extends vg{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,null!=e&&(this.maxValue=e.maxValue)}call(e,t){e=ig(e);let n=rl(e);return null!=this.maxValue&&(n=Yi(n,0,this.maxValue)),n}computeOutputShape(e){return e}getConfig(){const e={maxValue:this.maxValue},t=super.getConfig();return Object.assign(e,t),e}}Nb.className="ReLU",Do(Nb);class Tb extends vg{constructor(e){super(null==e?{}:e),this.DEFAULT_ALPHA=.3,null==e&&(e={}),this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=ig(e);return wc(n,this.alpha)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Tb.className="LeakyReLU",Do(Tb);class Eb extends vg{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA_INITIALIZER="zeros",null==e&&(e={}),this.supportsMasking=!0,this.alphaInitializer=rg(e.alphaInitializer||this.DEFAULT_ALPHA_INITIALIZER),this.alphaRegularizer=Ib(e.alphaRegularizer),this.alphaConstraint=Pg(e.alphaConstraint),null==e.sharedAxes)this.sharedAxes=null;else if(Array.isArray(e.sharedAxes))this.sharedAxes=e.sharedAxes;else{if("number"!==typeof e.sharedAxes)throw new Tf("Expected sharedAxes to be a number or an array of numbers, "+"but got ".concat(e.sharedAxes));this.sharedAxes=[e.sharedAxes]}}build(e){const t=(e=cg(e)).slice(1);if(null!=this.sharedAxes)for(const a of this.sharedAxes)t[a-1]=1;this.alpha=this.addWeight("alpha",t,"float32",this.alphaInitializer,this.alphaRegularizer,!0,this.alphaConstraint);const n={};if(null!=this.sharedAxes)for(let a=1;a<e.length;++a)n[a]=e[a];this.inputSpec=[new fg({ndim:e.length,axes:n})],this.built=!0}call(e,t){return e=ig(e),Jc(e,this.alpha.read())}getConfig(){const e={alphaInitializer:ag(this.alphaInitializer),alphaRegularizer:kb(this.alphaRegularizer),alphaConstraint:Lg(this.alphaConstraint),sharedAxes:this.sharedAxes},t=super.getConfig();return Object.assign(e,t),e}}Eb.className="PReLU",Do(Eb);class Cb extends vg{constructor(e){if(super(null==e?{}:e),this.DEFAULT_ALPHA=1,null==e&&(e={}),null!=e.alpha&&e.alpha!==this.DEFAULT_ALPHA)throw new Ef("Non-default alpha value (".concat(e.alpha,") is not supported by the ")+"ELU layer yet.");this.alpha=null==e.alpha?this.DEFAULT_ALPHA:e.alpha}call(e,t){const n=ig(e);return uc(n)}computeOutputShape(e){return e}getConfig(){const e={alpha:this.alpha},t=super.getConfig();return Object.assign(e,t),e}}Cb.className="ELU",Do(Cb);class Rb extends vg{constructor(e){super(null==e?{}:e),this.DEFAULT_THETA=1,null==e&&(e={}),this.theta=null==e.theta?this.DEFAULT_THETA:e.theta}call(e,t){const n=ig(e);return ko(n,yo(vc(n,this.theta),"float32"))}computeOutputShape(e){return e}getConfig(){const e={theta:this.theta},t=super.getConfig();return Object.assign(e,t),e}}Rb.className="ThresholdedReLU",Do(Rb);class Ab extends vg{constructor(e){super(null==e?{}:e),this.DEFAULT_AXIS=1,null==e&&(e={}),this.softmax=(new lb).apply,this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis}call(e,t){return Es((()=>{let n=ig(e);const a=t.mask;if(null!=a){const e=ko(Po(Xc(n.shape),yo(a,n.dtype)),Eo(-1e9));n=vo(n,e)}return this.axis instanceof Array?this.axis.length>1?pc(Po(n,Mc(n,this.axis,!0))):this.softmax(n,this.axis[0]):this.softmax(n,this.axis)}))}computeOutputShape(e){return e}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function _b(e,t,n){if("number"===typeof e)return Af(e,t);if(e.length!==t)throw new Tf("The ".concat(n," argument must be an integer or tuple of ").concat(t," integers.")+" Received: ".concat(e.length," elements."));for(let r=0;r<t;++r){const s=e[r];if((a=s)!==parseInt(a.toString(),10))throw new Tf("The ".concat(n," argument must be an integer or tuple of ").concat(t)+" integers. Received: ".concat(JSON.stringify(e)," including a")+" non-integer number ".concat(s))}return e;var a}function Db(e,t,n,a){if(null==e)return e;let r;return r="same"===n?e:e-(t+(t-1)*((arguments.length>4&&void 0!==arguments[4]?arguments[4]:1)-1))+1,Math.floor((r+a-1)/a)}function Fb(e,t,n,a){if(null==e)return null;if("valid"===a)e=e*t+ym([n-t,0]);else{if("same"!==a)throw new Tf("Unsupport padding mode: ".concat(a,"."));e*=t}return e}function Ob(e,t){return Es((()=>(sm(t),"channelsFirst"===t?El(e,[0,2,3,1]):e)))}function Mb(e,t){return Es((()=>(sm(t),"channelsFirst"===t?El(e,[0,2,3,4,1]):e)))}function Lb(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:1;return Es((()=>{if(null==s&&(s="channelsLast"),sm(s),3!==e.shape.length)throw new Tf("The input of a conv1dWithBias operation should be 3, but is "+"".concat(e.shape.length," instead."));if(3!==t.shape.length)throw new Tf("The kernel for a conv1dWithBias operation should be 3, but is "+"".concat(t.shape.length," instead"));if(null!=n&&1!==n.shape.length)throw new Tf("The bias for a conv1dWithBias operation should be 1, but is "+"".concat(n.shape.length," instead"));if("channelsFirst"===s&&(e=El(e,[0,2,1])),"causal"===r)throw new Ef("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");let i=nc(e,t,a,"same"===r?"same":"valid","NWC",o);return null!=n&&(i=Om(i,n)),i}))}function zb(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:null;return Es((()=>{if(null==s&&(s="channelsLast"),sm(s),3!==e.rank&&4!==e.rank)throw new Tf("conv2dWithBiasActivation expects input to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));if(3!==t.rank&&4!==t.rank)throw new Tf("conv2dWithBiasActivation expects kernel to be of rank 3 or 4, "+"but received ".concat(e.rank,"."));let c=Ob(e,s);if("causal"===r)throw new Ef("The support for CAUSAL padding mode in conv1dWithBias is not implemented yet.");return c=Wl({x:c,filter:t,strides:a,pad:"same"===r?"same":"valid",dilations:o,dataFormat:"NHWC",bias:n,activation:i}),"channelsFirst"===s&&(c=El(c,[0,3,1,2])),c}))}function Pb(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:[1,1,1],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"valid",s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6?arguments[6]:void 0;return Es((()=>{if(null==s&&(s="channelsLast"),sm(s),4!==e.rank&&5!==e.rank)throw new Tf("conv3dWithBias expects input to be of rank 4 or 5, but received "+"".concat(e.rank,"."));if(4!==t.rank&&5!==t.rank)throw new Tf("conv3dWithBias expects kernel to be of rank 4 or 5, but received "+"".concat(e.rank,"."));let i=Mb(e,s);if("causal"===r)throw new Ef("The support for CAUSAL padding mode in conv3dWithBias is not implemented yet.");return i=sc(i,t,a,"same"===r?"same":"valid","NDHWC",o),null!=n&&(i=Om(i,n)),"channelsFirst"===s&&(i=El(i,[0,4,1,2,3])),i}))}Ab.className="Softmax",Do(Ab);class Bb extends vg{constructor(e,t){if(super(t),this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",Bb.verifyArgs(t),this.rank=e,Kf(this.rank,"rank"),1!==this.rank&&2!==this.rank&&3!==this.rank)throw new Ef("Convolution layer for rank other than 1, 2, or 3 (".concat(this.rank,") is ")+"not implemented yet.");if(this.kernelSize=_b(t.kernelSize,e,"kernelSize"),this.strides=_b(null==t.strides?1:t.strides,e,"strides"),this.padding=null==t.padding?"valid":t.padding,om(this.padding),this.dataFormat=null==t.dataFormat?"channelsLast":t.dataFormat,sm(this.dataFormat),this.activation=yb(t.activation),this.useBias=null==t.useBias||t.useBias,this.biasInitializer=rg(t.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.biasConstraint=Pg(t.biasConstraint),this.biasRegularizer=Ib(t.biasRegularizer),this.activityRegularizer=Ib(t.activityRegularizer),this.dilationRate=_b(null==t.dilationRate?1:t.dilationRate,e,"dilationRate"),1===this.rank&&Array.isArray(this.dilationRate)&&1!==this.dilationRate.length)throw new Tf("dilationRate must be a number or an array of a single number for 1D convolution, but received "+"".concat(JSON.stringify(this.dilationRate)));if(2===this.rank){if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate];else if(2!==this.dilationRate.length)throw new Tf("dilationRate must be a number or array of two numbers for 2D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}else if(3===this.rank)if("number"===typeof this.dilationRate)this.dilationRate=[this.dilationRate,this.dilationRate,this.dilationRate];else if(3!==this.dilationRate.length)throw new Tf("dilationRate must be a number or array of three numbers for 3D "+"convolution, but received ".concat(JSON.stringify(this.dilationRate)))}static verifyArgs(e){if(_f("kernelSize"in e,"required key 'kernelSize' not in config"),"number"!==typeof e.kernelSize&&!jf(e.kernelSize,"number",1,3))throw new Tf("BaseConv expects config.kernelSize to be number or number[] with "+"length 1, 2, or 3, but received ".concat(JSON.stringify(e.kernelSize),"."))}getConfig(){const e={kernelSize:this.kernelSize,strides:this.strides,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,activation:mb(this.activation),useBias:this.useBias,biasInitializer:ag(this.biasInitializer),biasRegularizer:kb(this.biasRegularizer),activityRegularizer:kb(this.activityRegularizer),biasConstraint:Lg(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}class Wb extends Bb{constructor(e,t){super(e,t),this.kernel=null,Wb.verifyArgs(t),this.filters=t.filters,Kf(this.filters,"filters"),this.kernelInitializer=rg(t.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.kernelConstraint=Pg(t.kernelConstraint),this.kernelRegularizer=Ib(t.kernelRegularizer)}build(e){e=cg(e);const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Tf("The channel dimension of the input should be defined. "+"Found ".concat(e[t]));const n=e[t],a=this.kernelSize.concat([n,this.filters]);this.kernel=this.addWeight("kernel",a,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[{ndim:this.rank+2,axes:{[t]:n}}],this.built=!0}call(e,t){return Es((()=>{let t;e=ig(e);const n=null==this.bias?null:this.bias.read(),a=Xf(this.activation.getClassName());if(null!=a&&2===this.rank)t=zb(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate,a);else{if(1===this.rank)t=Lb(e,this.kernel.read(),n,this.strides[0],this.padding,this.dataFormat,this.dilationRate[0]);else if(2===this.rank)t=zb(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate);else{if(3!==this.rank)throw new Ef("convolutions greater than 3D are not implemented yet.");t=Pb(e,this.kernel.read(),n,this.strides,this.padding,this.dataFormat,this.dilationRate)}null!=this.activation&&(t=this.activation.apply(t))}return t}))}computeOutputShape(e){e=cg(e);const t=[],n="channelsLast"===this.dataFormat?e.slice(1,e.length-1):e.slice(2);for(let r=0;r<n.length;++r){const e=Db(n[r],this.kernelSize[r],this.padding,this.strides[r],"number"===typeof this.dilationRate?this.dilationRate:this.dilationRate[r]);t.push(e)}let a=[e[0]];return"channelsLast"===this.dataFormat?(a=a.concat(t),a.push(this.filters)):(a.push(this.filters),a=a.concat(t)),a}getConfig(){const e={filters:this.filters,kernelInitializer:ag(this.kernelInitializer),kernelRegularizer:kb(this.kernelRegularizer),kernelConstraint:Lg(this.kernelConstraint)},t=super.getConfig();return Object.assign(e,t),e}static verifyArgs(e){if(!("filters"in e)||"number"!==typeof e.filters||e.filters<1)throw new Tf("Convolution layer expected config.filters to be a 'number' > 0 "+"but got ".concat(JSON.stringify(e.filters)))}}class Vb extends Wb{constructor(e){super(2,e),Vb.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!jf(e.kernelSize,"number",1,2))throw new Tf("Conv2D expects config.kernelSize to be number or number[] with "+"length 1 or 2, but received ".concat(JSON.stringify(e.kernelSize),"."))}}Vb.className="Conv2D",Do(Vb);class Ub extends Wb{constructor(e){super(3,e),Ub.verifyArgs(e)}getConfig(){const e=super.getConfig();return delete e.rank,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&(!Array.isArray(e.kernelSize)||1!==e.kernelSize.length&&3!==e.kernelSize.length))throw new Tf("Conv3D expects config.kernelSize to be number or"+" [number, number, number], but received ".concat(JSON.stringify(e.kernelSize),"."))}}Ub.className="Conv3D",Do(Ub);class Gb extends Vb{constructor(e){if(super(e),this.inputSpec=[new fg({ndim:4})],"same"!==this.padding&&"valid"!==this.padding)throw new Tf("Conv2DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(4!==(e=cg(e)).length)throw new Tf("Input should have rank 4; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Tf("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new fg({ndim:4,axes:{[t]:n}})],this.built=!0}call(e,t){return Es((()=>{let t=ig(e);if(4!==t.shape.length)throw new Tf("Conv2DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,s;"channelsFirst"===this.dataFormat?(r=2,s=3):(r=1,s=2);const o=n[r],i=n[s],c=this.kernelSize[0],l=this.kernelSize[1],u=this.strides[0],h=this.strides[1],d=[a,Fb(o,u,c,this.padding),Fb(i,h,l,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=El(t,[0,2,3,1]));let p=rc(t,this.kernel.read(),d,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(p=El(p,[0,3,1,2])),null!=this.bias&&(p=Om(p,this.bias.read(),this.dataFormat)),null!=this.activation&&(p=this.activation.apply(p)),p}))}computeOutputShape(e){const t=(e=cg(e)).slice();let n,a,r;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3):(n=3,a=1,r=2);const s=this.kernelSize[0],o=this.kernelSize[1],i=this.strides[0],c=this.strides[1];return t[n]=this.filters,t[a]=Fb(t[a],i,s,this.padding),t[r]=Fb(t[r],c,o,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Gb.className="Conv2DTranspose",Do(Gb);class Hb extends Ub{constructor(e){if(super(e),this.inputSpec=[new fg({ndim:5})],"same"!==this.padding&&"valid"!==this.padding)throw new Tf("Conv3DTranspose currently supports only padding modes 'same' "+"and 'valid', but received padding mode ".concat(this.padding))}build(e){if(5!==(e=cg(e)).length)throw new Tf("Input should have rank 5; Received input shape: "+JSON.stringify(e));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t])throw new Tf("The channel dimension of the inputs should be defined. Found `None`.");const n=e[t],a=this.kernelSize.concat([this.filters,n]);this.kernel=this.addWeight("kernel",a,"float32",this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint)),this.inputSpec=[new fg({ndim:5,axes:{[t]:n}})],this.built=!0}call(e,t){return Es((()=>{let t=ig(e);if(5!==t.shape.length)throw new Tf("Conv3DTranspose.call() expects input tensor to be rank-4, but "+"received a tensor of rank-".concat(t.shape.length));const n=t.shape,a=n[0];let r,s,o;"channelsFirst"===this.dataFormat?(o=2,r=3,s=4):(o=1,r=2,s=3);const i=n[o],c=n[r],l=n[s],u=this.kernelSize[0],h=this.kernelSize[1],d=this.kernelSize[2],p=this.strides[0],f=this.strides[1],m=this.strides[2],g=[a,Fb(i,p,u,this.padding),Fb(c,f,h,this.padding),Fb(l,m,d,this.padding),this.filters];"channelsLast"!==this.dataFormat&&(t=El(t,[0,2,3,4,1]));let y=ic(t,this.kernel.read(),g,this.strides,this.padding);return"channelsLast"!==this.dataFormat&&(y=El(y,[0,4,1,2,3])),null!==this.bias&&(y=Om(y,this.bias.read(),this.dataFormat)),null!==this.activation&&(y=this.activation.apply(y)),y}))}computeOutputShape(e){const t=(e=cg(e)).slice();let n,a,r,s;"channelsFirst"===this.dataFormat?(n=1,a=2,r=3,s=4):(n=4,a=1,r=2,s=3);const o=this.kernelSize[0],i=this.kernelSize[1],c=this.kernelSize[2],l=this.strides[0],u=this.strides[1],h=this.strides[2];return t[n]=this.filters,t[a]=Fb(t[a],l,o,this.padding),t[r]=Fb(t[r],u,i,this.padding),t[s]=Fb(t[s],h,c,this.padding),t}getConfig(){const e=super.getConfig();return delete e.dilationRate,e}}Hb.className="Conv3DTranspose",Do(Hb);class jb extends Wb{constructor(e,t){if(super(e,t),this.DEFAULT_DEPTHWISE_INITIALIZER="glorotUniform",this.DEFAULT_POINTWISE_INITIALIZER="glorotUniform",this.depthwiseKernel=null,this.pointwiseKernel=null,null==t.filters)throw new Tf("The `filters` configuration field is required by SeparableConv, but is unspecified.");if(null!=t.kernelInitializer||null!=t.kernelRegularizer||null!=t.kernelConstraint)throw new Tf("Fields kernelInitializer, kernelRegularizer and kernelConstraint are invalid for SeparableConv2D. Use depthwiseInitializer, depthwiseRegularizer, depthwiseConstraint, pointwiseInitializer, pointwiseRegularizer and pointwiseConstraint instead.");if(null!=t.padding&&"same"!==t.padding&&"valid"!==t.padding)throw new Tf("SeparableConv".concat(this.rank,"D supports only padding modes: ")+"'same' and 'valid', but received ".concat(JSON.stringify(t.padding)));this.depthMultiplier=null==t.depthMultiplier?1:t.depthMultiplier,this.depthwiseInitializer=rg(t.depthwiseInitializer||this.DEFAULT_DEPTHWISE_INITIALIZER),this.depthwiseRegularizer=Ib(t.depthwiseRegularizer),this.depthwiseConstraint=Pg(t.depthwiseConstraint),this.pointwiseInitializer=rg(t.depthwiseInitializer||this.DEFAULT_POINTWISE_INITIALIZER),this.pointwiseRegularizer=Ib(t.pointwiseRegularizer),this.pointwiseConstraint=Pg(t.pointwiseConstraint)}build(e){if((e=cg(e)).length<this.rank+2)throw new Tf("Inputs to SeparableConv".concat(this.rank,"D should have rank ")+"".concat(this.rank+2,", but received input shape: ")+"".concat(JSON.stringify(e)));const t="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[t]||e[t]<0)throw new Tf("The channel dimension of the inputs should be defined, "+"but found ".concat(JSON.stringify(e[t])));const n=e[t],a=this.kernelSize.concat([n,this.depthMultiplier]),r=[];for(let o=0;o<this.rank;++o)r.push(1);r.push(n*this.depthMultiplier,this.filters);const s=!0;this.depthwiseKernel=this.addWeight("depthwise_kernel",a,"float32",this.depthwiseInitializer,this.depthwiseRegularizer,s,this.depthwiseConstraint),this.pointwiseKernel=this.addWeight("pointwise_kernel",r,"float32",this.pointwiseInitializer,this.pointwiseRegularizer,s,this.pointwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[this.filters],"float32",this.biasInitializer,this.biasRegularizer,s,this.biasConstraint):this.bias=null,this.inputSpec=[new fg({ndim:this.rank+2,axes:{[t]:n}})],this.built=!0}call(e,t){return Es((()=>{let t;if(e=ig(e),1===this.rank)throw new Ef("1D separable convolution is not implemented yet.");return 2===this.rank&&("channelsFirst"===this.dataFormat&&(e=El(e,[0,2,3,1])),t=il(e,this.depthwiseKernel.read(),this.pointwiseKernel.read(),this.strides,this.padding,this.dilationRate,"NHWC")),this.useBias&&(t=Om(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),"channelsFirst"===this.dataFormat&&(t=El(t,[0,3,1,2])),t}))}getConfig(){const e=super.getConfig();return delete e.rank,delete e.kernelInitializer,delete e.kernelRegularizer,delete e.kernelConstraint,e.depthwiseInitializer=ag(this.depthwiseInitializer),e.pointwiseInitializer=ag(this.pointwiseInitializer),e.depthwiseRegularizer=kb(this.depthwiseRegularizer),e.pointwiseRegularizer=kb(this.pointwiseRegularizer),e.depthwiseConstraint=Lg(this.depthwiseConstraint),e.pointwiseConstraint=Lg(this.pointwiseConstraint),e}}jb.className="SeparableConv";class Kb extends jb{constructor(e){super(2,e)}}Kb.className="SeparableConv2D",Do(Kb);class qb extends Wb{constructor(e){super(1,e),qb.verifyArgs(e),this.inputSpec=[{ndim:3}]}getConfig(){const e=super.getConfig();return delete e.rank,delete e.dataFormat,e}static verifyArgs(e){if("number"!==typeof e.kernelSize&&!jf(e.kernelSize,"number",1,1))throw new Tf("Conv1D expects config.kernelSize to be number or number[] with "+"length 1, but received ".concat(JSON.stringify(e.kernelSize),"."))}}qb.className="Conv1D",Do(qb);class Xb extends vg{constructor(e){super(e),"number"===typeof e.cropping?this.cropping=[[e.cropping,e.cropping],[e.cropping,e.cropping]]:"number"===typeof e.cropping[0]?this.cropping=[[e.cropping[0],e.cropping[0]],[e.cropping[1],e.cropping[1]]]:this.cropping=e.cropping,this.dataFormat=void 0===e.dataFormat?"channelsLast":e.dataFormat,this.inputSpec=[{ndim:4}]}computeOutputShape(e){return"channelsFirst"===this.dataFormat?[e[0],e[1],e[2]-this.cropping[0][0]-this.cropping[0][1],e[3]-this.cropping[1][0]-this.cropping[1][1]]:[e[0],e[1]-this.cropping[0][0]-this.cropping[0][1],e[2]-this.cropping[1][0]-this.cropping[1][1],e[3]]}call(e,t){return Es((()=>{if(e=ig(e),"channelsLast"===this.dataFormat){const t=Nm(e,this.cropping[0][0],e.shape[1]-this.cropping[0][0]-this.cropping[0][1],2);return Nm(t,this.cropping[1][0],e.shape[2]-this.cropping[1][1]-this.cropping[1][0],3)}{const t=Nm(e,this.cropping[0][0],e.shape[2]-this.cropping[0][0]-this.cropping[0][1],3);return Nm(t,this.cropping[1][0],e.shape[3]-this.cropping[1][1]-this.cropping[1][0],4)}}))}getConfig(){const e={cropping:this.cropping,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}Xb.className="Cropping2D",Do(Xb);class Yb extends vg{constructor(e){var t;super(e),this.DEFAULT_SIZE=[2,2],this.inputSpec=[{ndim:4}],this.size=null==e.size?this.DEFAULT_SIZE:e.size,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sm(this.dataFormat),this.interpolation=null==e.interpolation?"nearest":e.interpolation,t=this.interpolation,Hf(em,"InterpolationFormat",t)}computeOutputShape(e){if("channelsFirst"===this.dataFormat){const t=null==e[2]?null:this.size[0]*e[2],n=null==e[3]?null:this.size[1]*e[3];return[e[0],e[1],t,n]}{const t=null==e[1]?null:this.size[0]*e[1],n=null==e[2]?null:this.size[1]*e[2];return[e[0],t,n,e[3]]}}call(e,t){return Es((()=>{let t=ig(e);const n=t.shape;if("channelsFirst"===this.dataFormat){t=El(t,[0,2,3,1]);const e=this.size[0]*n[2],a=this.size[1]*n[3],r="nearest"===this.interpolation?Cu.resizeNearestNeighbor(t,[e,a]):Cu.resizeBilinear(t,[e,a]);return El(r,[0,3,1,2])}{const e=this.size[0]*n[1],a=this.size[1]*n[2];return"nearest"===this.interpolation?Cu.resizeNearestNeighbor(t,[e,a]):Cu.resizeBilinear(t,[e,a])}}))}getConfig(){const e={size:this.size,dataFormat:this.dataFormat,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}}Yb.className="UpSampling2D",Do(Yb);class Qb extends Bb{constructor(e){super(2,e),this.depthwiseKernel=null,this.depthMultiplier=null==e.depthMultiplier?1:e.depthMultiplier,this.depthwiseInitializer=rg(e.depthwiseInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.depthwiseConstraint=Pg(e.depthwiseConstraint),this.depthwiseRegularizer=Ib(e.depthwiseRegularizer)}build(e){if((e=cg(e)).length<4)throw new Tf("Inputs to DepthwiseConv2D should have rank 4. "+"Received input shape: ".concat(JSON.stringify(e),"."));const t="channelsFirst"===this.dataFormat?1:3;if(null==e[t]||e[t]<0)throw new Tf("The channel dimension of the inputs to DepthwiseConv2D should "+"be defined, but is not (".concat(e[t],")."));const n=e[t],a=[this.kernelSize[0],this.kernelSize[1],n,this.depthMultiplier];this.depthwiseKernel=this.addWeight("depthwise_kernel",a,null,this.depthwiseInitializer,this.depthwiseRegularizer,!0,this.depthwiseConstraint),this.useBias?this.bias=this.addWeight("bias",[n*this.depthMultiplier],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Es((()=>{let t=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[1,1],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"valid",r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0;return Es((()=>{null==r&&(r="channelsLast"),sm(r);let o=Ob(e,r);if(4!==e.rank)throw new Tf("Input for depthwiseConv2d is required to be 4-D, but is instead "+"".concat(e.rank,"-D"));if(4!==t.rank)throw new Tf("depthwiseKernel is required to be 4-D, but is instead "+"".concat(t.rank,"-D"));return o=lc(o,t,n,"same"===a?"same":"valid","NHWC",s),"channelsFirst"===r&&(o=El(o,[0,3,1,2])),o}))}(e=ig(e),this.depthwiseKernel.read(),this.strides,this.padding,this.dataFormat,null);return this.useBias&&(t=Om(t,this.bias.read(),this.dataFormat)),null!=this.activation&&(t=this.activation.apply(t)),t}))}computeOutputShape(e){e=cg(e);const t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[1]*this.depthMultiplier:e[3]*this.depthMultiplier,r=Db(t,this.kernelSize[0],this.padding,this.strides[0]),s=Db(n,this.kernelSize[1],this.padding,this.strides[1]);return"channelsFirst"===this.dataFormat?[e[0],a,r,s]:[e[0],r,s,a]}getConfig(){const e=super.getConfig();return e.depthMultiplier=this.depthMultiplier,e.depthwiseInitializer=ag(this.depthwiseInitializer),e.depthwiseRegularizer=kb(this.depthwiseRegularizer),e.depthwiseConstraint=Lg(this.depthwiseRegularizer),e}}function Jb(e,t,n,a){if(Array.isArray(e)){if(null!=t||null!=n)throw new Tf("When inputs is an array, neither initialState or constants should be provided");null!=a&&(n=e.slice(e.length-a,e.length),e=e.slice(0,e.length-a)),e.length>1&&(t=e.slice(1,e.length)),e=e[0]}function r(e){return null==e||Array.isArray(e)?e:[e]}return{inputs:e,initialState:t=r(t),constants:n=r(n)}}function Zb(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5?arguments[5]:void 0,o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7];return Es((()=>{const c=t.shape.length;if(c<3)throw new Tf("Input should be at least 3D, but is ".concat(c,"D."));const l=[1,0].concat(bm(2,c));if(t=El(t,l),null!=s)throw new Ef("The rnn() functoin of the deeplearn.js backend does not support constants yet.");o&&console.warn("Backend rnn(): the unroll = true option is not applicable to the imperative deeplearn.js backend."),null!=r&&(r=yo(yo(r,"bool"),"float32"),r.rank===c-1&&(r=fc(r,-1)),r=El(r,l)),a&&(t=sl(t,0),null!=r&&(r=sl(r,0)));const u=[];let h,d=n;const p=t.shape[0],f=Sl(t);let m,g;null!=r&&(m=Sl(r));for(let t=0;t<p;++t){const n=f[t],a=Es((()=>e(n,d)));if(null==r)h=a[0],d=a[1];else{const e=Es((()=>{const e=m[t],n=Po(Yc(e),e);return{output:vo(ko(a[0],e),ko(d[0],n)),newStates:d.map(((t,r)=>vo(ko(a[1][r],e),ko(t,n))))}}));h=e.output,d=e.newStates}i&&u.push(h)}if(i){g=bl(u,1)}return[h,g,d]}))}Qb.className="DepthwiseConv2D",Do(Qb);class $b extends vg{constructor(e){let t;if(super(e),null==e.cell)throw new Tf("cell property is missing for the constructor of RNN.");if(t=Array.isArray(e.cell)?new iv({cells:e.cell}):e.cell,null==t.stateSize)throw new Tf("The RNN cell should have an attribute `stateSize` (tuple of integers, one integer per RNN state).");this.cell=t,this.returnSequences=null!=e.returnSequences&&e.returnSequences,this.returnState=null!=e.returnState&&e.returnState,this.goBackwards=null!=e.goBackwards&&e.goBackwards,this._stateful=null!=e.stateful&&e.stateful,this.unroll=null!=e.unroll&&e.unroll,this.supportsMasking=!0,this.inputSpec=[new fg({ndim:3})],this.stateSpec=null,this.states_=null,this.numConstants=null,this.keptStates=[]}getStates(){if(null==this.states_){return bm(0,Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1).map((e=>null))}return this.states_}setStates(e){this.states_=e}computeOutputShape(e){sg(e)&&(e=e[0]);let t=this.cell.stateSize;Array.isArray(t)||(t=[t]);const n=t[0];let a;if(a=this.returnSequences?[e[0],e[1],n]:[e[0],n],this.returnState){const n=[];for(const a of t)n.push([e[0],a]);return[a].concat(n)}return a}computeMask(e,t){return Es((()=>{Array.isArray(t)&&(t=t[0]);const e=this.returnSequences?t:null;if(this.returnState){const t=this.states.map((e=>null));return[e].concat(t)}return e}))}get states(){if(null==this.states_){const e=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1,t=[];for(let n=0;n<e;++n)t.push(null);return t}return this.states_}set states(e){this.states_=e}build(e){if(null!=this.numConstants)throw new Ef("Constants support is not implemented in RNN yet.");sg(e)&&(e=e[0]);const t=this.stateful?e[0]:null,n=e.slice(2);this.inputSpec[0]=new fg({shape:[t,null,...n]});const a=[e[0]].concat(e.slice(2));let r;if(this.cell.build(a),r=Array.isArray(this.cell.stateSize)?this.cell.stateSize:[this.cell.stateSize],null!=this.stateSpec){if(!te(this.stateSpec.map((e=>e.shape[e.shape.length-1])),r))throw new Tf("An initialState was passed that is not compatible with "+"cell.stateSize. Received stateSpec=".concat(this.stateSpec,"; ")+"However cell.stateSize is ".concat(this.cell.stateSize))}else this.stateSpec=r.map((e=>new fg({shape:[null,e]})));this.stateful&&this.resetStates()}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Es((()=>{if(!this.stateful)throw new If("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape[0];if(null==n)throw new Tf("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.states_)Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>qc([n,e]))):this.states_=[qc([n,this.cell.stateSize])];else if(null==e)Cs(this.states_),null!=this.keptStates&&(Cs(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((e=>qc([n,e]))):this.states_[0]=qc([n,this.cell.stateSize]);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Tf("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));!0===t?this.keptStates.push(this.states_.slice()):Cs(this.states_);for(let t=0;t<this.states_.length;++t){const a=e[t],r=Array.isArray(this.cell.stateSize)?this.cell.stateSize[t]:this.cell.stateSize,s=[n,r];if(!te(a.shape,s))throw new Tf("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(s,", received shape=").concat(a.shape));this.states_[t]=a}}this.states_=this.states_.map((e=>Rs(e.clone())))}))}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=Jb(e,n,a,this.numConstants);e=r.inputs,n=r.initialState,a=r.constants;let s=[],o=[];if(null!=n){t.initialState=n,s=s.concat(n),this.stateSpec=[];for(const e of n)this.stateSpec.push(new fg({shape:e.shape}));o=o.concat(this.stateSpec)}null!=a&&(t.constants=a,s=s.concat(a),this.numConstants=a.length);if(s[0]instanceof mg){const n=[e].concat(s),a=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return Es((()=>{const n=null==t?null:t.mask,a=null==t?null:t.training;let r=null==t?null:t.initialState;e=ig(e),null==r&&(r=this.stateful?this.states_:this.getInitialState(e));const s=Array.isArray(this.cell.stateSize)?this.cell.stateSize.length:1;if(r.length!==s)throw new Tf("RNN Layer has ".concat(s," state(s) but was passed ")+"".concat(r.length," initial state(s)."));this.unroll&&console.warn("Ignoring unroll = true for RNN layer, due to imperative backend.");const o={training:a},i=Zb(((e,t)=>{const n=this.cell.call([e].concat(t),o);return[n[0],n.slice(1)]}),e,r,this.goBackwards,n,null,this.unroll,this.returnSequences),c=i[0],l=i[1],u=i[2];this.stateful&&this.resetStates(u,a);const h=this.returnSequences?l:c;return this.returnState?[h].concat(u):h}))}getInitialState(e){return Es((()=>{let t=qc(e.shape);return t=Nc(t,[1,2]),t=km(t),Array.isArray(this.cell.stateSize)?this.cell.stateSize.map((e=>e>1?Cm(t,[1,e]):t)):this.cell.stateSize>1?[Cm(t,[1,this.cell.stateSize])]:[t]}))}get trainableWeights(){return this.trainable?this.cell.trainableWeights:[]}get nonTrainableWeights(){return this.trainable?this.cell.nonTrainableWeights:this.cell.weights}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.cell&&this.cell.setFastWeightInitDuringBuild(e)}getConfig(){const e=super.getConfig(),t={returnSequences:this.returnSequences,returnState:this.returnState,goBackwards:this.goBackwards,stateful:this.stateful,unroll:this.unroll};null!=this.numConstants&&(t.numConstants=this.numConstants);const n=this.cell.getConfig();return this.getClassName()===$b.className&&(t.cell={className:this.cell.getClassName(),config:n}),Object.assign(Object.assign(Object.assign({},n),e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=Qg(t.cell,n);return new e(Object.assign(t,{cell:a}))}}$b.className="RNN",Do($b);class ev extends vg{}class tv extends ev{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Kf(this.units,"units"),this.activation=yb(null==e.activation?this.DEFAULT_ACTIVATION:e.activation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rg(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ib(e.kernelRegularizer),this.recurrentRegularizer=Ib(e.recurrentRegularizer),this.biasRegularizer=Ib(e.biasRegularizer),this.kernelConstraint=Pg(e.kernelConstraint),this.recurrentConstraint=Pg(e.recurrentConstraint),this.biasConstraint=Pg(e.biasConstraint),this.dropout=gm([1,ym([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gm([1,ym([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){e=cg(e),this.kernel=this.addWeight("kernel",[e[e.length-1],this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Es((()=>{if(2!==e.length)throw new Tf("SimpleRNNCell expects 2 input Tensors, got ".concat(e.length,"."));let n=e[1];e=e[0];const a=null!=t.training&&t.training;let r;0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cv({ones:()=>Yc(e),rate:this.dropout,training:a,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cv({ones:()=>Yc(n),rate:this.recurrentDropout,training:a,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;r=Am(null!=s?ko(e,s):e,this.kernel.read()),null!=this.bias&&(r=Om(r,this.bias.read())),null!=o&&(n=ko(n,o));let i=vo(r,Am(n,this.recurrentKernel.read()));return null!=this.activation&&(i=this.activation.apply(i)),[i,i]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mb(this.activation),useBias:this.useBias,kernelInitializer:ag(this.kernelInitializer),recurrentInitializer:ag(this.recurrentInitializer),biasInitializer:ag(this.biasInitializer),kernelRegularizer:kb(this.kernelRegularizer),recurrentRegularizer:kb(this.recurrentRegularizer),biasRegularizer:kb(this.biasRegularizer),activityRegularizer:kb(this.activityRegularizer),kernelConstraint:Lg(this.kernelConstraint),recurrentConstraint:Lg(this.recurrentConstraint),biasConstraint:Lg(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout};return Object.assign(Object.assign({},e),t)}}tv.className="SimpleRNNCell",Do(tv);class nv extends $b{constructor(e){e.cell=new tv(e),super(e)}call(e,t){return Es((()=>{null!=this.cell.dropoutMask&&(Cs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Cs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return new e(t)}}nv.className="SimpleRNN",Do(nv);class av extends ev{constructor(e){if(super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",e.resetAfter)throw new Tf("GRUCell does not support reset_after parameter set to true.");this.units=e.units,Kf(this.units,"units"),this.activation=yb(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=yb(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rg(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelRegularizer=Ib(e.kernelRegularizer),this.recurrentRegularizer=Ib(e.recurrentRegularizer),this.biasRegularizer=Ib(e.biasRegularizer),this.kernelConstraint=Pg(e.kernelConstraint),this.recurrentConstraint=Pg(e.recurrentConstraint),this.biasConstraint=Pg(e.biasConstraint),this.dropout=gm([1,ym([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gm([1,ym([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=this.units,this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){const t=(e=cg(e))[e.length-1];this.kernel=this.addWeight("kernel",[t,3*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,3*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias?this.bias=this.addWeight("bias",[3*this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint):this.bias=null,this.built=!0}call(e,t){return Es((()=>{if(2!==e.length)throw new Tf("GRUCell expects 2 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=null!=t.training&&t.training;let a=e[1];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cv({ones:()=>Yc(e),rate:this.dropout,training:n,count:3,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cv({ones:()=>Yc(a),rate:this.recurrentDropout,training:n,count:3,dropoutFunc:this.dropoutFunc}));const r=this.dropoutMask,s=this.recurrentDropoutMask;let o,i,c;0<this.dropout&&this.dropout<1&&(e=ko(e,r[0]));let l=Am(e,this.kernel.read());this.useBias&&(l=Om(l,this.bias.read())),0<this.recurrentDropout&&this.recurrentDropout<1&&(a=ko(a,s[0]));const u=this.recurrentKernel.read(),[h,d]=gl(u,[2*this.units,this.units],u.rank-1),p=Am(a,h),[f,m,g]=gl(l,3,l.rank-1),[y,b]=gl(p,2,p.rank-1);o=this.recurrentActivation.apply(vo(f,y)),i=this.recurrentActivation.apply(vo(m,b));const v=Am(ko(i,a),d);c=this.activation.apply(vo(g,v));const x=vo(ko(o,a),ko(vo(1,Hc(o)),c));return[x,x]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mb(this.activation),recurrentActivation:mb(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ag(this.kernelInitializer),recurrentInitializer:ag(this.recurrentInitializer),biasInitializer:ag(this.biasInitializer),kernelRegularizer:kb(this.kernelRegularizer),recurrentRegularizer:kb(this.recurrentRegularizer),biasRegularizer:kb(this.biasRegularizer),activityRegularizer:kb(this.activityRegularizer),kernelConstraint:Lg(this.kernelConstraint),recurrentConstraint:Lg(this.recurrentConstraint),biasConstraint:Lg(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation,resetAfter:!1};return Object.assign(Object.assign({},e),t)}}av.className="GRUCell",Do(av);class rv extends $b{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new av(e),super(e)}call(e,t){return Es((()=>{null!=this.cell.dropoutMask&&(Cs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Cs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}rv.className="GRU",Do(rv);class sv extends ev{constructor(e){super(e),this.DEFAULT_ACTIVATION="tanh",this.DEFAULT_RECURRENT_ACTIVATION="hardSigmoid",this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_RECURRENT_INITIALIZER="orthogonal",this.DEFAULT_BIAS_INITIALIZER="zeros",this.units=e.units,Kf(this.units,"units"),this.activation=yb(void 0===e.activation?this.DEFAULT_ACTIVATION:e.activation),this.recurrentActivation=yb(void 0===e.recurrentActivation?this.DEFAULT_RECURRENT_ACTIVATION:e.recurrentActivation),this.useBias=null==e.useBias||e.useBias,this.kernelInitializer=rg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.recurrentInitializer=rg(e.recurrentInitializer||this.DEFAULT_RECURRENT_INITIALIZER),this.biasInitializer=rg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.unitForgetBias=e.unitForgetBias,this.kernelRegularizer=Ib(e.kernelRegularizer),this.recurrentRegularizer=Ib(e.recurrentRegularizer),this.biasRegularizer=Ib(e.biasRegularizer),this.kernelConstraint=Pg(e.kernelConstraint),this.recurrentConstraint=Pg(e.recurrentConstraint),this.biasConstraint=Pg(e.biasConstraint),this.dropout=gm([1,ym([0,null==e.dropout?0:e.dropout])]),this.recurrentDropout=gm([1,ym([0,null==e.recurrentDropout?0:e.recurrentDropout])]),this.dropoutFunc=e.dropoutFunc,this.implementation=e.implementation,this.stateSize=[this.units,this.units],this.dropoutMask=null,this.recurrentDropoutMask=null}build(e){var t;const n=(e=cg(e))[e.length-1];let a;if(this.kernel=this.addWeight("kernel",[n,4*this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.recurrentKernel=this.addWeight("recurrent_kernel",[this.units,4*this.units],null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){if(this.unitForgetBias){const e=this.biasInitializer,n=this.units;a=new((t=class extends Bm{apply(t,a){const r=e.apply([n]),s=(new Vm).apply([n]),o=e.apply([2*n]);return Em(Em(r,s),o)}}).className="CustomInit",t)}else a=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.units],null,a,this.biasRegularizer,!0,this.biasConstraint)}else this.bias=null;this.built=!0}call(e,t){return Es((()=>{const n=null!=t.training&&t.training;if(3!==e.length)throw new Tf("LSTMCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));let a=e[1];const r=e[2];e=e[0],0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cv({ones:()=>Yc(e),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc})),0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cv({ones:()=>Yc(a),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const s=this.dropoutMask,o=this.recurrentDropoutMask;let i,c,l,u;0<this.dropout&&this.dropout<1&&(e=ko(e,s[0]));let h=Am(e,this.kernel.read());0<this.recurrentDropout&&this.recurrentDropout<1&&(a=ko(a,o[0])),h=vo(h,Am(a,this.recurrentKernel.read())),this.useBias&&(h=Om(h,this.bias.read()));const[d,p,f,m]=gl(h,4,h.rank-1);i=this.recurrentActivation.apply(d),c=this.recurrentActivation.apply(p),l=vo(ko(c,r),ko(i,this.activation.apply(f))),u=this.recurrentActivation.apply(m);const g=ko(u,this.activation.apply(l));return[g,g,l]}))}getConfig(){const e=super.getConfig(),t={units:this.units,activation:mb(this.activation),recurrentActivation:mb(this.recurrentActivation),useBias:this.useBias,kernelInitializer:ag(this.kernelInitializer),recurrentInitializer:ag(this.recurrentInitializer),biasInitializer:ag(this.biasInitializer),unitForgetBias:this.unitForgetBias,kernelRegularizer:kb(this.kernelRegularizer),recurrentRegularizer:kb(this.recurrentRegularizer),biasRegularizer:kb(this.biasRegularizer),activityRegularizer:kb(this.activityRegularizer),kernelConstraint:Lg(this.kernelConstraint),recurrentConstraint:Lg(this.recurrentConstraint),biasConstraint:Lg(this.biasConstraint),dropout:this.dropout,recurrentDropout:this.recurrentDropout,implementation:this.implementation};return Object.assign(Object.assign({},e),t)}}sv.className="LSTMCell",Do(sv);class ov extends $b{constructor(e){0===e.implementation&&console.warn("`implementation=0` has been deprecated, and now defaults to `implementation=1`. Please update your layer call."),e.cell=new sv(e),super(e)}call(e,t){return Es((()=>{null!=this.cell.dropoutMask&&(Cs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Cs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null);const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}static fromConfig(e,t){return 0===t.implmentation&&(t.implementation=1),new e(t)}}ov.className="LSTM",Do(ov);class iv extends ev{constructor(e){super(e),this.cells=e.cells}get stateSize(){const e=[];for(const t of this.cells.slice().reverse())Array.isArray(t.stateSize)?e.push(...t.stateSize):e.push(t.stateSize);return e}call(e,t){return Es((()=>{let n=e.slice(1);const a=[];for(const e of this.cells.slice().reverse())Array.isArray(e.stateSize)?a.push(n.splice(0,e.stateSize.length)):a.push(n.splice(0,1));a.reverse();const r=[];let s;for(let o=0;o<this.cells.length;++o){const i=this.cells[o];n=a[o],s=0===o?[e[0]].concat(n):[s[0]].concat(n),s=i.call(s,t),r.push(s.slice(1))}n=[];for(const e of r.slice().reverse())n.push(...e);return[s[0]].concat(n)}))}build(e){let t;sg(e)&&(e=e[0]),this.cells.forEach(((n,a)=>{um("RNNCell_".concat(a),(()=>{n.build(e),t=Array.isArray(n.stateSize)?n.stateSize[0]:n.stateSize,e=[e[0],t]}))})),this.built=!0}getConfig(){const e=super.getConfig(),t={cells:this.cells.map((e=>({className:e.getClassName(),config:e.getConfig()})))};return Object.assign(Object.assign({},e),t)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=[];for(const r of t.cells)a.push(Qg(r,n));return new e({cells:a})}get trainableWeights(){if(!this.trainable)return[];const e=[];for(const t of this.cells)e.push(...t.trainableWeights);return e}get nonTrainableWeights(){const e=[];for(const t of this.cells)e.push(...t.nonTrainableWeights);if(!this.trainable){const t=[];for(const e of this.cells)t.push(...e.trainableWeights);return t.concat(e)}return e}getWeights(){const e=[];for(const t of this.cells)e.push(...t.weights);return dg(e)}setWeights(e){const t=[];for(const n of this.cells){const a=n.weights.length,r=e.splice(a);for(let e=0;e<n.weights.length;++e)t.push([n.weights[e],r[e]])}pg(t)}}function cv(e){const{ones:t,rate:n,training:a=!1,count:r=1,dropoutFunc:s}=e,o=()=>null!=s?s(t(),n):Mm(t(),n),i=()=>Lm(o,t,a);if(!r||r<=1)return Rs(i().clone());return Array(r).fill(void 0).map(i).map((e=>Rs(e.clone())))}iv.className="StackedRNNCells",Do(iv);var lv=function(e,t){var n={};for(var a in e)Object.prototype.hasOwnProperty.call(e,a)&&t.indexOf(a)<0&&(n[a]=e[a]);if(null!=e&&"function"===typeof Object.getOwnPropertySymbols){var r=0;for(a=Object.getOwnPropertySymbols(e);r<a.length;r++)t.indexOf(a[r])<0&&Object.prototype.propertyIsEnumerable.call(e,a[r])&&(n[a[r]]=e[a[r]])}return n};class uv extends $b{constructor(e){if(e.unroll)throw new Ef("Unrolling is not possible with convolutional RNNs.");if(Array.isArray(e.cell))throw new Ef("It is not possible at the moment to stack convolutional cells.");super(e),this.inputSpec=[new fg({ndim:5})]}call(e,t){return Es((()=>{if(null!=this.cell.dropoutMask&&(Cs(this.cell.dropoutMask),this.cell.dropoutMask=null),null!=this.cell.recurrentDropoutMask&&(Cs(this.cell.recurrentDropoutMask),this.cell.recurrentDropoutMask=null),t&&t.constants)throw new Tf("ConvRNN2D cell does not support constants");const n=null==t?null:t.mask,a=null==t?null:t.training,r=null==t?null:t.initialState;return super.call(e,{mask:n,training:a,initialState:r})}))}computeOutputShape(e){let t=this.computeSingleOutputShape(e);return this.returnSequences||(t=[t[0],...t.slice(2)]),this.returnState&&(t=[t,...Array(2).fill([e[0],...t.slice(-3)])]),t}getInitialState(e){return Es((()=>{const{stateSize:t}=this.cell,n=e.shape,a=this.computeSingleOutputShape(n),r=qc([a[0],...a.slice(2)]);return Array.isArray(t)?Array(t.length).fill(r):[r]}))}resetStates(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];Es((()=>{if(!this.stateful)throw new If("Cannot call resetStates() on an RNN Layer that is not stateful.");const n=this.inputSpec[0].shape,a=this.computeSingleOutputShape(n),r=[a[0],...a.slice(2)];if(null==n[0])throw new Tf("If an RNN is stateful, it needs to know its batch size. Specify the batch size of your input tensors: \n- If using a Sequential model, specify the batch size by passing a `batchInputShape` option to your first layer.\n- If using the functional API, specify the batch size by passing a `batchShape` option to your Input layer.");if(null==this.getStates())Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>qc(r))):this.states_=[qc(r)];else if(null==e)Cs(this.states_),null!=this.keptStates&&(Cs(this.keptStates),this.keptStates=[]),Array.isArray(this.cell.stateSize)?this.states_=this.cell.stateSize.map((()=>qc(r))):this.states_[0]=qc(r);else{if(Array.isArray(e)||(e=[e]),e.length!==this.states_.length)throw new Tf("Layer ".concat(this.name," expects ").concat(this.states_.length," state(s), ")+"but it received ".concat(e.length," state value(s). Input ")+"received: ".concat(e));t?this.keptStates.push(this.states_.slice()):Cs(this.states_);for(let t=0;t<this.states_.length;++t){const n=e[t],a=r;if(!te(n.shape,a))throw new Tf("State ".concat(t," is incompatible with layer ").concat(this.name,": ")+"expected shape=".concat(a,", received shape=").concat(n.shape));this.states_[t]=n}}this.states_=this.states_.map((e=>Rs(e.clone())))}))}computeSingleOutputShape(e){const{dataFormat:t,filters:n,kernelSize:a,padding:r,strides:s,dilationRate:o}=this.cell,i="channelsFirst"===t,c=e[i?3:2],l=e[i?4:3],u=Db(c,a[0],r,s[0],o[0]),h=Db(l,a[1],r,s[1],o[1]);return[...e.slice(0,2),...i?[n,u,h]:[u,h,n]]}}uv.className="ConvRNN2D";class hv extends sv{constructor(e){const{filters:t,kernelSize:n,strides:a,padding:r,dataFormat:s,dilationRate:o}=e;super(Object.assign(Object.assign({},e),{units:t})),this.filters=t,Kf(this.filters,"filters"),this.kernelSize=_b(n,2,"kernelSize"),this.kernelSize.forEach((e=>Kf(e,"kernelSize"))),this.strides=_b(a||1,2,"strides"),this.strides.forEach((e=>Kf(e,"strides"))),this.padding=r||"valid",om(this.padding),this.dataFormat=s||"channelsLast",sm(this.dataFormat),this.dilationRate=_b(o||1,2,"dilationRate"),this.dilationRate.forEach((e=>Kf(e,"dilationRate")))}build(e){var t;e=cg(e);const n="channelsFirst"===this.dataFormat?1:e.length-1;if(null==e[n])throw new Tf("The channel dimension of the input should be defined. "+"Found ".concat(e[n]));const a=e[n],r=this.kernelSize.concat([a,4*this.filters]);this.kernel=this.addWeight("kernel",r,null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint);const s=this.kernelSize.concat([this.filters,4*this.filters]);if(this.recurrentKernel=this.addWeight("recurrent_kernel",s,null,this.recurrentInitializer,this.recurrentRegularizer,!0,this.recurrentConstraint),this.useBias){let e;if(this.unitForgetBias){const n=this.biasInitializer,a=this.filters;e=new((t=class extends Bm{apply(e,t){return Tm([n.apply([a]),Xc([a]),n.apply([2*a])])}}).className="CustomInit",t)}else e=this.biasInitializer;this.bias=this.addWeight("bias",[4*this.filters],null,e,this.biasRegularizer,!0,this.biasConstraint)}this.built=!0}call(e,t){return Es((()=>{if(3!==e.length)throw new Tf("ConvLSTM2DCell expects 3 input Tensors (inputs, h, c), got "+"".concat(e.length,"."));const n=t.training||!1,a=e[0],r=e[1],s=e[2];0<this.dropout&&this.dropout<1&&null==this.dropoutMask&&(this.dropoutMask=cv({ones:()=>Yc(a),rate:this.dropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const o=this.dropoutMask,i=(e,t,n)=>t&&t[n]?ko(t[n],e):e;let c=i(a,o,0),l=i(a,o,1),u=i(a,o,2),h=i(a,o,3);0<this.recurrentDropout&&this.recurrentDropout<1&&null==this.recurrentDropoutMask&&(this.recurrentDropoutMask=cv({ones:()=>Yc(r),rate:this.recurrentDropout,training:n,count:4,dropoutFunc:this.dropoutFunc}));const d=this.recurrentDropoutMask;let p=i(r,d,0),f=i(r,d,1),m=i(r,d,2),g=i(r,d,3);const[y,b,v,x]=gl(this.kernel.read(),4,3),[w,k,S,I]=this.useBias?gl(this.bias.read(),4):[null,null,null,null];c=this.inputConv(c,y,w,this.padding),l=this.inputConv(l,b,k,this.padding),u=this.inputConv(u,v,S,this.padding),h=this.inputConv(h,x,I,this.padding);const[N,T,E,C]=gl(this.recurrentKernel.read(),4,3);p=this.recurrentConv(p,N),f=this.recurrentConv(f,T),m=this.recurrentConv(m,E),g=this.recurrentConv(g,C);const R=this.recurrentActivation.apply(vo(c,p)),A=this.recurrentActivation.apply(vo(l,f)),_=vo(ko(A,s),ko(R,this.activation.apply(vo(u,m)))),D=ko(this.recurrentActivation.apply(vo(h,g)),this.activation.apply(_));return[D,D,_]}))}getConfig(){const e=super.getConfig(),{units:t}=e,n=lv(e,["units"]),a={filters:this.filters,kernelSize:this.kernelSize,padding:this.padding,dataFormat:this.dataFormat,dilationRate:this.dilationRate,strides:this.strides};return Object.assign(Object.assign({},n),a)}inputConv(e,t,n,a){const r=tc(e,t,this.strides,a||"valid","channelsFirst"===this.dataFormat?"NCHW":"NHWC",this.dilationRate);return n?Om(r,n,this.dataFormat):r}recurrentConv(e,t){return tc(e,t,1,"same","channelsFirst"===this.dataFormat?"NCHW":"NHWC")}}hv.className="ConvLSTM2DCell",Do(hv);class dv extends uv{constructor(e){const t=new hv(e);super(Object.assign(Object.assign({},e),{cell:t}))}static fromConfig(e,t){return new e(t)}}dv.className="ConvLSTM2D",Do(dv);class pv extends vg{constructor(e){super(e),this.rate=Math.max(Math.min(e.rate,1),0),this.noiseShape=e.noiseShape,this.seed=e.seed,this.supportsMasking=!0}getNoiseShape(e){if(null==this.noiseShape)return this.noiseShape;const t=e.shape,n=[];for(let a=0;a<this.noiseShape.length;++a)n.push(null==this.noiseShape[a]?t[a]:this.noiseShape[a]);return n}call(e,t){return Es((()=>{this.invokeCallHook(e,t);const n=ig(e);if(0<this.rate&&this.rate<1){const e=null!=t.training&&t.training,a=this.getNoiseShape(n);return Lm((()=>Mm(n,this.rate,a,this.seed)),(()=>n),e)}return e}))}getConfig(){const e={rate:this.rate,noiseShape:this.noiseShape,seed:this.seed},t=super.getConfig();return Object.assign(e,t),e}dispose(){return super.dispose()}}pv.className="Dropout",Do(pv);class fv extends pv{constructor(e){super(e),this.inputSpec=[{ndim:3}]}getNoiseShape(e){const t=e.shape;return[t[0],1,t[2]]}}fv.className="SpatialDropout1D",Do(fv);class mv extends vg{constructor(e){if(super(e),this.activation=null,this.useBias=!0,this.kernel=null,this.bias=null,this.DEFAULT_KERNEL_INITIALIZER="glorotNormal",this.DEFAULT_BIAS_INITIALIZER="zeros",null==e.batchInputShape&&null==e.inputShape&&null!=e.inputDim){let t=null;null!=e.batchSize&&(t=e.batchSize),this.batchInputShape=[t,e.inputDim]}this.units=e.units,Kf(this.units,"units"),this.activation=yb(e.activation),null!=e.useBias&&(this.useBias=e.useBias),this.kernelInitializer=rg(e.kernelInitializer||this.DEFAULT_KERNEL_INITIALIZER),this.biasInitializer=rg(e.biasInitializer||this.DEFAULT_BIAS_INITIALIZER),this.kernelConstraint=Pg(e.kernelConstraint),this.biasConstraint=Pg(e.biasConstraint),this.kernelRegularizer=Ib(e.kernelRegularizer),this.biasRegularizer=Ib(e.biasRegularizer),this.activityRegularizer=Ib(e.activityRegularizer),this.supportsMasking=!0,this.inputSpec=[{minNDim:2}]}build(e){const t=(e=cg(e))[e.length-1];null==this.kernel&&(this.kernel=this.addWeight("kernel",[t,this.units],null,this.kernelInitializer,this.kernelRegularizer,!0,this.kernelConstraint),this.useBias&&(this.bias=this.addWeight("bias",[this.units],null,this.biasInitializer,this.biasRegularizer,!0,this.biasConstraint))),this.inputSpec=[{minNDim:2,axes:{[-1]:t}}],this.built=!0}computeOutputShape(e){const t=(e=cg(e)).slice();return t[t.length-1]=this.units,t}call(e,t){return Es((()=>{this.invokeCallHook(e,t);const n=ig(e),a=Xf(this.activation.getClassName());let r;return null!=a?r=Am(n,this.kernel.read(),a,this.bias?this.bias.read():null):(r=Am(n,this.kernel.read()),null!=this.bias&&(r=Om(r,this.bias.read())),null!=this.activation&&(r=this.activation.apply(r))),r}))}getConfig(){const e={units:this.units,activation:mb(this.activation),useBias:this.useBias,kernelInitializer:ag(this.kernelInitializer),biasInitializer:ag(this.biasInitializer),kernelRegularizer:kb(this.kernelRegularizer),biasRegularizer:kb(this.biasRegularizer),activityRegularizer:kb(this.activityRegularizer),kernelConstraint:Lg(this.kernelConstraint),biasConstraint:Lg(this.biasConstraint)},t=super.getConfig();return Object.assign(e,t),e}}mv.className="Dense",Do(mv);class gv extends vg{constructor(e){super(e=e||{}),this.inputSpec=[{minNDim:3}],this.dataFormat=e.dataFormat}computeOutputShape(e){e=cg(e);for(const t of e.slice(1))if(null==t)throw new Tf('The shape of the input to "Flatten" is not fully defined '+"(got ".concat(e.slice(1),"). Make sure to pass a complete ")+'"input_shape" or "batch_input_shape" argument to the first layer in your model.');return[e[0],mm(e,1)]}call(e,t){return Es((()=>{this.invokeCallHook(e,t);let n=ig(e);if("channelsFirst"===this.dataFormat&&n.rank>1){const e=[0];for(let t=2;t<n.rank;++t)e.push(t);e.push(1),n=El(n,e)}return function(e){if(e.rank<=1)throw new Tf("batchFlatten requires a minimum rank of 2. Got rank: ".concat(e.rank,"."));const t=[e.shape[0],mm(e.shape,1)];return Vi(e,t)}(n)}))}getConfig(){const e={};null!=this.dataFormat&&(e.dataFormat=this.dataFormat);const t=super.getConfig();return Object.assign(e,t),e}}gv.className="Flatten",Do(gv);class yv extends vg{constructor(e){super(e),this.supportsMasking=!0,this.activation=yb(e.activation)}call(e,t){return Es((()=>{this.invokeCallHook(e,t);const n=ig(e);return this.activation.apply(n)}))}getConfig(){const e={activation:mb(this.activation)},t=super.getConfig();return Object.assign(e,t),e}}yv.className="Activation",Do(yv);class bv extends vg{constructor(e){super(e),this.n=e.n,this.inputSpec=[{ndim:2}]}computeOutputShape(e){return[e[0],this.n,e[1]]}call(e,t){return Es((()=>{return e=ig(e),t=e,n=this.n,Es((()=>{if(2!==t.shape.length)throw new Tf("repeat() expects a rank-2 tensor, but received a "+"rank-".concat(t.shape.length," tensor."));return Cm(km(t,1),[1,n,1])}));var t,n}))}getConfig(){const e={n:this.n},t=super.getConfig();return Object.assign(e,t),e}}bv.className="RepeatVector",Do(bv);class vv extends vg{constructor(e){super(e),this.targetShape=e.targetShape;for(let t=0;t<this.targetShape.length;++t)this.isUnknown(this.targetShape[t])&&(this.targetShape[t]=null)}isUnknown(e){return e<0||null==e}fixUnknownDimension(e,t){const n="Total size of new array must be unchanged.",a=t.slice();let r=1,s=null;for(let i=0;i<a.length;++i){const e=a[i];if(this.isUnknown(e)){if(null!==s)throw new Tf("Can only specifiy one unknown dimension.");s=i}else r*=e}const o=mm(e);if(null!==s){if(0===r||o%r!==0)throw new Tf(n);a[s]=o/r}else if(o!==r)throw new Tf(n);return a}computeOutputShape(e){let t=!1;for(let n=0;n<e.length;++n)if(this.isUnknown(e[n])){t=!0;break}return t?e.slice(0,1).concat(this.targetShape):e.slice(0,1).concat(this.fixUnknownDimension(e.slice(1),this.targetShape))}call(e,t){return Es((()=>{this.invokeCallHook(e,t);const n=ig(e),a=n.shape,r=a.slice(0,1).concat(this.fixUnknownDimension(a.slice(1),this.targetShape));return Vi(n,r)}))}getConfig(){const e={targetShape:this.targetShape},t=super.getConfig();return Object.assign(e,t),e}}vv.className="Reshape",Do(vv);class xv extends vg{constructor(e){if(super(e),null==e.dims)throw new Error("Required configuration field `dims` is missing during Permute constructor call.");if(!Array.isArray(e.dims))throw new Error("Permute constructor requires `dims` to be an Array, but received "+"".concat(e.dims," instead."));const t=bm(1,e.dims.length+1);if(!te(e.dims.slice().sort(),t))throw new Error("Invalid permutation `dims`: "+JSON.stringify(e.dims)+" `dims` must contain consecutive integers starting from 1.");this.dims=e.dims,this.dimsIncludingBatch=[0].concat(this.dims),this.inputSpec=[new fg({ndim:this.dims.length+1})]}computeOutputShape(e){const t=(e=cg(e)).slice();return this.dims.forEach(((n,a)=>{t[a+1]=e[n]})),t}call(e,t){return El(ig(e),this.dimsIncludingBatch)}getConfig(){const e={dims:this.dims},t=super.getConfig();return Object.assign(e,t),e}}xv.className="Permute",Do(xv);class wv extends vg{constructor(e){super(null==e?{}:e),this.supportsMasking=!0,this.maskValue=null!=e?null==e.maskValue?0:e.maskValue:0}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={maskValue:this.maskValue};return Object.assign(t,e),t}computeMask(e,t){const n=ig(e);return Ii(jc(n,this.maskValue),-1)}call(e,t){return Es((()=>{this.invokeCallHook(e,t);const n=ig(e),a=Ii(jc(n,this.maskValue),-1,!0);return ko(n,yo(a,n.dtype))}))}}wv.className="Masking",Do(wv);class kv extends vg{constructor(e){if(super(e),this.embeddings=null,this.DEFAULT_EMBEDDINGS_INITIALIZER="randomUniform",null==e.batchInputShape&&null==e.inputShape){let t=null;null!=e.batchSize&&(t=e.batchSize),null==e.inputLength?this.batchInputShape=[t,null]:this.batchInputShape=[t].concat(Of(e.inputLength))}this.inputDim=e.inputDim,Kf(this.inputDim,"inputDim"),this.outputDim=e.outputDim,Kf(this.outputDim,"outputDim"),this.embeddingsInitializer=rg(e.embeddingsInitializer||this.DEFAULT_EMBEDDINGS_INITIALIZER),this.embeddingsRegularizer=Ib(e.embeddingsRegularizer),this.activityRegularizer=Ib(e.activityRegularizer),this.embeddingsConstraint=Pg(e.embeddingsConstraint),this.maskZero=e.maskZero,this.supportsMasking=e.maskZero,this.inputLength=e.inputLength}build(e){this.embeddings=this.addWeight("embeddings",[this.inputDim,this.outputDim],this.dtype,this.embeddingsInitializer,this.embeddingsRegularizer,!0,this.embeddingsConstraint),this.built=!0}warnOnIncompatibleInputShape(e){}computeMask(e,t){return Es((()=>this.maskZero?(e=ig(e),jc(e,No(e))):null))}computeOutputShape(e){if(e=cg(e),null==this.inputLength)return[...e,this.outputDim];const t=Of(this.inputLength);if(t.length!==e.length-1)throw new Tf('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));{let n=0;for(let a=0;a<t.length;++a){const r=t[a],s=e[a+1];if(null!=r&&null!=s&&r!==s)throw new Tf('"inputLength" is '.concat(this.inputLength,", but received ")+"input shape has shape ".concat(e));null==r&&(t[n]=s),n++}}return[e[0],...t,this.outputDim]}call(e,t){return Es((()=>{this.invokeCallHook(e,t);let n=ig(e);"int32"!==n.dtype&&(n=wm(n,"int32"));const a=_m(this.embeddings.read(),Vi(n,[n.size]));return Vi(a,cg(this.computeOutputShape(n.shape)))}))}getConfig(){const e={inputDim:this.inputDim,outputDim:this.outputDim,embeddingsInitializer:ag(this.embeddingsInitializer),embeddingsRegularizer:kb(this.embeddingsRegularizer),activityRegularizer:kb(this.activityRegularizer),embeddingsConstraint:Lg(this.embeddingsConstraint),maskZero:this.maskZero,inputLength:this.inputLength},t=super.getConfig();return Object.assign(e,t),e}}kv.className="Embedding",Do(kv);class Sv extends vg{constructor(e){super(e||{}),this.supportsMasking=!0}mergeFunction(e){throw new Ef}computeElementwiseOpOutputShape(e,t){if(null==e||null==t)return null;if(e.length<t.length)return this.computeElementwiseOpOutputShape(t,e);if(0===t.length)return e;const n=e.slice(0,e.length-t.length);for(let a=0;a<t.length;++a){const r=e[e.length-t.length+a],s=t[a];if(null==r||null==s||r<0||s<0)n.push(null);else if(1===r)n.push(s);else if(1===s)n.push(r);else{if(r!==s)throw new Tf("Operands could not be broadcast together with shapes "+JSON.stringify(e)+" "+JSON.stringify(t));n.push(r)}}return n}build(e){if(Array.isArray(e)&&!Array.isArray(e[0])&&(e=[cg(e)]),e.length<2)throw new Tf("A merge layer should be called on an Array of at least 2 inputs."+" Got ".concat(e.length," input(s)."));let t=[];for(const r of e)null!=r&&null!==r[0]&&t.push(r[0]);if(t=Uf(t),t.length>1)throw new Tf("Can not merge tensors with different batch sizes. "+"Got tensors with shapes: ".concat(JSON.stringify(e),"."));let n=null==e[0]?null:e[0].slice(1);for(let r=1;r<e.length;++r){const t=null==e[r]?null:e[r].slice(1);n=this.computeElementwiseOpOutputShape(n,t)}const a=e.map((e=>e.length));-1===e.indexOf(null)&&1===Uf(a).length?this.reshapeRequired=!1:this.reshapeRequired=!0}call(e,t){return Es((()=>{if(this.reshapeRequired){const t=[],n=e.map((e=>e.rank));if(-1===n.indexOf(null)){const a=ym(n);for(let n of e){const e=n.rank;for(let t=0;t<a-e;++t)n=km(n,1);t.push(n)}return this.mergeFunction(t)}{let n=!1;for(const s of e){const e=s.rank;if(null==e){const e=s.shape,a=e[0],r=e.slice(1).concat([a]);let o=Vi(s,[a].concat(mm(e.slice(1))));o=El(o,[1,0]),o=Vi(o,r),t.push(o),n=!0}else if(e>1){const a=bm(1,e).concat([0]);t.push(El(s,a)),n=!0}else t.push(s)}let a=this.mergeFunction(t);const r=a.rank;if(n)if(null==r){const e=a.shape,t=e[e.length-1],n=[t].concat(e.slice(0,e.length-1));a=Vi(El(Vi(a,[-1,t]),[1,0]),n)}else if(r>1){const e=[r-1].concat(bm(0,r-1));a=El(a,e)}return a}}return this.mergeFunction(e)}))}computeOutputShape(e){let t;t=null==e[0]?null:e[0].slice(1);for(let a=1;a<e.length;++a){const n=null==e[a]?null:e[a].slice(1);t=this.computeElementwiseOpOutputShape(t,n)}let n=[];for(const a of e)null!=a&&null!==a[0]&&n.push(a[0]);return n=Uf(n),t=1===n.length?n.concat(t):[null].concat(t),t}computeMask(e,t){return Es((()=>{if(null==t)return null;if(!Array.isArray(t))throw new Tf("`mask` should be an Array");if(!Array.isArray(e))throw new Tf("`inputs` should be an Array");if(t.length!==e.length)throw new Tf("The Array 'inputs' and 'mask' are expected to have the same length, but have different lengths "+"(".concat(e.length," vs ").concat(t.length,")"));if(t.every((e=>null==e)))return null;let n=(t=t.map((e=>null==e?e:fc(e,0))))[0];for(let e=1;e<t.length-1;++e)n=Lc(n,t[e]);return n}))}}class Iv extends Sv{constructor(e){super(e)}mergeFunction(e){return Es((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=vo(t,e[n]);return t}))}}Iv.className="Add",Do(Iv);class Nv extends Sv{constructor(e){super(e)}mergeFunction(e){return Es((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=ko(t,e[n]);return t}))}}Nv.className="Multiply",Do(Nv);class Tv extends Sv{constructor(e){super(e)}mergeFunction(e){return Es((()=>{let t=e[0].clone();for(let n=1;n<e.length;++n)t=vo(t,e[n]);return ko(1/e.length,t)}))}}Tv.className="Average",Do(Tv);class Ev extends Sv{constructor(e){super(e)}mergeFunction(e){return Es((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Ho(t,e[n]);return t}))}}Ev.className="Maximum",Do(Ev);class Cv extends Sv{constructor(e){super(e)}mergeFunction(e){return Es((()=>{let t=e[0];for(let n=1;n<e.length;++n)t=Uc(t,e[n]);return t}))}}Cv.className="Minimum",Do(Cv);class Rv extends Sv{constructor(e){super(e),this.DEFAULT_AXIS=-1,null==e&&(e={}),this.axis=null==e.axis?this.DEFAULT_AXIS:e.axis,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){if(!Array.isArray(e)||!Array.isArray(e[0])||1===e.length)throw new Tf("A `Concatenate` layer should be called on a list of at least 2 inputs");let t=!0;for(const a of e)if(null!=a){t=!1;break}if(t)return;const n=[];for(let a=0;a<e.length;++a){const t=e[a].slice();t.splice(this.axis,1);let r=!1;for(const e of n)if(te(e,t)){r=!0;break}r||n.push(t)}if(n.length>1)throw new Tf("A `Concatenate` layer requires inputs with matching shapes except for the concat axis. Got input shapes: "+JSON.stringify(e))}mergeFunction(e){return Es((()=>Tm(e,this.axis)))}computeOutputShape(e){if(!Array.isArray(e)||!Array.isArray(e[0]))throw new Tf("A `Concatenate` layer should be called on a list of inputs.");const t=e,n=t[0].slice(),a=this.axis<0?n.length+this.axis:this.axis;for(const r of t.slice(1)){if(null==n[a]||null==r[a]){n[a]=null;break}n[a]+=r[a]}return n}computeMask(e,t){if(null==t)return null;if(!Array.isArray(t))throw new Tf("`mask` should be an array for Concatenate");if(!Array.isArray(e))throw new Tf("`inputs` should be an array for Concatenate");if(t.length!==e.length)throw new Tf("Mismatch in the length of mask (".concat(t.length,") ")+"and the legnth of inputs (".concat(e.length,")"));return Es((()=>{let n=!0;if(t.forEach((e=>{null==e||(n=!1)})),n)return null;const a=[];for(let s=0;s<e.length;++s)null==t[s]?a.push(yo(Yc(e[s]),"bool")):t[s].rank<e[s].rank?a.push(fc(t[s],-1)):a.push(t[s]);const r=Qi(a,this.axis);return Si(r,-1,!1)}))}getConfig(){const e={axis:this.axis},t=super.getConfig();return Object.assign(e,t),e}}function Av(e,t){for(;e<0;)e+=t;return e}Rv.className="Concatenate",Do(Rv);class _v extends Sv{constructor(e){super(e),this.axes=e.axes,this.normalize=null!=e.normalize&&e.normalize,this.supportsMasking=!0,this.reshapeRequired=!1}build(e){J(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0],n=e[1];if(t.length>3||n.length>3)throw new Ef("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);if(t[a[0]]!==n[a[1]])throw new Tf("Dimension incompatibility: "+"".concat(t[a[0]]," !== ").concat(n[a[1]]))}mergeFunction(e){if(2!==e.length)throw new Tf("A `Dot` layer must be called on exactly 2 inputs, "+"but received ".concat(e.length," input(s)."));let t,n=e[0],a=e[1];return t=Array.isArray(this.axes)?this.axes.map(((t,n)=>Av(t,e[n].shape.length))):[Av(this.axes,n.shape.length),Av(this.axes,a.shape.length)],this.normalize&&(n=Jg(n,t[0]),a=Jg(a,t[1])),function(e,t,n){if(e.shape.length>3||t.shape.length>3)throw new Ef("batchDot is not implemented for tensors of 4D or higher rank yet");if(J(e.shape.length>=2,(()=>"batchDot requires the rank of x to be >= 2, "+"but got ".concat(e.shape.length))),J(e.shape.length>=2,(()=>"batchDot requires the rank of y to be >= 2, "+"but got ".concat(t.shape.length))),"number"===typeof n&&(n=[n,n]),"complex64"===e.dtype||"complex64"===t.dtype)throw new Ef("batchDot is not implemented for complex64-type Tensors yet.");const a=e.shape.length,r=t.shape.length;null==n&&(n=[a-1,r-2]);const s=n;return Es((()=>{let n,o;if(a>r){n=a-r;const e=[];for(let t=0;t<n;++t)e.push(1);t=Vi(t,t.shape.concat(e))}else if(r>a){n=r-a;const t=[];for(let e=0;e<n;++e)t.push(1);e=Vi(e,e.shape.concat(t))}else n=0;if(2===e.shape.length&&2===t.shape.length)o=s[0]===s[1]?Nc(ko(e,t),s[0]):Nc(ko(El(e,[1,0]),t),s[1]);else{const n=s[0]!==e.shape.length-1,a=s[1]===t.shape.length-1;o=zc(e,t,n,a)}if(n>0){let e;e=a>r?a+r-3:a-1;const t=[];for(let a=e;a<e+n;++a)t.push(a);o=yl(o,t)}return 1===o.shape.length&&(o=fc(o,1)),o}))}(n,a,t)}interpretAxes(e,t){let n;return n=Array.isArray(this.axes)?this.axes:[Av(this.axes,e.length),Av(this.axes,t.length)],n}computeOutputShape(e){J(Array.isArray(e)&&2===e.length&&Array.isArray(e[0])&&Array.isArray(e[1]),(()=>"A `Dot` layer should be called on a list of exactly 2 inputs."));const t=e[0].slice(),n=e[1].slice();if(t.length>3||n.length>3)throw new Ef("Dot layer does not support tensors of 4D or higher rank yet.");const a=this.interpretAxes(t,n);t.splice(a[0],1),n.splice(a[1],1),n.splice(0,1);const r=t.concat(n);return 1===r.length&&r.push(1),r}computeMask(e,t){return null}getConfig(){const e={axes:this.axes,normalize:this.normalize},t=super.getConfig();return Object.assign(e,t),e}}_v.className="Dot",Do(_v);class Dv extends vg{constructor(e){super(e),this.supportsMasking=!0,this.stddev=e.stddev}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={stddev:this.stddev};return Object.assign(t,e),t}call(e,t){return Es((()=>{this.invokeCallHook(e,t);const n=ig(e);return Lm((()=>vo(Rm(n.shape,0,this.stddev),n)),(()=>n),t.training||!1)}))}}Dv.className="GaussianNoise",Do(Dv);class Fv extends vg{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Es((()=>{this.invokeCallHook(e,t);const n=ig(e);if(this.rate>0&&this.rate<1){return Lm((()=>{const e=Math.sqrt(this.rate/(1-this.rate));return ko(n,Rm(n.shape,1,e))}),(()=>n),t.training||!1)}return n}))}}Fv.className="GaussianDropout",Do(Fv);class Ov extends vg{constructor(e){super(e),this.supportsMasking=!0,this.rate=e.rate,this.noiseShape=e.noiseShape}_getNoiseShape(e){return this.noiseShape||ig(e).shape}computeOutputShape(e){return e}getConfig(){const e=super.getConfig(),t={rate:this.rate};return Object.assign(t,e),t}call(e,t){return Es((()=>{if(this.rate<1&&this.rate>0){const n=this._getNoiseShape(e),a=()=>{const t=ig(e),a=-1.7580993408473766;let r=xc(nl(n),this.rate);r=wm(r,"float32");const s=((1-this.rate)*(1+this.rate*a**2))**-.5,o=-s*a*this.rate,i=vo(ko(t,r),ko(vo(r,-1),a));return vo(ko(i,s),o)};return Lm(a,(()=>ig(e)),t.training||!1)}return e}))}}function Mv(e,t,n,a,r){let s,o=arguments.length>5&&void 0!==arguments[5]?arguments[5]:.001;if(2===e.rank)s=ji(e,t,n,a,r,o);else if(3===e.rank)s=Ki(e,t,n,a,r,o);else{if(4!==e.rank)throw new Ef("batchNormalization is not implemented for array of rank ".concat(e.rank," ")+"yet");s=qi(e,t,n,a,r,o)}return s}function Lv(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return te(a.slice().sort(),bm(0,e.rank-1))?function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Es((()=>{const s=Gc(e,a),o=s.mean,i=s.variance;return[Mv(e,o,i,n,t,r),o,i]}))}(e,t,n,a,r):function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.001;return Es((()=>{const s=Gc(e,a),o=s.mean,i=s.variance,c=[];for(const t of bm(0,e.rank))-1!==a.indexOf(t)?c.push(1):c.push(e.shape[t]);const l=Vi(o,c),u=Vi(i,c),h=null==t?null:Vi(t,c),d=null==n?null:Vi(n,c);return[Mv(e,l,u,d,h,r),o,i]}))}(e,t,n,a,r)}Ov.className="AlphaDropout",Do(Ov);class zv extends vg{constructor(e){null==e&&(e={}),super(e),this.supportsMasking=!0,this.axis=null==e.axis?-1:e.axis,this.momentum=null==e.momentum?.99:e.momentum,this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=rg(e.betaInitializer||"zeros"),this.gammaInitializer=rg(e.gammaInitializer||"ones"),this.movingMeanInitializer=rg(e.movingMeanInitializer||"zeros"),this.movingVarianceInitializer=rg(e.movingVarianceInitializer||"ones"),this.betaConstraint=Pg(e.betaConstraint),this.gammaConstraint=Pg(e.gammaConstraint),this.betaRegularizer=Ib(e.betaRegularizer),this.gammaRegularizer=Ib(e.gammaRegularizer)}build(e){e=cg(e);const t=this.axis>=0?this.axis:this.axis+e.length,n=e[t];if(null==n)throw new Tf("Axis ".concat(t," of input tensor should have a defined dimension but ")+"the layer received an input with shape "+"".concat(JSON.stringify(e),"."));this.inputSpec=[new fg({ndim:e.length,axes:{[t]:n}})];const a=[n];this.scale&&(this.gamma=this.addWeight("gamma",a,null,this.gammaInitializer,this.gammaRegularizer,!0,this.gammaConstraint)),this.center&&(this.beta=this.addWeight("beta",a,null,this.betaInitializer,this.betaRegularizer,!0,this.betaConstraint)),this.movingMean=this.addWeight("moving_mean",a,null,this.movingMeanInitializer,null,!1),this.movingVariance=this.addWeight("moving_variance",a,null,this.movingVarianceInitializer,null,!1),this.built=!0}call(e,t){return Es((()=>{const n=null!=t.training&&t.training,a=ig(e),r=a.shape,s=r.length,o=bm(0,s),i=this.axis>=0?this.axis:this.axis+s;o.splice(i,1);const c=Af(1,s);c[i]=r[i];const l=o.slice();l.sort();const u=!te(l,bm(0,s).slice(0,s-1));if(!n)return(()=>{if(u){const e=Vi(this.movingMean.read(),c),t=Vi(this.movingVariance.read(),c),n=this.center?Vi(this.beta.read(),c):null,r=this.scale?Vi(this.gamma.read(),c):null;return Mv(a,e,t,n,r,this.epsilon)}return Mv(a,this.movingMean.read(),this.movingVariance.read(),null==this.beta?null:this.beta.read(),null==this.gamma?null:this.gamma.read(),this.epsilon)})();const[h,d,p]=Lv(a,this.gamma.read(),this.beta.read(),o,this.epsilon),f=(e,t,n)=>{Es((()=>{const a=1-n,r=e.read(),s=ko(Po(r,t),a);e.write(Po(r,s))}))};return(()=>{f(this.movingMean,d,this.momentum),f(this.movingVariance,p,this.momentum)})(),h}))}getConfig(){const e={axis:this.axis,momentum:this.momentum,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ag(this.betaInitializer),gammaInitializer:ag(this.gammaInitializer),movingMeanInitializer:ag(this.movingMeanInitializer),movingVarianceInitializer:ag(this.movingVarianceInitializer),betaRegularizer:kb(this.betaRegularizer),gammaRegularizer:kb(this.gammaRegularizer),betaConstraint:Lg(this.betaConstraint),gammaConstraint:Lg(this.gammaConstraint)},t=super.getConfig();return Object.assign(e,t),e}}zv.className="BatchNormalization",Do(zv);class Pv extends vg{constructor(e){if(null==e&&(e={}),super(e),this.axis=null==e.axis?-1:e.axis,"number"===typeof this.axis){if(!Number.isInteger(this.axis))throw new Error("Expected axis to be an integer, but received ".concat(this.axis))}else{if(!Array.isArray(this.axis))throw new Error("Expected axis to be an integer or an array of integers, "+"but received ".concat(JSON.stringify(this.axis)));for(const e of this.axis)if(!Number.isInteger(e))throw new Error("Expected axis to be an array of integers, "+"but received ".concat(JSON.stringify(this.axis)))}this.epsilon=null==e.epsilon?.001:e.epsilon,this.center=null==e.center||e.center,this.scale=null==e.scale||e.scale,this.betaInitializer=rg(e.betaInitializer||"zeros"),this.gammaInitializer=rg(e.gammaInitializer||"ones"),this.betaRegularizer=Ib(e.betaRegularizer),this.gammaRegularizer=Ib(e.gammaRegularizer),this.supportsMasking=!0}build(e){const t=(e=cg(e)).length;"number"===typeof this.axis&&(this.axis=[this.axis]);for(let r=0;r<this.axis.length;++r)this.axis[r]<0&&(this.axis[r]+=t);for(const r of this.axis)if(r<0||r>=t)throw new Error("Invalid axis: ".concat(r));if(this.axis.length!==Uf(this.axis).length)throw new Error("Found duplicate axes in: ".concat(this.axis));const n=this.axis.map((t=>e[t])),a=!0;this.scale?this.gamma=this.addWeight("gamma",n,"float32",this.gammaInitializer,this.gammaRegularizer,a):this.gamma=null,this.center?this.beta=this.addWeight("beta",n,"float32",this.betaInitializer,this.betaRegularizer,a):this.beta=null,this.built=!0}call(e,t){const n=ig(e),a=n.shape,r=a.length;return Es((()=>{let{mean:e,variance:t}=Gc(n,this.axis,!0);const s=Af(1,r);for(const n of this.axis)s[n]=a[n];const o=e=>null!=e&&e.shape.length!==r?Vi(e,s):e;let i=this.scale?o(this.gamma.read()):null,c=this.center?o(this.beta.read()):null;const l=[],u=[];for(let n=0;n<r;++n)-1!==this.axis.indexOf(n)?(l.push(a[n]),u.push(1)):(l.push(1),u.push(a[n]));return e=mc(e,l),t=mc(t,l),null!=i&&(i=mc(i,u)),null!=c&&(c=mc(c,u)),Mv(n,e,t,c,i,this.epsilon)}))}getConfig(){const e={axis:this.axis,epsilon:this.epsilon,center:this.center,scale:this.scale,betaInitializer:ag(this.betaInitializer),gammaInitializer:ag(this.gammaInitializer),betaRegularizer:kb(this.betaRegularizer),gammaRegularizer:kb(this.gammaRegularizer)},t=super.getConfig();return Object.assign(e,t),e}}Pv.className="LayerNormalization",Do(Pv);class Bv extends vg{constructor(e){if(null==e&&(e={}),super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,null==e.padding)this.padding=[[1,1],[1,1]];else if("number"===typeof e.padding)this.padding=[[e.padding,e.padding],[e.padding,e.padding]];else{if(e.padding=e.padding,2!==e.padding.length)throw new Tf("ZeroPadding2D expects padding to be a length-2 array, but "+"received a length-".concat(e.padding.length," array."));let t,n;if("number"===typeof e.padding[0])t=[e.padding[0],e.padding[0]],n=[e.padding[1],e.padding[1]];else{if(e.padding=e.padding,2!==e.padding[0].length)throw new Tf("ZeroPadding2D expects height padding to be a length-2 array, "+"but received a length-".concat(e.padding[0].length," array."));if(t=e.padding[0],2!==e.padding[1].length)throw new Tf("ZeroPadding2D expects width padding to be a length-2 array, "+"but received a length-".concat(e.padding[1].length," array."));n=e.padding[1]}this.padding=[t,n]}this.inputSpec=[new fg({ndim:4})]}computeOutputShape(e){let t,n;return e=cg(e),"channelsFirst"===this.dataFormat?(t=null!=e[2]&&e[2]>=0?e[2]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[3]&&e[3]>=0?e[3]+this.padding[1][0]+this.padding[1][1]:null,[e[0],e[1],t,n]):(t=null!=e[1]&&e[1]>=0?e[1]+this.padding[0][0]+this.padding[0][1]:null,n=null!=e[2]&&e[2]>=0?e[2]+this.padding[1][0]+this.padding[1][1]:null,[e[0],t,n,e[3]])}call(e,t){return Es((()=>{return t=ig(e),n=this.padding,a=this.dataFormat,Es((()=>{if(4!==t.rank)throw new Tf("temporalPadding expects input tensor to be 4-D, but received a "+"".concat(t.rank,"-D tensor."));if(null==n&&(n=[[1,1],[1,1]]),2!==n.length||2!==n[0].length||2!==n[1].length)throw new Tf("spatial2dPadding expects `padding` to be an Array of two Arrays, each of which is an Array of two integers.");if(null==a&&(a="channelsLast"),"channelsLast"!==a&&"channelsFirst"!==a)throw new Tf("Unknown data format: ".concat(a,". ")+"Supported data formats are 'channelsLast' and 'channelsFirst.");let e;return e="channelsFirst"===a?[[0,0],[0,0],n[0],n[1]]:[[0,0],n[0],n[1],[0,0]],Qc(t,e)}));var t,n,a}))}getConfig(){const e={padding:this.padding,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}function Wv(e,t,n,a,r,s){return Es((()=>{let o;sm(r),im(s),om(a),null==n&&(n=[1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),e=Ob(e,r);const i="same"===a?"same":"valid";return o="max"===s?Pc(e,t,n,i):Ui(e,t,n,i),"channelsFirst"===r&&(o=El(o,[0,3,1,2])),o}))}function Vv(e,t,n,a,r,s){return Es((()=>{let o;sm(r),im(s),om(a),null==n&&(n=[1,1,1]),null==a&&(a="valid"),null==r&&(r="channelsLast"),null==s&&(s="max"),e=Mb(e,r);const i="same"===a?"same":"valid";return o="max"===s?Bc(e,t,n,i):Gi(e,t,n,i),"channelsFirst"===r&&(o=El(o,[0,4,1,2,3])),o}))}Bv.className="ZeroPadding2D",Do(Bv);class Uv extends vg{constructor(e){if(null==e.poolSize&&(e.poolSize=2),super(e),"number"===typeof e.poolSize)this.poolSize=[e.poolSize];else{if(!Array.isArray(e.poolSize)||1!==e.poolSize.length||"number"!==typeof e.poolSize[0])throw new Tf("poolSize for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.poolSize)));this.poolSize=e.poolSize}if(Kf(this.poolSize,"poolSize"),null==e.strides)this.strides=this.poolSize;else if("number"===typeof e.strides)this.strides=[e.strides];else{if(!Array.isArray(e.strides)||1!==e.strides.length||"number"!==typeof e.strides[0])throw new Tf("strides for 1D convolutional layer must be a number or an Array of a single number, but received "+"".concat(JSON.stringify(e.strides)));this.strides=e.strides}Kf(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,om(this.padding),this.inputSpec=[new fg({ndim:3})]}computeOutputShape(e){const t=Db((e=cg(e))[1],this.poolSize[0],this.padding,this.strides[0]);return[e[0],t,e[2]]}call(e,t){return Es((()=>{this.invokeCallHook(e,t),e=km(ig(e),2);const n=this.poolingFunction(ig(e),[this.poolSize[0],1],[this.strides[0],1],this.padding,"channelsLast");return yl(n,[2])}))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides},t=super.getConfig();return Object.assign(e,t),e}}class Gv extends Uv{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return sm(r),om(a),Wv(e,t,n,a,r,"max")}}Gv.className="MaxPooling1D",Do(Gv);class Hv extends Uv{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return sm(r),om(a),Wv(e,t,n,a,r,"avg")}}Hv.className="AveragePooling1D",Do(Hv);class jv extends vg{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(2!==e.strides.length)throw new Tf("If the strides property of a 2D pooling layer is an Array, it is expected to have a length of 2, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides];Kf(this.poolSize,"poolSize"),Kf(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sm(this.dataFormat),om(this.padding),this.inputSpec=[new fg({ndim:4})]}computeOutputShape(e){e=cg(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2];return t=Db(t,this.poolSize[0],this.padding,this.strides[0]),n=Db(n,this.poolSize[1],this.padding,this.strides[1]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n]:[e[0],t,n,e[3]]}call(e,t){return Es((()=>(this.invokeCallHook(e,t),this.poolingFunction(ig(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Kv extends jv{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return sm(r),om(a),Wv(e,t,n,a,r,"max")}}Kv.className="MaxPooling2D",Do(Kv);class qv extends jv{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return sm(r),om(a),Wv(e,t,n,a,r,"avg")}}qv.className="AveragePooling2D",Do(qv);class Xv extends vg{constructor(e){if(null==e.poolSize&&(e.poolSize=[2,2,2]),super(e),this.poolSize=Array.isArray(e.poolSize)?e.poolSize:[e.poolSize,e.poolSize,e.poolSize],null==e.strides)this.strides=this.poolSize;else if(Array.isArray(e.strides)){if(3!==e.strides.length)throw new Tf("If the strides property of a 3D pooling layer is an Array, it is expected to have a length of 3, but received length "+"".concat(e.strides.length,"."));this.strides=e.strides}else this.strides=[e.strides,e.strides,e.strides];Kf(this.poolSize,"poolSize"),Kf(this.strides,"strides"),this.padding=null==e.padding?"valid":e.padding,this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sm(this.dataFormat),om(this.padding),this.inputSpec=[new fg({ndim:5})]}computeOutputShape(e){e=cg(e);let t="channelsFirst"===this.dataFormat?e[2]:e[1],n="channelsFirst"===this.dataFormat?e[3]:e[2],a="channelsFirst"===this.dataFormat?e[4]:e[3];return t=Db(t,this.poolSize[0],this.padding,this.strides[0]),n=Db(n,this.poolSize[1],this.padding,this.strides[1]),a=Db(a,this.poolSize[2],this.padding,this.strides[2]),"channelsFirst"===this.dataFormat?[e[0],e[1],t,n,a]:[e[0],t,n,a,e[4]]}call(e,t){return Es((()=>(this.invokeCallHook(e,t),this.poolingFunction(ig(e),this.poolSize,this.strides,this.padding,this.dataFormat))))}getConfig(){const e={poolSize:this.poolSize,padding:this.padding,strides:this.strides,dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class Yv extends Xv{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return sm(r),om(a),Vv(e,t,n,a,r,"max")}}Yv.className="MaxPooling3D",Do(Yv);class Qv extends Xv{constructor(e){super(e)}poolingFunction(e,t,n,a,r){return sm(r),om(a),Vv(e,t,n,a,r,"avg")}}Qv.className="AveragePooling3D",Do(Qv);class Jv extends vg{constructor(e){super(e),this.inputSpec=[new fg({ndim:3})]}computeOutputShape(e){return[e[0],e[2]]}call(e,t){throw new Ef}}class Zv extends Jv{constructor(e){super(e||{})}call(e,t){return Es((()=>{const t=ig(e);return Wc(t,1)}))}}Zv.className="GlobalAveragePooling1D",Do(Zv);class $v extends Jv{constructor(e){super(e||{})}call(e,t){return Es((()=>{const t=ig(e);return Ic(t,1)}))}}$v.className="GlobalMaxPooling1D",Do($v);class ex extends vg{constructor(e){super(e),this.dataFormat=null==e.dataFormat?"channelsLast":e.dataFormat,sm(this.dataFormat),this.inputSpec=[new fg({ndim:4})]}computeOutputShape(e){return"channelsLast"===this.dataFormat?[e[0],e[3]]:[e[0],e[1]]}call(e,t){throw new Ef}getConfig(){const e={dataFormat:this.dataFormat},t=super.getConfig();return Object.assign(e,t),e}}class tx extends ex{call(e,t){return Es((()=>{const t=ig(e);return"channelsLast"===this.dataFormat?Wc(t,[1,2]):Wc(t,[2,3])}))}}tx.className="GlobalAveragePooling2D",Do(tx);class nx extends ex{call(e,t){return Es((()=>{const t=ig(e);return"channelsLast"===this.dataFormat?Ic(t,[1,2]):Ic(t,[2,3])}))}}nx.className="GlobalMaxPooling2D",Do(nx);class ax extends vg{constructor(e){super(e),this.layer=e.layer}build(e){this.built=!0}get trainable(){return null!=this.layer&&this.layer.trainable}set trainable(e){null!=this.layer&&(this.layer.trainable=e)}get trainableWeights(){return this.layer.trainableWeights}get nonTrainableWeights(){return this.layer.nonTrainableWeights}get updates(){return this.layer._updates}get losses(){return this.layer.losses}getWeights(){return this.layer.getWeights()}setWeights(e){this.layer.setWeights(e)}getConfig(){const e={layer:{className:this.layer.getClassName(),config:this.layer.getConfig()}},t=super.getConfig();return Object.assign(e,t),e}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.layer&&this.layer.setFastWeightInitDuringBuild(e)}static fromConfig(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const a=Qg(t.layer,n);delete t.layer;const r={layer:a};return Object.assign(r,t),new e(r)}}class rx extends ax{constructor(e){super(e),this.supportsMasking=!0}build(e){if((e=cg(e)).length<3)throw new Tf("TimeDistributed layer expects an input shape >= 3D, but received "+"input shape ".concat(JSON.stringify(e)));this.inputSpec=[{shape:e}];const t=[e[0]].concat(e.slice(2));this.layer.built||(this.layer.build(t),this.layer.built=!0),super.build(e)}computeOutputShape(e){const t=[(e=cg(e))[0]].concat(e.slice(2)),n=this.layer.computeOutputShape(t),a=e[1];return[n[0],a].concat(n.slice(1))}call(e,t){return Es((()=>Zb(((e,n)=>[ig(this.layer.call(e,t)),[]]),e=ig(e),[],!1,null,null,!1,!0)[1]))}}rx.className="TimeDistributed",Do(rx);class sx extends ax{constructor(e){super(e);const t=e.layer.getConfig(),n={};n.className=e.layer.getClassName(),n.config=t,this.forwardLayer=Qg(n),t.goBackwards=!0!==t.goBackwards;const a={};var r;if(a.className=e.layer.getClassName(),a.config=t,this.backwardLayer=Qg(a),this.forwardLayer.name="forward_"+this.forwardLayer.name,this.backwardLayer.name="backward_"+this.backwardLayer.name,this.mergeMode=void 0===e.mergeMode?"concat":e.mergeMode,r=this.mergeMode,Hf(am,"BidirectionalMergeMode",r),e.weights)throw new Ef("weights support is not implemented for Bidirectional layer yet.");this._stateful=e.layer.stateful,this.returnSequences=e.layer.returnSequences,this.returnState=e.layer.returnState,this.supportsMasking=!0,this._trainable=!0,this.inputSpec=e.layer.inputSpec,this.numConstants=null}get trainable(){return this._trainable}set trainable(e){this._trainable=e,null!=this.forwardLayer&&(this.forwardLayer.trainable=e),null!=this.backwardLayer&&(this.backwardLayer.trainable=e)}getWeights(){return this.forwardLayer.getWeights().concat(this.backwardLayer.getWeights())}setWeights(e){const t=e.length,n=Math.floor(t/2);this.forwardLayer.setWeights(e.slice(0,n)),this.backwardLayer.setWeights(e.slice(n))}computeOutputShape(e){let t,n,a,r=this.forwardLayer.computeOutputShape(e);return Array.isArray(r)&&Array.isArray(r[0])||(r=[r]),this.returnState?(a=r.slice(1),t=r[0]):t=r[0],"concat"===this.mergeMode?(t[t.length-1]*=2,n=[t]):n=null==this.mergeMode?[t,t.slice()]:[t],this.returnState?null==this.mergeMode?n.concat(a).concat(a.slice()):[t].concat(a).concat(a.slice()):Ff(n)}apply(e,t){let n=null==t?null:t.initialState,a=null==t?null:t.constants;null==t&&(t={});const r=Jb(e,n,a,this.numConstants);if(e=r.inputs,n=r.initialState,a=r.constants,Array.isArray(e)&&(n=e.slice(1),e=e[0]),(null==n||0===n.length)&&null==a)return super.apply(e,t);const s=[],o=[];if(null!=n){const e=n.length;if(e%2>0)throw new Tf("When passing `initialState` to a Bidrectional RNN, the state should be an Array containing the states of the underlying RNNs.");t.initialState=n,s.push(...n);const a=n.map((e=>new fg({shape:e.shape})));this.forwardLayer.stateSpec=a.slice(0,e/2),this.backwardLayer.stateSpec=a.slice(e/2),o.push(...a)}if(null!=a)throw new Ef("Support for constants in Bidirectional layers is not implemented yet.");const i=s[0]instanceof mg;for(const c of s)if(c instanceof mg!==i)throw new Tf("The initial state of a Bidirectional layer cannot be specified as a mix of symbolic and non-symbolic tensors");if(i){const n=[e].concat(s),a=this.inputSpec.concat(o),r=this.inputSpec;this.inputSpec=a;const i=super.apply(n,t);return this.inputSpec=r,i}return super.apply(e,t)}call(e,t){return Es((()=>{const n=t.initialState;let a,r,s,o;if(null==n)a=this.forwardLayer.call(e,t),r=this.backwardLayer.call(e,t);else{const s=n.slice(0,n.length/2),o=n.slice(n.length/2);a=this.forwardLayer.call(e,Object.assign(t,{initialState:s})),r=this.backwardLayer.call(e,Object.assign(t,{initialState:o}))}return this.returnState&&(Array.isArray(a)&&(s=a.slice(1).concat(r.slice(1))),a=a[0],r=r[0]),this.returnSequences&&(r=sl(r,1)),"concat"===this.mergeMode?o=Tm([a,r]):"sum"===this.mergeMode?o=vo(a,r):"ave"===this.mergeMode?o=ko(.5,vo(a,r)):"mul"===this.mergeMode?o=ko(a,r):null==this.mergeMode&&(o=[a,r]),this.returnState?null==this.mergeMode?o.concat(s):[o].concat(s):o}))}resetStates(e){this.forwardLayer.resetStates(),this.backwardLayer.resetStates()}build(e){um(this.forwardLayer.name,(()=>{this.forwardLayer.build(e)})),um(this.backwardLayer.name,(()=>{this.backwardLayer.build(e)})),this.built=!0}computeMask(e,t){let n;if(Array.isArray(t)&&(t=t[0]),n=this.returnSequences?null==this.mergeMode?[t,t]:t:null==this.mergeMode?[null,null]:null,this.returnState){const e=this.forwardLayer.states.map((e=>null));return Array.isArray(n)?n.concat(e).concat(e):[n].concat(e).concat(e)}return n}get trainableWeights(){return this.forwardLayer.trainableWeights.concat(this.backwardLayer.trainableWeights)}get nonTrainableWeights(){return this.forwardLayer.nonTrainableWeights.concat(this.backwardLayer.nonTrainableWeights)}setFastWeightInitDuringBuild(e){super.setFastWeightInitDuringBuild(e),null!=this.forwardLayer&&this.forwardLayer.setFastWeightInitDuringBuild(e),null!=this.backwardLayer&&this.backwardLayer.setFastWeightInitDuringBuild(e)}getConfig(){const e={mergeMode:this.mergeMode},t=super.getConfig();return Object.assign(e,t),e}static fromConfig(e,t){const n=Qg(t.layer);if(delete t.layer,null!=t.numConstants)throw new Ef("Deserialization of a Bidirectional layer with numConstants present is not supported yet.");const a=t;return a.layer=n,new e(a)}}sx.className="Bidirectional",Do(sx);class ox extends vg{constructor(e){super(e),this.scale=e.scale,e.offset?this.offset=e.offset:this.offset=0}getConfig(){const e={scale:this.scale,offset:this.offset},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Es((()=>("float32"!==(e=ig(e)).dtype&&(e=wm(e,"float32")),vo(ko(e,this.scale),this.offset))))}}ox.className="Rescaling",Do(ox);const{resizeBilinear:ix,cropAndResize:cx}=Cu;class lx extends vg{constructor(e){super(e),this.height=e.height,this.width=e.width}centerCrop(e,t,n,a,r,s,o,i){return Es((()=>{let c,l=!1;const u=[t/s,n/o,(a+t)/s,(r+n)/o],h=[];3===e.rank?(l=!0,c=bl([e])):c=e;for(let e=0;e<c.shape[0];e++)h.push(u);const d=Ss(h,[h.length,4]),p=al(0,h.length,1,"int32"),f=cx(c,d,p,[a,r],"nearest");return wm(l?ig(Sl(f)):f,i)}))}upsize(e,t,n,a){return Es((()=>wm(ix(e,[t,n]),a)))}call(e,t){return Es((()=>{const t=ig(e),n=t.dtype,a=t.shape,r=a[a.length-3],s=a[a.length-2];let o=0;r!==this.height&&(o=Math.floor((r-this.height)/2));let i=0;return s!==this.width&&(i=Math.floor((s-this.width)/2),0===i&&(i=1)),o>=0&&i>=0?this.centerCrop(t,o,i,this.height,this.width,r,s,n):this.upsize(e,this.height,this.width,n)}))}getConfig(){const e={height:this.height,width:this.width},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=cg(e)).length-3,n=e.length-2;return e[t]=this.height,e[n]=this.width,e}}lx.className="CenterCrop",Do(lx);class ux extends vg{constructor(e){super(e),this.numTokens=e.numTokens,e.outputMode?this.outputMode=e.outputMode:this.outputMode="multiHot"}getConfig(){const e={numTokens:this.numTokens,outputMode:this.outputMode},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){return null==(e=cg(e))?[this.numTokens]:"oneHot"===this.outputMode&&1!==e[e.length-1]?(e.push(this.numTokens),e):(e[e.length-1]=this.numTokens,e)}call(e,t){return Es((()=>{let n;if("int32"!==(e=ig(e)).dtype&&(e=wm(e,"int32")),"undefined"!==typeof t.countWeights){if("count"!==this.outputMode)throw new Tf("countWeights is not used when outputMode !== count.\n              Received countWeights=".concat(t.countWeights));n=ig(t.countWeights)}const a=Ic(e),r=Vc(e),s=vc(this.numTokens,a).bufferSync().get(0),o=xc(r,0).bufferSync().get(0);if(!s||!o)throw new Tf("Input values must be between 0 < values <="+" numTokens with numTokens=".concat(this.numTokens));return function(e,t,n,a){let r=ig(e);if("int32"!==r.dtype&&(r=wm(r,"int32")),"int"===t)return r;const s=r.shape;if(0===r.rank&&(r=fc(r,-1)),"oneHot"===t&&1!==r.shape[r.shape.length-1]&&(r=fc(r,-1)),r.rank>2)throw new Tf("When outputMode is not int, maximum output rank is 2"+" Received outputMode ".concat(t," and input shape ").concat(s)+" which would result in output rank ".concat(r.rank,"."));const o=["multiHot","oneHot"].includes(t),i=r;let c;if(c=cc(i,"undefined"!==typeof a&&"count"===t?a:[],n,o),"tfIdf"!==t)return c;if(a)return ko(c,a);throw new Tf("When outputMode is 'tfIdf', weights must be provided.")}(e,this.outputMode,this.numTokens,n)}))}}ux.className="CategoryEncoding",Do(ux);const hx=new Set(["bilinear","nearest"]);class dx extends vg{constructor(e){if(super(e),this.height=e.height,this.width=e.width,e.interpolation){if(!hx.has(e.interpolation))throw new Tf("Invalid interpolation parameter: ".concat(e.interpolation," is not implemented"));this.interpolation=e.interpolation}else this.interpolation="bilinear";this.cropToAspectRatio=Boolean(e.cropToAspectRatio)}computeOutputShape(e){const t=(e=cg(e))[2];return[this.height,this.width,t]}getConfig(){const e={height:this.height,width:this.width,interpolation:this.interpolation,cropToAspectRatio:this.cropToAspectRatio},t=super.getConfig();return Object.assign(e,t),e}call(e,t){return Es((()=>{const t=[this.height,this.width];if("bilinear"===this.interpolation)return Cu.resizeBilinear(e,t,!this.cropToAspectRatio);if("nearest"===this.interpolation)return Cu.resizeNearestNeighbor(e,t,!this.cropToAspectRatio);throw new Error("Interpolation is ".concat(this.interpolation," but only ").concat([...hx]," are supported"))}))}}dx.className="Resizing",Do(dx);class px{constructor(e){this.seed=e}next(){if(void 0!==this.seed)return this.seed++}}px.className="RandomSeed";class fx extends vg{constructor(e){super(e),this.randomGenerator=new px(e.seed)}getConfig(){const e={seed:this.randomGenerator.seed},t=super.getConfig();return Object.assign(e,t),e}}fx.className="BaseRandomLayer";const mx=new Set(["bilinear","nearest"]);class gx extends fx{constructor(e){super(e);const{factor:t,interpolation:n="bilinear"}=e;if(this.factor=t,Array.isArray(this.factor)&&2===this.factor.length)this.widthLower=this.factor[0],this.widthUpper=this.factor[1];else{if(Array.isArray(this.factor)||!(this.factor>0))throw new Tf("Invalid factor: ".concat(this.factor,". Must be positive number or tuple of 2 numbers"));this.widthLower=-this.factor,this.widthUpper=this.factor}if(this.widthLower<-1||this.widthUpper<-1)throw new Tf("factor must have values larger than -1. Got: ".concat(this.factor));if(this.widthUpper<this.widthLower)throw new Tf("factor cannot have upper bound less than lower bound.\n        Got upper bound: ".concat(this.widthUpper,".\n        Got lower bound: ").concat(this.widthLower,"\n      "));if(n){if(!mx.has(n))throw new Tf("Invalid interpolation parameter: ".concat(n," is not implemented"));this.interpolation=n}}getConfig(){const e={factor:this.factor,interpolation:this.interpolation},t=super.getConfig();return Object.assign(e,t),e}computeOutputShape(e){const t=(e=cg(e))[2];return[this.imgHeight,-1,t]}call(e,t){return Es((()=>{const t=ig(e);this.imgHeight=t.shape[t.shape.length-3];const n=t.shape[t.shape.length-2];this.widthFactor=nl([1],1+this.widthLower,1+this.widthUpper,"float32",this.randomGenerator.next());let a=this.widthFactor.dataSync()[0]*n;a=Math.round(a);const r=[this.imgHeight,a];switch(this.interpolation){case"bilinear":return Cu.resizeBilinear(e,r);case"nearest":return Cu.resizeNearestNeighbor(e,r);default:throw new Error("Interpolation is ".concat(this.interpolation,"\n          but only ").concat([...mx]," are supported"))}}))}}gx.className="RandomWidth",Do(gx);var yx,bx;_e().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(yx||(yx={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(bx||(bx={}));Error;new Set(["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"]),new Set(["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"]),new Set(["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"]);function vx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Map,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:new Set;if(null==e)return null;if("function"===typeof Blob&&e instanceof Blob)return e.slice();if(a.has(e))throw new Error("Circular references are not supported.");if(n.has(e))return n.get(e);const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep map function may not return both a value and recurse=true.");if(r.recurse){if(Sx(e)){const r=Array.isArray(e)?[]:{};a.add(e);for(const s in e){const o=vx(e[s],t,n,a);r[s]=o}return a.delete(e),e.__proto__&&(r.__proto__=e.__proto__),r}throw new Error("Can't recurse into non-iterable type: ".concat(e))}return n.set(e,r.value),r.value}function xx(e){return wx(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:kx)}function wx(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:new Set;const a=e[0];if(n.has(a))throw new Error("Circular references are not supported.");const r=t(e);if(r.recurse&&null!==r.value)throw new Error("A deep zip function may not return both a value and recurse=true.");if(r.recurse){if(Sx(a)){const r=Array.isArray(a)?[]:{};n.add(a);for(const s in a){const a=wx(e.map((e=>e[s])),t,n);r[s]=a}return n.delete(a),r}throw new Error("Can't recurse into non-iterable type: ".concat(a))}return r.value}function kx(e){return null===e?null:Sx(e[0])?{value:null,recurse:!0}:{value:e,recurse:!1}}function Sx(e){let t=!1;if(_e().get("IS_BROWSER"))t=e instanceof TextDecoder;else{const{StringDecoder:a}=n(222);t=e instanceof a}return null!=e&&!ArrayBuffer.isView(e)&&(Array.isArray(e)||"object"===typeof e&&!(e instanceof Ur)&&!(e instanceof Promise)&&!t)}function Ix(e){return function(e,t){return vx(e,t)}(e,Nx)}function Nx(e){return e instanceof Ur?{value:e.clone(),recurse:!1}:Sx(e)?{value:null,recurse:!0}:{value:e,recurse:!1}}class Tx{constructor(e){if(this.capacity=e,this.begin=0,this.end=0,null==e)throw new RangeError("Can't create a ring buffer of unknown capacity.");if(e<1)throw new RangeError("Can't create ring buffer of capacity < 1.");this.data=new Array(e),this.doubledCapacity=2*e}wrap(e){for(;e<0;)e+=this.doubledCapacity;return e%this.doubledCapacity}get(e){if(e<0)throw new RangeError("Can't get item at a negative index.");return this.data[e%this.capacity]}set(e,t){if(e<0)throw new RangeError("Can't set item at a negative index.");this.data[e%this.capacity]=t}length(){let e=this.end-this.begin;return e<0&&(e=this.doubledCapacity+e),e}isFull(){return this.length()===this.capacity}isEmpty(){return 0===this.length()}push(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.set(this.end,e),this.end=this.wrap(this.end+1)}pushAll(e){for(const t of e)this.push(t)}pop(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");this.end=this.wrap(this.end-1);const e=this.get(this.end);return this.set(this.end,void 0),e}unshift(e){if(this.isFull())throw new RangeError("Ring buffer is full.");this.begin=this.wrap(this.begin-1),this.set(this.begin,e)}shift(){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const e=this.get(this.begin);return this.set(this.begin,void 0),this.begin=this.wrap(this.begin+1),e}shuffleExcise(e){if(this.isEmpty())throw new RangeError("Ring buffer is empty.");const t=this.wrap(this.begin+e),n=this.get(t);return this.set(t,this.pop()),n}}class Ex extends Tx{constructor(){super(Ex.INITIAL_CAPACITY)}isFull(){return!1}push(e){super.isFull()&&this.expand(),super.push(e)}unshift(e){super.isFull()&&this.expand(),super.unshift(e)}expand(){const e=2*this.capacity,t=new Array(e),n=this.length();for(let a=0;a<n;a++)t[a]=this.get(this.wrap(this.begin+a));this.data=t,this.capacity=e,this.doubledCapacity=2*this.capacity,this.begin=0,this.end=n}}function Cx(e){return new Dx(e)}function Rx(e,t){return new Gx(e,t)}Ex.INITIAL_CAPACITY=32;class Ax{async toArray(){const e=[];let t=await this.next();for(;!t.done;)e.push(t.value),t=await this.next();return e}async toArrayForTest(){const e=this.prefetch(100),t=[];let n=await e.next();for(;!n.done;)t.push(n.value),n=await e.next();return t}async resolveFully(){let e=await this.next();for(;!e.done;)e=await this.next()}async resolveWhile(e){let t=await this.next(),n=e(t.value);for(;!t.done&&n;)t=await this.next(),n=e(t.value)}handleErrors(e){return new Bx(this,e)}filter(e){return new zx(this,e)}map(e){return new Px(this,e)}mapAsync(e){return new Wx(this,e)}serialMapAsync(e){return new Wx(this,e).serial()}flatmap(e){return new Ux(this,e)}async forEachAsync(e){return this.map(e).resolveFully()}async serialForEach(e){return this.serialMapAsync(e).resolveWhile((e=>!0===e))}rowMajorBatch(e){return new Lx(this,e,!(arguments.length>1&&void 0!==arguments[1])||arguments[1])}columnMajorBatch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:kx;return this.rowMajorBatch(e,t).map((e=>xx(e,n)))}concatenate(e,t){return new Gx(new _x([this,e]),t)}take(e){return e<0||null==e?this:new Mx(this,e)}skip(e){return e<0||null==e?this:new Ox(this,e)}prefetch(e){return new jx(this,e)}shuffle(e,t){return new Kx(this,e,t)}serial(){return new Fx(this)}}class _x extends Ax{constructor(e){super(),this.items=e,this.trav=0}summary(){return"Array of ".concat(this.items.length," items")}async next(){if(this.trav>=this.items.length)return{value:null,done:!0};const e=this.items[this.trav];return this.trav++,{value:Ix(e),done:!1}}}class Dx extends Ax{constructor(e){super(),this.nextFn=e}summary(){return"Function call"}async next(){try{return this.nextFn()}catch(e){throw e.message="Error thrown while iterating through a dataset: ".concat(e.message),e}}}class Fx extends Ax{constructor(e){super(),this.upstream=e,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Serial")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){return this.upstream.next()}}class Ox extends Ax{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Skip")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;this.count++<this.maxCount;){const e=await this.upstream.next();if(e.done)return e;Cs(e.value)}return this.upstream.next()}}class Mx extends Ax{constructor(e,t){super(),this.upstream=e,this.maxCount=t,this.count=0}summary(){return"".concat(this.upstream.summary()," -> Take")}async next(){return this.count++>=this.maxCount?{value:null,done:!0}:this.upstream.next()}}class Lx extends Ax{constructor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];super(),this.upstream=e,this.batchSize=t,this.enableSmallLastBatch=n,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> RowMajorBatch")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){const e=[];for(;e.length<this.batchSize;){const t=await this.upstream.next();if(t.done)return this.enableSmallLastBatch&&e.length>0?{value:e,done:!1}:{value:null,done:!0};e.push(t.value)}return{value:e,done:!1}}}class zx extends Ax{constructor(e,t){super(),this.upstream=e,this.predicate=t,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> Filter")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;){const e=await this.upstream.next();if(e.done||this.predicate(e.value))return e;Cs(e.value)}}}class Px extends Ax{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Map")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=as(e.value),n=this.transform(e.value),a=as(n);for(const r of t)ns(r,a)||r.dispose();return{value:n,done:!1}}}class Bx extends Ax{constructor(e,t){super(),this.upstream=e,this.handler=t,this.count=0,this.lastRead=Promise.resolve({value:null,done:!1})}summary(){return"".concat(this.upstream.summary()," -> handleErrors")}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;;)try{return await this.upstream.next()}catch(e){if(!this.handler(e))return{value:null,done:!0}}}}class Wx extends Ax{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> AsyncMap")}async next(){const e=await this.upstream.next();if(e.done)return{value:null,done:!0};const t=as(e.value),n=await this.transform(e.value),a=as(n);for(const r of t)ns(r,a)||r.dispose();return{value:n,done:!1}}}class Vx extends Ax{constructor(){super(),this.outputQueue=new Ex,this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}async serialNext(){for(;0===this.outputQueue.length();)if(!await this.pump())return{value:null,done:!0};return{value:this.outputQueue.shift(),done:!1}}}class Ux extends Vx{constructor(e,t){super(),this.upstream=e,this.transform=t}summary(){return"".concat(this.upstream.summary()," -> Flatmap")}async pump(){const e=await this.upstream.next();if(e.done)return!1;const t=as(e.value),n=this.transform(e.value),a=as(n);this.outputQueue.pushAll(n);for(const r of t)ns(r,a)||r.dispose();return!0}}class Gx extends Ax{constructor(e,t){super(),this.baseErrorHandler=t,this.lastRead=null,this.iterator=null,this.moreIterators=e}summary(){return"".concat("TODO: fill in upstream of chained summaries"," -> Chained")}async next(){return this.lastRead=this.readFromChain(this.lastRead),this.lastRead}async readFromChain(e){if(await e,null==this.iterator){const e=await this.moreIterators.next();if(e.done)return{value:null,done:!0};this.iterator=e.value,null!=this.baseErrorHandler&&(this.iterator=this.iterator.handleErrors(this.baseErrorHandler))}const t=await this.iterator.next();return t.done?(this.iterator=null,this.readFromChain(e)):t}}var Hx;!function(e){e[e.FAIL=0]="FAIL",e[e.SHORTEST=1]="SHORTEST",e[e.LONGEST=2]="LONGEST"}(Hx||(Hx={}));class jx extends Ax{constructor(e,t){super(),this.upstream=e,this.bufferSize=t,this.buffer=new Tx(t)}summary(){return"".concat(this.upstream.summary()," -> Prefetch")}refill(){for(;!this.buffer.isFull();){const e=this.upstream.next();this.buffer.push(e)}}next(){return this.refill(),this.buffer.shift()}}class Kx extends jx{constructor(e,t,n){super(e,t),this.upstream=e,this.windowSize=t,this.upstreamExhausted=!1,this.random=Zc.alea(n||kr().toString()),this.lastRead=Promise.resolve({value:null,done:!1})}async next(){return this.lastRead=this.lastRead.then((()=>this.serialNext())),this.lastRead}randomInt(e){return Math.floor(this.random()*e)}chooseIndex(){return this.randomInt(this.buffer.length())}async serialNext(){for(this.upstreamExhausted||this.refill();!this.buffer.isEmpty();){const e=this.chooseIndex(),t=await this.buffer.shuffleExcise(e);if(!t.done)return this.refill(),t;this.upstreamExhausted=!0}return{value:null,done:!0}}}class qx{constructor(){this.size=null}batch(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1];const n=this;let a;return J(e>0,(()=>"batchSize needs to be positive, but it is\n      ".concat(e))),a=this.size===1/0||null==this.size?this.size:t?Math.ceil(this.size/e):Math.floor(this.size/e),Xx((async()=>(await n.iterator()).columnMajorBatch(e,t,Yx)),a)}concatenate(e){const t=this;let n;return n=this.size===1/0||e.size===1/0?1/0:null!=this.size&&null!=e.size?this.size+e.size:null,Xx((async()=>(await t.iterator()).concatenate(await e.iterator())),n)}filter(e){const t=this;let n;return n=this.size===1/0?1/0:null,Xx((async()=>(await t.iterator()).filter((t=>Es((()=>e(t)))))),n)}async forEachAsync(e){return(await this.iterator()).forEachAsync(e)}map(e){const t=this;return Xx((async()=>(await t.iterator()).map((t=>Es((()=>e(t)))))),this.size)}mapAsync(e){const t=this;return Xx((async()=>(await t.iterator()).mapAsync(e)),this.size)}prefetch(e){if(null==e)throw new RangeError("`Dataset.prefetch()` requires bufferSize to be specified.");const t=this;return Xx((async()=>(await t.iterator()).prefetch(e)),this.size)}repeat(e){const t=this;let n;return n=null!=this.size&&e>0?this.size*e:0===e?0:null!=this.size&&(void 0===e||e<0)?1/0:null,Xx((async()=>Rx(Cx((async()=>({value:await t.iterator(),done:!1}))).take(e))),n)}skip(e){const t=this;let n;return n=null!=this.size&&e>=0&&this.size>=e?this.size-e:null!=this.size&&(this.size<e||void 0===e||e<0)?0:null,Xx((async()=>(await t.iterator()).skip(e)),n)}shuffle(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(null==e||e<0)throw null==this.size?new RangeError("`Dataset.shuffle()` requires bufferSize to be specified."):new RangeError("`Dataset.shuffle()` requires bufferSize to be specified.  If your data fits in main memory (for regular JS objects), and/or GPU memory (for `tf.Tensor`s), consider setting "+"bufferSize to the dataset size (".concat(this.size," elements)"));const a=this,r=Zc.alea(t||kr().toString());return Xx((async()=>{let t=r.int32();return n&&(t+=r.int32()),(await a.iterator()).shuffle(e,t.toString())}),this.size)}take(e){const t=this;let n;return n=null!=this.size&&this.size>e?e:null!=this.size&&this.size<=e?this.size:null,Xx((async()=>(await t.iterator()).take(e)),n)}async toArray(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArray()}async toArrayForTest(){if(this.size===1/0)throw new Error("Can not convert infinite data stream to array.");return(await this.iterator()).toArrayForTest()}}function Xx(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;return new class extends qx{constructor(){super(...arguments),this.size=t}async iterator(){return e()}}}function Yx(e){if(null===e)return null;if(function(e){return null==e||null===(t=e)||"object"!==typeof t&&"function"!==typeof t||Array.isArray(e)||"object"===typeof e&&e instanceof Ur||Nr(e);var t}(e[0])){return{value:function(e){if(0===e.length)throw new Error("Can't make a batch of zero elements.");return e[0]instanceof Ur?bl(e):Ss(e)}(e),recurse:!1}}return{value:null,recurse:!0}}qx.MAX_BUFFER_SIZE=1e4;Symbol("out"),Symbol("field"),Symbol("quote"),Symbol("quoteafterquote"),Symbol("quoteinquote");function Qx(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&J("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors in the CPU backend.")))}))}const Jx=Uh;class Zx extends j{nextDataId(){return Zx.nextDataId++}constructor(){super(),this.blockSize=48,this.firstUse=!0,this.data=new H(this,Ns())}write(e,t,n){this.firstUse&&(this.firstUse=!1,_e().get("IS_NODE")&&Xa("\n============================\nHi, looks like you are running TensorFlow.js in Node.js. To speed things up dramatically, install our node backend, visit https://github.com/tensorflow/tfjs-node for more details. \n============================"));const a={id:this.nextDataId()};return this.data.set(a,{values:e,dtype:n,refCount:1}),a}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&pe(n[0])){const r=n.map((e=>Sr(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return{dataId:a,shape:e,dtype:t}}refCount(e){if(this.data.has(e)){return this.data.get(e).refCount}return 0}incRef(e){this.data.get(e).refCount++}decRef(e){if(this.data.has(e)){this.data.get(e).refCount--}}move(e,t,n,a,r){this.data.set(e,{values:t,dtype:a,refCount:r})}numDataIds(){return this.data.numDataIds()}async read(e){return this.readSync(e)}readSync(e){const{dtype:t,complexTensorInfos:n}=this.data.get(e);if("complex64"===t){return oh(this.readSync(n.real.dataId),this.readSync(n.imag.dataId))}return function(e,t){if(Array.isArray(e))return e;if("float32"===t)return e instanceof Float32Array?e:new Float32Array(e);if("int32"===t)return e instanceof Int32Array?e:new Int32Array(e);if("bool"===t||"string"===t)return Uint8Array.from(new Int32Array(e));throw new Error("Unknown dtype ".concat(t))}(this.data.get(e).values,t)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Ir(e)));return go(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return go(e.shape,e.dtype,t)}makeOutput(e,t,n){return Ns().makeTensorFromTensorInfo(this.makeTensorInfo(t,n,e),this)}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.data.has(e)){if(this.data.get(e).refCount--,!t&&this.data.get(e).refCount>0)return!1;const{complexTensorInfos:n}=this.data.get(e);null!=n&&(this.disposeData(n.real.dataId,!0),this.disposeData(n.imag.dataId,!0)),this.data.delete(e)}return!0}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}async time(e){const t=kr();e();return{kernelMs:kr()-t}}memory(){return{unreliable:!0,reasons:["The reported memory is an upper bound. Due to automatic garbage collection, the true allocated memory may be less."]}}where(e){Qx([e],"where");const t=this.readSync(e.dataId);return Jx(e.shape,t)}dispose(){}floatPrecision(){return 32}epsilon(){return super.epsilon()}}Zx.nextDataId=0;function $x(e){return(t,n,a)=>{const r=ue(n,t.length);for(let s=0;s<t.length;++s)r[s]=e(t[s],a);return r}}function ew(e,t,n){return tw(e,$x(t),n)}function tw(e,t,n){return a=>{let{inputs:r,attrs:s,backend:o}=a;const{x:i}=r;Qx(i,e);const c=o,l=c.data.get(i.dataId).values;let u;if("string"===i.dtype){if(!Array.isArray(l))throw new Error("String tensor's value was not an instance of Array");u=Wh(l)}else u=l;const h=n||i.dtype,d=t(u,h,s);return c.makeTensorInfo(i.shape,h,d)}}As("cpu",(()=>new Zx),1);const nw=ew(Ot,(e=>e>=0?e:Math.exp(e)-1)),aw={kernelName:Ot,backendName:"cpu",kernelFunc:nw};function rw(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const sw={kernelName:Jt,backendName:"cpu",kernelFunc:rw};function ow(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a;Qx([r],"leakyRelu");const o=ee(r.shape),i=n.data.get(r.dataId).values,c=le("float32",o);for(let l=0;l<i.length;l++)c[l]=i[l]<0?s*i[l]:i[l];return n.makeTensorInfo(r.shape,"float32",c)}const iw={kernelName:an,backendName:"cpu",kernelFunc:ow};function cw(e){return(t,n,a,r,s)=>{const o=Go(t,n),i=o.length,c=be(o),l=le(s,ee(o)),u=t.length,h=n.length,d=be(t),p=be(n),f=Vo(t,o),m=Vo(n,o);if(f.length+m.length===0)for(let g=0;g<l.length;++g)l[g]=e(a[g%a.length],r[g%r.length]);else for(let g=0;g<l.length;++g){const t=Te(g,i,c),n=t.slice(-u);f.forEach((e=>n[e]=0));const s=Ne(n,u,d),o=t.slice(-h);m.forEach((e=>o[e]=0));const y=Ne(o,h,p);l[g]=e(a[s],r[y])}return[l,o]}}const lw=cw(((e,t)=>e<0?t*e:e));function uw(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t;Qx([a,r],"prelu");const s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,[i,c]=lw(a.shape,r.shape,s,o,"float32");return n.makeTensorInfo(c,"float32",i)}const hw={kernelName:Bn,backendName:"cpu",kernelFunc:uw},dw=ew(qn,(e=>Math.max(0,e))),pw={kernelName:qn,backendName:"cpu",kernelFunc:dw},fw=ew($n,(e=>Math.min(Math.max(0,e),6))),mw={kernelName:$n,backendName:"cpu",kernelFunc:fw},gw=$x((e=>1/(1+Math.exp(-e)))),yw=ew(da,(e=>1/(1+Math.exp(-e)))),bw={kernelName:da,backendName:"cpu",kernelFunc:yw};function vw(e,t,n,a,r){if("linear"===n)return rw({inputs:{x:t},backend:e});if("relu"===n)return dw({inputs:{x:t},backend:e});if("elu"===n)return nw({inputs:{x:t},backend:e});if("relu6"===n)return fw({inputs:{x:t},backend:e});if("prelu"===n)return uw({inputs:{x:t,alpha:a},backend:e});if("leakyrelu"===n)return ow({inputs:{x:t},backend:e,attrs:{alpha:r}});if("sigmoid"===n)return yw({inputs:{x:t},backend:e});throw new Error("Activation ".concat(n," has not been implemented for the CPU backend."))}function xw(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,i=n.makeTensorInfo(a.shape,"complex64");return n.data.get(i.dataId).complexTensorInfos={real:n.makeTensorInfo(a.shape,"float32",s),imag:n.makeTensorInfo(r.shape,"float32",o)},i}const ww={kernelName:ct,backendName:"cpu",kernelFunc:xw};function kw(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"float32";if("complex64"===n){return xw({inputs:{real:kw(e,t,"float32"),imag:kw(e,t,"float32")},backend:e})}const a=ke(ee(t),n);return e.makeTensorInfo(t,n,a)}function Sw(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.real,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const Iw={kernelName:jn,backendName:"cpu",kernelFunc:Sw};function Nw(e,t,n,a){if("int32"===a){return[t,"int32",Int32Array.from(e)]}if("bool"===a){const a=wr([0],n),[r,s]=cw(((e,t)=>e!==t?1:0))(t,[],e,a,"bool");return[s,"bool",r]}throw new Error("Error in Cast: failed to cast ".concat(n," to ").concat(a))}function Tw(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dtype:s}=a;if("complex64"===s){if("complex64"===r.dtype)return rw({inputs:{x:r},backend:n});const e=kw(n,r.shape,r.dtype),t=Tw({inputs:{x:r},backend:n,attrs:{dtype:"float32"}}),a=xw({inputs:{real:t,imag:e},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),a}if("complex64"===r.dtype){const e=Sw({inputs:{input:r},backend:n}),t=Tw({inputs:{x:e},backend:n,attrs:{dtype:s}});return n.disposeIntermediateTensorInfo(e),t}if(!he(r.dtype,s)){const e=rw({inputs:{x:r},backend:n});return{dataId:e.dataId,shape:e.shape,dtype:s}}const o=n.data.get(r.dataId).values,[i,c,l]=Nw(o,r.shape,r.dtype,s);return n.makeTensorInfo(i,c,l)}const Ew={kernelName:st,backendName:"cpu",kernelFunc:Tw};function Cw(e,t,n,a){return null==n?n=>{let{inputs:r,backend:s}=n;const{a:o,b:i}=r,c=s;Qx([o,i],e);const l=c.data.get(o.dataId).values,u=c.data.get(i.dataId).values,h="string"===o.dtype?Wh(l):l,d="string"===o.dtype?Wh(u):u,p=a||o.dtype,[f,m]=t(o.shape,i.shape,h,d,p);return c.makeTensorInfo(m,p,f)}:e=>{let{inputs:r,backend:s}=e;const{a:o,b:i}=r,c=s;if("complex64"===o.dtype||"complex64"===i.dtype){const e=Tw({inputs:{x:o},backend:c,attrs:{dtype:"complex64"}}),t=c.data.get(e.dataId),a=t.complexTensorInfos.real,r=t.complexTensorInfos.imag,s=c.data.get(a.dataId).values,l=c.data.get(r.dataId).values,u=Tw({inputs:{x:i},backend:c,attrs:{dtype:"complex64"}}),h=c.data.get(u.dataId),d=h.complexTensorInfos.real,p=h.complexTensorInfos.imag,f=c.data.get(d.dataId).values,m=c.data.get(p.dataId).values,[g,y,b]=n(o.shape,i.shape,s,l,f,m),v=c.makeTensorInfo(b,"float32",g),x=c.makeTensorInfo(b,"float32",y),w=xw({inputs:{real:v,imag:x},backend:c});return c.disposeIntermediateTensorInfo(e),c.disposeIntermediateTensorInfo(u),c.disposeIntermediateTensorInfo(v),c.disposeIntermediateTensorInfo(x),w}{const e=c.data.get(o.dataId).values,n=c.data.get(i.dataId).values,r=a||o.dtype,[s,l]=t(o.shape,i.shape,e,n,r);return c.makeTensorInfo(l,r,s)}}}function Rw(e){return(t,n,a,r,s,o)=>{const i=Go(t,n),c=ee(i),l=i.length,u=be(i),h=le("float32",c),d=le("float32",c),p=Vo(t,i),f=Vo(n,i),m=oh(a,r),g=oh(s,o),y=t.length,b=be(t),v=n.length,x=be(n);if(p.length+f.length===0)for(let w=0;w<h.length;w++){const t=w%m.length,n=w%g.length,a=e(m[2*t],m[2*t+1],g[2*n],g[2*n+1]);h[w]=a.real,d[w]=a.imag}else for(let w=0;w<h.length;w++){const t=Te(w,l,u),n=t.slice(-y);p.forEach((e=>n[e]=0));const a=Ne(n,y,b),r=t.slice(-v);f.forEach((e=>r[e]=0));const s=Ne(r,v,x),o=e(m[2*a],m[2*a+1],g[2*s],g[2*s+1]);h[w]=o.real,d[w]=o.imag}return[h,d,i]}}const Aw=cw(((e,t)=>e+t)),_w=Rw(((e,t,n,a)=>({real:e+n,imag:t+a}))),Dw=Cw(Be,Aw,_w),Fw={kernelName:Be,backendName:"cpu",kernelFunc:Dw};function Ow(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,o=ee(r.shape),i=oe(s,o),c=ee(i);J(o===c,(()=>"The new shape (".concat(i,") has ").concat(c," elements and the old ")+"shape (".concat(r.shape,") has ").concat(o," elements. The new shape and old ")+"shape must have the same number of elements.")),n.incRef(r.dataId);const l=n.data.get(r.dataId);if(null!=l.complexTensorInfos){const e=l.complexTensorInfos.real,t=l.complexTensorInfos.imag;e.shape=i,t.shape=i}return{dataId:r.dataId,shape:i,dtype:r.dtype}}const Mw={kernelName:Xn,backendName:"cpu",kernelFunc:Ow};function Lw(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:o,transposeB:i}=a;Qx([r,s],"matMul");const c=r.shape.length,l=s.shape.length,u=o?r.shape[c-2]:r.shape[c-1],h=i?s.shape[l-1]:s.shape[l-2],d=o?r.shape[c-1]:r.shape[c-2],p=i?s.shape[l-2]:s.shape[l-1],f=r.shape.slice(0,-2),m=s.shape.slice(0,-2),g=ee(f),y=ee(m),b=Go(r.shape.slice(0,-2),s.shape.slice(0,-2)).concat([d,p]);J(u===h,(()=>"Error in matMul: inner shapes (".concat(u,") and (")+"".concat(h,") of Tensors with shapes ").concat(r.shape," and ")+"".concat(s.shape," and transposeA=").concat(o)+" and transposeB=".concat(i," must match.")));const v=i?[y,p,h]:[y,h,p],x=Ow({inputs:{x:r},backend:n,attrs:{shape:o?[g,u,d]:[g,d,u]}}),w=Ow({inputs:{x:s},backend:n,attrs:{shape:v}}),k=o?x.shape[1]:x.shape[2],S=o?x.shape[2]:x.shape[1],I=i?w.shape[1]:w.shape[2],N=Math.max(g,y),T=n.data.get(x.dataId).values,E=n.data.get(w.dataId).values,C=be(x.shape),R=be(w.shape),[A,_,D]=o?[C[0],1,C[1]]:[C[0],C[1],1],[F,O,M]=i?[1,R[1],R[0]]:[R[1],1,R[0]],L=S*I,z=go([N,S,I],x.dtype),P=z.values,B=n.blockSize;for(let W=0;W<N;W++){const e=W%g,t=W%y;for(let n=0;n<S;n+=B){const a=Math.min(n+B,S);for(let r=0;r<I;r+=B){const s=Math.min(r+B,I);for(let o=0;o<k;o+=B){const i=Math.min(o+B,k);for(let c=n;c<a;c++)for(let n=r;n<s;n++){let a=0;for(let r=o;r<i;r++){a+=T[e*A+c*_+r*D]*E[r*F+n*O+t*M]}P[W*L+(c*I+n)]+=a}}}}}return n.disposeIntermediateTensorInfo(x),n.disposeIntermediateTensorInfo(w),n.makeTensorInfo(b,z.dtype,z.values)}const zw={kernelName:et,backendName:"cpu",kernelFunc:Lw};const Pw={kernelName:ja,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=a;let d,p,f;const m=[];d=Lw({inputs:{a:r,b:s},attrs:{transposeA:c,transposeB:l},backend:n}),o&&(p=Dw({inputs:{a:d,b:o},backend:n}),m.push(d),d=p),u&&(f=vw(n,d,u,i,h),m.push(d),d=f);for(const g of m)n.disposeIntermediateTensorInfo(g);return d}};function Bw(e){const t=new Float32Array(e.length);for(let n=0;n<e.length;++n)t[n]=Math.abs(e[n]);return t}const Ww={kernelName:Le,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend;Qx(t,"abs");let a=new Float32Array(ee(t.shape));return a=Bw(n.data.get(t.dataId).values),n.makeOutput(a,t.shape,t.dtype)}},Vw=ew(ze,(e=>Math.acos(e))),Uw={kernelName:ze,backendName:"cpu",kernelFunc:Vw},Gw=ew(Pe,(e=>Math.acosh(e))),Hw={kernelName:Pe,backendName:"cpu",kernelFunc:Gw};const jw={kernelName:We,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,a=t;Qx(t,"addN");const r=a.map((e=>n.data.get(e.dataId).values)),s=go(a[0].shape,a[0].dtype),o=s.values;for(let i=0;i<a.length;i++){const e=r[i];for(let t=0;t<o.length;t++)o[t]+=e[t]}return n.makeTensorInfo(s.shape,s.dtype,s.values)}};function Kw(e,t,n,a,r){const s=t.length,o=ee(t),i=be(t),c=be(r),l=le(n,ee(r));for(let u=0;u<o;++u){const t=Te(u,s,i),n=new Array(t.length);for(let e=0;e<n.length;e++)n[e]=t[a[e]];l[Ne(n,s,c)]=e[u]}return l}function qw(e){const{inputs:t,attrs:n,backend:a}=e,{x:r}=t,{perm:s}=n;Qx(r,"transpose");const o=r.shape.length,i=new Array(o);for(let l=0;l<i.length;l++)i[l]=r.shape[s[l]];const c=Kw(a.data.get(r.dataId).values,r.shape,r.dtype,s,i);return{dataId:a.write(c,i,r.dtype),shape:i,dtype:r.dtype}}const Xw={kernelName:za,backendName:"cpu",kernelFunc:qw};const Yw={kernelName:Ve,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;Qx(r,"all");const i=ie(s,r.shape);let c=i;const l=Dc(c,r.shape.length);let u=r;null!=l&&(u=qw({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Oc(c.length,r.shape.length)),_c("all",c,u.shape.length);const[h,d]=Rc(u.shape,c),p=ee(d),f=ke(ee(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t&&a}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(o){const e=Ow({inputs:{x:g},backend:n,attrs:{shape:Ac(h,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const Qw={kernelName:Ue,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;Qx(r,"any");const i=ie(s,r.shape);let c=i;const l=Dc(c,r.shape.length);let u=r;null!=l&&(u=qw({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Oc(c.length,r.shape.length)),_c("any",c,u.shape.length);const[h,d]=Rc(u.shape,c),p=ee(d),f=ke(ee(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];t=t||a}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(o){const e=Ow({inputs:{x:g},backend:n,attrs:{shape:Ac(h,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}};const Jw={kernelName:Ge,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;Qx(r,"argMax");let o=ie(s,r.shape);const i=Dc(o,r.shape.length);let c=r;const l=[];null!=i&&(c=qw({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),o=Oc(o.length,c.shape.length)),o=[o[0]],_c("argMax",o,c.shape.length);const[u,h]=Rc(c.shape,o),d=ke(ee(u),"int32"),p=ee(h),f=n.data.get(c.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r>t&&(t=r,n=a)}d[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",d)}};const Zw={kernelName:He,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;Qx(r,"argMin");let o=ie(s,r.shape);const i=Dc(o,r.shape.length);let c=r;const l=[];null!=i&&(c=qw({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),o=Oc(o.length,c.shape.length)),o=[o[0]],_c("argMin",o,c.shape.length);const[u,h]=Rc(c.shape,o),d=ke(ee(u),"int32"),p=ee(h),f=n.data.get(c.dataId).values;for(let m=0;m<d.length;++m){const e=m*p;let t=f[e],n=0;for(let a=0;a<p;++a){const r=f[e+a];r<t&&(t=r,n=a)}d[m]=n}return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(u,"int32",d)}},$w=ew(je,(e=>Math.asin(e))),ek={kernelName:je,backendName:"cpu",kernelFunc:$w},tk=ew(Ke,(e=>Math.asinh(e))),nk={kernelName:Ke,backendName:"cpu",kernelFunc:tk},ak=ew(qe,(e=>Math.atan(e))),rk={kernelName:qe,backendName:"cpu",kernelFunc:ak},sk=cw(((e,t)=>Math.atan2(e,t))),ok=Cw(Ye,sk),ik={kernelName:Ye,backendName:"cpu",kernelFunc:ok},ck=ew(Xe,(e=>Math.atanh(e))),lk={kernelName:Xe,backendName:"cpu",kernelFunc:ck};function uk(e,t,n,a,r,s){const o=r.strideHeight,i=r.strideWidth,c=r.dilationHeight,l=r.dilationWidth,u=r.effectiveFilterHeight,h=r.effectiveFilterWidth,d=r.padInfo.top,p=r.padInfo.left,f="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,m=go(r.outShape,n),g=m.values,y=r.outShape[1]*r.outShape[2]*r.outShape[3],b=r.outShape[2]*r.outShape[3],v=r.outShape[3];for(let x=0;x<r.batchSize;++x){const t=x*y,n=x*a[0];for(let m=0;m<r.inChannels;++m)for(let y=0;y<r.outHeight;++y){const x=y*o-d,w=Math.max(0,x),k=Math.min(r.inHeight,u+x),S=t+y*b;for(let t=0;t<r.outWidth;++t){const o=t*i-p,u=Math.max(0,o),d=Math.min(r.inWidth,h+o);let y=f,b=0,x=0;for(let t=w;t<k;t+=c){const r=n+t*a[1];for(let t=u;t<d;t+=l){const n=e[r+t*a[2]+m];"max"===s&&n>y?y=n:"avg"===s&&(b+=n,x++)}if(isNaN(y))break}g[S+t*v+m]="avg"===s?b/x:y}}}return m}function hk(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=go(a.outShape,"int32"),i=a.strideHeight,c=a.strideWidth,l=a.dilationHeight,u=a.dilationWidth,h=a.effectiveFilterHeight,d=a.effectiveFilterWidth,p=a.padInfo.top,f=a.padInfo.left,m=go(t,n,e);for(let g=0;g<a.batchSize;++g)for(let e=0;e<a.inChannels;++e)for(let t=0;t<a.outHeight;++t){const n=t*i-p;let y=n;for(;y<0;)y+=l;const b=Math.min(a.inHeight,h+n);for(let i=0;i<a.outWidth;++i){const h=i*c-f;let p=h;for(;p<0;)p+=u;const v=Math.min(a.inWidth,d+h);let x=Number.NEGATIVE_INFINITY,w=-1;for(let t=y;t<b;t+=l){const o=t-n;for(let n=p;n<v;n+=u){const i=n-h,c=m.get(g,t,n,e);c>x&&(x=c,w=r?s?((g*a.inHeight+t)*a.inWidth+n)*a.inChannels+e:(t*a.inWidth+n)*a.inChannels+e:o*d+i)}}o.set(w,g,t,i,e)}}return o}function dk(e,t,n,a,r,s){const o=r.strideDepth,i=r.strideHeight,c=r.strideWidth,l=r.dilationDepth,u=r.dilationHeight,h=r.dilationWidth,d=r.effectiveFilterDepth,p=r.effectiveFilterHeight,f=r.effectiveFilterWidth,m=r.padInfo.front,g=r.padInfo.top,y=r.padInfo.left,b="max"===s?Number.NEGATIVE_INFINITY:Number.POSITIVE_INFINITY,v=go(r.outShape,n),x=v.values,w=r.outShape[1]*r.outShape[2]*r.outShape[3]*r.outShape[4],k=r.outShape[2]*r.outShape[3]*r.outShape[4],S=r.outShape[3]*r.outShape[4],I=r.outShape[4];for(let N=0;N<r.batchSize;++N){const t=N*w,n=N*a[0];for(let v=0;v<r.inChannels;++v)for(let w=0;w<r.outDepth;++w){const N=w*o-m;let T=N;for(;T<0;)T+=l;const E=Math.min(r.inDepth,d+N),C=t+w*k;for(let t=0;t<r.outHeight;++t){const o=t*i-g;let d=o;for(;d<0;)d+=u;const m=Math.min(r.inHeight,p+o),w=C+t*S;for(let t=0;t<r.outWidth;++t){const o=t*c-y;let i=o;for(;i<0;)i+=h;const p=Math.min(r.inWidth,f+o),g=w+t*I;let k=b,S=0,N=0;for(let t=T;t<E;t+=l){const r=n+t*a[1];for(let t=d;t<m;t+=u){const n=r+t*a[2];for(let t=i;t<p;t+=h){const r=e[n+t*a[3]+v];if("max"===s&&r>k?k=r:"avg"===s&&(S+=r,N++),isNaN(k))break}if(isNaN(k))break}if(isNaN(k))break}x[g+v]="avg"===s?S/Math.max(N,1):k}}}}return v}const pk={kernelName:Qe,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;Qx(r,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:c}=a;J(zi(o,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const l=Ei(r.shape,s,o,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&te(l.inShape,l.outShape))u=rw({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=be(r.shape),a=uk(e,r.shape,r.dtype,t,l,"avg");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const fk={kernelName:Ze,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:c,dataFormat:l}=a;Qx(r,"avgPool3d");const u=Ci(r.shape,s,o,1,i,c,l),h=dk(n.data.get(r.dataId).values,r.shape,r.dtype,be(r.shape),u,"avg");return n.makeTensorInfo(h.shape,"float32",h.values)}};const mk={kernelName:$e,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:o,strides:i,pad:c,dimRoundingMode:l}=a;Qx([r,s],"avgPool3DGrad");const u=Ci(s.shape,o,i,1,c,l),h=u.strideDepth,d=u.strideHeight,p=u.strideWidth,f=u.filterDepth,m=u.filterHeight,g=u.filterWidth,y=u.dilationDepth,b=u.dilationHeight,v=u.dilationWidth,x=u.effectiveFilterDepth,w=u.effectiveFilterHeight,k=u.effectiveFilterWidth,S=x-1-u.padInfo.front,I=k-1-u.padInfo.left,N=w-1-u.padInfo.top,T=go(s.shape,"float32"),E=1/(f*m*g),C=n.bufferSync(r);for(let R=0;R<u.batchSize;++R)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-S,s=n-N,o=a-I;let i=0;for(let t=0;t<x;t+=y){const n=(r+t)/h;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let t=0;t<w;t+=b){const a=(s+t)/d;if(!(a<0||a>=u.outHeight||Math.floor(a)!==a))for(let t=0;t<k;t+=v){const r=(o+t)/p;if(r<0||r>=u.outWidth||Math.floor(r)!==r)continue;i+=C.get(R,n,a,r,e)}}}T.set(i*E,R,t,n,a,e)}return n.makeTensorInfo(T.shape,T.dtype,T.values)}};const gk={kernelName:Je,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s;Qx([r,s],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=Ei(o.shape,i,c,1,l),h=u.strideHeight,d=u.strideWidth,p=u.filterHeight,f=u.filterWidth,m=u.dilationHeight,g=u.dilationWidth,y=u.effectiveFilterHeight,b=u.effectiveFilterWidth,v=b-1-u.padInfo.left,x=y-1-u.padInfo.top,w=go(o.shape,"float32"),k=1/(p*f),S=n.data.get(r.dataId).values,I=go(r.shape,"float32",S);for(let N=0;N<u.batchSize;++N)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inHeight;++t)for(let n=0;n<u.inWidth;++n){const a=t-x,r=n-v;let s=0;for(let t=0;t<y;t+=m){const n=(a+t)/h;if(!(n<0||n>=u.outHeight||Math.floor(n)!==n))for(let t=0;t<b;t+=g){const a=(r+t)/d;if(a<0||a>=u.outWidth||Math.floor(a)!==a)continue;s+=I.get(N,n,a,e)}}w.set(s*k,N,t,n,e)}return n.makeTensorInfo(w.shape,w.dtype,w.values)}};const yk={kernelName:Kt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,scale:s,offset:o,mean:i,variance:c}=t;J(i.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),J(null==o||i.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),J(null==s||i.shape.length===s.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks.")),Qx([r,i,c,s,o],"batchNorm");let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=n.data.get(r.dataId).values,h=n.data.get(i.dataId).values,d=n.data.get(c.dataId).values,p=s?n.data.get(s.dataId).values:new Float32Array([1]),f=o?n.data.get(o.dataId).values:new Float32Array([0]),m=new Float32Array(u.length),g=f.length,y=p.length,b=d.length,v=h.length;let x=0,w=0,k=0,S=0;for(let I=0;I<u.length;++I)m[I]=f[x++]+(u[I]-h[w++])*p[k++]/Math.sqrt(d[S++]+l),x>=g&&(x=0),w>=v&&(w=0),k>=y&&(k=0),S>=b&&(S=0);return n.makeTensorInfo(r.shape,r.dtype,m)}};function bk(e,t,n,a,r){const s=bi(a,t,n),o=ee(n),i=be(a);if(s){const n=vi(t,i);return"string"===r?e.slice(n,n+o):e.subarray(n,n+o)}const c=go(a,r,"string"===r?Wh(e):e),l=go(n,r);for(let u=0;u<l.size;++u){const e=l.indexToLoc(u),n=e.map(((e,n)=>e+t[n]));l.set(c.get(...n),...e)}return"string"===r?Vh(l.values):l.values}function vk(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:o}=a;Qx(r,"slice");const[i,c]=xi(r,s,o);oi(r,i,c);const l=bk(n.data.get(r.dataId).values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,l)}const xk={kernelName:ca,backendName:"cpu",kernelFunc:vk};const wk={kernelName:tt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:o}=a;Qx([r],"batchToSpaceND");const i=s.reduce(((e,t)=>e*t)),c=Gu(r.shape,s,i),l=Hu(c.length,s.length),u=ju(r.shape,s,i),h=Ku(o,s.length),d=qu(u,o,s.length),p=Ow({inputs:{x:r},backend:n,attrs:{shape:c}}),f=qw({inputs:{x:p},backend:n,attrs:{perm:l}}),m=Ow({inputs:{x:f},backend:n,attrs:{shape:u}}),g=vk({inputs:{x:m},backend:n,attrs:{begin:h,size:d}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}};function kk(e,t,n,a,r){const s=ee(a),o=ke(r,n);for(let i=0;i<e.length;i++){const n=e[i];if(n<0)throw new Error("Input x must be non-negative!");n>=r||(o[n]+=s>0?t[i]:1)}return o}function Sk(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e.shape[0],s=e.shape[1],o=go([r,n],t.dtype);for(let i=0;i<r;i++)for(let r=0;r<s;r++){const s=e.get(i,r);if(s<0)throw new Error("Input x must be non-negative!");s>=n||(a?o.set(1,i,s):t.size>0?o.set(o.get(i,s)+t.get(i,r),i,s):o.set(o.get(i,s)+1,i,s))}return o}const Ik={kernelName:nt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o}=a,i=kk(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,i)}},Nk=cw(((e,t)=>e&t)),Tk={kernelName:at,backendName:"cpu",kernelFunc:Cw(at,Nk)};const Ek={kernelName:rt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.data.get(a.dataId).values,o=n.data.get(r.dataId).values,i=Go(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},Ck=$x((e=>Math.ceil(e))),Rk=tw(ot,Ck),Ak={kernelName:ot,backendName:"cpu",kernelFunc:Rk},_k=ew(it,((e,t)=>{const n=t;return e>n.clipValueMax?n.clipValueMax:e<n.clipValueMin?n.clipValueMin:e})),Dk={kernelName:it,backendName:"cpu",kernelFunc:_k},Fk={kernelName:lt,backendName:"cpu",kernelFunc:e=>{const{x:t}=e.inputs,n=e.backend,a=new Float32Array(ee(t.shape)),r=n.data.get(t.dataId),s=r.complexTensorInfos.real,o=r.complexTensorInfos.imag,i=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values;for(let l=0;l<i.length;l++){const e=i[l],t=c[l];a[l]=Math.hypot(e,t)}return n.makeOutput(a,t.shape,"float32")}};function Ok(e,t,n,a){const r=ue(n,ee(t));if(a&&"string"!==n){let t=0;e.forEach((e=>{const n=ee(e.shape);r.set(e.vals,t),t+=n}))}else{let a=0;e.forEach((e=>{const s="string"===n?Wh(e.vals):e.vals;let o=0;for(let n=0;n<e.shape[0];++n){const i=n*t[1]+a;for(let t=0;t<e.shape[1];++t)r[i+t]=s[o++]}a+=e.shape[1]}))}return r}function Mk(e){const{inputs:t,backend:n}=e,{input:a}=t,r=n.data.get(a.dataId).complexTensorInfos.imag,s=n.data.get(r.dataId).values;return n.makeTensorInfo(r.shape,r.dtype,s)}const Lk={kernelName:$t,backendName:"cpu",kernelFunc:Mk};function zk(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=ie(r,t[0].shape)[0];Fu(t.map((e=>e.shape)),s);let o=Ou(t.map((e=>e.shape)),s);if(0===ee(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>ee(e.shape)>0));if(1===i.length)return rw({inputs:{x:i[0]},backend:n});if("complex64"===i[0].dtype){const e=i.map((e=>Sw({inputs:{input:e},backend:n}))),t=i.map((e=>Mk({inputs:{input:e},backend:n}))),a=zk({inputs:e,backend:n,attrs:{axis:s}}),r=zk({inputs:t,backend:n,attrs:{axis:s}}),o=xw({inputs:{real:a,imag:r},backend:n});return e.forEach((e=>n.disposeIntermediateTensorInfo(e))),t.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r),o}const c=i.map((e=>{const t=ee(e.shape.slice(s));return Ow({inputs:{x:e},backend:n,attrs:{shape:[-1,t]}})})),l=c.map((e=>({vals:n.data.get(e.dataId).values,shape:e.shape})));o=Ou(c.map((e=>e.shape)),1);const u=1===c[0].shape[0],h=Ok(l,o,t[0].dtype,u),d=Ou(i.map((e=>e.shape)),s),p=n.makeTensorInfo(d,t[0].dtype,h);return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}const Pk={kernelName:ut,backendName:"cpu",kernelFunc:zk};function Bk(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a;Qx([r,s],"conv2d");const h=Bi(c),d=Ri(r.shape,s.shape,o,l,i,u,!1,h),p=d.filterHeight,f=d.filterWidth,m=d.dilationHeight,g=d.dilationWidth,y=d.padInfo.left,b=d.padInfo.top,v="channelsLast"===d.dataFormat,x=new Pr(d.outShape,r.dtype),w=be(r.shape),k=be(s.shape),S=w[0],I=v?w[1]:w[2],N=v?w[2]:1,T=v?1:w[1],E=x.strides[0],C=v?x.strides[1]:x.strides[2],R=v?x.strides[2]:1,A=v?1:x.strides[1],_=n.data.get(r.dataId).values,D=n.data.get(s.dataId).values,F=x.values;for(let O=0;O<d.batchSize;++O){const e=O*S,t=O*E;for(let n=0;n<d.outHeight;++n){const a=t+n*C,r=n*d.strideHeight-b;for(let t=0;t<p;++t){const n=r+t*m;if(n<0||n>=d.inHeight)continue;const s=t*k[0],o=e+n*I;for(let e=0;e<d.outWidth;++e){const t=a+e*R,n=e*d.strideWidth-y;for(let e=0;e<f;++e){const a=n+e*g;if(a<0||a>=d.inWidth)continue;const r=o+a*N;let i=s+e*k[1];for(let e=0;e<d.inChannels;++e){const n=_[r+e*T];for(let e=0;e<d.outChannels;++e)F[t+e*A]+=n*D[i+e];i+=d.outChannels}}}}}}return n.makeTensorInfo(x.shape,x.dtype,F)}const Wk={kernelName:ht,backendName:"cpu",kernelFunc:Bk};const Vk={kernelName:dt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a;Qx([r,s],"conv2dBackpropFilter");const h=Bi(c),d=Ri(r.shape,u,o,1,i,l,!1,h),{strideHeight:p,strideWidth:f,filterHeight:m,filterWidth:g}=d,y="channelsLast"===d.dataFormat,b=new Pr(d.filterShape,"float32"),v=d.padInfo.left,x=d.padInfo.top,w=n.data.get(r.dataId).values,k=n.data.get(s.dataId).values,S=new Pr(r.shape,r.dtype,w),I=new Pr(s.shape,s.dtype,k);for(let N=0;N<m;++N){const e=Math.max(0,Math.ceil((x-N)/p)),t=Math.min(d.outHeight,(d.inHeight+x-N)/p);for(let n=0;n<g;++n){const a=Math.max(0,Math.ceil((v-n)/f)),r=Math.min(d.outWidth,(d.inWidth+v-n)/f);for(let s=0;s<d.inChannels;++s)for(let o=0;o<d.outChannels;++o){let i=0;for(let c=0;c<d.batchSize;++c)for(let l=e;l<t;++l){const e=N+l*p-x;for(let t=a;t<r;++t){const a=n+t*f-v;i+=y?S.get(c,e,a,s)*I.get(c,l,t,o):S.get(c,s,e,a)*I.get(c,o,l,t)}}b.set(i,N,n,s,o)}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const Uk={kernelName:pt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:o,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a;Qx([r,s],"conv2dBackpropInput");const h=be(s.shape),d=be(r.shape);let p=Bi(l);const f=Ri(o,s.shape,i,1,c,u,!1,p),m=new Pr(f.inShape,"float32"),g=m.values,y=n.data.get(r.dataId).values,b=n.data.get(s.dataId).values,[v,x,w]=h,{batchSize:k,filterHeight:S,filterWidth:I,inChannels:N,inHeight:T,inWidth:E,outChannels:C,outHeight:R,outWidth:A,strideHeight:_,strideWidth:D}=f;p=f.dataFormat;const F=S-1-f.padInfo.top,O=I-1-f.padInfo.left,M="channelsLast"===p,L=m.strides[0],z=M?m.strides[1]:m.strides[2],P=M?m.strides[2]:1,B=M?1:m.strides[1],W=d[0],V=M?d[1]:d[2],U=M?d[2]:1,G=M?1:d[1];for(let H=0;H<k;++H)for(let e=0;e<N;++e)for(let t=0;t<T;++t){const n=t-F,a=Math.max(0,Math.ceil(n/_)),r=Math.min(R,(S+n)/_);for(let s=0;s<E;++s){const o=s-O,i=Math.max(0,Math.ceil(o/D)),c=Math.min(A,(I+o)/D);let l=0;for(let t=a;t<r;++t){const a=t*_-n;for(let n=i;n<c;++n){const r=W*H+V*t+U*n,s=v*(S-1-a)+x*(I-1-(n*D-o))+w*e;for(let e=0;e<C;++e){l+=y[r+G*e]*b[s+e]}}}g[L*H+z*t+P*s+B*e]=l}}return n.makeTensorInfo(m.shape,m.dtype,m.values)}};const Gk={kernelName:ft,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:c}=a;Qx([r,s],"conv3d");const l=Ai(r.shape,s.shape,o,c,i),{filterDepth:u,filterHeight:h,filterWidth:d,dilationDepth:p,dilationHeight:f,dilationWidth:m,padInfo:g}=l,y=g.front,b=g.left,v=g.top,x=new Pr(l.outShape,r.dtype),w=n.data.get(r.dataId).values,k=n.data.get(s.dataId).values,S=x.values,I=be(r.shape),N=be(s.shape);for(let T=0;T<l.batchSize;++T){const e=T*I[0],t=T*x.strides[0];for(let n=0;n<l.outDepth;++n){const a=t+n*x.strides[1],r=n*l.strideDepth-y;for(let t=0;t<u;++t){const n=r+t*p;if(n<0||n>=l.inDepth)continue;const s=t*N[0],o=e+n*I[1];for(let e=0;e<l.outHeight;++e){const t=a+e*x.strides[2],n=e*l.strideHeight-v;for(let e=0;e<h;++e){const a=n+e*f;if(a<0||a>=l.inHeight)continue;const r=s+e*N[1],i=o+a*I[2];for(let e=0;e<l.outWidth;++e){const n=t+e*l.outChannels,a=e*l.strideWidth-b;for(let e=0;e<d;++e){const t=a+e*m;if(t<0||t>=l.inWidth)continue;const s=r+e*N[2],o=i+t*l.inChannels;let c=s;for(let e=0;e<l.inChannels;++e){const t=w[o+e];for(let e=0;e<l.outChannels;++e)S[n+e]+=t*k[c+e];c+=l.outChannels}}}}}}}}return n.makeTensorInfo(x.shape,x.dtype,x.values)}};const Hk={kernelName:mt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,filterShape:c}=a;Qx([r,s],"conv3dBackpropFilterV2");const l=be(r.shape),u=be(s.shape),h=Ai(r.shape,c,o,1,i),d=h.strideDepth,p=h.strideHeight,f=h.strideWidth,m=h.filterDepth,g=h.filterHeight,y=h.filterWidth,b=new Pr(h.filterShape,"float32"),v=b.values,[x,w,k,S]=b.strides,I=n.data.get(s.dataId).values,[N,T,E,C]=u,R=n.data.get(r.dataId).values,[A,_,D,F]=l,O=h.padInfo.front,M=h.padInfo.left,L=h.padInfo.top;for(let z=0;z<m;++z){const e=Math.max(0,Math.ceil((O-z)/d)),t=Math.min(h.outDepth,(h.inDepth+O-z)/d),n=z*x;for(let a=0;a<g;++a){const r=Math.max(0,Math.ceil((L-a)/p)),s=Math.min(h.outHeight,(h.inHeight+L-a)/p),o=a*w+n;for(let n=0;n<y;++n){const i=Math.max(0,Math.ceil((M-n)/f)),c=Math.min(h.outWidth,(h.inWidth+M-n)/f),l=n*k+o;for(let o=0;o<h.inChannels;++o){const u=o*S+l;for(let l=0;l<h.outChannels;++l){let m=0;for(let u=0;u<h.batchSize;++u){const h=u*A,g=u*N;for(let u=e;u<t;++u){const e=(z+u*d-O)*_+h,t=u*T+g;for(let u=r;u<s;++u){const r=(a+u*p-L)*D+e,s=u*E+t;for(let e=i;e<c;++e){const t=e*C+s;m+=R[(n+e*f-M)*F+r+o]*I[t+l]}}}}v[u+l]=m}}}}}return n.makeTensorInfo(b.shape,b.dtype,b.values)}};const jk={kernelName:gt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:o,strides:i,inputShape:c}=a;Qx([r],"conv3dBackpropInputV2");const l=be(r.shape),u=be(s.shape),h=Ai(c,s.shape,i,1,o),d=new Pr(h.inShape,"float32"),p=d.values,[f,m,g,y]=d.strides,b=n.data.get(r.dataId).values,[v,x,w,k]=l,S=n.data.get(s.dataId).values,[I,N,T,E]=u,{batchSize:C,filterDepth:R,filterHeight:A,filterWidth:_,inChannels:D,inDepth:F,inHeight:O,inWidth:M,outChannels:L,outDepth:z,outHeight:P,outWidth:B,strideDepth:W,strideHeight:V,strideWidth:U}=h,G=R-1-h.padInfo.front,H=A-1-h.padInfo.top,j=_-1-h.padInfo.left;for(let K=0;K<C;++K)for(let e=0;e<D;++e)for(let t=0;t<F;++t){const n=t-G,a=Math.max(0,Math.ceil(n/W)),r=Math.min(z,(R+n)/W);for(let s=0;s<O;++s){const o=s-H,i=Math.max(0,Math.ceil(o/V)),c=Math.min(P,(A+o)/V);for(let l=0;l<M;++l){const u=l-j,h=Math.max(0,Math.ceil(u/U)),d=Math.min(B,(_+u)/U);let C=0;for(let t=a;t<r;++t){const a=t*W-n;for(let n=i;n<c;++n){const r=n*V-o;for(let s=h;s<d;++s){const o=v*K+x*t+w*n+k*s,i=I*(R-1-a)+N*(A-1-r)+T*(_-1-(s*U-u))+E*e;for(let e=0;e<L;++e){C+=b[o+e]*S[i+e]}}}}p[f*K+m*t+g*s+y*l+e]=C}}}return n.makeTensorInfo(d.shape,d.dtype,d.values)}},Kk=ew(yt,(e=>Math.cos(e))),qk={kernelName:yt,backendName:"cpu",kernelFunc:Kk},Xk=ew(bt,(e=>Math.cosh(e))),Yk={kernelName:bt,backendName:"cpu",kernelFunc:Xk};const Qk={kernelName:wt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:o}=t,{cropSize:i,method:c,extrapolationValue:l}=a,[u,h,d,p]=r.shape,f=s.shape[0],[m,g]=i,y=go([f,m,g,p],"float32"),b=n.data.get(s.dataId).values,v=n.data.get(o.dataId).values,x=n.data.get(r.dataId).values,w=be(r.shape),k=be(y.shape);for(let S=0;S<f;S++){const e=4*S,t=b[e],n=b[e+1],a=b[e+2],r=b[e+3],s=v[S];if(s>=u)continue;const o=m>1?(a-t)*(h-1)/(m-1):0,i=g>1?(r-n)*(d-1)/(g-1):0;for(let u=0;u<m;u++){const e=m>1?t*(h-1)+u*o:.5*(t+a)*(h-1);if(e<0||e>h-1)for(let t=0;t<g;t++)for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];y.values[n]=l}else if("bilinear"===c){const t=Math.floor(e),a=Math.ceil(e),o=e-t;for(let e=0;e<g;e++){const c=g>1?n*(d-1)+e*i:.5*(n+r)*(d-1);if(c<0||c>d-1){for(let t=0;t<p;t++){const n=t+e*k[2]+u*k[1]+S*k[0];y.values[n]=l}continue}const h=Math.floor(c),f=Math.ceil(c),m=c-h;for(let n=0;n<p;n++){let r=n+h*w[2]+t*w[1]+s*w[0];const i=x[r];r=n+f*w[2]+t*w[1]+s*w[0];const c=x[r];r=n+h*w[2]+a*w[1]+s*w[0];const l=x[r];r=n+f*w[2]+a*w[1]+s*w[0];const d=i+(c-i)*m,p=l+(x[r]-l)*m;r=n+e*k[2]+u*k[1]+S*k[0],y.values[r]=d+(p-d)*o}}}else for(let t=0;t<g;++t){const a=g>1?n*(d-1)+t*i:.5*(n+r)*(d-1);if(a<0||a>d-1){for(let e=0;e<p;e++){const n=e+t*k[2]+u*k[1]+S*k[0];y.values[n]=l}continue}const o=Math.round(a),c=Math.round(e);for(let e=0;e<p;e++){const n=e+o*w[2]+c*w[1]+s*w[0],a=e+t*k[2]+u*k[1]+S*k[0];y.values[a]=x[n]}}}}return n.makeTensorInfo(y.shape,y.dtype,y.values)}};const Jk={kernelName:vt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a;Qx(r,"cumprod");const c=Dc([s],r.shape.length);let l=r;null!=c&&(l=qw({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=Oc(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumprod in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const h=Jr(l.dtype,"int32"),d=we(ee(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=o?1:p[t];else{const n=m(y,e-1);d[t]=o?p[n]*d[n]:p[t]*d[n]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=c){const e=qw({inputs:{x:g},backend:n,attrs:{perm:Fc(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const Zk={kernelName:xt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a;Qx(r,"cumsum");const c=Dc([s],r.shape.length);let l=r;null!=c&&(l=qw({inputs:{x:r},backend:n,attrs:{perm:c}}));const u=Oc(1,r.shape.length)[0];if(u!==l.shape.length-1)throw new Error("backend.cumsum in CPU expects an inner-most "+"axis=".concat(l.shape.length-1," but got axis=").concat(u));const h=Jr(l.dtype,"int32"),d=ke(ee(l.shape),h),p=n.data.get(l.dataId).values,f=l.shape[l.shape.length-1],m=i?(e,t)=>e+f-t-1:(e,t)=>e+t;for(let y=0;y<p.length;y+=f)for(let e=0;e<f;e++){const t=m(y,e);if(0===e)d[t]=o?0:p[t];else{const n=m(y,e-1);d[t]=o?p[n]+d[n]:p[t]+d[n]}}const g=n.makeTensorInfo(l.shape,h,d);if(null!=c){const e=qw({inputs:{x:g},backend:n,attrs:{perm:Fc(c)}});return n.disposeIntermediateTensorInfo(g),n.disposeIntermediateTensorInfo(l),e}return g}};const $k={kernelName:kt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o,binaryOutput:i}=a;if(1===r.shape.length){const e=kk(n.data.get(r.dataId).values,n.data.get(s.dataId).values,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,e)}if(2===r.shape.length){const e=Sk(n.bufferSync(r),n.bufferSync(s),o,i);return n.makeTensorInfo(e.shape,s.dtype,e.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};const eS={kernelName:St,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:o}=a;J("NHWC"===o,(()=>"Only NHWC dataFormat supported on CPU for depthToSpace. Got ".concat(o)));const i=r.shape[0],c=r.shape[1],l=r.shape[2],u=r.shape[3],h=c*s,d=l*s,p=u/(s*s),f=n.data.get(r.dataId).values,m=new Float32Array(i*h*d*p);let g=0;for(let y=0;y<i;++y)for(let e=0;e<h;++e){const t=Math.floor(e/s),n=e%s;for(let e=0;e<d;++e){const a=Math.floor(e/s),r=(n*s+e%s)*p;for(let e=0;e<p;++e){const n=e+r+u*(a+l*(t+c*y));m[g++]=f[n]}}}return n.makeTensorInfo([i,h,d,p],r.dtype,m)}};function tS(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:c,dimRoundingMode:l}=a;Qx([r,s],"depthwiseConv2DNative");const u=be(r.shape),h=be(s.shape);let d=c;null==d&&(d=[1,1]),J(zi(o,d),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(d,"'")));const p=Ri(r.shape,s.shape,o,d,i,l,!0),{filterHeight:f,filterWidth:m,dilationHeight:g,dilationWidth:y,padInfo:b}=p,v=b.left,x=b.top,w=p.outChannels/p.inChannels,k=new Pr(p.outShape,r.dtype),S=n.data.get(r.dataId).values,I=n.data.get(s.dataId).values,N=k.values;for(let T=0;T<p.batchSize;++T){const e=T*u[0],t=T*k.strides[0];for(let n=0;n<p.outHeight;++n){const a=t+n*k.strides[1],r=n*p.strideHeight-x;for(let t=0;t<f;++t){const n=r+t*g;if(n<0||n>=p.inHeight)continue;const s=t*h[0],o=e+n*u[1];for(let e=0;e<p.outWidth;++e){const t=a+e*k.strides[2],n=e*p.strideWidth-v;for(let e=0;e<m;++e){const a=n+e*y;if(a<0||a>=p.inWidth)continue;const r=s+e*h[1],i=o+a*p.inChannels;let c=t,l=r;for(let e=0;e<p.inChannels;++e){const t=S[i+e];for(let e=0;e<w;++e)N[c+e]+=t*I[l+e];c+=w,l+=w}}}}}}return n.makeTensorInfo(k.shape,k.dtype,k.values)}const nS={kernelName:It,backendName:"cpu",kernelFunc:tS};const aS={kernelName:Nt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a;Qx([r,s],"depthwiseConv2dNativeBackpropFilter");const h=Ri(r.shape,u,o,i,c,l,!0),{strideHeight:d,strideWidth:p,filterHeight:f,filterWidth:m}=h,g=new Pr(h.filterShape,"float32"),y=h.padInfo.left,b=h.padInfo.top,v=h.outChannels/h.inChannels,x=n.data.get(r.dataId).values,w=new Pr(r.shape,r.dtype,x),k=n.data.get(s.dataId).values,S=new Pr(s.shape,s.dtype,k);for(let I=0;I<f;++I){const e=Math.max(0,Math.ceil((b-I)/d)),t=Math.min(h.outHeight,(h.inHeight+b-I)/d);for(let n=0;n<m;++n){const a=Math.max(0,Math.ceil((y-n)/p)),r=Math.min(h.outWidth,(h.inWidth+y-n)/p);for(let s=0;s<h.outChannels;++s){const o=Math.trunc(s/v),i=s%v;let c=0;for(let l=0;l<h.batchSize;++l)for(let i=e;i<t;++i){const e=I+i*d-b;for(let t=a;t<r;++t){const a=n+t*p-y;c+=w.get(l,e,a,o)*S.get(l,i,t,s)}}g.set(c,I,n,o,i)}}}return n.makeTensorInfo(g.shape,g.dtype,g.values)}};const rS={kernelName:Tt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:o,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a;Qx([r,s],"depthwiseConv2DNativeBackpropInput");const h=be(r.shape),d=be(s.shape),p=Ri(u,s.shape,o,i,c,l,!0),f=new Pr(p.inShape,"float32"),m=f.values,[g,y,b]=f.strides,v=n.data.get(r.dataId).values,[x,w,k]=h,S=n.data.get(s.dataId).values,[I,N,T]=d,{batchSize:E,filterHeight:C,filterWidth:R,inChannels:A,inHeight:_,inWidth:D,outChannels:F,outHeight:O,outWidth:M,strideHeight:L,strideWidth:z}=p,P=C-1-p.padInfo.top,B=R-1-p.padInfo.left,W=F/A;for(let V=0;V<E;++V)for(let e=0;e<A;++e)for(let t=0;t<_;++t){const n=t-P,a=Math.max(0,Math.ceil(n/L)),r=Math.min(O,(C+n)/L);for(let s=0;s<D;++s){const o=s-B,i=Math.max(0,Math.ceil(o/z)),c=Math.min(M,(R+o)/z);let l=0;for(let t=a;t<r;++t){const a=t*L-n;for(let n=i;n<c;++n){const r=x*V+w*t+k*n,s=I*(C-1-a)+N*(R-1-(n*z-o))+T*e;for(let t=0;t<W;++t){l+=v[r+(e*W+t)]*S[s+t]}}}m[g*V+y*t+b*s+e]=l}}return n.makeTensorInfo(f.shape,f.dtype,f.values)}};const sS={kernelName:Et,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=ee(a.shape),s=n.data.get(a.dataId).values,o=go([r,r],a.dtype),i=o.values;for(let l=0;l<s.length;l++)i[l*r+l]=s[l];const c=[...a.shape,...a.shape];return n.makeTensorInfo(c,o.dtype,o.values)}},oS={kernelName:Ct,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:s}=t,{strides:o,pad:i,dilations:c}=a,l=n,u=l.data.get(r.dataId).values,h=r.shape.length,d=l.data.get(s.dataId).values,p=s.shape.length,{batchSize:f,inHeight:m,inWidth:g,inChannels:y,outHeight:b,outWidth:v,padInfo:x,strideHeight:w,strideWidth:k,filterHeight:S,filterWidth:I,dilationHeight:N,dilationWidth:T,outShape:E}=Ti(r.shape,s.shape,o,i,"NHWC",c),C=ee(E),R=E.length,A=ue(r.dtype,C);for(let _=0;_<f;++_)for(let e=0;e<b;++e){const t=e*w-x.top;for(let n=0;n<v;++n){const a=n*k-x.left;for(let o=0;o<y;++o){let i=Number.MIN_SAFE_INTEGER;for(let e=0;e<S;++e){const n=t+e*N;if(n>=0&&n<m)for(let t=0;t<I;++t){const c=a+t*T;if(c>=0&&c<g){const a=Ne([_,n,c,o],h,be(r.shape)),l=Ne([e,t,o],p,be(s.shape)),f=u[a]+d[l];f>i&&(i=f)}}}A[Ne([_,e,n,o],R,be(E))]=i}}}return{dataId:l.write(wr(A,r.dtype),E,r.dtype),shape:E,dtype:r.dtype}}},iS={kernelName:At,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:s,dy:o}=t,{strides:i,pad:c,dilations:l}=a,u=n,h=xe(r.shape,u.data.get(r.dataId).values),d=xe(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:T}=Ti(r.shape,s.shape,i,c,"NHWC",l);J(o.rank===T.length,(()=>"Error in ".concat(At,", dy ")+"must have the same rank as output ".concat(T.length,", but got ")+"".concat(o.rank)));const E=xe(T,u.data.get(o.dataId).values),C=Se(s.shape,s.dtype);for(let R=0;R<p;++R)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const a=n*w-v.left;for(let r=0;r<g;++r){let s=Number.MIN_SAFE_INTEGER,o=0,i=0;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const c=a+t*N;if(c>=0&&c<m){const a=h[R][n][c][r]+d[e][t][r];a>s&&(s=a,o=e,i=t)}}}C[o][i][r]+=E[R][e][n][r]}}}return{dataId:u.write(wr(C,r.dtype),s.shape,s.dtype),shape:s.shape,dtype:s.dtype}}},cS={kernelName:Rt,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,filter:s,dy:o}=t,{strides:i,pad:c,dilations:l}=a,u=n,h=xe(r.shape,u.data.get(r.dataId).values),d=xe(s.shape,u.data.get(s.dataId).values),{batchSize:p,inHeight:f,inWidth:m,inChannels:g,outHeight:y,outWidth:b,padInfo:v,strideHeight:x,strideWidth:w,filterHeight:k,filterWidth:S,dilationHeight:I,dilationWidth:N,outShape:T}=Ti(r.shape,s.shape,i,c,"NHWC",l);J(o.rank===T.length,(()=>"Error in ".concat(Rt,", dy ")+"must have the same rank as output ".concat(T.length,", but got ")+"".concat(o.rank)));const E=xe(T,u.data.get(o.dataId).values),C=Se(r.shape,r.dtype);for(let R=0;R<p;++R)for(let e=0;e<y;++e){const t=e*x-v.top;for(let n=0;n<b;++n){const a=n*w-v.left;for(let r=0;r<g;++r){let s=Number.MIN_SAFE_INTEGER,o=t<0?0:t,i=a<0?0:a;for(let e=0;e<k;++e){const n=t+e*I;if(n>=0&&n<f)for(let t=0;t<S;++t){const c=a+t*N;if(c>=0&&c<m){const a=h[R][n][c][r]+d[e][t][r];a>s&&(s=a,o=n,i=c)}}}C[R][o][i][r]+=E[R][e][n][r]}}}return{dataId:u.write(wr(C,r.dtype),r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}};const lS={kernelName:_t,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r}=t,{canvas:s,options:o}=a,{contextOptions:i,imageOptions:c}=o||{},l=(null===c||void 0===c?void 0:c.alpha)||1,u=(null===i||void 0===i?void 0:i.contextType)||"2d";if("2d"!==u)throw new Error("Context type ".concat(i.contextType," is not supported by the CPU backend."));const h=s.getContext(u,(null===i||void 0===i?void 0:i.contextAttributes)||{});if(null==h)throw new Error("Could not get the context with ".concat(u," type."));const[d,p]=r.shape.slice(0,2),f=2===r.shape.length?1:r.shape[2],m=n.data.get(r.dataId).values,g="float32"===r.dtype?255:1,y=new Uint8ClampedArray(p*d*4);for(let v=0;v<d*p;++v){const e=[0,0,0,255*l];for(let n=0;n<f;n++){const t=m[v*f+n];if("float32"===r.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===r.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===f?(e[0]=t*g,e[1]=t*g,e[2]=t*g):e[n]=t*g}const t=4*v;y[t+0]=Math.round(e[0]),y[t+1]=Math.round(e[1]),y[t+2]=Math.round(e[2]),y[t+3]=Math.round(e[3])}s.width=p,s.height=d;const b=new ImageData(y,p,d);return h.putImageData(b,0,0),r}},uS=cw(((e,t)=>e*t)),hS=Rw(((e,t,n,a)=>({real:e*n-t*a,imag:e*a+t*n}))),dS=Cw(Cn,uS,hS),pS={kernelName:Cn,backendName:"cpu",kernelFunc:dS};function fS(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;let i;Qx(r,"sum"),i="bool"===r.dtype?Tw({inputs:{x:r},backend:n,attrs:{dtype:"int32"}}):rw({inputs:{x:r},backend:n});const c=i.shape.length,l=ie(s,i.shape),u=Dc(l,c);let h=l,d=i;null!=u&&(d=qw({inputs:{x:i},backend:n,attrs:{perm:u}}),h=Oc(h.length,c)),_c("sum",h,d.shape.length);const[p,f]=Rc(d.shape,h);let m=kw(n,p,Jr(d.dtype,"int32"));const g=ee(f),y=n.data.get(m.dataId).values,b=n.data.get(d.dataId).values;for(let v=0;v<y.length;++v){const e=v*g;let t=0;for(let n=0;n<g;++n)t+=b[e+n];y[v]=t}if(o){const e=m;m=Ow({inputs:{x:m},backend:n,attrs:{shape:Ac(m.shape,l)}}),n.disposeIntermediateTensorInfo(e)}return n.disposeIntermediateTensorInfo(i),null!=u&&n.disposeIntermediateTensorInfo(d),m}const mS={kernelName:ma,backendName:"cpu",kernelFunc:fS};const gS={kernelName:Ft,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:o,summedDims:i,idDims:c}=bh(r,s.length);xh(o.length,c,s);const{path:l,steps:u}=wh(i,c),h=u.length;let d=null,p=o.length;const f=[];for(let m=0;m<h;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=vh(p,c[e]);let r;kh(t)?r=s[e]:(r=qw({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(r));const o=r.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);te(r.shape,o)||(r=Ow({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===d?d=r:(d=dS({inputs:{a:r,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=fS({inputs:{x:d},backend:n,attrs:{axis:l[m]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}};const yS={kernelName:Mt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{dy:a,y:r}=t;Qx([a,r],"eluGrad");const s=new Float32Array(ee(r.shape)),o=n.data.get(r.dataId).values,i=n.data.get(a.dataId).values;for(let c=0;c<o.length;++c){const e=o[c];s[c]=e>=0?i[c]:i[c]*(e+1)}return n.makeTensorInfo(r.shape,"float32",s)}},bS=cw(((e,t)=>e===t?1:0)),vS=Cw(zt,bS,null,"bool"),xS={kernelName:zt,backendName:"cpu",kernelFunc:vS},wS=eh,kS=th,SS=nh,IS=ah,NS=rh,TS=sh,ES=ew(Lt,(e=>{const t=Math.sign(e),n=Math.abs(e),a=1/(1+wS*n);return t*(1-((((TS*a+NS)*a+IS)*a+SS)*a+kS)*a*Math.exp(-n*n))})),CS={kernelName:Lt,backendName:"cpu",kernelFunc:ES},RS=$x((e=>Math.exp(e))),AS=tw(Pt,RS,"float32"),_S={kernelName:Pt,backendName:"cpu",kernelFunc:AS};function DS(e){const{inputs:t,backend:n,attrs:a}=e,{input:r}=t,{dim:s}=a,o=r.shape.length,i=r.shape.slice();let c=s;return s<0&&(J(-(o+1)<=s,(()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]"))),c=o+s+1),i.splice(c,0,1),Ow({inputs:{x:r},backend:n,attrs:{shape:i}})}const FS={kernelName:Bt,backendName:"cpu",kernelFunc:DS},OS=$x((e=>Math.expm1(e))),MS=tw(Wt,OS),LS={kernelName:Wt,backendName:"cpu",kernelFunc:MS},zS=cw(((e,t)=>e/t)),PS=Cw(Dt,zS),BS={kernelName:Dt,backendName:"cpu",kernelFunc:PS},WS=cw(((e,t)=>e-t)),VS=Rw(((e,t,n,a)=>({real:e-n,imag:t-a}))),US=Cw(_a,WS,VS),GS={kernelName:_a,backendName:"cpu",kernelFunc:US};function HS(e,t,n){const a=e.shape,r=a[0],s=a[1],o=n.data.get(e.dataId),i=o.complexTensorInfos.real,c=o.complexTensorInfos.imag,l=[r,s],u=ee(l),h=le("float32",u),d=le("float32",u);for(let g=0;g<r;g++){const e=vk({inputs:{x:i},backend:n,attrs:{begin:[g,0],size:[1,s]}}),a=vk({inputs:{x:c},backend:n,attrs:{begin:[g,0],size:[1,s]}}),r=xw({inputs:{real:e,imag:a},backend:n}),{real:o,imag:l}=jS(r,t,n),u=oh(o,l);for(let t=0;t<s;t++){const e=uh(u,t);h[g*s+t]=e.real,d[g*s+t]=e.imag}n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(a),n.disposeIntermediateTensorInfo(r)}const p=n.makeTensorInfo(l,"float32",h),f=n.makeTensorInfo(l,"float32",d),m=xw({inputs:{real:p,imag:f},backend:n});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}function jS(e,t,n){const a=ee(e.shape),r=n.data.get(e.dataId),s=n.data.get(r.complexTensorInfos.real.dataId).values,o=n.data.get(r.complexTensorInfos.imag.dataId).values;if(0===((i=a)&i-1)){const r=KS(s,o,a,t,n),i=[e.shape[0],e.shape[1]];if(t){const e=n.makeTensorInfo(i,"float32",r.real),t=n.makeTensorInfo(i,"float32",r.imag),s=n.makeTensorInfo([],"float32",xr(a,"float32")),o=rw({inputs:{x:s},backend:n}),c=BS.kernelFunc({inputs:{a:e,b:s},backend:n}),l=BS.kernelFunc({inputs:{a:t,b:o},backend:n}),u=n.data.get(c.dataId).values,h=n.data.get(l.dataId).values;return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),{real:u,imag:h}}return r}{const e=function(e,t,n){const a=new Float32Array(2*t);for(let r=0;r<t;r++){let s=0,o=0;for(let a=0;a<t;a++){const i=ph(r*a,t,n),c=uh(e,a);s+=c.real*i.real-c.imag*i.imag,o+=c.real*i.imag+c.imag*i.real}n&&(s/=t,o/=t),hh(a,s,o,r)}return a}(oh(s,o),a,t);return ih(e)}var i}function KS(e,t,n,a,r){if(1===n)return{real:e,imag:t};const s=oh(e,t),o=n/2,i=ch(s),c=i.real,l=i.imag,u=[c.length],h=r.makeTensorInfo(u,"float32",c),d=r.makeTensorInfo(u,"float32",l),p=xw({inputs:{real:h,imag:d},backend:r}),f=lh(s),m=f.real,g=f.imag,y=[m.length],b=r.makeTensorInfo(y,"float32",m),v=r.makeTensorInfo(y,"float32",g),x=xw({inputs:{real:b,imag:v},backend:r}),w=KS(c,l,o,a,r),k=w.real,S=w.imag,I=[k.length],N=r.makeTensorInfo(I,"float32",k),T=r.makeTensorInfo(I,"float32",S),E=xw({inputs:{real:N,imag:T},backend:r}),C=KS(m,g,o,a,r),R=C.real,A=C.imag,_=[R.length],D=r.makeTensorInfo(_,"float32",R),F=r.makeTensorInfo(_,"float32",A),O=xw({inputs:{real:D,imag:F},backend:r}),M=dh(n,a),L=[M.real.length],z=r.makeTensorInfo(L,"float32",M.real),P=r.makeTensorInfo(L,"float32",M.imag),B=xw({inputs:{real:z,imag:P},backend:r}),W=dS({inputs:{a:B,b:O},backend:r}),V=Dw({inputs:{a:E,b:W},backend:r}),U=US({inputs:{a:E,b:W},backend:r}),G=Sw({inputs:{input:V},backend:r}),H=Sw({inputs:{input:U},backend:r}),j=Mk({inputs:{input:V},backend:r}),K=Mk({inputs:{input:U},backend:r}),q=zk({inputs:[G,H],backend:r,attrs:{axis:0}}),X=zk({inputs:[j,K],backend:r,attrs:{axis:0}}),Y=r.data.get(q.dataId).values,Q=r.data.get(X.dataId).values;return r.disposeIntermediateTensorInfo(h),r.disposeIntermediateTensorInfo(d),r.disposeIntermediateTensorInfo(p),r.disposeIntermediateTensorInfo(b),r.disposeIntermediateTensorInfo(v),r.disposeIntermediateTensorInfo(x),r.disposeIntermediateTensorInfo(N),r.disposeIntermediateTensorInfo(T),r.disposeIntermediateTensorInfo(E),r.disposeIntermediateTensorInfo(D),r.disposeIntermediateTensorInfo(F),r.disposeIntermediateTensorInfo(O),r.disposeIntermediateTensorInfo(z),r.disposeIntermediateTensorInfo(P),r.disposeIntermediateTensorInfo(B),r.disposeIntermediateTensorInfo(W),r.disposeIntermediateTensorInfo(V),r.disposeIntermediateTensorInfo(U),r.disposeIntermediateTensorInfo(G),r.disposeIntermediateTensorInfo(j),r.disposeIntermediateTensorInfo(H),r.disposeIntermediateTensorInfo(K),r.disposeIntermediateTensorInfo(q),r.disposeIntermediateTensorInfo(X),{real:Y,imag:Q}}const qS={kernelName:Vt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=ee(a.shape),s=a.shape[a.shape.length-1],o=Ow({inputs:{x:a},backend:n,attrs:{shape:[r/s,s]}}),i=HS(o,!1,n),c=Ow({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),c}};function XS(e){const{backend:t,attrs:n}=e,{shape:a,value:r,dtype:s}=n,o=s||me(r),i=ue(o,ee(a));return function(e,t,n){e.fill(t)}(i,r),t.makeTensorInfo(a,o,i)}const YS={kernelName:Ut,backendName:"cpu",kernelFunc:XS};const QS={kernelName:Gt,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,s=a,o=le(r.dtype,ee(r.shape)),[i,c,l,u]=r.shape,h=s.data.get(r.dataId).values;for(let d=0;d<i;d++){const e=d*l*c*u;for(let t=0;t<c;t++){const n=t*(l*u);for(let t=0;t<l;t++){const a=t*u;for(let r=0;r<u;r++){const s=Math.round(l-t-1),i=e+n+a+r;let c=h[i];if(s>=0&&s<l){c=h[e+n+s*u+r]}o[i]=c}}}}return{dataId:s.write(o,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},JS=$x((e=>Math.floor(e))),ZS=tw(Ht,JS),$S={kernelName:Ht,backendName:"cpu",kernelFunc:ZS},eI=cw(((e,t)=>Math.floor(e/t))),tI=Cw(jt,eI,null,"int32"),nI={kernelName:jt,backendName:"cpu",kernelFunc:tI};const aI={kernelName:Ka,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a;let m=Bk({inputs:{x:r,filter:s},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const e=m;if("NCHW"===u&&1===o.shape.length&&1!==o.shape[0]){const e=Ow({inputs:{x:o},backend:n,attrs:{shape:[o.shape[0],1,1]}});m=Dw({inputs:{a:m,b:e},backend:n}),n.disposeIntermediateTensorInfo(e)}else m=Dw({inputs:{a:m,b:o},backend:n});n.disposeIntermediateTensorInfo(e)}if(p){const e=m;if("NCHW"===u&&"prelu"===p&&1===i.shape.length&&1!==i.shape[0]){const e=Ow({inputs:{x:i},backend:n,attrs:{shape:[i.shape[0],1,1]}});m=vw(n,m,p,e,f),n.disposeIntermediateTensorInfo(e)}else m=vw(n,m,p,i,f);n.disposeIntermediateTensorInfo(e)}return m}};const rI={kernelName:qa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a;let m=tS({inputs:{x:r,filter:s},backend:n,attrs:{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d}});if(o){const e=m;m=Dw({inputs:{a:m,b:o},backend:n}),n.disposeIntermediateTensorInfo(e)}if(p){const e=m;m=vw(n,m,p,i,f),n.disposeIntermediateTensorInfo(e)}return m}};function sI(e,t,n,a,r,s,o,i,c){const l=go([a,s],n);for(let u=0;u<a;u++){const n=[];let a=0;for(let t=0;t<r;t++){const s=e[u*r+t];a+=s*o[t],n.push(s)}if(a<0||a>=c/s)throw new Error("Invalid indices: ".concat(n," does not index into ").concat(i));for(let e=0;e<s;e++)l.values[u*s+e]=t.get(...t.indexToLoc(a*s+e))}return l}const oI={kernelName:Xt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=ee(a.shape),o=r.shape,i=o[o.length-1],[c,l,u,h]=Xu(a,r);if(0===l)return n.makeTensorInfo(c,a.dtype,[]);const d=sI(n.data.get(r.dataId).values,n.bufferSync(a),a.dtype,l,i,u,h,a.shape,s);return n.makeTensorInfo(c,a.dtype,d.values)}};function iI(e,t,n){const a=go(n,e.dtype);for(let r=0;r<a.size;++r){const n=a.indexToLoc(r).slice(),s=n[0],o=n[2],i=t.locToIndex([s,o]);n[2]=t.values[i];const c=e.locToIndex(n);0<=c&&c<e.values.length&&(a.values[r]=e.values[c])}return a}const cI={kernelName:qt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:o,batchDims:i}=a;Qx([r,s],"gatherV2");const c=ie(o,r.shape)[0],l=n.data.get(s.dataId).values,u=r.shape[c];for(let v=0;v<l.length;++v){const e=l[v];J(e<=u-1&&e>=0,(()=>"GatherV2: the index value ".concat(e," is not in [0, ").concat(u-1,"]")))}let h=i;null==i&&(h=0);const d=ee(s.shape),p=Bh(r,s,c,h),f=Ow({inputs:{x:r},backend:n,attrs:{shape:[p.batchSize,p.outerSize,p.dimSize,p.sliceSize]}}),m=Ow({inputs:{x:s},backend:n,attrs:{shape:[p.batchSize,d/p.batchSize]}}),g=[p.batchSize,p.outerSize,d/p.batchSize,p.sliceSize],y=n.bufferSync(m),b=iI(n.bufferSync(f),y,g);return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.makeTensorInfo(p.outputShape,b.dtype,b.values)}},lI=cw(((e,t)=>e>t?1:0)),uI=Cw(Yt,lI,null,"bool"),hI={kernelName:Yt,backendName:"cpu",kernelFunc:uI},dI=cw(((e,t)=>e>=t?1:0)),pI=Cw(Qt,dI,null,"bool"),fI={kernelName:Qt,backendName:"cpu",kernelFunc:pI};const mI={kernelName:Zt,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t,r=ee(a.shape),s=a.shape[a.shape.length-1],o=Ow({inputs:{x:a},backend:n,attrs:{shape:[r/s,s]}}),i=HS(o,!0,n),c=Ow({inputs:{x:i},backend:n,attrs:{shape:a.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(i),c}},gI=ew(en,(e=>Number.isFinite(e)?1:0),"bool"),yI={kernelName:en,backendName:"cpu",kernelFunc:gI},bI=ew(tn,(e=>Math.abs(e)===1/0?1:0),"bool"),vI={kernelName:tn,backendName:"cpu",kernelFunc:bI},xI=ew(nn,(e=>Number.isNaN(e)?1:0),"bool"),wI={kernelName:nn,backendName:"cpu",kernelFunc:xI},kI=cw(((e,t)=>e<t?1:0)),SI=Cw(rn,kI,null,"bool"),II={kernelName:rn,backendName:"cpu",kernelFunc:SI},NI=cw(((e,t)=>e<=t?1:0)),TI=Cw(sn,NI,null,"bool"),EI={kernelName:sn,backendName:"cpu",kernelFunc:TI};function CI(e,t,n){const a=(t-e)/(n-1),r=ke(n,"float32");r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+a;return r}const RI={kernelName:on,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,o=CI(a,r,s);return t.makeTensorInfo([o.length],"float32",o)}},AI=$x((e=>Math.log(e))),_I=tw(cn,AI),DI={kernelName:cn,backendName:"cpu",kernelFunc:_I},FI=ew(ln,(e=>Math.log1p(e))),OI={kernelName:ln,backendName:"cpu",kernelFunc:FI},MI=cw(((e,t)=>e&&t)),LI=Cw(un,MI,null,"bool"),zI={kernelName:un,backendName:"cpu",kernelFunc:LI},PI=ew(hn,(e=>e?0:1),"bool"),BI={kernelName:hn,backendName:"cpu",kernelFunc:PI},WI=cw(((e,t)=>e||t)),VI=Cw(dn,WI,null,"bool"),UI={kernelName:dn,backendName:"cpu",kernelFunc:VI};const GI={kernelName:pn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:o,alpha:i,beta:c}=a;Qx(r,"LRN");const l=r.shape[3],u=l-1,h=n.data.get(r.dataId).values,d=ee(r.shape),p=new Float32Array(d);function f(e){const t=e%l;let n=e-t+Math.max(0,t-s);const a=e-t+Math.min(t+s,u);let r=0;for(;n<=a;n++){const e=h[n];r+=e*e}return r}for(let m=0;m<d;m++){const e=f(m),t=h[m]*Math.pow(o+i*e,-c);p[m]=t}return n.makeTensorInfo(r.shape,r.dtype,p)}};const HI={kernelName:fn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:o}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a;Qx(o,"LRNGrad");const h=ee(o.shape),d=o.shape[3],p=n.data.get(o.dataId).values,f=n.data.get(r.dataId).values,m=n.data.get(s.dataId).values,g=new Float32Array(h),y=h;for(let b=0;b<y;b++){const e=b%d,t=b-e+Math.max(0,e-i),n=b-e+Math.min(d,e+i+1);let a=0;for(let r=t;r<n;r++)a+=Math.pow(f[r],2);a=l*a+c;for(let r=t;r<n;r++){let e=-2*l*u*f[r]*m[b]/a;b===r&&(e+=Math.pow(a,-u)),e*=p[b],g[r]+=e}}return n.makeTensorInfo(o.shape,r.dtype,g)}};function jI(e,t,n,a){const r=le(a,ee(n));for(let s=0;s<r.length;++s){const n=s*t;let a=e[n];for(let r=0;r<t;++r){const t=e[n+r];(Number.isNaN(t)||t>a)&&(a=t)}r[s]=a}return r}function KI(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:o}=a,i=n;let c=r.shape;const l=c.length,u=ie(s,c);let h=u;const d=Dc(h,l);let p=i.data.get(r.dataId).values;if(null!=d){const e=new Array(l);for(let t=0;t<e.length;t++)e[t]=c[d[t]];p=Kw(p,c,r.dtype,d,e),h=Oc(h.length,l),c=e}Qx(r,"max"),_c("max",h,l);const[f,m]=Rc(c,h),g=jI(p,ee(m),f,r.dtype),y=i.write(g,f,r.dtype);let b=f;if(o){b=Ac(f,u)}return{dataId:y,shape:b,dtype:r.dtype}}const qI={kernelName:mn,backendName:"cpu",kernelFunc:KI},XI=cw(((e,t)=>Math.max(e,t))),YI=Cw(gn,XI),QI={kernelName:gn,backendName:"cpu",kernelFunc:YI};const JI={kernelName:yn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;Qx(r,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:c}=a;J(zi(o,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const l=Ei(r.shape,s,o,1,i,c);let u;if(1===l.filterWidth&&1===l.filterHeight&&te(l.inShape,l.outShape))u=rw({inputs:{x:r},backend:n});else{const e=n.data.get(r.dataId).values,t=be(r.shape),a=uk(e,r.shape,r.dtype,t,l,"max");u=n.makeTensorInfo(l.outShape,r.dtype,a.values)}return u}};const ZI={kernelName:vn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:c,dataFormat:l}=a;Qx(r,"maxPool3d");const u=Ci(r.shape,s,o,1,i,c,l),h=dk(n.data.get(r.dataId).values,r.shape,r.dtype,be(r.shape),u,"max");return n.makeTensorInfo(h.shape,"float32",h.values)}};const $I={kernelName:xn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,{filterSize:o,strides:i,pad:c,dimRoundingMode:l}=a;Qx([r,s],"maxPool3DGrad");const u=Ci(s.shape,o,i,1,c,l),h=function(e,t){const n=go(t.outShape,"int32"),a=t.strideDepth,r=t.strideHeight,s=t.strideWidth,o=t.dilationDepth,i=t.dilationHeight,c=t.dilationWidth,l=t.effectiveFilterDepth,u=t.effectiveFilterHeight,h=t.effectiveFilterWidth,d=t.padInfo.front,p=t.padInfo.top,f=t.padInfo.left;for(let m=0;m<t.batchSize;++m)for(let g=0;g<t.inChannels;++g)for(let y=0;y<t.outDepth;++y){const b=y*a-d;let v=b;for(;v<0;)v+=o;const x=Math.min(t.inDepth,l+b);for(let a=0;a<t.outHeight;++a){const l=a*r-p;let d=l;for(;d<0;)d+=i;const w=Math.min(t.inHeight,u+l);for(let r=0;r<t.outWidth;++r){const p=r*s-f;let k=p;for(;k<0;)k+=c;const S=Math.min(t.inWidth,h+p);let I=Number.NEGATIVE_INFINITY,N=-1;for(let t=v;t<x;t+=o){const n=t-b;for(let a=d;a<w;a+=i){const r=a-l;for(let s=k;s<S;s+=c){const o=s-p,i=e.get(m,t,a,s,g);i>=I&&(I=i,N=n*u*h+r*u+o)}}}n.set(N,m,y,a,r,g)}}}return n}(n.bufferSync(s),u),d=u.strideDepth,p=u.strideHeight,f=u.strideWidth,m=u.dilationDepth,g=u.dilationHeight,y=u.dilationWidth,b=u.effectiveFilterDepth,v=u.effectiveFilterHeight,x=u.effectiveFilterWidth,w=b-1-u.padInfo.front,k=x-1-u.padInfo.left,S=v-1-u.padInfo.top,I=go(s.shape,"float32"),N=n.bufferSync(r);for(let T=0;T<u.batchSize;++T)for(let e=0;e<u.inChannels;++e)for(let t=0;t<u.inDepth;++t)for(let n=0;n<u.inHeight;++n)for(let a=0;a<u.inWidth;++a){const r=t-w,s=n-S,o=a-k;let i=0;for(let t=0;t<b;t+=m){const n=(r+t)/d;if(!(n<0||n>=u.outDepth||Math.floor(n)!==n))for(let a=0;a<v;a+=g){const r=(s+a)/p;if(!(r<0||r>=u.outHeight||Math.floor(r)!==r))for(let s=0;s<x;s+=y){const c=(o+s)/f;if(c<0||c>=u.outWidth||Math.floor(c)!==c)continue;const l=b*v*x-1-h.get(T,n,r,c,e)===t*v*x+a*x+s?1:0;if(0===l)continue;i+=N.get(T,n,r,c,e)*l}}}I.set(i,T,t,n,a,e)}return n.makeTensorInfo(I.shape,I.dtype,I.values)}};const eN={kernelName:bn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:o}=t,i=s;Qx([s,o],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:h}=a,d=Ei(i.shape,c,l,1,u,h),p=n.data.get(i.dataId).values,f=go(d.outShape,i.dtype,hk(p,i.shape,i.dtype,d).values),m=d.strideHeight,g=d.strideWidth,y=d.dilationHeight,b=d.dilationWidth,v=d.effectiveFilterHeight,x=d.effectiveFilterWidth,w=x-1-d.padInfo.left,k=v-1-d.padInfo.top,S=go(i.shape,"float32"),I=n.data.get(r.dataId).values,N=go(r.shape,"float32",I);for(let T=0;T<d.batchSize;++T)for(let e=0;e<d.inChannels;++e)for(let t=0;t<d.inHeight;++t)for(let n=0;n<d.inWidth;++n){const a=t-k,r=n-w;let s=0;for(let t=0;t<v;t+=y){const n=(a+t)/m;if(!(n<0||n>=d.outHeight||Math.floor(n)!==n))for(let a=0;a<x;a+=b){const o=(r+a)/g;if(o<0||o>=d.outWidth||Math.floor(o)!==o)continue;const i=v*x-1-f.get(T,n,o,e)===t*x+a?1:0;if(0===i)continue;s+=N.get(T,n,o,e)*i}}S.set(s,T,t,n,e)}return n.makeTensorInfo(S.shape,S.dtype,S.values)}};const tN={kernelName:wn,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:c}=n,l=a;Qx(r,"MaxPoolWithArgmax");const u=l.data.get(r.dataId).values,h=Ei(r.shape,s,o,[1,1],i),[d,p]=function(e,t,n,a,r){const s=uk(e,0,n,be(t),r,"max"),o=hk(e,t,n,r,!0,a);return[s.values,o.values]}(u,r.shape,r.dtype,c,h),f=l.write(d,h.outShape,r.dtype),m=l.write(p,h.outShape,r.dtype);return[{dataId:f,shape:h.outShape,dtype:r.dtype},{dataId:m,shape:h.outShape,dtype:"int32"}]}};const nN={kernelName:kn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=ie(s,r.shape),c=ee(Rc(r.shape,i)[1]),l=[],u=n.makeTensorInfo([],"float32",new Float32Array([c]));l.push(u);const h=Tw({inputs:{x:r},backend:n,attrs:{dtype:"float32"}});l.push(h);const d=PS({inputs:{a:h,b:u},backend:n});l.push(d);const p=fS({inputs:{x:d},backend:n,attrs:{axis:s,keepDims:o}});return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),p}};const aN={kernelName:Sn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;Qx(r,"min");const i=ie(s,r.shape);let c=i;const l=Dc(c,r.shape.length);let u=r;null!=l&&(u=qw({inputs:{x:r},backend:n,attrs:{perm:l}}),c=Oc(c.length,r.shape.length)),_c("min",c,u.shape.length);const[h,d]=Rc(u.shape,c),p=ee(d),f=ke(ee(h),u.dtype),m=n.data.get(u.dataId).values;for(let y=0;y<f.length;++y){const e=y*p;let t=m[e];for(let n=0;n<p;++n){const a=m[e+n];(Number.isNaN(a)||a<t)&&(t=a)}f[y]=t}null!=l&&n.disposeIntermediateTensorInfo(u);const g=n.makeTensorInfo(h,u.dtype,f);if(o){const e=Ow({inputs:{x:g},backend:n,attrs:{shape:Ac(h,i)}});return n.disposeIntermediateTensorInfo(g),e}return g}},rN=cw(((e,t)=>Math.min(e,t))),sN=Cw(In,rN),oN={kernelName:In,backendName:"cpu",kernelFunc:sN};const iN={kernelName:Nn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,mode:o}=a;Qx(r,"mirrorPad");const i=s.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=s.map((e=>e[0])),l=s.map(((e,t)=>e[0]+r.shape[t])),u="reflect"===o?0:1,h=n.data.get(r.dataId).values,d=r.shape.length,p=be(r.shape),f=ee(i),m=i.length,g=be(i),y=le(r.dtype,f);for(let b=0;b<f;b++){let e=Te(b,m,g);for(let n=0;n<m;n++)e[n]<c[n]?e[n]=2*c[n]-e[n]-u:e[n]>=l[n]&&(e[n]=2*(l[n]-1)-e[n]+u);e=e.map(((e,t)=>e-c[t]));const t=Ne(e,d,p);y[b]=h[t]}return{dataId:n.write(y,i,r.dtype),shape:i,dtype:r.dtype}}},cN=cw(((e,t)=>{const n=e%t;return e<0&&t<0||e>=0&&t>=0?n:(n+t)%t})),lN=Cw(Tn,cN),uN={kernelName:Tn,backendName:"cpu",kernelFunc:lN};function hN(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,o=r.shape.length;let i=s;if(-1===i&&(i=o-1),i!==o-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(o," and dim was ").concat(i));const c=ie([i],r.shape),l=KI({inputs:{x:r},backend:n,attrs:{reductionIndices:c,keepDims:!1}}),u=Ac(l.shape,c),h=Ow({inputs:{x:l},backend:n,attrs:{shape:u}}),d=US({inputs:{a:r,b:h},backend:n}),p=AS({inputs:{x:d},backend:n}),f=fS({inputs:{x:p},backend:n,attrs:{axis:c,keepDims:!1}}),m=Ow({inputs:{x:f},backend:n,attrs:{shape:u}}),g=PS({inputs:{a:p,b:m},backend:n});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),g}const dN={kernelName:ba,backendName:"cpu",kernelFunc:hN};const pN={kernelName:En,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:o,normalized:i}=a;Qx(r,"multinomial");const c=i?r:hN({inputs:{logits:r},backend:n,attrs:{dim:-1}}),l=c.shape[0],u=c.shape[1],h=n.data.get(c.dataId).values,d=[l,s],p=ke(ee(d),"int32");for(let f=0;f<l;++f){const e=f*u,t=new Float32Array(u-1);t[0]=h[e];for(let r=1;r<t.length;++r)t[r]=t[r-1]+h[e+r];const n=Zc.alea(o.toString()),a=f*s;for(let r=0;r<s;++r){const e=n();p[a+r]=t.length;for(let n=0;n<t.length;n++)if(e<t[n]){p[a+r]=n;break}}}return i||n.disposeIntermediateTensorInfo(c),n.makeTensorInfo(d,"int32",p)}};function fN(e,t,n){const a=xr(-1,n);return uS([],t,a,e,n)}const mN={kernelName:Rn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;Qx(a,"neg");const r=n.data.get(a.dataId).values,[s,o]=fN(r,a.shape,a.dtype);return n.makeTensorInfo(o,a.dtype,s)}},gN=eu;const yN={kernelName:_n,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=a;Qx(r,"NonMaxSuppression");const l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,{selectedIndices:h}=gN(l,u,o,i,c);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},bN=tu;const vN={kernelName:Dn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a;Qx(r,"NonMaxSuppressionPadded");const u=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,{selectedIndices:d,validOutputs:p}=bN(u,h,o,i,c,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},xN=nu;const wN={kernelName:Fn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a;Qx(r,"NonMaxSuppressionWithScore");const u=n.data.get(r.dataId).values,h=n.data.get(s.dataId).values,d=o,p=i,f=c,m=l,{selectedIndices:g,selectedScores:y}=xN(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}},kN=cw(((e,t)=>e!==t?1:0)),SN=Cw(An,kN,null,"bool"),IN={kernelName:An,backendName:"cpu",kernelFunc:SN};const NN={kernelName:Mn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:o,onValue:i,offValue:c}=a;Qx(r,"oneHot");const l=ee(r.shape),u=new Float32Array(l*o);u.fill(c);const h=n.data.get(r.dataId).values;for(let d=0;d<l;++d)h[d]>=0&&h[d]<o&&(u[d*o+h[d]]=i);return n.makeTensorInfo([...r.shape,o],s,u)}};function TN(e){const{inputs:t,backend:n}=e,{x:a}=t;if("string"===a.dtype)throw new Error("zerosLike is not supported for string tensors");if("complex64"===a.dtype){const e=Sw({inputs:{input:a},backend:n}),t=TN({inputs:{x:e},backend:n}),r=Mk({inputs:{input:a},backend:n}),s=TN({inputs:{x:r},backend:n}),o=xw({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return XS({backend:n,attrs:{shape:a.shape,value:0,dtype:a.dtype}})}const EN={kernelName:Va,backendName:"cpu",kernelFunc:TN};const CN={kernelName:On,backendName:"cpu",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported for string tensors");if("complex64"===r.dtype){const t=Sw({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=Mk({inputs:{input:r},backend:a}),o=TN({inputs:{x:s},backend:a}),i=xw({inputs:{real:n,imag:o},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}return XS({backend:a,attrs:{shape:r.shape,value:1,dtype:r.dtype}})}};function RN(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return DS({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{Z(s,e.shape,"All tensors passed to stack must have matching shapes"),J(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=zk({inputs:t.map((e=>{const t=DS({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}const AN={kernelName:Ln,backendName:"cpu",kernelFunc:RN};const _N={kernelName:zn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:o}=a;Qx(r,"pad");const i=s.map(((e,t)=>e[0]+r.shape[t]+e[1])),c=s.map((e=>e[0])),l=n.data.get(r.dataId).values,u=ee(r.shape),h=r.shape.length,d=be(r.shape),p=ee(i),f=i.length,m=be(i),g=le(r.dtype,p);0!==o&&g.fill(o);for(let y=0;y<u;y++){g[Ne(Te(y,h,d).map(((e,t)=>e+c[t])),f,m)]=l[y]}return{dataId:n.write(g,i,r.dtype),shape:i,dtype:r.dtype}}},DN=cw(((e,t)=>Math.pow(e,t))),FN=Cw(Pn,DN),ON={kernelName:Pn,backendName:"cpu",kernelFunc:FN};function MN(e,t,n,a){const[r,s]=Rc(e,a),o=Jr(t,"int32"),i=ke(ee(r),o),c=ee(s);for(let l=0;l<i.length;++l){const e=l*c;let t=1;for(let a=0;a<c;++a)t*=n[e+a];i[l]=t}return{outVals:i,outShape:r,outDtype:o}}const LN={kernelName:Wn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;Qx(r,"prod");const i=r.shape.length,c=ie(s,r.shape),l=Dc(c,i);let u=c,h=r;const d=[];null!=l&&(h=qw({inputs:{x:r},backend:n,attrs:{perm:l}}),d.push(h),u=Oc(u.length,i));const p=n.data.get(h.dataId).values,{outVals:f,outShape:m,outDtype:g}=MN(h.shape,h.dtype,p,u);let y=m;return o&&(y=Ac(m,c)),d.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(y,g,f)}};function zN(e,t,n,a){const r=[];let s=0;const o=t.length-1+n.length,i=new Array(o).fill(null).map((()=>[0]));!function(e,t){for(let n=0;n<e.length;++n){const a=e[n],r=n===e.length-1?t:e[n+1].length;if(0===a.length)throw new Error("Ragged splits may not be empty");if(a[0]<0)throw new Error("Ragged splits must be non-negative");if(a[a.length-1]>r)throw new Error("Ragged splits must not point past values");for(let e=1;e<a.length;++e)if(a[e-1]>a[e])throw new Error("Ragged splits must be sorted in ascending order")}}(n,a);let c=1;for(let l=0;l<t.length-1;++l){c*=t[l];const e=t[l+1];for(let t=1;t<c+1;++t)i[l].push(t*e)}for(let l=0;l<e.length;++l){let a=e[l],o=e[l]+1;for(let e=0;e<n.length;++e){const r=n[e],s=e+t.length-1;if(s>=0){const e=i[s],t=e[e.length-1]-r[a];for(let n=a;n<o;++n)i[s].push(r[n+1]+t)}a=r[a],o=r[o]}o!==a&&(r.push([a,o]),s+=o-a)}return{outSplits:i,valueSlices:r,numValues:s}}function PN(e,t){const n=e.slice(0,t);for(;n.length<t;)n.push(1);for(let a=t;a<e.length;a++)n[t-1]*=e[a];return n}function BN(e,t,n,a,r){const s=t.slice();s[0]=r;const o=ue(n,ee(s)),i=e.length;return function(e,t,n,a,r,s){const o=PN(t,2)[1],i=PN(s,2)[1];let c=0;for(const l of n)for(let t=l[0];t<l[1];++t){for(let n=0;n<a;++n)r[c*i+n]=e[t*o+n];++c}}(e,t,a,0===i?0:i/t[0],o,s),[o,s]}function WN(e,t,n,a,r,s,o,i){if(0===e.length)throw new Error("paramsNestedSplits must be non empty");if(0===t[0].length)throw new Error("Split tensors must not be scalars");if(function(e,t,n){e.forEach(((e,a)=>{if(e<0||e>=n){const r=Te(a,t.length,be(t)).join(",");throw new Error("indices[".concat(r,"] = ").concat(e," is not in [0, ").concat(n,")"))}}))}(s,o,t[0][0]-1),0===a.length)throw new Error("params.rank must be nonzero");const c=a[0],{outSplits:l,valueSlices:u,numValues:h}=zN(s,o,e,c),d=function(e){const t=[];for(let n=0;n<e.length;++n){const a=ue("int32",e[n].length);t.push(a),e[n].forEach(((e,t)=>a[t]=e))}return t}(l),p=BN(n,a,r,u,h);return[d,p[0],p[1]]}const VN={kernelName:Vn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:o}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.data.get(e.dataId).values)),l=r.map((e=>e.shape)),u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,[d,p,f]=WN(c,l,u,s.shape,s.dtype,h,o.shape),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}},UN=2147483647;function GN(e,t,n,a,r,s,o){if(t.length>1)throw new Error("starts must be a scalar or vector");if(r.length>1)throw new Error("limits must be a scalar or vector");if(o.length>1)throw new Error("deltas must be a scalar or vector");const i=0===t.length,c=0===r.length,l=0===o.length,u=[];i||u.push(t[0]),c||u.push(r[0]),l||u.push(o[0]);for(let m=1;m<u.length;++m)if(u[m]!==u[m-1])throw new Error("starts, limits, and deltas must have the same shape");const h=0===u.length?1:u[0],d=ue("int32",h+1);d[0]=0;for(let m=0;m<h;++m){const t=i?e[0]:e[m],n=c?a[0]:a[m],r=l?s[0]:s[m];if(0===r)throw new Error("Requires delta != 0");let o;if(r>0&&n<t||r<0&&n>t)o=0;else if(o=Math.ceil(Math.abs((n-t)/r)),o>UN)throw new Error("Requires ((limit - start) / delta) <= ".concat(UN));d[m+1]=d[m]+o}const p=ue(n,d[h]);let f=0;for(let m=0;m<h;++m){const t=d[m+1]-d[m];let n=i?e[0]:e[m];const a=l?s[0]:s[m];for(let e=0;e<t;++e)p[f++]=n,n+=a}return[d,p]}const HN={kernelName:Un,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,[l,u]=GN(o,a.shape,a.dtype,i,r.shape,c,s.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};var jN=Mu;class KN{constructor(e,t,n,a,r,s,o,i,c,l){this.shape=e,this.shapeShape=t,this.values=n,this.valuesShape=a,this.valuesDType=r,this.defaultValue=s,this.defaultValueShape=o,this.rowPartitionValues=i,this.rowPartitionValuesShapes=c,this.rowPartitionTypes=zu(l),this.raggedRank=Pu(this.rowPartitionTypes)}getRowPartitionTypeByDimension(e){return this.rowPartitionTypes[0]===jN.FIRST_DIM_SIZE?this.rowPartitionTypes[e+1]:this.rowPartitionTypes[e]}getRowPartitionTensor(e){return this.rowPartitionTypes[0]===jN.FIRST_DIM_SIZE?this.rowPartitionValues[e+1]:this.rowPartitionValues[e]}getMaxWidth(e){const t=this.getRowPartitionTensor(e-1);switch(this.getRowPartitionTypeByDimension(e-1)){case jN.VALUE_ROWIDS:return KN.getMaxWidthValueRowID(t);case jN.ROW_SPLITS:return KN.getMaxWidthRowSplit(t);default:throw new Error("Cannot handle partition type ".concat(jN[this.getRowPartitionTypeByDimension(e-1)]))}}static getMaxWidthRowSplit(e){const t=e.length;if(0===t||1===t)return 0;let n=0;for(let a=0;a<t-1;++a){const t=e[a+1]-e[a];t>n&&(n=t)}return n}static getMaxWidthValueRowID(e){const t=e.length;if(0===t)return 0;let n=0,a=e[0],r=0;for(let s=1;s<t;++s){const t=e[s];t!==a&&(a=t,r=Math.max(s-n,r),n=s)}return Math.max(t-n,r)}tensorShapeFromTensor(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];if(0===t.length){if(-1===e[0])return[];throw new Error("The only valid scalar shape tensor is the fully unknown shape specified as -1.")}return XN(e,n)}calculateOutputSize(e){const t=this.valuesShape;Bu(this.defaultValueShape,t);const n=this.tensorShapeFromTensor(this.shape,this.shapeShape),a=Lu(this.raggedRank,n,t);a[0]<0&&(a[0]=e);for(let r=1;r<=this.raggedRank;++r)a[r]<0&&(a[r]=this.getMaxWidth(r));return a}calculateFirstParentOutputIndex(e,t,n){const a=Math.min(e,n),r=[];let s=0;for(let o=0;o<a;++o,s+=t)r.push(s);for(let o=a;o<e;++o)r.push(-1);return J(r.length===e,(()=>"Final length of result must be equal to firstDimension.")),r}calculateOutputIndexRowSplit(e,t,n,a){const r=e.length,s=[];for(let o=0;o<r-1;++o){const r=e[o+1]-e[o];let i=Math.min(a,r),c=t[o];-1===c&&(i=0);for(let e=0;e<i;++e)s.push(c),c+=n;for(let e=0;e<r-i;++e)s.push(-1)}if(r>0&&s.length!==e[r-1])throw new Error("Invalid row split size.");return s}calculateOutputIndexValueRowID(e,t,n,a){const r=e.length,s=[];if(0===r)return[];let o=0,i=e[0];if(i>=t.length)throw new Error("Got currentValueRowId=".concat(i,", which is not less than ").concat(t.length));let c=t[i];s.push(c);for(let l=1;l<r;++l){const r=e[l];if(r===i)c>=0&&(++o,o<a?c+=n:c=-1);else{if(o=0,i=r,r>=t.length)throw new Error("Got nextValueRowId=".concat(r," which is not less than ").concat(t.length));c=t[r]}s.push(c)}if(s.length!==e.length)throw new Error("Invalid row ids.");return s}calculateOutputIndex(e,t,n,a){const r=this.getRowPartitionTensor(e),s=this.getRowPartitionTypeByDimension(e);switch(s){case jN.VALUE_ROWIDS:return this.calculateOutputIndexValueRowID(r,t,n,a);case jN.ROW_SPLITS:if(r.length-1>t.length)throw new Error("Row partition size is greater than output size: ".concat(r.length-1," > ").concat(t.length));return this.calculateOutputIndexRowSplit(r,t,n,a);default:throw new Error("Unsupported partition type: ".concat(jN[s]))}}getFirstDimensionSize(){const e=this.rowPartitionValues[0];if(0===this.rowPartitionTypes.length)throw new Error("No row_partition_types given.");const t=this.rowPartitionTypes[0];switch(t){case jN.FIRST_DIM_SIZE:return e[0];case jN.VALUE_ROWIDS:throw new Error("Cannot handle VALUE_ROWIDS in first dimension.");case jN.ROW_SPLITS:return this.rowPartitionValuesShapes[0][0]-1;default:throw new Error("Cannot handle type ".concat(jN[t]))}}compute(){if(this.rowPartitionValues[0].length<=0)throw new Error("Invalid first partition input. Tensor requires at least one element.");const e=this.getFirstDimensionSize(),t=this.calculateOutputSize(e),n=new Array(this.raggedRank+1);n[n.length-1]=1;for(let s=n.length-2;s>=0;--s)n[s]=n[s+1]*t[s+1];const a=XN(t,!1),r=ue(this.valuesDType,ee(a));if(n[0]*t[0]>0){let s=this.calculateFirstParentOutputIndex(e,n[0],t[0]);for(let e=1;e<=this.raggedRank;++e){s=this.calculateOutputIndex(e-1,s,n[e],t[e])}this.setOutput(this.raggedRank,s,r,a)}return[a,r]}setOutput(e,t,n,a){if(0===n.length)return;const r=this.values,s=n;let o=a.slice();o=o.slice(e+1);const i=ee(o),c=t.length;let l=this.defaultValue;if(l.length!==i&&1!==l.length){const e=this.defaultValueShape;Es((()=>{const t=Vi(l,e),n=Xi(t,o);l=n.dataSync()}))}let u=0,h=0,d=0;for(let p=0;p<=c;++p){let e=p<c?t[p]:-1;if(e!==d){if(h<d){const e=r.subarray(u*i);qN(s.subarray(h*i),e,(d-h)*i)}if(p>=c){const t=n.length;e=Math.floor(t/i)}if(e>d)if(1===this.defaultValue.length)s.subarray(d*i,e*i).fill(this.defaultValue[0]),d=e;else for(;e>d;){qN(s.slice(d*i),l,i),++d}e<0?(u=p+1,h=d):(u=p,h=d,d=h+1)}else++d}}}function qN(e,t,n){for(let a=0;a<n;a++)e[a]=t[a]}function XN(e,t){const n=[];for(let a of e){if(a<0){if(!t)throw new Error("Dimension ".concat(a," must be >= 0"));if(a<-1)throw new Error("Dimension ".concat(a," must be >= -1"));a=-1}n.push(a)}return n}function YN(e,t,n,a,r,s,o,i,c,l){return new KN(e,t,n,a,r,s,o,i,c,l).compute()}const QN={kernelName:Gn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.data.get(r.dataId).values,u=n.data.get(s.dataId).values,h=n.data.get(o.dataId).values,d=i.map((e=>n.data.get(e.dataId).values)),p=i.map((e=>e.shape)),[f,m]=YN(l,r.shape,u,s.shape,s.dtype,h,o.shape,d,p,c);return n.makeTensorInfo(f,s.dtype,m)}};function JN(e,t,n,a){if(e===t||e<t&&n<0||t<e&&n>1)return ke(0,a);const r=ke(Math.abs(Math.ceil((t-e)/n)),a);t<e&&1===n&&(n=-1),r[0]=e;for(let s=1;s<r.length;s++)r[s]=r[s-1]+n;return r}const ZN={kernelName:Hn,backendName:"cpu",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,dtype:s,step:o}=n,i=JN(a,r,o,s);return t.makeTensorInfo([i.length],s,i)}},$N=ew(Kn,(e=>1/e)),eT={kernelName:Kn,backendName:"cpu",kernelFunc:$N};const tT={kernelName:Jn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a;Qx(r,"resizeBilinear");const c=be(r.shape),[l,u]=i,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(ee([h,l,u,f])),y=[s&&l>1?d-1:d,s&&u>1?p-1:p],b=[s&&l>1?l-1:l,s&&u>1?u-1:u];let v=0;const x=y[0]/b[0],w=y[1]/b[1];for(let k=0;k<h;k++)for(let e=0;e<l;e++){let t;t=o?x*(e+.5)-.5:x*e;const n=Math.max(0,Math.floor(t)),a=t-n,r=Math.min(d-1,Math.ceil(t)),s=k*c[0]+n*c[1],i=k*c[0]+r*c[1];for(let e=0;e<u;e++){let t;t=o?w*(e+.5)-.5:w*e;const n=Math.max(0,Math.floor(t)),r=t-n,l=Math.min(p-1,Math.ceil(t)),u=s+n*c[2],h=i+n*c[2],d=s+l*c[2],y=i+l*c[2];for(let e=0;e<f;e++){const t=m[u+e],n=m[h+e],s=t+(m[d+e]-t)*r,o=s+(n+(m[y+e]-n)*r-s)*a;g[v++]=o}}}return n.makeTensorInfo([h,l,u,f],"float32",g)}};const nT={kernelName:Zn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a;Qx([s,r],"resizeBilinearGrad");const i=be(r.shape),[c,l,u,h]=r.shape,[,d,p]=s.shape,f=new Float32Array(c*l*u*h),m=[o&&d>1?l-1:l,o&&p>1?u-1:u],g=[o&&d>1?d-1:d,o&&p>1?p-1:p],y=m[0]/g[0],b=m[1]/g[1],v=n.data.get(s.dataId).values;let x=0;for(let w=0;w<c;w++){const e=w*i[0];for(let t=0;t<d;t++){const n=t*y,a=Math.floor(n),r=Math.min(Math.ceil(n),l-1),s=e+a*i[1],o=e+r*i[1],c=n-a,d=1-c;for(let e=0;e<p;e++){const t=e*b,n=Math.floor(t),a=Math.min(Math.ceil(t),u-1),r=t-n,l=1-r,p=s+n*i[2],m=s+a*i[2],g=o+n*i[2],y=o+a*i[2],w=d*l,k=d*r,S=c*l,I=c*r;for(let e=0;e<h;e++){const t=v[x++];f[p+e]+=t*w,f[m+e]+=t*k,f[g+e]+=t*S,f[y+e]+=t*I}}}}return n.makeTensorInfo([c,u,l,h],"float32",f)}};const aT={kernelName:Yn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a;Qx(r,"resizeNearestNeighbor");const c=be(r.shape),[l,u]=i,[h,d,p,f]=r.shape,m=n.data.get(r.dataId).values,g=new Float32Array(h*l*u*f),y=[s&&l>1?d-1:d,s&&u>1?p-1:p],b=[s&&l>1?l-1:l,s&&u>1?u-1:u],v=y[0]/b[0],x=y[1]/b[1];let w=0;for(let k=0;k<h;k++){const e=k*c[0];for(let t=0;t<l;t++){const n=o?v*(t+.5):v*t;let a=Math.min(d-1,s?Math.round(n):Math.floor(n));o&&(a=Math.max(0,a));const r=e+a*c[1];for(let e=0;e<u;e++){const t=o?x*(e+.5):x*e;let n=Math.min(p-1,s?Math.round(t):Math.floor(t));o&&(n=Math.max(0,n));const a=r+n*c[2];for(let e=0;e<f;e++){const t=m[a+e];g[w++]=t}}}}return n.makeTensorInfo([h,l,u,f],r.dtype,g)}};const rT={kernelName:Qn,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a;Qx([s,r],"resizeNearestNeighborGrad");const i=be(r.shape),c=be(s.shape),[l,u,h,d]=r.shape,[,p,f]=s.shape,m=new Float32Array(l*u*h*d),g=n.data.get(s.dataId).values,y=[o&&p>1?u-1:u,o&&f>1?h-1:h],b=[o&&p>1?p-1:p,o&&f>1?f-1:f],v=y[0]/b[0],x=y[1]/b[1],w=1/v,k=1/x,S=2*Math.ceil(w)+2,I=2*Math.ceil(k)+2;for(let N=0;N<l;N++){const e=N*i[0];for(let t=0;t<u;t++){const n=e+t*i[1],a=Math.floor(t*w),r=Math.floor(a-S/2);for(let s=0;s<h;s++){const a=n+s*i[2],l=Math.floor(s*k),y=Math.floor(l-I/2);for(let n=0;n<d;n++){let i=0;for(let a=0;a<S;a++){const l=a+r;if(l<0||l>=p)continue;const d=e+l*c[1],m=l*v;if(t===Math.min(u-1,o?Math.round(m):Math.floor(m)))for(let e=0;e<I;e++){const t=e+y;if(t<0||t>=f)continue;const a=d+t*c[2],r=t*x;s===Math.min(h-1,o?Math.round(r):Math.floor(r))&&(i+=g[a+n])}}m[a+n]=i}}}}return n.makeTensorInfo(r.shape,r.dtype,m)}};const sT={kernelName:ea,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a;Qx(r,"reverse");const o=r.shape.length,i=ie(s,r.shape);if(0===o)return rw({inputs:{x:r},backend:n});const c=new Pr(r.shape,r.dtype),l=n.bufferSync(r);for(let u=0;u<c.size;u++){const e=c.indexToLoc(u),t=e.slice();i.forEach((e=>t[e]=r.shape[e]-1-t[e])),c.set(l.get(...t),...e)}return n.makeTensorInfo(c.shape,c.dtype,c.values)}},oT={kernelName:Ha,backendName:"cpu",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:s,fillValue:o,center:i}=n,c=a,l=le(r.dtype,ee(r.shape)),[u,h,d,p]=r.shape,[f,m]=Uu(i,h,d),g=Math.sin(s),y=Math.cos(s),b=c.data.get(r.dataId).values;for(let v=0;v<u;v++){const e=v*d*h*p;for(let t=0;t<h;t++){const n=t*(d*p);for(let a=0;a<d;a++){const r=a*p;for(let s=0;s<p;s++){const i=[u,t,a,s],c=i[2],v=i[1];let x=(c-f)*y-(v-m)*g,w=(c-f)*g+(v-m)*y;x=Math.round(x+f),w=Math.round(w+m);let k=o;if("number"!==typeof o&&(k=3===s?255:o[s]),x>=0&&x<d&&w>=0&&w<h){k=b[e+w*(d*p)+x*p+s]}l[e+n+r+s]=k}}}}return{dataId:c.write(l,r.shape,r.dtype),shape:r.shape,dtype:r.dtype}}},iT=ew(ta,(e=>{const t=Math.floor(e);return e-t<.5?Math.floor(e):e-t>.5?Math.ceil(e):t%2===0?t:t+1})),cT={kernelName:ta,backendName:"cpu",kernelFunc:iT},lT=$x((e=>1/Math.sqrt(e))),uT=tw(na,lT),hT={kernelName:na,backendName:"cpu",kernelFunc:uT};function dT(e,t,n,a,r,s,o,i,c,l){const u=[a/r,r],h=e.values,d=t.values;if(0===a)return go(n,t.dtype);const p=c instanceof Pr?c:go(u,t.dtype);"string"===typeof c||"number"===typeof c?p.values.fill(c):"boolean"===typeof c&&p.values.fill(+c);for(let f=0;f<s;f++){const e=[];let s=0;for(let t=0;t<o;t++){const n=h[f*o+t];e.push(n),s+=n*i[t]}if(s<0||s>=a/r)throw new Error("Invalid indices: ".concat(e," does not index into ").concat(n));for(let n=0;n<r;n++)l?p.values[s*r+n]+=d[f*r+n]:p.values[s*r+n]=0===t.rank?d[0]:d[f*r+n]}return p}const pT={kernelName:aa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:o}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=Ju(0,r,o),d=dT(n.bufferSync(r),n.bufferSync(s),o,h,l,c,i,u,0,!0);return n.makeTensorInfo(o,d.dtype,d.values)}};function fT(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<t?n=r+1:a=r;return a}function mT(e,t){let n=0,a=e.length,r=0;for(;n<a;)r=Math.floor((n+a)/2),e[r]<=t?n=r+1:a=r;return a}const gT={kernelName:sa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:o}=a,i=function(e,t,n,a,r,s){const o=ue("int32",n*r);for(let i=0;i<n;++i){const n=e.slice(i*a,(i+1)*a),c=i*r;for(let e=0;e<r;++e)o[c+e]="left"===s?fT(n,t[e+c]):mT(n,t[e+c])}return o}(n.data.get(r.dataId).values,n.data.get(s.dataId).values,r.shape[0],r.shape[1],s.shape[1],o);return n.makeTensorInfo(s.shape,"int32",i)}};const yT={kernelName:oa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t;Qx([a,r,s],"select");const o=a.shape.length,i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=Jr(r.dtype,s.dtype),h=ke(ee(r.shape),u);let d=0;const p=0===o||o>1||1===r.shape.length?1:ee(r.shape.slice(1));for(let f=0;f<i.length;f++)for(let e=0;e<p;e++)1===i[f]?h[d++]=c[f]:h[d++]=l[f];return n.makeTensorInfo(r.shape,u,h)}},bT=Zu,vT=$u,xT=ew(ia,(e=>e>=0?vT*e:bT*(Math.exp(e)-1))),wT={kernelName:ia,backendName:"cpu",kernelFunc:xT},kT=ew(ha,(e=>e<0?-1:e>0?1:0)),ST={kernelName:ha,backendName:"cpu",kernelFunc:kT},IT=ew(la,(e=>Math.sin(e))),NT={kernelName:la,backendName:"cpu",kernelFunc:IT},TT=ew(ua,(e=>Math.sinh(e))),ET={kernelName:ua,backendName:"cpu",kernelFunc:TT},CT=Math.log(1.1920928955078125e-7)+2,RT=ew(pa,(e=>{const t=e>-CT,n=e<CT,a=Math.exp(e);let r;return r=n?a:t?e:Math.log(1+a),r})),AT={kernelName:pa,backendName:"cpu",kernelFunc:RT};const _T={kernelName:ga,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:o}=a;Qx([r],"spaceToBatchND");const i=ee(s),c=[[0,0]];c.push(...o);for(let g=1+s.length;g<r.shape.length;++g)c.push([0,0]);const l=_N.kernelFunc({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),u=Gu(l.shape,s,i,!1),h=Hu(u.length,s.length,!1),d=ju(l.shape,s,i,!1),p=Ow({inputs:{x:l},backend:n,attrs:{shape:u}}),f=qw({inputs:{x:p},backend:n,attrs:{perm:h}}),m=Ow({inputs:{x:f},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),m}};function DT(e,t,n,a,r,s,o){const i=t[0],c=s[0],l=new Array(c),u=new Array(i),h=t[1];if(0===c){if(0!==i)throw new Error(Nh(i));return[ue(n,0),[0,h],ue(r,0),l,u]}let d=!0,p=0;const f=new Array(c).fill(0);for(let g=0;g<i;++g){const t=e[g*h];if(t<0)throw new Error(Th(g,t));if(t>=c)throw new Error(Eh(g,t,c));++f[t],d=d&&t>=p,p=t}let m=!0;for(let g=0;g<c;++g){const e=0===f[g];l[g]=e,m=m&&!e,f[g]=Math.max(f[g],1),g>0&&(f[g]+=f[g-1])}if(m&&d){const t=e,n=a;for(let e=0;e<i;++e)u[e]=e;return[t,[i,h],n,l,u]}{const t=f[c-1],s=ue(n,t*h),d=ue(r,t),p=new Array(c).fill(0);for(let n=0;n<i;++n){const t=e[n*h],r=p[t],o=(0===t?0:f[t-1])+r;p[t]++;for(let a=0;a<h;++a)s[o*h+a]=e[n*h+a];d[o]=a[n],u[n]=o}for(let e=0;e<c;++e){if(0===p[e]){const t=0===e?0:f[e-1];s[t*h+0]=e;for(let e=1;e<h;++e)s[t*h+e]=0;d[t]=o}}return[s,[t,h],d,l,u]}}const FT={kernelName:va,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n        ".concat(s.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n        ".concat(r.shape));if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));const i=n.data.get(a.dataId).values,c=n.data.get(r.dataId).values,l=n.data.get(s.dataId).values,u=n.data.get(o.dataId).values[0],[h,d,p,f,m]=DT(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};function OT(e,t,n,a,r){const s=ee(a),o=t[0],i=r.length,c=[];let l=1,u=-1;for(let m=0;m<i;++m){const e=r[m];if(-1===e){if(-1!==u)throw new Error(Ch(u,m));u=m,c.push(1)}else{if(e<0)throw new Error(Rh(m,e));l*=e,c.push(e)}}if(-1!==u){if(l<=0)throw new Error("reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero");const e=Math.trunc(s/l);if(l*e!==s)throw new Error(_h(a,c));c[u]=e}if(ee(c)!==s)throw new Error(Dh(a,c));const h=a.length,d=[];if(h>0){d[h-1]=1;for(let e=h-2;e>=0;--e)d[e]=d[e+1]*a[e+1]}const p=[];if(i>0){p[i-1]=1;for(let e=i-2;e>=0;--e)p[e]=p[e+1]*c[e+1]}const f=ue(n,o*i);for(let m=0;m<o;++m){let t=0;for(let n=0;n<h;++n)t+=e[m*h+n]*d[n];for(let e=0;e<i;++e)f[m*i+e]=Math.trunc(t/p[e]),t%=p[e]}return[f,[o,i],c]}const MT={kernelName:xa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape\n        ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape\n        ".concat(r.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const o=Array.from(n.data.get(r.dataId).values),i=n.data.get(a.dataId).values,c=Array.from(n.data.get(s.dataId).values),[l,u,h]=OT(i,a.shape,a.dtype,o,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};function LT(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0;const i=a.length,c=[t[0],e.length/t[0]],l=c[1],u=i>0?r[i-1]+1:0;if(u<0)throw new Error("segment ids must be >= 0");const h=t.slice();h[0]=u;const d=ue(n,h.reduce(((e,t)=>e*t),1));if(0===i)return u>0&&d.fill(o),[d,h];if(u<=0)throw new Error("segment ids must be >= 0");let p=0,f=1,m=0,g=r[p];for(;;){let t=0;if(f<i){if(t=r[f],g===t){++f;continue}if(g>=t)throw new Error("segment ids are not increasing")}if(g<0||g>=u)throw new Error(Mh(g,u));g>m&&d.fill(o,m*l,g*l);for(let n=p;n<f;++n){const t=a[n];if(t<0||t>=c[0])throw new Error(Lh(n,a[n],c[0]));for(let n=0;n<l;n++)d[g*l+n]+=e[t*l+n]}if(s)for(let e=0;e<l;e++)d[g*l+e]/=f-p;if(p=f,++f,m=g+1,g=t,f>i)break}return m<u&&d.fill(o,m*l,u*l),[d,h]}const zT={kernelName:wa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n          ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n          ".concat(s.shape));if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,[l,u]=LT(o,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const PT={kernelName:ka,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n         ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n         ".concat(s.shape));if(r.shape[0]!==s.shape[0])throw new Error("segmentIds and indices should have same size.");const o=n.data.get(a.dataId).values,i=n.data.get(r.dataId).values,c=n.data.get(s.dataId).values,[l,u]=LT(o,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const BT={kernelName:Sa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=Ju(0,r,i),p=!1,f=n.bufferSync(r);let m;switch(s.dtype){case"bool":m=dT(f,n.bufferSync(s),i,d,u,l,c,h,Boolean(n.data.get(o.dataId).values[0]),p);break;case"float32":m=dT(f,n.bufferSync(s),i,d,u,l,c,h,n.data.get(o.dataId).values[0],p);break;case"int32":m=dT(f,n.bufferSync(s),i,d,u,l,c,h,n.data.get(o.dataId).values[0],p);break;case"string":m=dT(f,n.bufferSync(s),i,d,u,l,c,h,Ir(n.data.get(o.dataId).values[0]),p);break;default:throw new Error("Unsupported type ".concat(s.dtype))}return n.makeTensorInfo(i,m.dtype,m.values)}};const WT={kernelName:ya,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:o}=a,i=ie(o,r.shape)[0],c=Ih(r,s,i),l=new Array(r.shape.length).fill(0),u=r.shape.slice();return c.map((e=>{const t=[...u];t[i]=e;const a=vk({inputs:{x:r},backend:n,attrs:{begin:l,size:t}});return l[i]+=e,a}))}},VT=$x((e=>Math.sqrt(e))),UT=ew(fa,(e=>Math.sqrt(e))),GT={kernelName:fa,backendName:"cpu",kernelFunc:UT},HT={kernelName:Na,backendName:"cpu",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{x:a}=t,r=n;Qx(a,"square");const s=r.data.get(a.dataId).values,o=new Float32Array(s.length);for(let i=0;i<s.length;++i){const e=s[i];o[i]=e*e}return{dataId:r.write(o,a.shape,a.dtype),shape:a.shape,dtype:a.dtype}}},jT=cw(((e,t)=>{const n=e-t;return n*n})),KT=Cw(Ia,jT),qT={kernelName:Ia,backendName:"cpu",kernelFunc:KT},XT=$x(((e,t)=>{const{pattern:n,replaceGlobal:a,rewrite:r}=t;return e.replace(new RegExp(n,a?"g":""),r)})),YT=tw(Ta,XT),QT={kernelName:Ta,backendName:"cpu",kernelFunc:YT},JT=ew(Ua,((e,t)=>{const n=t;return isNaN(e)?NaN:e>0?1:n.alpha})),ZT={kernelName:Ua,backendName:"cpu",kernelFunc:JT};function $T(e,t,n,a){const r=go(e,t.dtype);for(let s=0;s<r.size;s++){const e=r.indexToLoc(s),o=new Array(e.length);for(let t=0;t<o.length;t++)o[t]=e[t]*n[t]+a[t];r.set(t.get(...o),...e)}return r}const eE={kernelName:Ea,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:o,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a;Qx(r,"stridedSlice");const{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=wi(r.shape,s,o,i,c,l,u,h,d);let w;if(m)w=Ow({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||y){J(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=ci(b,v,x),t=vk({inputs:{x:r},backend:n,attrs:{begin:b,size:e}});w=Ow({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{const e=$T(p,n.bufferSync(r),x,b);w=n.makeTensorInfo(f,e.dtype,e.values)}return w}};class tE{constructor(e,t,n,a,r,s){this.separator=Sr(e),this.nGramWidths=t,this.leftPad=Sr(n),this.rightPad=Sr(a),this.padWidth=r,this.preserveShort=s}getPadWidth(e){return Math.min(this.padWidth<0?e-1:this.padWidth,e-1)}getNumNGrams(e,t){const n=this.getPadWidth(t);return Math.max(0,e+2*n-t+1)}createNGrams(e,t,n,a,r,s){for(let o=0;o<r;++o){const i=this.getPadWidth(s),c=Math.max(0,i-o),l=Math.max(0,i-(r-(o+1))),u=s-(c+l),h=t+(c>0?0:o-i);let d=0;d+=c*this.leftPad.length;for(let t=0;t<u;++t)d+=e[h+t].length;d+=l*this.rightPad.length;d+=(c+l+u-1)*this.separator.length,n[a+o]=new Uint8Array(d);const p=n[a+o];let f=0;const m=e=>e.forEach((e=>p[f++]=e));for(let e=0;e<c;++e)m(this.leftPad),m(this.separator);for(let t=0;t<u-1;++t)m(e[h+t]),m(this.separator);if(u>0){m(e[h+u-1]);for(let e=0;e<l;++e)m(this.separator),m(this.rightPad)}else{for(let e=0;e<l-1;++e)m(this.rightPad),m(this.separator);m(this.rightPad)}}}compute(e,t){const n=e.length,a=t.length;if(a>0){let e=t[0];if(0!==e)throw new Error("First split value must be 0, got ".concat(e));for(let r=1;r<a;++r){let a=t[r]>=e;if(a=a&&t[r]<=n,!a)throw new Error("Invalid split value ".concat(t[r],", must be in [").concat(e,", ").concat(n,"]"));e=t[r]}if(e!==n)throw new Error("Last split value must be data size. Expected ".concat(n,", got ").concat(e))}const r=a-1,s=ue("int32",a);if(0===n||0===a){const e=new Array(n);for(let t=0;t<=r;++t)s[t]=0;return[e,s]}s[0]=0;for(let i=1;i<=r;++i){const e=t[i]-t[i-1];let n=0;this.nGramWidths.forEach((t=>{n+=this.getNumNGrams(e,t)})),this.preserveShort&&e>0&&0===n&&(n=1),s[i]=s[i-1]+n}const o=new Array(s[r]);for(let i=0;i<r;++i){const n=t[i];let a=s[i];if(this.nGramWidths.forEach((r=>{const s=t[i+1]-t[i],c=this.getNumNGrams(s,r);this.createNGrams(e,n,o,a,c,r),a+=c})),this.preserveShort&&a===s[i]){const r=t[i+1]-t[i];if(0===r)continue;const s=r+2*this.padWidth,c=1;this.createNGrams(e,n,o,a,c,s)}}return[o,s]}}function nE(e,t,n,a,r,s,o,i){return new tE(n,a,r,s,o,i).compute(e,t)}const aE={kernelName:Ca,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:o,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:h}=t,d=n.data.get(u.dataId).values,p=n.data.get(h.dataId).values,[f,m]=nE(d,p,r,s,o,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};function rE(e,t,n,a){if(!e.length)return;if(0===t.length){for(let t=0;t<e.length;++t)a.push(e.subarray(t,t+1));return}if(1===t.length){const r=t[0];let s=e.indexOf(r);for(;-1!==s;){const t=e.subarray(0,s);n&&0===t.length||a.push(t),s=(e=e.subarray(s+1)).indexOf(r)}return void(n&&0===e.length||a.push(e))}let r=0;for(let s=0;s<e.length+1;s++)if(s===e.length||-1!==t.indexOf(e[s])){const t=e.subarray(r,s);n&&0===t.length||a.push(t),r=s+1}}function sE(e,t,n){const a=e.length,r=[];let s=0,o=0;const i=new Array(a);for(let d=0;d<a;++d){const a=r.length;rE(e[d],t,n,r);const c=r.length-a;i[d]=c,s+=c,o=Math.max(o,c)}const c=ue("int32",2*s),l=new Array(s),u=[a,o];let h=0;for(let d=0;d<a;++d)for(let e=0;e<i[d];++e)c[2*h]=d,c[2*h+1]=e,l[h]=r[h],++h;return[c,l,u]}const oE={kernelName:Ra,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(o.shape));const i=n.data.get(s.dataId).values,c=n.data.get(o.dataId).values[0],[l,u,h]=sE(i,c,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};function iE(e,t){const n=ue("int32",e.length);for(let a=0;a<e.length;++a)n[a]=vr(e[a]).modulo(t).getLowBitsUnsigned();return n}const cE={kernelName:Aa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=iE(n.data.get(s.dataId).values,r);return n.makeTensorInfo(s.shape,"int32",o)}},lE=ew(Da,(e=>Math.tan(e))),uE={kernelName:Da,backendName:"cpu",kernelFunc:lE},hE=ew(Fa,(e=>Math.tanh(e)));const dE={kernelName:ra,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n}=e,{tensor:a,indices:r,updates:s}=t,{sliceRank:o,numUpdates:i,sliceSize:c,strides:l,outputSize:u}=Ju(0,r,a.shape),h=n.bufferSync(r),d=n.bufferSync(s),p=n.bufferSync(a),f=dT(h,d,a.shape,u,c,i,o,l,p,!1);return n.makeTensorInfo(a.shape,f.dtype,f.values)}};function pE(e,t){const n=new Array(e.rank);for(let r=0;r<n.length;r++)n[r]=e.shape[r]*t[r];const a=go(n,e.dtype);for(let r=0;r<a.values.length;++r){const t=a.indexToLoc(r),n=new Array(e.rank);for(let a=0;a<n.length;a++)n[a]=t[a]%e.shape[a];const s=e.locToIndex(n);a.values[r]=e.values[s]}return a}const fE={kernelName:Oa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;Qx(r,"tile");const o=pE(n.bufferSync(r),s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}},mE=(e,t)=>{const n=t.value-e.value;return 0===n?e.index-t.index:n};function gE(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:e.length-1;for(;a>n;){if(a-n>600){const r=a-n+1,s=t-n+1,o=Math.log(r),i=.5*Math.exp(2*o/3),c=.5*Math.sqrt(o*i*(r-i)/r)*Math.sign(s-r/2);gE(e,t,Math.max(n,Math.floor(t-s*i/r+c)),Math.min(a,Math.floor(t+(r-s)*i/r+c)))}const r=e[t];let s=n,o=a;for(Q(e,n,t),mE(e[a],r)>0&&Q(e,n,a);s<o;){for(Q(e,s,o),s++,o--;mE(e[s],r)<0;)s+=1;for(;mE(e[o],r)>0;)o-=1}0===mE(e[n],r)?Q(e,n,o):(o+=1,Q(e,o,a)),o<=t&&(n=o+1),t<=o&&(a=o-1)}}function yE(e,t,n,a,r){const s=t[t.length-1],[o,i]=[e.length/s,s],c=le(n,o*a),l=le("int32",o*a);for(let h=0;h<o;h++){const t=h*i,n=e.subarray(t,t+i);let s=new Array(n.length);n.forEach(((e,t)=>s[t]={value:e,index:t})),a<s.length&&(gE(s,a),s=s.slice(0,a)),r&&s.sort(mE);const o=h*a,u=c.subarray(o,o+a),d=l.subarray(o,o+a);for(let e=0;e<a;e++)u[e]=s[e].value,d[e]=s[e].index}const u=t.slice();return u[u.length-1]=a,[go(u,n,c),go(u,"int32",l)]}const bE={kernelName:Ma,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:o}=a;Qx(r,"topk");const i=n.data.get(r.dataId).values,[c,l]=yE(i,r.shape,r.dtype,s,o);return[n.makeTensorInfo(c.shape,c.dtype,c.values),n.makeTensorInfo(l.shape,l.dtype,l.values)]}};const vE={kernelName:La,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{image:r,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:c,outputShape:l}=n,[u,h,d,p]=r.shape,[f,m]=null!=l?l:[h,d],g=[u,f,m,p],y=be(r.shape),b=y[0],v=y[1],x=y[2],w=be(g),k=w[0],S=w[1],I=w[2],N=le(r.dtype,ee(g));N.fill(c);const T=a.data.get(r.dataId).values,E=a.data.get(s.dataId).values;for(let C=0;C<u;++C){const e=1===s.shape[0]?E:E.subarray(8*C,8*C+8);for(let t=0;t<f;++t)for(let n=0;n<m;++n)for(let a=0;a<p;++a){let r;const s=e[6]*n+e[7]*t+1;if(0===s)continue;const l=(e[0]*n+e[1]*t+e[2])/s,u=(e[3]*n+e[4]*t+e[5])/s,p=xE(l,d,i),f=xE(u,h,i);switch(o){case"nearest":r=kE(T,h,d,b,v,x,C,f,p,a,c);break;case"bilinear":r=SE(T,h,d,b,v,x,C,f,p,a,c);break;default:throw new Error("Error in Transform: Expect 'nearest' or "+"'bilinear', but got ".concat(o))}N[C*k+t*S+n*I+a]=r}return a.makeTensorInfo(g,r.dtype,N)}return{dataId:a.write(N,g,r.dtype),shape:r.shape,dtype:r.dtype}}};function xE(e,t,n){switch(n){case"reflect":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=2*t;n<e&&(n=e*Math.trunc(-n/e)+n),n=n<-t?n+e:-n-1}else if(n>t-1)if(t<=1)n=0;else{const e=2*t;n-=e*Math.trunc(n/e),n>=t&&(n=e-n-1)}return X(0,n,t-1)}(e,t);case"wrap":return function(e,t){let n=e;if(n<0)if(t<=1)n=0;else{const e=t-1;n+=t*(Math.trunc(-n/e)+1)}else if(n>t-1)if(t<=1)n=0;else{const e=t-1;n-=t*Math.trunc(n/e)}return X(0,n,t-1)}(e,t);case"nearest":return function(e,t){return X(0,e,t-1)}(e,t);default:return function(e,t){return e}(e)}}function wE(e,t,n,a,r,s,o,i,c,l,u){return 0<=i&&i<t&&0<=c&&c<n?e[o*a+i*r+c*s+l]:u}function kE(e,t,n,a,r,s,o,i,c,l,u){return wE(e,t,n,a,r,s,o,Math.round(i),Math.round(c),l,u)}function SE(e,t,n,a,r,s,o,i,c,l,u){const h=Math.floor(i),d=Math.floor(c),p=h+1,f=d+1;return(p-i)*((f-c)*wE(e,t,n,a,r,s,o,h,d,l,u)+(c-d)*wE(e,t,n,a,r,s,o,h,f,l,u))+(i-h)*((f-c)*wE(e,t,n,a,r,s,o,p,d,l,u)+(c-d)*wE(e,t,n,a,r,s,o,p,f,l,u))}function IE(e,t,n,a){const r=ie(t,n)[0],s=[1,n[0],1];for(let f=0;f<r;f++)s[0]*=n[f];s[1]=n[r];for(let f=r+1;f<n.length;f++)s[2]*=n[f];const o=new Map,i=new Int32Array(n[r]),c=new Pr(s,a,e),l=[],u=1===s[0]&&1===s[2];for(let f=0;f<n[r];f++){let t;if(u)t=e[f].toString();else{const e=[];for(let t=0;t<s[0];t++)for(let n=0;n<s[2];n++)e.push(c.get(t,f,n));t=e.join(",")}const n=o.get(t);if(null!=n)i[f]=n;else{const e=o.size;o.set(t,e),i[f]=e,l.push(f)}}const h=s.slice();h[1]=o.size;const d=new Pr(h,a);l.forEach(((e,t)=>{for(let n=0;n<s[0];n++)for(let a=0;a<s[2];a++)d.set(c.get(n,e,a),n,t,a)}));const p=n.slice();return p[r]=h[1],{outputValues:d.values,outputShape:p,indices:i}}const NE={kernelName:Pa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;Qx(s,"unique");const o=a.data.get(s.dataId).values,{outputValues:i,outputShape:c,indices:l}=IE(o,r,s.shape,s.dtype);return[a.makeTensorInfo(c,s.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const TE={kernelName:Ba,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r.shape.length,i=r.shape[s],c=new Array(o-1);let l=0;for(let p=0;p<o;p++)p!==s&&(c[l++]=r.shape[p]);const u=new Array(o).fill(0),h=r.shape.slice();h[s]=1;const d=new Array(i);for(let p=0;p<d.length;p++){u[s]=p;const e=vk({inputs:{x:r},backend:n,attrs:{begin:u,size:h}});d[p]=Ow({inputs:{x:e},backend:n,attrs:{shape:c}}),n.disposeIntermediateTensorInfo(e)}return d}};const EE={kernelName:Wa,backendName:"cpu",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:o}=a;Qx(r,"unsortedSegmentSum");const i=[],c=[],l=r.shape.length-s.shape.length;let u=s;for(let d=0;d<l;++d){const e=DS({inputs:{input:u},backend:n,attrs:{dim:d+1}});u=e,c.push(e)}for(let d=0;d<o;++d){const e=xr(d,"int32"),t=n.makeTensorInfo([],"int32",e),a=vS({inputs:{a:t,b:u},backend:n}),s=Tw({inputs:{x:a},backend:n,attrs:{dtype:"float32"}}),o=dS({inputs:{a:s,b:r},backend:n}),l=fS({inputs:{x:o},backend:n,attrs:{axis:0,keepDims:!1}});i.push(l),c.push(t),c.push(a),c.push(s),c.push(o),c.push(l)}const h=RN({inputs:i,backend:n,attrs:{axis:0}});return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),h}},CE=[Pw,Ww,Uw,Hw,Fw,jw,Yw,Qw,Jw,Zw,ek,nk,rk,ik,lk,pk,fk,mk,gk,zw,yk,wk,Ik,Tk,Ek,Ew,Ak,Dk,ww,Fk,Pk,Wk,Vk,Uk,Gk,Hk,jk,qk,Yk,Qk,Jk,Zk,$k,eS,nS,aS,rS,sS,oS,iS,cS,lS,gS,aw,yS,xS,CS,_S,FS,LS,qS,YS,QS,$S,nI,aI,rI,oI,cI,hI,fI,sw,mI,Lk,yI,vI,wI,iw,II,EI,RI,DI,OI,zI,BI,UI,GI,HI,qI,QI,JI,ZI,$I,eN,tN,nN,aN,oN,iN,uN,pN,pS,mN,yN,vN,wN,IN,NN,CN,AN,_N,ON,hw,LN,VN,HN,QN,ZN,Iw,BS,eT,pw,mw,Mw,tT,nT,aT,rT,sT,oT,cT,hT,pT,gT,yT,wT,bw,ST,NT,ET,xk,dN,AT,_T,FT,MT,zT,PT,BT,WT,GT,HT,qT,QT,ZT,eE,aE,oE,cE,GS,mS,uE,{kernelName:Fa,backendName:"cpu",kernelFunc:hE},dE,fE,bE,vE,Xw,NE,TE,EE,EN];for(const n of CE)tr(n);const RE={},AE={alpha:!1,antialias:!1,premultipliedAlpha:!1,preserveDrawingBuffer:!1,depth:!1,stencil:!1,failIfMajorPerformanceCaveat:!0};function _E(e,t){if(!(e in RE)||null!=t){const n=function(e,t){if(1!==e&&2!==e)throw new Error("Cannot get WebGL rendering context, WebGL is disabled.");const n=null==t?function(e){if(_e().getBool("IS_SAFARI")||"undefined"===typeof OffscreenCanvas||2!==e){if("undefined"!==typeof document)return document.createElement("canvas");throw new Error("Cannot create a canvas in this context")}return new OffscreenCanvas(300,150)}(e):t;n.addEventListener("webglcontextlost",(t=>{t.preventDefault(),delete RE[e]}),!1),_e().getBool("SOFTWARE_WEBGL_ENABLED")&&(AE.failIfMajorPerformanceCaveat=!1);if(1===e)return n.getContext("webgl",AE)||n.getContext("experimental-webgl",AE);return n.getContext("webgl2",AE)}(e,t);if(null===n)return console.log("Could not get context for WebGL version",e),null;RE[e]=n}const n=RE[e];return null==n||n.isContextLost()?(delete RE[e],_E(e)):(n.disable(n.DEPTH_TEST),n.disable(n.STENCIL_TEST),n.disable(n.BLEND),n.disable(n.DITHER),n.disable(n.POLYGON_OFFSET_FILL),n.disable(n.SAMPLE_COVERAGE),n.enable(n.SCISSOR_TEST),n.enable(n.CULL_FACE),n.cullFace(n.BACK),RE[e])}var DE,FE,OE;function ME(e,t){return[t,e]}function LE(e){const t=ee(e);return ae(Math.ceil(t/4))}function zE(e,t){return[Math.max(1,Math.ceil(t/2)),Math.max(1,Math.ceil(e/2))]}function PE(e,t){const n=e;let a,r,s,o,i,c,l,u,h,d;return 2===_e().getNumber("WEBGL_VERSION")?(a=n.R32F,r=n.R16F,s=n.RGBA16F,o=n.RGBA32F,i=n.RED,l=4,u=1,h=n.HALF_FLOAT,d=n.FLOAT,c=n.RGBA8):(a=e.RGBA,r=e.RGBA,s=e.RGBA,o=n.RGBA,i=e.RGBA,l=4,u=4,h=null!=t?t.HALF_FLOAT_OES:null,d=e.FLOAT,c=e.RGBA),{internalFormatFloat:a,internalFormatHalfFloat:r,internalFormatPackedHalfFloat:s,internalFormatPackedFloat:o,textureFormatFloat:i,downloadTextureFormat:c,downloadUnpackNumChannels:l,defaultNumChannels:u,textureTypeHalfFloat:h,textureTypeFloat:d}}function BE(e,t){const n=t();return _e().getBool("DEBUG")&&function(e){const t=e.getError();if(t!==e.NO_ERROR)throw new Error("WebGL Error: "+function(e,t){switch(t){case e.NO_ERROR:return"NO_ERROR";case e.INVALID_ENUM:return"INVALID_ENUM";case e.INVALID_VALUE:return"INVALID_VALUE";case e.INVALID_OPERATION:return"INVALID_OPERATION";case e.INVALID_FRAMEBUFFER_OPERATION:return"INVALID_FRAMEBUFFER_OPERATION";case e.OUT_OF_MEMORY:return"OUT_OF_MEMORY";case e.CONTEXT_LOST_WEBGL:return"CONTEXT_LOST_WEBGL";default:return"Unknown error code ".concat(t)}}(e,t))}(e),n}!function(e){e[e.DENSE=0]="DENSE",e[e.SHARED_BATCH=1]="SHARED_BATCH"}(DE||(DE={})),function(e){e[e.RENDER=0]="RENDER",e[e.UPLOAD=1]="UPLOAD",e[e.PIXELS=2]="PIXELS",e[e.DOWNLOAD=3]="DOWNLOAD"}(FE||(FE={})),function(e){e[e.UNPACKED_FLOAT16=0]="UNPACKED_FLOAT16",e[e.UNPACKED_FLOAT32=1]="UNPACKED_FLOAT32",e[e.PACKED_4X1_UNSIGNED_BYTE=2]="PACKED_4X1_UNSIGNED_BYTE",e[e.PACKED_2X2_FLOAT32=3]="PACKED_2X2_FLOAT32",e[e.PACKED_2X2_FLOAT16=4]="PACKED_2X2_FLOAT16"}(OE||(OE={}));function WE(e){return!!(_e().getBool("WEBGL_RENDER_FLOAT32_ENABLED")||0===e||5.96e-8<Math.abs(e)&&Math.abs(e)<65504)}function VE(e,t){return QE(e,(()=>e.getExtension(t)),'Extension "'+t+'" not supported on this browser.')}const UE=/ERROR: [0-9]+:([0-9]+):/g;function GE(e,t){const n=UE.exec(t);if(null==n)return console.log("Couldn't parse line number in error: ".concat(t)),void console.log(e);const a=+n[1],r=e.split("\n"),s=r.length.toString().length+2,o=r.map(((e,t)=>re((t+1).toString(),s)+e));let i=0;for(let h=0;h<o.length;h++)i=Math.max(o[h].length,i);const c=o.slice(0,a-1),l=o.slice(a-1,a),u=o.slice(a);console.log(c.join("\n")),console.log(t.split("\n")[0]),console.log("%c ".concat(re(l[0],i)),"border:1px solid red; background-color:#e3d2d2; color:#a61717"),console.log(u.join("\n"))}function HE(e,t){if(BE(e,(()=>e.validateProgram(t))),!1===e.getProgramParameter(t,e.VALIDATE_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Shader program validation failed.")}function jE(e,t,n,a,r,s,o){const i=e.getAttribLocation(t,n);return-1!==i&&(BE(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,a))),BE(e,(()=>e.vertexAttribPointer(i,r,e.FLOAT,!1,s,o))),BE(e,(()=>e.enableVertexAttribArray(i))),!0)}function KE(e,t,n,a){BE(e,(()=>function(e,t,n){JE(e,n),BE(e,(()=>e.activeTexture(e.TEXTURE0+n))),BE(e,(()=>e.bindTexture(e.TEXTURE_2D,t)))}(e,t,a))),BE(e,(()=>e.uniform1i(n,a)))}function qE(e,t,n){BE(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,n))),BE(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,t,0)))}function XE(e,t){BE(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,t))),BE(e,(()=>e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,null,0)))}function YE(e){const t=e.checkFramebufferStatus(e.FRAMEBUFFER);if(t!==e.FRAMEBUFFER_COMPLETE)throw new Error("Error binding framebuffer: "+function(e,t){switch(t){case e.FRAMEBUFFER_INCOMPLETE_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT:return"FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT";case e.FRAMEBUFFER_INCOMPLETE_DIMENSIONS:return"FRAMEBUFFER_INCOMPLETE_DIMENSIONS";case e.FRAMEBUFFER_UNSUPPORTED:return"FRAMEBUFFER_UNSUPPORTED";default:return"unknown error ".concat(t)}}(e,t))}function QE(e,t,n){const a=BE(e,(()=>t()));if(null==a)throw new Error(n);return a}function JE(e,t){const n=e.MAX_COMBINED_TEXTURE_IMAGE_UNITS-1,a=t+e.TEXTURE0;if(a<e.TEXTURE0||a>n){const e="[gl.TEXTURE0, gl.TEXTURE".concat(n,"]");throw new Error("textureUnit must be in ".concat(e,"."))}}function ZE(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:2;return ee(e.slice(0,e.length-t))}function $E(e){if(0===e.length)throw Error("Cannot get rows and columns of an empty shape array.");return[e.length>1?e[e.length-2]:1,e[e.length-1]]}function eC(e){let t=[1,1,1];return 0===e.length||1===e.length&&1===e[0]||(t=[ZE(e),...$E(e)]),t}function tC(e){return e%2===0}function nC(e,t){if(te(e=e.slice(-2),t=t.slice(-2)))return!0;if(!e.length||!t.length)return!0;if(0===e[0]||0===e[1]||0===t[0]||0===t[1])return!0;if(e.length!==t.length){const n=e[e.length-1],a=t[t.length-1];if(n===a)return!0;if(tC(n)&&tC(a)&&(1===e[0]||1===t[0]))return!0}return e[1]===t[1]&&tC(e[0])&&tC(t[0])}let aC,rC;function sC(e,t){return null!=e.getExtension(t)}function oC(e){try{if(null!=_E(e))return!0}catch(t){return console.log("Error when getting WebGL context: ",t),!1}return!1}function iC(e){if(0===e)return!1;const t=_E(e);if(1!==e){if(sC(t,"EXT_color_buffer_float"))return cC(t);const e="EXT_color_buffer_half_float";if(sC(t,e)){const n=t.getExtension(e);return function(e,t){const n=PE(e,t),a=e.createTexture();e.bindTexture(e.TEXTURE_2D,a);const r=1,s=1;e.texImage2D(e.TEXTURE_2D,0,n.internalFormatHalfFloat,r,s,0,n.textureFormatFloat,n.textureTypeHalfFloat,null);const o=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,o),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,a,0);const i=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(a),e.deleteFramebuffer(o),i}(t,n)}return!1}if(!sC(t,"OES_texture_float"))return!1;if(!sC(t,"WEBGL_color_buffer_float"))return!1;return cC(t)}function cC(e){const t=PE(e),n=e.createTexture();e.bindTexture(e.TEXTURE_2D,n);e.texImage2D(e.TEXTURE_2D,0,t.internalFormatFloat,1,1,0,t.textureFormatFloat,t.textureTypeFloat,null);const a=e.createFramebuffer();e.bindFramebuffer(e.FRAMEBUFFER,a),e.framebufferTexture2D(e.FRAMEBUFFER,e.COLOR_ATTACHMENT0,e.TEXTURE_2D,n,0);const r=e.checkFramebufferStatus(e.FRAMEBUFFER)===e.FRAMEBUFFER_COMPLETE;return e.bindTexture(e.TEXTURE_2D,null),e.bindFramebuffer(e.FRAMEBUFFER,null),e.deleteTexture(n),e.deleteFramebuffer(a),r}function lC(e,t){Array.isArray(e)||(e=[e]),e.forEach((e=>{null!=e&&J("complex64"!==e.dtype,(()=>"".concat(t," does not support complex64 tensors ")+"in the WebGL backend."))}))}const uC=_e();function hC(){let e,t,n,a,r,s,o,i,c,l;return 2===_e().getNumber("WEBGL_VERSION")?(e="#version 300 es",t="in",n="out",a="in",r="texture",s="outputColor",o="out vec4 outputColor;",i=_e().getBool("WEBGL2_ISNAN_CUSTOM")?"\n      bool isnan_custom(float val) {\n        uint floatToUint = floatBitsToUint(val);\n        return (floatToUint & 0x7fffffffu) > 0x7f800000u;\n      }\n\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan_custom(val.x),\n          isnan_custom(val.y), isnan_custom(val.z), isnan_custom(val.w));\n      }\n\n      #define isnan(value) isnan_custom(value)\n    ":"",c="",l="\n      #define round(value) newRound(value)\n      int newRound(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 newRound(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "):(e="",t="attribute",n="varying",a="varying",r="texture2D",s="gl_FragColor",o="",i="\n      #define isnan(value) isnan_custom(value)\n      bool isnan_custom(float val) {\n        return (val > 0. || val < 1. || val == 0.) ? false : true;\n      }\n      bvec4 isnan_custom(vec4 val) {\n        return bvec4(isnan(val.x), isnan(val.y), isnan(val.z), isnan(val.w));\n      }\n    ",c="\n      uniform float INFINITY;\n\n      bool isinf(float val) {\n        return abs(val) == INFINITY;\n      }\n      bvec4 isinf(vec4 val) {\n        return equal(abs(val), vec4(INFINITY));\n      }\n    ",l="\n      int round(float value) {\n        return int(floor(value + 0.5));\n      }\n\n      ivec4 round(vec4 value) {\n        return ivec4(floor(value + vec4(0.5)));\n      }\n    "),{version:e,attribute:t,varyingVs:n,varyingFs:a,texture2D:r,output:s,defineOutput:o,defineSpecialNaN:i,defineSpecialInf:c,defineRound:l}}function dC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=be(t);return a.map(((t,r)=>{const s="int ".concat(e[r]," = ").concat(n," / ").concat(t),o=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(t):"index -= ".concat(e[r]," * ").concat(t);return"".concat(s,"; ").concat(o,";")})).join("")}function pC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=be(t);return a.map(((t,r)=>{const s="int ".concat(e[r]," = ").concat(n," / outShapeStrides[").concat(r,"]"),o=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * outShapeStrides[").concat(r,"]"):"index -= ".concat(e[r]," * outShapeStrides[").concat(r,"]");return"".concat(s,"; ").concat(o,";")})).join("")}function fC(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"index";const a=function(e,t){const n=e.length,a=e.map((e=>"".concat(t,"[").concat(e,"]"))),r=new Array(n-1);r[n-2]=a[n-1];for(let s=n-3;s>=0;--s)r[s]="(".concat(r[s+1]," * ").concat(a[s+1],")");return r}(e.map(((e,t)=>t)),t);return a.map(((t,r)=>{const s="int ".concat(e[r]," = ").concat(n," / ").concat(a[r]),o=r===a.length-1?"int ".concat(e[r+1]," = ").concat(n," - ").concat(e[r]," * ").concat(a[r]):"index -= ".concat(e[r]," * ").concat(a[r]);return"".concat(s,"; ").concat(o,";")})).join("")}function mC(e){const t=be(e).map((e=>e.toString()));return"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * ".concat(t[0]," + coords.y * ").concat(t[1]," + coords.z;\n  }\n")}uC.registerFlag("HAS_WEBGL",(()=>uC.getNumber("WEBGL_VERSION")>0)),uC.registerFlag("WEBGL_VERSION",(()=>oC(2)?2:oC(1)?1:0)),uC.registerFlag("WEBGL_CHECK_NUMERICAL_PROBLEMS",(()=>!1)),uC.registerFlag("WEBGL_BUFFER_SUPPORTED",(()=>2===uC.get("WEBGL_VERSION"))),uC.registerFlag("WEBGL_CPU_FORWARD",(()=>!0)),uC.registerFlag("WEBGL_FORCE_F16_TEXTURES",(()=>!1)),uC.registerFlag("WEBGL_PACK",(()=>uC.getBool("HAS_WEBGL"))),uC.registerFlag("WEBGL_PACK_NORMALIZATION",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_PACK_CLIP",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_PACK_DEPTHWISECONV",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_PACK_BINARY_OPERATIONS",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_PACK_UNARY_OPERATIONS",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_PACK_ARRAY_OPERATIONS",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_PACK_IMAGE_OPERATIONS",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_PACK_REDUCE",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_LAZILY_UNPACK",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_CONV_IM2COL",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_PACK_CONV2DTRANSPOSE",(()=>uC.getBool("WEBGL_PACK"))),uC.registerFlag("WEBGL_MAX_TEXTURE_SIZE",(()=>function(e){if(null==aC){const t=_E(e);aC=t.getParameter(t.MAX_TEXTURE_SIZE)}return aC}(uC.getNumber("WEBGL_VERSION")))),uC.registerFlag("WEBGL_MAX_TEXTURES_IN_SHADER",(()=>function(e){if(null==rC){const t=_E(e);rC=t.getParameter(t.MAX_TEXTURE_IMAGE_UNITS)}return Math.min(16,rC)}(uC.getNumber("WEBGL_VERSION")))),uC.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION",(()=>{const e=uC.getNumber("WEBGL_VERSION");return 0===e?0:function(e){if(0===e)return 0;let t;const n=_E(e);return t=sC(n,"EXT_disjoint_timer_query_webgl2")&&2===e?2:sC(n,"EXT_disjoint_timer_query")?1:0,t}(e)})),uC.registerFlag("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE",(()=>uC.getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0&&!ds())),uC.registerFlag("WEBGL_RENDER_FLOAT32_CAPABLE",(()=>function(e){if(0===e)return!1;const t=_E(e);if(1===e){if(!sC(t,"OES_texture_float"))return!1}else if(!sC(t,"EXT_color_buffer_float"))return!1;return cC(t)}(uC.getNumber("WEBGL_VERSION")))),uC.registerFlag("WEBGL_RENDER_FLOAT32_ENABLED",(()=>!uC.getBool("WEBGL_FORCE_F16_TEXTURES")&&uC.getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))),uC.registerFlag("WEBGL_DOWNLOAD_FLOAT_ENABLED",(()=>iC(uC.getNumber("WEBGL_VERSION")))),uC.registerFlag("WEBGL_FENCE_API_ENABLED",(()=>{return 2===(e=uC.getNumber("WEBGL_VERSION"))&&null!=_E(e).fenceSync;var e})),uC.registerFlag("WEBGL_SIZE_UPLOAD_UNIFORM",(()=>uC.getBool("WEBGL_RENDER_FLOAT32_ENABLED")?4:0)),uC.registerFlag("WEBGL_DELETE_TEXTURE_THRESHOLD",(()=>-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be a number but "+"got ".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_DELETE_TEXTURE_THRESHOLD must be -1 (indicating never "+"delete) or at least 0, but got ".concat(e,"."))})),uC.registerFlag("WEBGL_FLUSH_THRESHOLD",(()=>ds()?1:-1),(e=>{if("number"!==typeof e)throw new Error("WEBGL_FLUSH_THRESHOLD must be a number but got "+"".concat(e,"."));if(e<0&&-1!==e)throw new Error("WEBGL_FLUSH_THRESHOLD must be -1 (indicating never "+"manual flush) or at least 0, but got ".concat(e,"."))})),uC.registerFlag("CPU_HANDOFF_SIZE_THRESHOLD",(()=>128)),uC.registerFlag("WEBGL_USE_SHAPES_UNIFORMS",(()=>!1)),uC.registerFlag("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD",(()=>1e5)),uC.registerFlag("TOPK_K_CPU_HANDOFF_THRESHOLD",(()=>128)),uC.registerFlag("WEBGL_EXP_CONV",(()=>!1)),uC.registerFlag("SOFTWARE_WEBGL_ENABLED",(()=>uC.getBool("IS_TEST"))),uC.registerFlag("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE",(()=>1/0)),uC.registerFlag("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE",(()=>!1)),uC.registerFlag("WEBGL2_ISNAN_CUSTOM",(()=>!1)),uC.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1));const gC="\n  const float FLOAT_MAX = 1.70141184e38;\n  const float FLOAT_MIN = 1.17549435e-38;\n\n  lowp vec4 encode_float(highp float v) {\n    if (isnan(v)) {\n      return vec4(255, 255, 255, 255);\n    }\n\n    highp float av = abs(v);\n\n    if(av < FLOAT_MIN) {\n      return vec4(0.0, 0.0, 0.0, 0.0);\n    } else if(v > FLOAT_MAX) {\n      return vec4(0.0, 0.0, 128.0, 127.0) / 255.0;\n    } else if(v < -FLOAT_MAX) {\n      return vec4(0.0, 0.0,  128.0, 255.0) / 255.0;\n    }\n\n    highp vec4 c = vec4(0,0,0,0);\n\n    highp float e = floor(log2(av));\n    highp float m = exp2(fract(log2(av))) - 1.0;\n\n    c[2] = floor(128.0 * m);\n    m -= c[2] / 128.0;\n    c[1] = floor(32768.0 * m);\n    m -= c[1] / 32768.0;\n    c[0] = floor(8388608.0 * m);\n\n    highp float ebias = e + 127.0;\n    c[3] = floor(ebias / 2.0);\n    ebias -= c[3] * 2.0;\n    c[2] += floor(ebias) * 128.0;\n\n    c[3] += 128.0 * step(0.0, -v);\n\n    return c / 255.0;\n  }\n",{getBroadcastDims:yC}=a;function bC(e,t,n){const a=[];if(e.forEach((e=>{const t=ee(e.shapeInfo.logicalShape);if(e.shapeInfo.isUniform?a.push("uniform float ".concat(e.name).concat(t>1?"[".concat(t,"]"):"",";")):(a.push("uniform sampler2D ".concat(e.name,";")),a.push("uniform int offset".concat(e.name,";"))),n.enableShapeUniforms){const{uniformShape:t}=CC(n.packedInputs,e.shapeInfo.logicalShape,e.shapeInfo.texShape);switch(t.length){case 1:a.push("uniform int ".concat(e.name,"Shape;"));break;case 2:a.push("uniform ivec2 ".concat(e.name,"Shape;"));break;case 3:a.push("uniform ivec3 ".concat(e.name,"Shape;"));break;case 4:a.push("uniform ivec4 ".concat(e.name,"Shape;"))}a.push("uniform ivec2 ".concat(e.name,"TexShape;"))}})),n.enableShapeUniforms){switch(t.logicalShape.length){case 1:a.push("uniform int outShape;");break;case 2:a.push("uniform ivec2 outShape;"),a.push("uniform int outShapeStrides;");break;case 3:a.push("uniform ivec3 outShape;"),a.push("uniform ivec2 outShapeStrides;");break;case 4:a.push("uniform ivec4 outShape;"),a.push("uniform ivec3 outShapeStrides;")}a.push("uniform ivec2 outTexShape;")}n.customUniforms&&n.customUniforms.forEach((e=>{a.push("uniform ".concat(e.type," ").concat(e.name).concat(e.arrayIndex?"[".concat(e.arrayIndex,"]"):"",";"))}));const r=a.join("\n"),s=e.map((e=>function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3?arguments[3]:void 0,r="";r+=n?xC(e,a):vC(e,a);const s=e.shapeInfo.logicalShape,o=t.logicalShape;s.length<=o.length&&(r+=n?function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=e.shapeInfo.logicalShape.length,o=t.logicalShape.length,i=yC(e.shapeInfo.logicalShape,t.logicalShape),c=EC(o),l=o-s;let u;const h=["x","y","z","w","u","v"];u=0===s?"":o<2&&i.length>=1?"coords = 0;":i.map((e=>"coords.".concat(h[e+l]," = 0;"))).join("\n");let d="";d=o<2&&s>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(h[t+l]))).join(", ");let p="return outputValue;";const f=1===ee(e.shapeInfo.logicalShape),m=ee(t.logicalShape),g=1===m;if(1!==s||f||g){if(f&&!g)p=1===o?"\n        return vec4(outputValue.x, outputValue.x, 0., 0.);\n      ":"\n        return vec4(outputValue.x);\n      ";else if(i.length){const e=s-2,t=s-1;i.indexOf(e)>-1&&i.indexOf(t)>-1?p="return vec4(outputValue.x);":i.indexOf(e)>-1?p="return vec4(outputValue.x, outputValue.y, outputValue.x, outputValue.y);":i.indexOf(t)>-1&&(p="return vec4(outputValue.xx, outputValue.zz);")}}else p="\n      return vec4(outputValue.xy, outputValue.xy);\n    ";return"\n    vec4 ".concat(r,"() {\n      ").concat(c," coords = getOutputCoords();\n      ").concat(u,"\n      vec4 outputValue = get").concat(a,"(").concat(d,");\n      ").concat(p,"\n    }\n  ")}(e,t):function(e,t){const n=e.name,a=n.charAt(0).toUpperCase()+n.slice(1),r="get"+a+"AtOutCoords",s=t.texShape,o=e.shapeInfo.texShape,i=e.shapeInfo.logicalShape.length,c=t.logicalShape.length;if(!e.shapeInfo.isUniform&&i===c&&null==e.shapeInfo.flatOffset&&te(o,s))return"\n      float ".concat(r,"() {\n        return sampleTexture(").concat(n,", resultUV);\n      }\n    ");const l=EC(c),u=yC(e.shapeInfo.logicalShape,t.logicalShape),h=c-i;let d;const p=["x","y","z","w","u","v"];d=0===i?"":c<2&&u.length>=1?"coords = 0;":u.map((e=>"coords.".concat(p[e+h]," = 0;"))).join("\n");let f="";f=c<2&&i>0?"coords":e.shapeInfo.logicalShape.map(((e,t)=>"coords.".concat(p[t+h]))).join(", ");return"\n    float ".concat(r,"() {\n      ").concat(l," coords = getOutputCoords();\n      ").concat(d,"\n      return get").concat(a,"(").concat(f,");\n    }\n  ")}(e,t));return r}(e,t,n.packedInputs,n.enableShapeUniforms))).join("\n"),o=t.texShape,i=hC(),c=function(e){return"\n    float sampleTexture(sampler2D textureSampler, vec2 uv) {\n      return ".concat(e.texture2D,"(textureSampler, uv).r;\n    }\n  ")}(i);let l,u,h=function(e){const t="".concat(e.version,"\n    precision highp float;\n    precision highp int;\n    precision highp sampler2D;\n    ").concat(e.varyingFs," vec2 resultUV;\n    ").concat(e.defineOutput,"\n    const vec2 halfCR = vec2(0.5, 0.5);\n\n    struct ivec5\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n    };\n\n    struct ivec6\n    {\n      int x;\n      int y;\n      int z;\n      int w;\n      int u;\n      int v;\n    };\n\n    uniform float NAN;\n    ").concat(e.defineSpecialNaN,"\n    ").concat(e.defineSpecialInf,"\n    ").concat(e.defineRound,"\n\n    int imod(int x, int y) {\n      return x - y * (x / y);\n    }\n\n    int idiv(int a, int b, float sign) {\n      int res = a / b;\n      int mod = imod(a, b);\n      if (sign < 0. && mod != 0) {\n        res -= 1;\n      }\n      return res;\n    }\n\n    //Based on the work of Dave Hoskins\n    //https://www.shadertoy.com/view/4djSRW\n    #define HASHSCALE1 443.8975\n    float random(float seed){\n      vec2 p = resultUV * seed;\n      vec3 p3  = fract(vec3(p.xyx) * HASHSCALE1);\n      p3 += dot(p3, p3.yzx + 19.19);\n      return fract((p3.x + p3.y) * p3.z);\n    }\n\n    ").concat(wC,"\n    ").concat(kC,"\n    ").concat(SC,"\n  ");return t}(i);t.isPacked?(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(1===a[0])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ceil(float(outTexShape[1]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.x * ".concat(a[1],".0);\n      }\n    ");if(1===a[1])return n?"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ceil(float(outTexShape[0]) / 2.0));\n      }\n    ":"\n      int getOutputCoords() {\n        return 2 * int(resultUV.y * ".concat(a[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      return 2 * (resTexRC.x * packedTexShape[1] + resTexRC.y);\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      return 2 * (resTexRC.x * ").concat(a[1]," + resTexRC.y);\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)];if(te(e,t))return n?"\n      ivec2 getOutputCoords() {\n        ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n        return 2 * ivec2(resultUV.yx * vec2(packedTexShape[0], packedTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return 2 * ivec2(resultUV.yx * vec2(".concat(a[0],", ").concat(a[1],"));\n      }\n    ");const r=Math.ceil(e[1]/2);if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n)return"\n    ivec3 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      int texelsInLogicalRow = int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec3(b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[2]/2),s=r*Math.ceil(e[1]/2);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec3(b, r, c);\n    }\n  ")}(e,t,n);default:return function(e,t,n){if(n)return"\n    ivec4 getOutputCoords() {\n      ivec2 packedTexShape = ivec2(ceil(float(outTexShape[0]) / 2.0), ceil(float(outTexShape[1]) / 2.0));\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(packedTexShape[0], packedTexShape[1]));\n      int index = resTexRC.x * packedTexShape[1] + resTexRC.y;\n\n      int texelsInLogicalRow = int(ceil(float(outShape[3]) / 2.0));\n      int texelsInBatch = texelsInLogicalRow * int(ceil(float(outShape[2]) / 2.0));\n      int texelsInBatchN = texelsInBatch * outShape[1];\n\n      int b2 = index / texelsInBatchN;\n      index -= b2 * texelsInBatchN;\n\n      int b = index / texelsInBatch;\n      index -= b * texelsInBatch;\n\n      int r = 2 * (index / texelsInLogicalRow);\n      int c = imod(index, texelsInLogicalRow) * 2;\n\n      return ivec4(b2, b, r, c);\n    }\n  ";const a=[Math.ceil(t[0]/2),Math.ceil(t[1]/2)],r=Math.ceil(e[e.length-1]/2),s=r*Math.ceil(e[e.length-2]/2);let o=s,i="",c="b, r, c";for(let l=2;l<e.length-1;l++)o*=e[e.length-l-1],i="\n      int b".concat(l," = index / ").concat(o,";\n      index -= b").concat(l," * ").concat(o,";\n    ")+i,c="b".concat(l,", ")+c;return"\n    ivec".concat(e.length," getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(").concat(a[0],", ").concat(a[1],"));\n      int index = resTexRC.x * ").concat(a[1]," + resTexRC.y;\n\n      ").concat(i,"\n\n      int b = index / ").concat(s,";\n      index -= b * ").concat(s,";\n\n      int r = 2 * (index / ").concat(r,");\n      int c = imod(index, ").concat(r,") * 2;\n\n      return ivec").concat(e.length,"(").concat(c,");\n    }\n  ")}(e,t,n)}}(t.logicalShape,o,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(vec4 val) {\n      ".concat(e.output," = val;\n    }\n  ")}(i)):(l=function(e,t,n){switch(e.length){case 0:return"\n    int getOutputCoords() {\n      return 0;\n    }\n  ";case 1:return function(e,t,n){if(1===t[0])return n?"\n      int getOutputCoords() {\n        return int(resultUV.x * float(outTexShape[1]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.x * ".concat(t[1],".0);\n      }\n    ");if(1===t[1])return n?"\n      int getOutputCoords() {\n        return int(resultUV.y * float(outTexShape[0]));\n      }\n    ":"\n      int getOutputCoords() {\n        return int(resultUV.y * ".concat(t[0],".0);\n      }\n    ");if(n)return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      return resTexRC.x * outTexShape[1] + resTexRC.y;\n    }\n  ";return"\n    int getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      return resTexRC.x * ").concat(t[1]," + resTexRC.y;\n    }\n  ")}(0,t,n);case 2:return function(e,t,n){if(te(e,t))return n?"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(outTexShape[0], outTexShape[1]));\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        return ivec2(resultUV.yx * vec2(".concat(t[0],", ").concat(t[1],"));\n      }\n    ");if(1===e[1])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(index, 0);\n      }\n    ");if(1===e[0])return n?"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(outTexShape[0], outTexShape[1]));\n        int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ":"\n      ivec2 getOutputCoords() {\n        ivec2 resTexRC = ivec2(resultUV.yx *\n                               vec2(".concat(t[0],", ").concat(t[1],"));\n        int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n        return ivec2(0, index);\n      }\n    ");if(n)return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      int r = index / outShape[1];\n      int c = index - r * outShape[1];\n      return ivec2(r, c);\n    }\n  ";return"\n    ivec2 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      int r = index / ").concat(e[1],";\n      int c = index - r * ").concat(e[1],";\n      return ivec2(r, c);\n    }\n  ")}(e,t,n);case 3:return function(e,t,n){if(n){const t=pC(["r","c","d"],e);return"\n  ivec3 getOutputCoords() {\n    ivec2 resTexRC = ivec2(resultUV.yx *\n                           vec2(outTexShape[0], outTexShape[1]));\n    int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n    ".concat(t,"\n    return ivec3(r, c, d);\n  }\n")}const a=dC(["r","c","d"],e);return"\n    ivec3 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n                             vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec3(r, c, d);\n    }\n  ")}(e,t,n);case 4:return function(e,t,n){if(n){const t=pC(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(outTexShape[0], outTexShape[1]));\n      int index = resTexRC.x * outTexShape[1] + resTexRC.y;\n      ".concat(t,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}const a=dC(["r","c","d","d2"],e);return"\n    ivec4 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n      ").concat(a,"\n      return ivec4(r, c, d, d2);\n    }\n  ")}(e,t,n);case 5:return function(e,t){const n=dC(["r","c","d","d2","d3"],e);return"\n    ivec5 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx * vec2(".concat(t[0],",\n                             ").concat(t[1],"));\n\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec5 outShape = ivec5(r, c, d, d2, d3);\n      return outShape;\n    }\n  ")}(e,t);case 6:return function(e,t){const n=dC(["r","c","d","d2","d3","d4"],e);return"\n    ivec6 getOutputCoords() {\n      ivec2 resTexRC = ivec2(resultUV.yx *\n        vec2(".concat(t[0],", ").concat(t[1],"));\n      int index = resTexRC.x * ").concat(t[1]," + resTexRC.y;\n\n      ").concat(n,"\n\n      ivec6 result = ivec6(r, c, d, d2, d3, d4);\n      return result;\n    }\n  ")}(e,t);default:throw new Error("".concat(e.length,"-D output sampling is not yet supported"))}}(t.logicalShape,o,n.enableShapeUniforms),u=function(e){return"\n    void setOutput(float val) {\n      ".concat(e.output," = vec4(val, 0, 0, 0);\n    }\n  ")}(i)),n.packedInputs&&(h+=IC);return[h,c,u,r,l,s,n.userCode].join("\n")}function vC(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const n=e.shapeInfo.logicalShape;switch(n.length){case 0:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"float ".concat(a,"() {return ").concat(n,";}");const[r,s]=e.shapeInfo.texShape;if(1===r&&1===s)return"\n      float ".concat(a,"() {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const o=NC(n);if(t)return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");const[i,c]=e.shapeInfo.texShape;return"\n    float ".concat(a,"() {\n      vec2 uv = uvFromFlat(").concat(i,", ").concat(c,", ").concat(o,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1);if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int index) {\n        ").concat(TC(e),"\n      }\n    ");const r=e.shapeInfo.texShape,s=r[0],o=r[1];if(1===o&&1===s)return"\n      float ".concat(a,"(int index) {\n        return sampleTexture(").concat(n,", halfCR);\n      }\n    ");const i=NC(n);if(1===o)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[0]));\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2(0.5, (float(index + ").concat(i,") + 0.5) / ").concat(s,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(1===s)return t?"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / float(").concat(n,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    "):"\n      float ".concat(a,"(int index) {\n        vec2 uv = vec2((float(index + ").concat(i,") + 0.5) / ").concat(o,".0, 0.5);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(t)return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(n,"TexShape[0], ").concat(n,"TexShape[1], index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ");return"\n    float ".concat(a,"(int index) {\n      vec2 uv = uvFromFlat(").concat(s,", ").concat(o,", index + ").concat(i,");\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape;if(null!=s&&te(n,s)){if(t)return"\n      float ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const e=s[0],n=s[1];return"\n    float ".concat(r,"(int row, int col) {\n      vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(n,".0, ").concat(e,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}const{newShape:o,keptDims:i}=ce(n),c=o;if(c.length<n.length){const n=RC(e,c),a=["row","col"];return"\n      ".concat(vC(n,t),"\n      float ").concat(r,"(int row, int col) {\n        return ").concat(r,"(").concat(AC(a,i),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col) {\n        int index = round(dot(vec2(row, col), vec2(").concat(n[1],", 1)));\n        ").concat(TC(e),"\n      }\n    ");const l=s[0],u=s[1],h=NC(a);if(1===u)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2(0.5, (index + 0.5) / float(").concat(a,"TexShape[0]));\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2(0.5, (index + 0.5) / ").concat(l,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(1===l)return t?"\n      float ".concat(r,"(int row, int col) {\n        float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(a,"Shape[1], 1, 1));\n        vec2 uv = vec2((index + 0.5) / float(").concat(a,"TexShape[1]), 0.5);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col) {\n      float index = dot(vec3(row, col, ").concat(h,"), vec3(").concat(n[1],", 1, 1));\n      vec2 uv = vec2((index + 0.5) / ").concat(u,".0, 0.5);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");if(t)return"\n      float ".concat(r,"(int row, int col) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(a,"Shape[1] + col + ").concat(h,";\n        vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");return"\n  float ".concat(r,"(int row, int col) {\n    // Explicitly use integer operations as dot() only works on floats.\n    int index = row * ").concat(n[1]," + col + ").concat(h,";\n    vec2 uv = uvFromFlat(").concat(l,", ").concat(u,", index);\n    return sampleTexture(").concat(a,", uv);\n  }\n")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[1]*n[2],o=n[2],{newShape:i,keptDims:c}=ce(n),l=i;if(l.length<n.length){const n=RC(e,l),a=["row","col","depth"];return"\n        ".concat(vC(n,t),"\n        float ").concat(r,"(int row, int col, int depth) {\n          return ").concat(r,"(").concat(AC(a,c),");\n        }\n      ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth) {\n        int index = round(dot(vec3(row, col, depth),\n                          vec3(").concat(s,", ").concat(o,", 1)));\n        ").concat(TC(e),"\n      }\n    ");const u=e.shapeInfo.texShape,h=u[0],d=u[1],p=e.shapeInfo.flatOffset;if(d===s&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        int stride1 = ").concat(a,"Shape[2];\n        float texR = float(row);\n        float texC = dot(vec2(col, depth), vec2(stride1, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n        float ".concat(r,"(int row, int col, int depth) {\n          float texR = float(row);\n          float texC = dot(vec2(col, depth), vec2(").concat(o,", 1));\n          vec2 uv = (vec2(texC, texR) + halfCR) /\n                     vec2(").concat(d,".0, ").concat(h,".0);\n          return sampleTexture(").concat(a,", uv);\n        }\n      ");if(d===o&&null==p)return t?"\n      float ".concat(r,"(int row, int col, int depth) {\n        float texR = dot(vec2(row, col), vec2(").concat(a,"Shape[1], 1));\n        float texC = float(depth);\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n    float ".concat(r,"(int row, int col, int depth) {\n      float texR = dot(vec2(row, col), vec2(").concat(n[1],", 1));\n      float texC = float(depth);\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(d,".0, ").concat(h,".0);\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");const f=NC(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int stride0 = ").concat(a,"Shape[1] * ").concat(a,"Shape[2];\n      int stride1 = ").concat(a,"Shape[2];\n      int index = row * stride0 + col * stride1 + depth + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index);\n      return sampleTexture(").concat(a,", uv);\n    }\n    ");return"\n      float ".concat(r,"(int row, int col, int depth) {\n        // Explicitly use integer operations as dot() only works on floats.\n        int index = row * ").concat(s," + col * ").concat(o," + depth + ").concat(f,";\n        vec2 uv = uvFromFlat(").concat(h,", ").concat(d,", index);\n        return sampleTexture(").concat(a,", uv);\n      }\n  ")}(e,t);case 4:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=n[3],o=n[2]*s,i=n[1]*o,{newShape:c,keptDims:l}=ce(n);if(c.length<n.length){const n=RC(e,c),a=["row","col","depth","depth2"];return"\n      ".concat(vC(n,t),"\n      float ").concat(r,"(int row, int col, int depth, int depth2) {\n        return ").concat(r,"(").concat(AC(a,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        int index = round(dot(vec4(row, col, depth, depth2),\n                          vec4(").concat(i,", ").concat(o,", ").concat(s,", 1)));\n        ").concat(TC(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1],f="int stride2 = ".concat(a,"Shape[3];"),m="int stride1 = ".concat(a,"Shape[2] * stride2;"),g="int stride0 = ".concat(a,"Shape[1] * stride1;");if(p===i&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        ").concat(f,"\n        ").concat(m,"\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(stride1, stride2, 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = float(row);\n        float texC =\n            dot(vec3(col, depth, depth2),\n                vec3(").concat(o,", ").concat(s,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");if(p===s&&null==u)return t?"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(a,"Shape[1] * ").concat(a,"Shape[2], ").concat(a,"Shape[2], 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n        return sampleTexture(").concat(a,", uv);\n      }\n    "):"\n      float ".concat(r,"(int row, int col, int depth, int depth2) {\n        float texR = dot(vec3(row, col, depth),\n                         vec3(").concat(n[1]*n[2],", ").concat(n[2],", 1));\n        float texC = float(depth2);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(a,", uv);\n      }\n    ");const y=NC(a);if(t)return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      ").concat(f,"\n      ").concat(m,"\n      ").concat(g,"\n      int index = row * stride0 + col * stride1 +\n          depth * stride2 + depth2;\n      vec2 uv = uvFromFlat(").concat(a,"TexShape[0], ").concat(a,"TexShape[1], index + ").concat(y,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ");return"\n    float ".concat(r,"(int row, int col, int depth, int depth2) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(o," +\n          depth * ").concat(s," + depth2;\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index + ").concat(y,");\n      return sampleTexture(").concat(a,", uv);\n    }\n  ")}(e,t);case 5:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=t[4],s=t[3]*r,o=t[2]*s,i=t[1]*o,{newShape:c,keptDims:l}=ce(t);if(c.length<t.length){const t=RC(e,c),n=["row","col","depth","depth2","depth3"];return"\n      ".concat(vC(t),"\n      float ").concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        return ").concat(a,"(").concat(AC(n,l),");\n      }\n    ")}if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float index = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(i,", ").concat(o,", ").concat(s,", ").concat(r,")) +\n          depth3;\n        ").concat(TC(e),"\n      }\n    ");const u=e.shapeInfo.flatOffset,h=e.shapeInfo.texShape,d=h[0],p=h[1];if(p===i&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n                         vec4(").concat(o,", ").concat(s,", ").concat(r,", 1));\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(p===r&&null==u)return"\n      float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n        float texR = dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3],",\n               ").concat(t[2]*t[3],", ").concat(t[3],", 1));\n        int texC = depth3;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(p,".0, ").concat(d,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const f=NC(n);return"\n    float ".concat(a,"(int row, int col, int depth, int depth2, int depth3) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(i," + col * ").concat(o," + depth * ").concat(s," +\n          depth2 * ").concat(r," + depth3 + ").concat(f,";\n      vec2 uv = uvFromFlat(").concat(d,", ").concat(p,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);case 6:return function(e){const t=e.shapeInfo.logicalShape,n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),{newShape:r,keptDims:s}=ce(t);if(r.length<t.length){const t=RC(e,r),n=["row","col","depth","depth2","depth3","depth4"];return"\n      ".concat(vC(t),"\n      float ").concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        return ").concat(a,"(").concat(AC(n,s),");\n      }\n    ")}const o=t[5],i=t[4]*o,c=t[3]*i,l=t[2]*c,u=t[1]*l;if(e.shapeInfo.isUniform)return"\n      float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n        int index = round(dot(\n          vec4(row, col, depth, depth2),\n          vec4(").concat(u,", ").concat(l,", ").concat(c,", ").concat(i,")) +\n          dot(\n            vec2(depth3, depth4),\n            vec2(").concat(o,", 1)));\n        ").concat(TC(e),"\n      }\n    ");const h=e.shapeInfo.flatOffset,d=e.shapeInfo.texShape,p=d[0],f=d[1];if(f===u&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        int texR = row;\n        float texC = dot(vec4(col, depth, depth2, depth3),\n          vec4(").concat(l,", ").concat(c,", ").concat(i,", ").concat(o,")) +\n               float(depth4);\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                   vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");if(f===o&&null==h)return"\n      float ".concat(a,"(int row, int col, int depth,\n                    int depth2, int depth3, int depth4) {\n        float texR = dot(vec4(row, col, depth, depth2),\n          vec4(").concat(t[1]*t[2]*t[3]*t[4],",\n               ").concat(t[2]*t[3]*t[4],",\n               ").concat(t[3]*t[4],",\n               ").concat(t[4],")) + float(depth3);\n        int texC = depth4;\n        vec2 uv = (vec2(texC, texR) + halfCR) /\n                  vec2(").concat(f,".0, ").concat(p,".0);\n        return sampleTexture(").concat(n,", uv);\n      }\n    ");const m=NC(n);return"\n    float ".concat(a,"(int row, int col, int depth,\n                  int depth2, int depth3, int depth4) {\n      // Explicitly use integer operations as dot() only works on floats.\n      int index = row * ").concat(u," + col * ").concat(l," + depth * ").concat(c," +\n          depth2 * ").concat(i," + depth3 * ").concat(o," + depth4 + ").concat(m,";\n      vec2 uv = uvFromFlat(").concat(p,", ").concat(f,", index);\n      return sampleTexture(").concat(n,", uv);\n    }\n  ")}(e);default:throw new Error("".concat(n.length,"-D input sampling")+" is not yet supported")}}function xC(e,t){switch(e.shapeInfo.logicalShape.length){case 0:return function(e){const t=e.name,n="get"+t.charAt(0).toUpperCase()+t.slice(1),a=hC();return"\n    vec4 ".concat(n,"() {\n      return ").concat(a.texture2D,"(").concat(t,", halfCR);\n    }\n  ")}(e);case 1:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=e.shapeInfo.texShape,s=hC();if(t)return"\n    vec4 ".concat(a,"(int index) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      vec2 uv = packedUVfrom1D(\n        packedTexShape[0], packedTexShape[1], index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ");const o=[Math.ceil(r[0]/2),Math.ceil(r[1]/2)];return"\n    vec4 ".concat(a,"(int index) {\n      vec2 uv = packedUVfrom1D(\n        ").concat(o[0],", ").concat(o[1],", index);\n      return ").concat(s.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t);case 2:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,o=s[0],i=s[1],c=hC();if(null!=s&&te(n,s))return t?"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(a,"TexShape[1], ").concat(a,"TexShape[0]);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    "):"\n      vec4 ".concat(r,"(int row, int col) {\n        vec2 uv = (vec2(col, row) + halfCR) / vec2(").concat(i,".0, ").concat(o,".0);\n\n        return ").concat(c.texture2D,"(").concat(a,", uv);\n      }\n    ");if(t)return"\n    vec4 ".concat(r,"(int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom2D(valuesPerRow, packedTexShape[0], packedTexShape[1], row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ");const l=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)],u=Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int row, int col) {\n      vec2 uv = packedUVfrom2D(").concat(u,", ").concat(l[0],", ").concat(l[1],", row, col);\n      return ").concat(c.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);case 3:return function(e,t){const n=e.shapeInfo.logicalShape,a=e.name,r="get"+a.charAt(0).toUpperCase()+a.slice(1),s=e.shapeInfo.texShape,o=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];if(1===n[0]){const a=[1,2],s=RC(e,n.slice(1)),o=["b","row","col"];return"\n        ".concat(xC(s,t),"\n        vec4 ").concat(r,"(int b, int row, int col) {\n          return ").concat(r,"(").concat(AC(o,a),");\n        }\n      ")}const i=hC();if(t)return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(a,"TexShape[0]) / 2.0), ceil(float(").concat(a,"TexShape[1]) / 2.0));\n      int valuesPerRow = int(ceil(float(").concat(a,"Shape[2]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(a,"Shape[1]) / 2.0));\n      vec2 uv = packedUVfrom3D(\n        packedTexShape[0], packedTexShape[1], texelsInBatch, valuesPerRow, b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ");const c=o[0],l=o[1],u=Math.ceil(n[2]/2),h=u*Math.ceil(n[1]/2);return"\n    vec4 ".concat(r,"(int b, int row, int col) {\n      vec2 uv = packedUVfrom3D(\n        ").concat(c,", ").concat(l,", ").concat(h,", ").concat(u,", b, row, col);\n      return ").concat(i.texture2D,"(").concat(a,", uv);\n    }\n  ")}(e,t);default:return function(e,t){const n=e.name,a="get"+n.charAt(0).toUpperCase()+n.slice(1),r=hC();if(t)return"\n    vec4 ".concat(a,"(int b2, int b, int row, int col) {\n      int valuesPerRow = int(ceil(float(").concat(n,"Shape[3]) / 2.0));\n      int texelsInBatch = valuesPerRow * int(ceil(float(").concat(n,"Shape[2]) / 2.0));\n      int index = b * texelsInBatch + (row / 2) * valuesPerRow + (col / 2);\n      texelsInBatch *= ").concat(n,"Shape[1];\n      index = b2 * texelsInBatch + index;\n      ivec2 packedTexShape = ivec2(ceil(float(").concat(n,"TexShape[0]) / 2.0), ceil(float(").concat(n,"TexShape[1]) / 2.0));\n      int texR = index / packedTexShape[1];\n      int texC = index - texR * packedTexShape[1];\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(packedTexShape[1], packedTexShape[0]); return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ");const s=e.shapeInfo.logicalShape,o=s.length,i=e.shapeInfo.texShape,c=[Math.ceil(i[0]/2),Math.ceil(i[1]/2)],l=c[0],u=c[1],h=Math.ceil(s[o-1]/2);let d=h*Math.ceil(s[o-2]/2),p="int b, int row, int col",f="b * ".concat(d," + (row / 2) * ").concat(h," + (col / 2)");for(let m=2;m<o-1;m++)p="int b".concat(m,", ")+p,d*=s[o-m-1],f="b".concat(m," * ").concat(d," + ")+f;return"\n    vec4 ".concat(a,"(").concat(p,") {\n      int index = ").concat(f,";\n      int texR = index / ").concat(u,";\n      int texC = index - texR * ").concat(u,";\n      vec2 uv = (vec2(texC, texR) + halfCR) / vec2(").concat(u,", ").concat(l,");\n      return ").concat(r.texture2D,"(").concat(n,", uv);\n    }\n  ")}(e,t)}}const wC="\nvec2 uvFromFlat(int texNumR, int texNumC, int index) {\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\nvec2 packedUVfrom1D(int texNumR, int texNumC, int index) {\n  int texelIndex = index / 2;\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",kC="\nvec2 packedUVfrom2D(int texelsInLogicalRow, int texNumR,\n  int texNumC, int row, int col) {\n  int texelIndex = (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = texelIndex / texNumC;\n  int texC = texelIndex - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",SC="\nvec2 packedUVfrom3D(int texNumR, int texNumC,\n    int texelsInBatch, int texelsInLogicalRow, int b,\n    int row, int col) {\n  int index = b * texelsInBatch + (row / 2) * texelsInLogicalRow + (col / 2);\n  int texR = index / texNumC;\n  int texC = index - texR * texNumC;\n  return (vec2(texC, texR) + halfCR) / vec2(texNumC, texNumR);\n}\n",IC="\n  float getChannel(vec4 frag, vec2 innerDims) {\n    vec2 modCoord = mod(innerDims, 2.);\n    return modCoord.x == 0. ?\n      (modCoord.y == 0. ? frag.r : frag.g) :\n      (modCoord.y == 0. ? frag.b : frag.a);\n  }\n  float getChannel(vec4 frag, int dim) {\n    float modCoord = mod(float(dim), 2.);\n    return modCoord == 0. ? frag.r : frag.g;\n  }\n";function NC(e){return"offset".concat(e)}function TC(e){const t=e.name,n=ee(e.shapeInfo.logicalShape);return n<2?"return ".concat(t,";"):"\n    for (int i = 0; i < ".concat(n,"; i++) {\n      if (i == index) {\n        return ").concat(t,"[i];\n      }\n    }\n  ")}function EC(e){if(e<=1)return"int";if(2===e)return"ivec2";if(3===e)return"ivec3";if(4===e)return"ivec4";if(5===e)return"ivec5";if(6===e)return"ivec6";throw Error("GPU for rank ".concat(e," is not yet supported"))}function CC(e,t,n){const{newShape:a,keptDims:r}=ce(t),s=t.length,o=e&&3===s&&1===t[0],i=o?t.slice(1):a,c=!e&&s>1&&!te(t,n)&&a.length<s||o;return{useSqueezeShape:c,uniformShape:c?i:t,keptDims:r}}function RC(e,t){const n=JSON.parse(JSON.stringify(e));return n.shapeInfo.logicalShape=t,n}function AC(e,t){return t.map((t=>e[t])).join(", ")}function _C(e,t,n,a){const r=n.map(((e,n)=>{const a={logicalShape:e.shape,texShape:e.isUniform?null:e.texData.texShape,isUniform:e.isUniform,isPacked:!e.isUniform&&e.texData.isPacked,flatOffset:null};return null!=e.texData&&null!=e.texData.slice&&e.texData.slice.flatOffset>0&&(a.flatOffset=e.texData.slice.flatOffset),{name:t.variableNames[n],shapeInfo:a}})),s=r.map((e=>e.shapeInfo)),o={logicalShape:a.shape,texShape:a.texData.texShape,isUniform:!1,isPacked:a.texData.isPacked,flatOffset:null},i=bC(r,o,t),c=function(e,t){const n=QE(e,(()=>e.createShader(e.FRAGMENT_SHADER)),"Unable to create fragment WebGLShader.");if(BE(e,(()=>e.shaderSource(n,t))),BE(e,(()=>e.compileShader(n))),_e().get("ENGINE_COMPILE_ONLY"))return n;if(!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw GE(t,e.getShaderInfoLog(n)),new Error("Failed to compile fragment shader.");return n}(e.gl,i),l=e.createProgram(c);return _e().get("ENGINE_COMPILE_ONLY")?{program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:o,variablesLocations:null,customUniformLocations:null,infLoc:null,nanLoc:null,outShapeLocation:null,outShapeStridesLocation:null,outTexShapeLocation:null}:(e.buildVao(l),Object.assign({program:t,fragmentShader:c,source:i,webGLProgram:l,inShapeInfos:s,outShapeInfo:o},DC(e,t,l)))}function DC(e,t,n){const a=[],r=[];let s,o,i,c=null,l=null;l=e.getUniformLocation(n,"NAN",!1),1===_e().getNumber("WEBGL_VERSION")&&(c=e.getUniformLocation(n,"INFINITY",!1));const u=!1;for(const h of t.variableNames){const r={name:h,uniform:e.getUniformLocation(n,h,u),offset:e.getUniformLocation(n,"offset".concat(h),u)};t.enableShapeUniforms&&(r.shape=e.getUniformLocation(n,"".concat(h,"Shape"),u),r.texShape=e.getUniformLocation(n,"".concat(h,"TexShape"),u)),a.push(r)}if(t.enableShapeUniforms&&(s=e.getUniformLocation(n,"outShape",u),i=e.getUniformLocation(n,"outShapeStrides",u),o=e.getUniformLocation(n,"outTexShape",u)),t.customUniforms)for(const h of t.customUniforms)r.push(e.getUniformLocation(n,h.name,u));return{variablesLocations:a,customUniformLocations:r,infLoc:c,nanLoc:l,outShapeLocation:s,outShapeStridesLocation:i,outTexShapeLocation:o}}function FC(e,t){if(e.length!==t.length)throw Error("Binary was compiled with ".concat(e.length," inputs, but ")+"was executed with ".concat(t.length," inputs"));e.forEach(((e,n)=>{const a=e.logicalShape,r=t[n],s=r.shape;if(!te(a,s))throw Error("Binary was compiled with different shapes than "+"the current args. Shapes ".concat(a," and ").concat(s," must match"));if(e.isUniform&&r.isUniform)return;const o=e.texShape,i=r.isUniform?null:r.texData.texShape;if(!te(o,i))throw Error("Binary was compiled with different texture shapes than the"+" current args. Shape ".concat(o," and ").concat(i," must match"))}))}function OC(e){return _e().getBool("WEBGL_USE_SHAPES_UNIFORMS")&&e<=4}class MC{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outPackingScheme=DE.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=hC();this.outputShape=e,this.enableShapeUniforms=OC(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?pC(["r","c","d"],e):dC(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getA(rc.x, rc.y, rc.z);\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class LC{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outPackingScheme=DE.DENSE,this.customUniforms=[{name:"texShape",type:"ivec2"}];const t=hC();this.outputShape=e,this.enableShapeUniforms=OC(this.outputShape.length),this.userCode="\n      ivec3 outCoordsFromFlatIndex(int index) {\n        ".concat(this.enableShapeUniforms?pC(["r","c","d"],e):dC(["r","c","d"],e),"\n        return ivec3(r, c, d);\n      }\n\n      void main() {\n        ivec2 resTexRC = ivec2(resultUV.yx * vec2(texShape[0], texShape[1]));\n        int index = 4 * (resTexRC.x * texShape[1] + resTexRC.y);\n\n        vec4 result = vec4(0.);\n\n        for (int i=0; i<4; i++) {\n          int flatIndex = index + i;\n          ivec3 rc = outCoordsFromFlatIndex(flatIndex);\n          result[i] = getChannel(getA(rc.x, rc.y, rc.z), vec2(rc.y, rc.z));\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}class zC{constructor(e){this.variableNames=["A"],this.outTexUsage=FE.DOWNLOAD;const t=hC();this.outputShape=e,this.userCode="\n      ".concat(gC,"\n\n      void main() {\n        float x = getAAtOutCoords();\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}class PC{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outTexUsage=FE.DOWNLOAD;const t=hC();this.outputShape=e,this.userCode="\n      ".concat(gC,"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        float x = getChannel(getAAtOutCoords(), vec2(coords.y, coords.z));\n        ").concat(t.output," = encode_float(x);\n      }\n    ")}}const BC={R:0,G:1,B:2,A:3};class WC{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"RGBA";this.variableNames=["A"],this.customUniforms=[{name:"texShape",type:"ivec2"}];const a=hC();this.outputShape=e,this.enableShapeUniforms=OC(this.outputShape.length);let r="result";t&&(r="floor(result * 255. + 0.5)");let s="";for(let o=0;o<n.length;o++){const e=n[o];s+="\n          if(offset == ".concat(o,") {\n            result = values[").concat(BC[e],"];\n          }")}this.userCode="\n      ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":mC(e),"\n\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int flatIndex = getFlatIndex(coords);\n        float result = 0.;\n        int offset = imod(flatIndex, ").concat(n.length,");\n\n        flatIndex = idiv(flatIndex, ").concat(n.length,", 1.);\n\n        int r = flatIndex / texShape[1];\n        if (r < texShape[0]) {\n          int c = imod(flatIndex, texShape[1]);\n          vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n          vec4 values = ").concat(a.texture2D,"(A, uv);\n          ").concat(s,"\n        }\n        ").concat(a.output," = vec4(").concat(r,", 0., 0., 0.);\n      }\n    ")}}class VC{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.customUniforms=[{name:"texShape",type:"ivec2"}];const n=hC();this.outputShape=e,this.enableShapeUniforms=OC(this.outputShape.length);let a="",r="result";t&&(r="floor(result * 255. + 0.5)");for(let s=0;s<=1;s++)for(let t=0;t<=1;t++){const r=2*s+t;a+="\n          localCoords = coords;\n          if(localCoords[2] + ".concat(t," < ").concat(this.enableShapeUniforms?"outShape[2]":"".concat(e[2]),") {\n          localCoords[2] += ").concat(t,";\n          if (localCoords[1] + ").concat(s," < ").concat(this.enableShapeUniforms?"outShape[1]":"".concat(e[1]),") {\n            localCoords[1] += ").concat(s,";\n\n            flatIndex = getFlatIndex(localCoords);\n            offset = imod(flatIndex, 4);\n\n            flatIndex = idiv(flatIndex, 4, 1.);\n\n            int r = flatIndex / texShape[1];\n            int c = imod(flatIndex, texShape[1]);\n            vec2 uv = (vec2(c, r) + halfCR) / vec2(texShape[1], texShape[0]);\n            values = ").concat(n.texture2D,"(A, uv);\n\n            if (offset == 0) {\n              result[").concat(r,"] = values[0];\n            } else if (offset == 1) {\n              result[").concat(r,"] = values[1];\n            } else if (offset == 2) {\n              result[").concat(r,"] = values[2];\n            } else {\n              result[").concat(r,"] = values[3];\n            }\n          }\n        }\n        ")}this.userCode="\n        ".concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":mC(e),"\n\n        void main() {\n          ivec3 coords = getOutputCoords();\n\n          vec4 result = vec4(0.);\n          int flatIndex, r, c, offset;\n          ivec3 localCoords;\n          vec2 uv;\n          vec4 values;\n\n          ").concat(a,"\n\n          ").concat(n.output," = ").concat(r,";\n        }\n    ")}}function UC(e){const t=hC();return function(e,t){const n=QE(e,(()=>e.createShader(e.VERTEX_SHADER)),"Unable to create vertex WebGLShader.");if(BE(e,(()=>e.shaderSource(n,t))),BE(e,(()=>e.compileShader(n))),!1===e.getShaderParameter(n,e.COMPILE_STATUS))throw console.log(e.getShaderInfoLog(n)),new Error("Failed to compile vertex shader.");return n}(e,"".concat(t.version,"\n    precision highp float;\n    ").concat(t.attribute," vec3 clipSpacePos;\n    ").concat(t.attribute," vec2 uv;\n    ").concat(t.varyingVs," vec2 resultUV;\n\n    void main() {\n      gl_Position = vec4(clipSpacePos, 1);\n      resultUV = uv;\n    }"))}function GC(e){return function(e,t){const n=QE(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return BE(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),BE(e,(()=>e.bufferData(e.ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Float32Array([-1,1,0,0,1,-1,-1,0,0,0,1,1,0,1,1,1,-1,0,1,0]))}function HC(e){return function(e,t){const n=QE(e,(()=>e.createBuffer()),"Unable to create WebGLBuffer");return BE(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,n))),BE(e,(()=>e.bufferData(e.ELEMENT_ARRAY_BUFFER,t,e.STATIC_DRAW))),n}(e,new Uint16Array([0,1,2,2,1,3]))}function jC(e,t,n,a,r,s){!function(e,t){const n=_e().getNumber("WEBGL_MAX_TEXTURE_SIZE");if(e<=0||t<=0){const n="[".concat(e,"x").concat(t,"]");throw new Error("Requested texture size "+n+" is invalid.")}if(e>n||t>n){const a="[".concat(e,"x").concat(t,"]"),r="[".concat(n,"x").concat(n,"]");throw new Error("Requested texture size "+a+" greater than WebGL maximum on this browser / GPU "+r+".")}}(t,n);const o=function(e){return QE(e,(()=>e.createTexture()),"Unable to create WebGLTexture.")}(e),i=e.TEXTURE_2D;return BE(e,(()=>e.bindTexture(i,o))),BE(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_S,e.CLAMP_TO_EDGE))),BE(e,(()=>e.texParameteri(i,e.TEXTURE_WRAP_T,e.CLAMP_TO_EDGE))),BE(e,(()=>e.texParameteri(i,e.TEXTURE_MIN_FILTER,e.NEAREST))),BE(e,(()=>e.texParameteri(i,e.TEXTURE_MAG_FILTER,e.NEAREST))),1===_e().getNumber("WEBGL_VERSION")?BE(e,(()=>e.texImage2D(i,0,a,t,n,0,r,s,null))):BE(e,(()=>e.texStorage2D(i,1,a,t,n))),BE(e,(()=>e.bindTexture(e.TEXTURE_2D,null))),{texture:o,texShape:[n,t]}}function KC(e){return e.internalFormatFloat}function qC(e){return e.internalFormatHalfFloat}function XC(e){return e.downloadTextureFormat}function YC(e){return e.internalFormatPackedFloat}function QC(e){return e.internalFormatPackedHalfFloat}function JC(e,t,n,a,r,s,o,i){const c=e,l=new Float32Array(function(e,t){const[n,a]=zE(e,t);return n*a*4}(s,o));return c.bindBuffer(c.PIXEL_PACK_BUFFER,t),c.getBufferSubData(c.PIXEL_PACK_BUFFER,0,l),c.bindBuffer(c.PIXEL_PACK_BUFFER,null),l}class ZC{constructor(e){this.outputTexture=null,this.program=null,this.disposed=!1,this.itemsToPoll=[];const t=_e().getNumber("WEBGL_VERSION");if(null!=e?(this.gl=e,function(e,t){RE[e]=t}(t,e)):this.gl=_E(t),e=this.gl,2===_e().getNumber("WEBGL_VERSION")){const t=e;this.createVertexArray=()=>BE(t,(()=>t.createVertexArray())),this.bindVertexArray=e=>BE(t,(()=>t.bindVertexArray(e))),this.deleteVertexArray=e=>BE(t,(()=>t.deleteVertexArray(e))),this.getVertexArray=()=>BE(t,(()=>t.getParameter(t.VERTEX_ARRAY_BINDING)))}else if(null!=e){const t=e.getExtension("OES_vertex_array_object");if(null==t)throw new Error("All WebGL1 implementations are expected to offer OES_vertex_array_object.");this.createVertexArray=()=>BE(e,(()=>t.createVertexArrayOES())),this.bindVertexArray=n=>BE(e,(()=>t.bindVertexArrayOES(n))),this.deleteVertexArray=n=>BE(e,(()=>t.deleteVertexArrayOES(n))),this.getVertexArray=()=>BE(e,(()=>e.getParameter(t.VERTEX_ARRAY_BINDING_OES)))}let n="WEBGL_color_buffer_float";const a="EXT_color_buffer_half_float";if(this.parallelCompilationExtension=this.gl.getExtension("KHR_parallel_shader_compile"),1===_e().getNumber("WEBGL_VERSION")){const e="OES_texture_float",t="OES_texture_half_float";if(this.textureFloatExtension=VE(this.gl,e),sC(this.gl,t))this.textureHalfFloatExtension=VE(this.gl,t);else if(_e().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support half float textures, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.");if(this.colorBufferFloatExtension=this.gl.getExtension(n),sC(this.gl,a))this.colorBufferHalfFloatExtension=VE(this.gl,a);else if(_e().get("WEBGL_FORCE_F16_TEXTURES"))throw new Error("GL context does not support color renderable half floats, yet the environment flag WEBGL_FORCE_F16_TEXTURES is set to true.")}else if(n="EXT_color_buffer_float",sC(this.gl,n))this.colorBufferFloatExtension=this.gl.getExtension(n);else{if(!sC(this.gl,a))throw new Error("GL context does not support color renderable floats");this.colorBufferHalfFloatExtension=this.gl.getExtension(a)}this.vertexBuffer=GC(this.gl),this.indexBuffer=HC(this.gl),this.framebuffer=function(e){return QE(e,(()=>e.createFramebuffer()),"Unable to create WebGLFramebuffer.")}(this.gl),this.textureConfig=PE(this.gl,this.textureHalfFloatExtension)}get debug(){return _e().getBool("DEBUG")}dispose(){if(this.disposed)return;null!=this.program&&console.warn("Disposing a GPGPUContext that still has a bound WebGLProgram. This is probably a resource leak, delete the program with GPGPUContext.deleteProgram before disposing."),null!=this.outputTexture&&console.warn("Disposing a GPGPUContext that still has a bound output matrix texture.  This is probably a resource leak, delete the output matrix texture with GPGPUContext.deleteMatrixTexture before disposing.");const e=this.gl;BE(e,(()=>e.finish())),BE(e,(()=>e.bindFramebuffer(e.FRAMEBUFFER,null))),BE(e,(()=>e.deleteFramebuffer(this.framebuffer))),BE(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,null))),BE(e,(()=>e.bindBuffer(e.ELEMENT_ARRAY_BUFFER,null))),BE(e,(()=>e.deleteBuffer(this.indexBuffer))),this.disposed=!0}createFloat32MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=ME(t,n);return jC(e,r,s,KC(a),a.textureFormatFloat,e.FLOAT)}(this.gl,e,t,this.textureConfig)}createFloat16MatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=ME(t,n);return jC(e,r,s,qC(a),a.textureFormatFloat,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createUnsignedBytesMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=ME(t,n);return jC(e,r,s,XC(a),e.RGBA,e.UNSIGNED_BYTE)}(this.gl,e,t,this.textureConfig)}uploadPixelDataToTexture(e,t){this.throwIfDisposed(),function(e,t,n){BE(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),n.data instanceof Uint8Array?2===_e().getNumber("WEBGL_VERSION")?BE(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n.width,n.height,e.RGBA,e.UNSIGNED_BYTE,n.data))):BE(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,n.width,n.height,0,e.RGBA,e.UNSIGNED_BYTE,n.data))):2===_e().getNumber("WEBGL_VERSION")?BE(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,e.RGBA,e.UNSIGNED_BYTE,n))):BE(e,(()=>e.texImage2D(e.TEXTURE_2D,0,e.RGBA,e.RGBA,e.UNSIGNED_BYTE,n))),BE(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t)}uploadDenseMatrixToTexture(e,t,n,a){this.throwIfDisposed(),function(e,t,n,a,r,s){let o,i,c;BE(e,(()=>e.bindTexture(e.TEXTURE_2D,t))),r instanceof Uint8Array?(o=new Uint8Array(n*a*4),i=e.UNSIGNED_BYTE,c=e.RGBA):(o=new Float32Array(n*a*4),i=e.FLOAT,c=s.internalFormatPackedFloat),o.set(r),2===_e().getNumber("WEBGL_VERSION")?BE(e,(()=>e.texSubImage2D(e.TEXTURE_2D,0,0,0,n,a,e.RGBA,i,o))):BE(e,(()=>e.texImage2D(e.TEXTURE_2D,0,c,n,a,0,e.RGBA,i,o))),BE(e,(()=>e.bindTexture(e.TEXTURE_2D,null)))}(this.gl,e,t,n,a,this.textureConfig)}createFloat16PackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=zE(t,n);return jC(e,r,s,QC(a),e.RGBA,a.textureTypeHalfFloat)}(this.gl,e,t,this.textureConfig)}createPackedMatrixTexture(e,t){return this.throwIfDisposed(),function(e,t,n,a){const[r,s]=zE(t,n);return jC(e,r,s,YC(a),e.RGBA,e.FLOAT)}(this.gl,e,t,this.textureConfig)}deleteMatrixTexture(e){this.throwIfDisposed(),this.outputTexture===e&&(XE(this.gl,this.framebuffer),this.outputTexture=null),BE(this.gl,(()=>this.gl.deleteTexture(e)))}downloadByteEncodedFloatMatrixFromOutputTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n,a){const[r,s]=ME(t,n),o=new Uint8Array(t*n*4);return BE(e,(()=>e.readPixels(0,0,r,s,a.downloadTextureFormat,e.UNSIGNED_BYTE,o))),new Float32Array(o.buffer)}(this.gl,t,n,this.textureConfig)))}downloadPackedMatrixFromBuffer(e,t,n,a,r,s){return JC(this.gl,e,0,0,0,r,s,this.textureConfig)}downloadFloat32MatrixFromBuffer(e,t){return function(e,t,n){const a=e,r=new Float32Array(n);return a.bindBuffer(a.PIXEL_PACK_BUFFER,t),a.getBufferSubData(a.PIXEL_PACK_BUFFER,0,r),a.bindBuffer(a.PIXEL_PACK_BUFFER,null),r}(this.gl,e,t)}createBufferFromTexture(e,t,n){this.bindTextureToFrameBuffer(e);const a=function(e,t,n,a){const r=e.createBuffer();BE(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,r)));const s=16*t*n;return BE(e,(()=>e.bufferData(e.PIXEL_PACK_BUFFER,s,e.STREAM_READ))),BE(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,0))),BE(e,(()=>e.bindBuffer(e.PIXEL_PACK_BUFFER,null))),r}(this.gl,t,n,this.textureConfig);return this.unbindTextureToFrameBuffer(),a}createAndWaitForFence(){const e=this.createFence(this.gl);return this.pollFence(e)}createFence(e){let t,n;if(_e().getBool("WEBGL_FENCE_API_ENABLED")){const a=e,r=a.fenceSync(a.SYNC_GPU_COMMANDS_COMPLETE,0);e.flush(),n=()=>{const e=a.clientWaitSync(r,0,0);return e===a.ALREADY_SIGNALED||e===a.CONDITION_SATISFIED},t=r}else _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")>0?(t=this.beginQuery(),this.endQuery(),n=()=>this.isQueryAvailable(t,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))):n=()=>!0;return{query:t,isFencePassed:n}}downloadMatrixFromPackedTexture(e,t,n){return this.downloadMatrixDriver(e,(()=>function(e,t,n){const a=new Float32Array(t*n*4);return BE(e,(()=>e.readPixels(0,0,n,t,e.RGBA,e.FLOAT,a))),a}(this.gl,t,n)))}createProgram(e){this.throwIfDisposed();const t=this.gl;null==this.vertexShader&&(this.vertexShader=UC(t));const n=function(e){return QE(e,(()=>e.createProgram()),"Unable to create WebGLProgram.")}(t);BE(t,(()=>t.attachShader(n,this.vertexShader))),BE(t,(()=>t.attachShader(n,e))),function(e,t){if(BE(e,(()=>e.linkProgram(t))),!_e().get("ENGINE_COMPILE_ONLY")&&!1===e.getProgramParameter(t,e.LINK_STATUS))throw console.log(e.getProgramInfoLog(t)),new Error("Failed to link vertex and fragment shaders.")}(t,n);const a=Object.assign(n,{vao:this.createVertexArray()});return this.debug&&HE(t,a),a}buildVao(e){this.setProgram(e),this.bindVertexArray(e.vao);const t=this.gl;BE(t,(()=>t.bindBuffer(t.ELEMENT_ARRAY_BUFFER,this.indexBuffer))),function(e,t,n){BE(e,(()=>e.bindBuffer(e.ARRAY_BUFFER,n))),jE(e,t,"clipSpacePos",n,3,20,0)&&jE(e,t,"uv",n,2,20,12)}(t,e,this.vertexBuffer)}deleteProgram(e){this.throwIfDisposed(),e===this.program&&(this.program=null),null!=e&&(BE(this.gl,(()=>this.gl.deleteProgram(e))),this.deleteVertexArray(e.vao))}setProgram(e){this.throwIfDisposed(),this.program=e,null!=this.program&&this.debug&&HE(this.gl,this.program),BE(this.gl,(()=>this.gl.useProgram(e)))}getUniformLocation(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];return this.throwIfDisposed(),n?function(e,t,n){return QE(e,(()=>e.getUniformLocation(t,n)),'uniform "'+n+'" not present in program.')}(this.gl,e,t):function(e,t,n){return e.getUniformLocation(t,n)}(this.gl,e,t)}getAttributeLocation(e,t){return this.throwIfDisposed(),BE(this.gl,(()=>this.gl.getAttribLocation(e,t)))}getUniformLocationNoThrow(e,t){return this.throwIfDisposed(),this.gl.getUniformLocation(e,t)}setInputMatrixTexture(e,t,n){this.throwIfDisposed(),this.throwIfNoProgram(),KE(this.gl,e,t,n)}setOutputMatrixTexture(e,t,n){this.setOutputMatrixTextureDriver(e,n,t)}setOutputPackedMatrixTexture(e,t,n){this.throwIfDisposed();const[a,r]=zE(t,n);this.setOutputMatrixTextureDriver(e,a,r)}setOutputMatrixWriteRegion(e,t,n,a){this.setOutputMatrixWriteRegionDriver(n,e,a,t)}setOutputPackedMatrixWriteRegion(e,t,n,a){throw new Error("setOutputPackedMatrixWriteRegion not implemented.")}debugValidate(){null!=this.program&&HE(this.gl,this.program),YE(this.gl)}executeProgram(){this.throwIfDisposed(),this.throwIfNoProgram();const e=this.gl;if(this.debug){const e=this.getVertexArray();console.assert(e===this.program.vao,"VAO changed between setProgram and executeProgram!"),this.debugValidate()}BE(e,(()=>e.drawElements(e.TRIANGLES,6,e.UNSIGNED_SHORT,0)))}blockUntilAllProgramsCompleted(){this.throwIfDisposed(),BE(this.gl,(()=>this.gl.finish()))}getQueryTimerExtension(){return null==this.disjointQueryTimerExtension&&(this.disjointQueryTimerExtension=VE(this.gl,2===_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")?"EXT_disjoint_timer_query_webgl2":"EXT_disjoint_timer_query")),this.disjointQueryTimerExtension}getQueryTimerExtensionWebGL2(){return this.getQueryTimerExtension()}getQueryTimerExtensionWebGL1(){return this.getQueryTimerExtension()}beginQuery(){if(2===_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2(),n=e.createQuery();return e.beginQuery(t.TIME_ELAPSED_EXT,n),n}const e=this.getQueryTimerExtensionWebGL1(),t=e.createQueryEXT();return e.beginQueryEXT(e.TIME_ELAPSED_EXT,t),t}endQuery(){if(2===_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")){const e=this.gl,t=this.getQueryTimerExtensionWebGL2();return void e.endQuery(t.TIME_ELAPSED_EXT)}const e=this.getQueryTimerExtensionWebGL1();e.endQueryEXT(e.TIME_ELAPSED_EXT)}async waitForQueryAndGetTime(e){return await se((()=>this.disposed||this.isQueryAvailable(e,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION")))),this.getQueryTime(e,_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_VERSION"))}getQueryTime(e,t){if(0===t)return null;if(2===t){const t=this.gl;return t.getQueryParameter(e,t.QUERY_RESULT)/1e6}{const t=this.getQueryTimerExtensionWebGL1();return t.getQueryObjectEXT(e,t.QUERY_RESULT_EXT)/1e6}}isQueryAvailable(e,t){if(0===t)return!0;if(2===t){const t=this.gl,n=this.getQueryTimerExtensionWebGL2(),a=t.getQueryParameter(e,t.QUERY_RESULT_AVAILABLE);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(n.GPU_DISJOINT_EXT)),a&&!this.disjoint}{const t=this.getQueryTimerExtensionWebGL1(),n=t.getQueryObjectEXT(e,t.QUERY_RESULT_AVAILABLE_EXT);return null==this.disjoint&&(this.disjoint=this.gl.getParameter(t.GPU_DISJOINT_EXT)),n&&!this.disjoint}}pollFence(e){return new Promise((t=>{this.addItemToPoll((()=>e.isFencePassed()),(()=>t()))}))}pollItems(){const e=function(e){let t=0;for(;t<e.length;++t){if(!e[t]())break}return t-1}(this.itemsToPoll.map((e=>e.isDoneFn)));for(let t=0;t<=e;++t){const{resolveFn:e}=this.itemsToPoll[t];e()}this.itemsToPoll=this.itemsToPoll.slice(e+1)}addItemToPoll(e,t){if(this.itemsToPoll.push({isDoneFn:e,resolveFn:t}),this.itemsToPoll.length>1)return;let n;"setTimeoutCustom"in _e().platform&&(n=_e().platform.setTimeoutCustom.bind(_e().platform)),se((()=>(this.pollItems(),0===this.itemsToPoll.length)),(()=>0),null,n)}bindTextureToFrameBuffer(e){this.throwIfDisposed(),qE(this.gl,e,this.framebuffer),this.debug&&YE(this.gl)}unbindTextureToFrameBuffer(){null!=this.outputTexture?(qE(this.gl,this.outputTexture,this.framebuffer),this.debug&&YE(this.gl)):XE(this.gl,this.framebuffer)}downloadMatrixDriver(e,t){this.bindTextureToFrameBuffer(e);const n=t();return this.unbindTextureToFrameBuffer(),n}setOutputMatrixTextureDriver(e,t,n){this.throwIfDisposed();const a=this.gl;qE(a,e,this.framebuffer),this.debug&&YE(a),this.outputTexture=e,BE(a,(()=>a.viewport(0,0,t,n))),BE(a,(()=>a.scissor(0,0,t,n)))}setOutputMatrixWriteRegionDriver(e,t,n,a){this.throwIfDisposed(),BE(this.gl,(()=>this.gl.scissor(e,t,n,a)))}throwIfDisposed(){if(this.disposed)throw new Error("Attempted to use disposed GPGPUContext.")}throwIfNoProgram(){if(null==this.program)throw new Error("No GPU program is currently set.")}}const{addImpl:$C,bincountImpl:eR,bincountReduceImpl:tR,bitwiseAndImpl:nR,castImpl:aR,ceilImpl:rR,concatImpl:sR,equalImpl:oR,expImpl:iR,expm1Impl:cR,floorImpl:lR,gatherNdImpl:uR,gatherV2Impl:hR,greaterImpl:dR,greaterEqualImpl:pR,lessImpl:fR,lessEqualImpl:mR,linSpaceImpl:gR,logImpl:yR,maxImpl:bR,maximumImpl:vR,minimumImpl:xR,multiplyImpl:wR,negImpl:kR,notEqualImpl:SR,prodImpl:IR,raggedGatherImpl:NR,raggedRangeImpl:TR,raggedTensorToTensorImpl:ER,rangeImpl:CR,rsqrtImpl:RR,scatterImpl:AR,sigmoidImpl:_R,simpleAbsImpl:DR,sliceImpl:FR,sparseFillEmptyRowsImpl:OR,sparseReshapeImpl:MR,sparseSegmentReductionImpl:LR,sqrtImpl:zR,staticRegexReplaceImpl:PR,stridedSliceImpl:BR,stringNGramsImpl:WR,stringSplitImpl:VR,stringToHashBucketFastImpl:UR,subImpl:GR,tileImpl:HR,topKImpl:jR,transposeImpl:KR,uniqueImpl:qR}=r;function XR(e,t){return["x","y","z","w","u","v"].slice(0,t).map((t=>"".concat(e,".").concat(t)))}function YR(e,t){return 1===t?[e]:XR(e,t)}class QR{constructor(e){if(this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.enableShapeUniforms=OC(this.outputShape.length),0===this.rank)this.userCode="\n        void main() {\n          setOutput(vec4(getA(), 0., 0., 0.));\n        }\n      ";else{const e=YR("rc",this.rank),t=EC(this.rank),n=this.getOutOfBoundsCondition(e),a=this.getSetup(e),r=this.getOutput(e);this.userCode="\n        void main() {\n          ".concat(t," rc = getOutputCoords();\n\n          if(").concat(n,") {\n            setOutput(vec4(0));\n          } else {\n            ").concat(a,"\n\n            setOutput(vec4(").concat(r,"));\n          }\n        }\n      ")}}getSourceCoordsArr(e){const t=[];for(let n=0;n<=1;n++)for(let a=0;a<=1;a++){let r="".concat(0===n?"r":"rp1",", ").concat(0===a?"c":"cp1");for(let t=2;t<this.rank;t++)r="".concat(e[e.length-1-t],",")+r;t.push(r)}return t}getOutOfBoundsCondition(e){if(1===this.rank)return"rc > ".concat(this.enableShapeUniforms?"outShape":this.outputShape[0]);let t="";for(let n=this.rank-2;n<this.rank;n++)t+="".concat(e[n]," >= ").concat(this.enableShapeUniforms?"outShape[".concat(n,"]"):this.outputShape[n]),n<this.rank-1&&(t+="||");return t}getSetup(e){if(1===this.rank)return"";const t=e.slice(-2),n=this.enableShapeUniforms?"outShape[".concat(this.rank," - 1]"):this.outputShape[this.rank-1],a=this.enableShapeUniforms?"outShape[".concat(this.rank," - 2]"):this.outputShape[this.rank-2];return"\n      int r = ".concat(t[0],";\n      int c = ").concat(t[1],";\n      int rp1 = r + 1;\n      int cp1 = c + 1;\n\n      bool cEdge = cp1 >= ").concat(n,";\n      bool rEdge = rp1 >= ").concat(a,";\n    ")}getOutput(e){const t=this.getSourceCoordsArr(e);if(1===this.rank){const e=this.enableShapeUniforms?"outShape":this.outputShape[0];return"getA(rc), (rc + 1 >= ".concat(e," ? 0. : getA(rc + 1)), 0, 0")}return"getA(".concat(t[0],"),\n            cEdge ? 0. : getA(").concat(t[1],"),\n            rEdge ? 0. : getA(").concat(t[2],"),\n            rEdge || cEdge ? 0. : getA(").concat(t[3],")")}}class JR{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec3"}],this.outputShape=e,this.enableShapeUniforms=OC(this.outputShape.length);let n="";for(let a=0;a<4;a++){let e="thisRC = rc;";a%2===1&&(e+="thisRC.z += 1;"),a>1&&(e+="thisRC.y += 1;"),n+="\n        ".concat(e,"\n        ").concat(a>0?"if(thisRC.y < rows && thisRC.z < cols){":"","\n          int flatIndex = getFlatIndex(thisRC);\n\n          ivec3 inputRC = inputCoordsFromReshapedOutCoords(flatIndex);\n          vec2 inputRCInnerDims = vec2(float(inputRC.y),float(inputRC.z));\n\n          result[").concat(a,"] =\n            getChannel(getA(inputRC.x, inputRC.y, inputRC.z), inputRCInnerDims);\n        ").concat(a>0?"}":"","\n      ")}this.userCode="\n      ".concat(function(e,t){const n=t?fC(["r","c","d"],"inputShape"):dC(["r","c","d"],e);return"\n    ivec3 inputCoordsFromReshapedOutCoords(int index) {\n      ".concat(n,"\n      return ivec3(r, c, d);\n    }\n  ")}(t,this.enableShapeUniforms),"\n      ").concat(this.enableShapeUniforms?"\n  int getFlatIndex(ivec3 coords) {\n    return coords.x * outShapeStrides[0] + coords.y * outShapeStrides[1] + coords.z;\n  }\n":mC(e),"\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0.);\n\n        ivec3 thisRC;\n        int rows = ").concat(this.enableShapeUniforms?"outShape[1]":e[1],";\n        int cols = ").concat(this.enableShapeUniforms?"outShape[2]":e[2],";\n\n        ").concat(n,"\n\n        setOutput(result);\n      }\n    ")}}class ZR{constructor(e){this.gpgpu=e,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0,this.freeTextures={},this.usedTextures={},this.logEnabled=!1}acquireTexture(e,t,n){const a=eA(t,n),r=tA(e,a,n);r in this.freeTextures||(this.freeTextures[r]=[]),r in this.usedTextures||(this.usedTextures[r]=[]);const s=$R(e,a,this.gpgpu.gl,this.gpgpu.textureConfig,n);if(this.freeTextures[r].length>0){this.numFreeTextures--,this.numUsedTextures++,this._numBytesFree-=s,this.log();const e=this.freeTextures[r].pop();return this.usedTextures[r].push(e),e}let o;return a===OE.PACKED_2X2_FLOAT32?o=this.gpgpu.createPackedMatrixTexture(e[0],e[1]):a===OE.PACKED_2X2_FLOAT16?o=this.gpgpu.createFloat16PackedMatrixTexture(e[0],e[1]):a===OE.UNPACKED_FLOAT32?o=this.gpgpu.createFloat32MatrixTexture(e[0],e[1]):a===OE.UNPACKED_FLOAT16?o=this.gpgpu.createFloat16MatrixTexture(e[0],e[1]):a===OE.PACKED_4X1_UNSIGNED_BYTE&&(o=this.gpgpu.createUnsignedBytesMatrixTexture(e[0],e[1])),this.usedTextures[r].push(o),this.numUsedTextures++,this._numBytesAllocated+=s,this.log(),o}releaseTexture(e,t,n,a){if(null==this.freeTextures)return;const r=eA(n,a),s=tA(t,r,a);s in this.freeTextures||(this.freeTextures[s]=[]);const o=$R(t,r,this.gpgpu.gl,this.gpgpu.textureConfig,a),i=_e().getNumber("WEBGL_DELETE_TEXTURE_THRESHOLD");-1!==i&&this._numBytesAllocated>i?(this.gpgpu.deleteMatrixTexture(e.texture),this._numBytesAllocated-=o):(this.freeTextures[s].push(e),this.numFreeTextures++,this._numBytesFree+=o),this.numUsedTextures--;const c=this.usedTextures[s],l=c&&c.indexOf(e);if(null==l||l<0)throw new Error("Cannot release a texture that was never provided by this texture manager");c[l]=c[c.length-1],c.pop(),this.log()}log(){if(!this.logEnabled)return;const e=this.numFreeTextures+this.numUsedTextures;console.log("Free/Used","".concat(this.numFreeTextures," / ").concat(this.numUsedTextures),"(".concat(e,")"));const t=this._numBytesFree/this._numBytesAllocated;console.log("Bytes allocated: ".concat(this._numBytesAllocated)),console.log("Bytes unused: ".concat(this._numBytesFree," (").concat(Math.round(100*t),"%)"))}get numBytesAllocated(){return this._numBytesAllocated}get numBytesFree(){return this._numBytesFree}getNumUsedTextures(){return this.numUsedTextures}getNumFreeTextures(){return this.numFreeTextures}dispose(){if(null!=this.freeTextures){for(const e in this.freeTextures)this.freeTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));for(const e in this.usedTextures)this.usedTextures[e].forEach((e=>{this.gpgpu.deleteMatrixTexture(e.texture)}));this.freeTextures=null,this.usedTextures=null,this.numUsedTextures=0,this.numFreeTextures=0,this._numBytesAllocated=0,this._numBytesFree=0}}}function $R(e,t,n,a,r){const s=function(e,t){switch(e){case OE.PACKED_2X2_FLOAT32:return YC(t);case OE.PACKED_2X2_FLOAT16:return QC(t);case OE.UNPACKED_FLOAT32:return KC(t);case OE.UNPACKED_FLOAT16:return qC(t);case OE.PACKED_4X1_UNSIGNED_BYTE:return XC(t);default:throw new Error("Unknown physical texture type ".concat(e))}}(t,a);let o;if(r){const[t,n]=zE(e[0],e[1]);o=t*n}else{const[t,n]=ME(e[0],e[1]);o=t*n}const i=function(e,t){const n=e;if(t===n.R32F)return 4;if(t===n.R16F)return 2;if(t===n.RGBA32F)return 16;if(t===e.RGBA)return 16;if(t===n.RGBA16F)return 8;if(t===n.RGBA8)return 4;throw new Error("Unknown internal format ".concat(t))}(n,s);return o*i}function eA(e,t){if(e===FE.UPLOAD)return OE.PACKED_2X2_FLOAT32;if(e===FE.RENDER||null==e)return function(e){return _e().getBool("WEBGL_RENDER_FLOAT32_ENABLED")?e?OE.PACKED_2X2_FLOAT32:OE.UNPACKED_FLOAT32:e?OE.PACKED_2X2_FLOAT16:OE.UNPACKED_FLOAT16}(t);if(e===FE.DOWNLOAD||e===FE.PIXELS)return OE.PACKED_4X1_UNSIGNED_BYTE;throw new Error("Unknown logical texture type ".concat(e))}function tA(e,t,n){return"".concat(e[0],"_").concat(e[1],"_").concat(t,"_").concat(n)}class nA{constructor(e,t){this.variableNames=["A"],this.outputShape=e,this.enableShapeUniforms=OC(this.outputShape.length),this.userCode="\n      float unaryOperation(float x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        float x = getAAtOutCoords();\n        float y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}const aA="if (isnan(x)) return x;",rA="return x;",sA="return abs(x);";const oA="return (x >= 0.0) ? x : (exp(x) - 1.0);",iA=aA+"\n  return (x < 0.0) ? 0.0 : x;\n",cA=aA+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",lA="return x;",uA="return 1.0 / (1.0 + exp(-1.0 * x));",hA="return x;",dA="\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n",pA="\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",fA="\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",mA="return 1.0 / (1.0 + exp(-1.0 * x));";class gA{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.enableShapeUniforms=OC(this.outputShape.length),this.userCode="\n      vec4 unaryOperation(vec4 x) {\n        ".concat(t,"\n      }\n\n      void main() {\n        vec4 x = getAAtOutCoords();\n        vec4 y = unaryOperation(x);\n\n        setOutput(y);\n      }\n    ")}}class yA{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!1,this.outputShape=e,this.enableShapeUniforms=OC(this.outputShape.length);const t=e.length,n=YR("rc",t),a=EC(t),r=function(e,t){if(1===e)return"rc";let n="";for(let a=0;a<e;a++)n+=t[a],a<e-1&&(n+=",");return n}(t,n),s=n.slice(-2),o=t<=1?"rc":"vec2(".concat(s.join(","),")");this.userCode="\n      void main() {\n        ".concat(a," rc = getOutputCoords();\n        vec4 packedInput = getA(").concat(r,");\n\n        setOutput(getChannel(packedInput, ").concat(o,"));\n      }\n    ")}}const bA=Uh,vA={};const xA=_e().getNumber("CPU_HANDOFF_SIZE_THRESHOLD");class wA extends j{nextDataId(){return wA.nextDataId++}constructor(e){if(super(),this.pendingRead=new WeakMap,this.pendingDisposal=new WeakSet,this.dataRefCount=new WeakMap,this.numBytesInGPU=0,this.uploadWaitMs=0,this.downloadWaitMs=0,this.lastGlFlushTime=0,this.warnedAboutMemory=!1,this.pendingDeletes=0,this.disposed=!1,!_e().getBool("HAS_WEBGL"))throw new Error("WebGL is not supported on this device");let t;if(null!=e){if(e instanceof ZC)t=e;else{const n=_E(_e().getNumber("WEBGL_VERSION"),e);t=new ZC(n)}this.binaryCache={},this.gpgpuCreatedLocally=!1}else{const e=_E(_e().getNumber("WEBGL_VERSION"));t=new ZC(e),this.binaryCache=((n=_e().getNumber("WEBGL_VERSION"))in vA||(vA[n]={}),vA[n]),this.gpgpuCreatedLocally=!0}var n;this.gpgpu=t,this.canvas=this.gpgpu.gl.canvas,this.textureManager=new ZR(this.gpgpu),this.numMBBeforeWarning=null==_e().global.screen?1024:_e().global.screen.height*_e().global.screen.width*window.devicePixelRatio*600/1024/1024,this.texData=new H(this,Ns())}numDataIds(){return this.texData.numDataIds()-this.pendingDeletes}writeTexture(e,t,n,a,r,s){const o=this.makeTensorInfo(t,n),i=this.texData.get(o.dataId);i.isPacked=!1,i.texture={texture:e,texShape:[a,r]},i.texShape=[a,r];const c=eC(t),l=new WC(c,!1,s),u=this.runWebGLProgram(l,[o],n,[[a,r]]);return u.shape=t,i.texture=null,this.disposeIntermediateTensorInfo(o),u.dataId}write(e,t,n){if((_e().getBool("WEBGL_CHECK_NUMERICAL_PROBLEMS")||_e().getBool("DEBUG"))&&this.checkNumericalProblems(e),"complex64"===n&&null!=e)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");const a={id:this.nextDataId()};return this.texData.set(a,{shape:t,dtype:n,values:e,usage:FE.UPLOAD,refCount:1}),a}refCount(e){if(this.texData.has(e)){return this.texData.get(e).refCount}return 0}incRef(e){this.texData.get(e).refCount++}decRef(e){if(this.texData.has(e)){this.texData.get(e).refCount--}}move(e,t,n,a,r){if(_e().getBool("DEBUG")&&this.checkNumericalProblems(t),"complex64"===a)throw new Error("Cannot write to a complex64 dtype. Please use tf.complex(real, imag).");this.texData.set(e,{shape:n,dtype:a,values:t,usage:FE.UPLOAD,refCount:r})}disposeIntermediateTensorInfo(e){this.disposeData(e.dataId)}readSync(e){const t=this.texData.get(e),{values:n,dtype:a,complexTensorInfos:r,slice:s,shape:o,isPacked:i}=t;if(null!=s){let t;t=i?new gA(o,lA):new nA(o,lA);const n=this.runWebGLProgram(t,[{dataId:e,shape:o,dtype:a}],a),r=this.readSync(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if("string"===a)return n;const c=null!=this.activeTimers;let l,u;if(c&&(l=kr()),"complex64"===a){u=oh(this.readSync(r.real.dataId),this.readSync(r.imag.dataId))}else u=this.getValuesFromTexture(e);return c&&(this.downloadWaitMs+=kr()-l),this.convertAndCacheOnCPU(e,u)}async read(e){if(this.pendingRead.has(e)){const t=this.pendingRead.get(e);return new Promise((e=>t.push(e)))}const t=this.texData.get(e),{values:n,shape:a,slice:r,dtype:s,complexTensorInfos:o,isPacked:i}=t;if(null!=r){let t;t=i?new gA(a,lA):new nA(a,lA);const n=this.runWebGLProgram(t,[{dataId:e,shape:a,dtype:s}],s),r=this.read(n.dataId);return this.disposeIntermediateTensorInfo(n),r}if(null!=n)return this.convertAndCacheOnCPU(e);if(_e().getBool("DEBUG")&&!_e().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")&&2===_e().getNumber("WEBGL_VERSION"))throw new Error("tensor.data() with WEBGL_DOWNLOAD_FLOAT_ENABLED=false and WEBGL_VERSION=2 not yet supported.");let c,l,u=null;if("complex64"!==s&&_e().get("WEBGL_BUFFER_SUPPORTED")){c=this.decode(e);const t=this.texData.get(c.dataId);u=this.gpgpu.createBufferFromTexture(t.texture.texture,...LE(a))}if(this.pendingRead.set(e,[]),"complex64"!==s&&await this.gpgpu.createAndWaitForFence(),"complex64"===s){const e=await Promise.all([this.read(o.real.dataId),this.read(o.imag.dataId)]);l=oh(e[0],e[1])}else if(null==u)l=this.getValuesFromTexture(e);else{const e=ee(a);l=this.gpgpu.downloadFloat32MatrixFromBuffer(u,e)}if(null!=c&&this.disposeIntermediateTensorInfo(c),null!=u){const e=this.gpgpu.gl;BE(e,(()=>e.deleteBuffer(u)))}const h=this.convertAndCacheOnCPU(e,l),d=this.pendingRead.get(e);return this.pendingRead.delete(e),d.forEach((e=>e(h))),this.pendingDisposal.has(e)&&(this.pendingDisposal.delete(e),this.disposeData(e)&&Ns().removeDataId(e,this),this.pendingDeletes--),h}readToGPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=this.texData.get(e),{values:a,shape:r,slice:s,dtype:o,isPacked:i,texture:c}=n;if("complex64"===o)throw new Error("Does not support reading texture for complex64 dtype.");if(null!=s){let n;n=i?new gA(r,lA):new nA(r,lA);const a=this.runWebGLProgram(n,[{dataId:e,shape:r,dtype:o}],o),s=this.readToGPU(a,t);return this.disposeIntermediateTensorInfo(a),s}if(null==c)throw null!=a?new Error("Data is not on GPU but on CPU."):new Error("There is no data on GPU or CPU.");const l=this.decode(e,t.customTexShape),u=Ns().makeTensorFromTensorInfo(l),h=this.texData.get(l.dataId);return Object.assign({tensorRef:u},h.texture)}bufferSync(e){const t=this.readSync(e.dataId);if("string"===e.dtype)try{const n=t.map((e=>Ir(e)));return go(e.shape,e.dtype,n)}catch(n){throw new Error("Failed to decode encoded string bytes into utf-8")}return go(e.shape,e.dtype,t)}checkNumericalProblems(e){if(null!=e)for(let t=0;t<e.length;t++){const n=e[t];if(!WE(n)){if(_e().getBool("WEBGL_RENDER_FLOAT32_CAPABLE"))throw Error("The value ".concat(n," cannot be represented with your ")+"current settings. Consider enabling float32 rendering: 'tf.env().set('WEBGL_RENDER_FLOAT32_ENABLED', true);'");throw Error("The value ".concat(n," cannot be represented on this device."))}}}getValuesFromTexture(e){const{shape:t,dtype:n,isPacked:a}=this.texData.get(e),r=ee(t);if(_e().getBool("WEBGL_DOWNLOAD_FLOAT_ENABLED")){const n=this.decode(e),a=this.texData.get(n.dataId),s=this.gpgpu.downloadMatrixFromPackedTexture(a.texture.texture,...LE(t)).subarray(0,r);return this.disposeIntermediateTensorInfo(n),s}const s=_e().getBool("WEBGL_PACK")&&!0===a,o=s?eC(t):t,i=s?new PC(o):new zC(o),c=this.runWebGLProgram(i,[{shape:o,dtype:n,dataId:e}],"float32"),l=this.texData.get(c.dataId),u=this.gpgpu.downloadByteEncodedFloatMatrixFromOutputTexture(l.texture.texture,l.texShape[0],l.texShape[1]).subarray(0,r);return this.disposeIntermediateTensorInfo(c),u}timerAvailable(){return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0}time(e){const t=this.activeTimers,n=[];let a=!1;null==this.programTimersStack?(this.programTimersStack=n,a=!0):this.activeTimers.push(n),this.activeTimers=n,e();const r=Tr(this.activeTimers.map((e=>e.query))).filter((e=>null!=e)),s=Tr(this.activeTimers.map((e=>e.name))).filter((e=>null!=e));this.activeTimers=t,a&&(this.programTimersStack=null);const o={uploadWaitMs:this.uploadWaitMs,downloadWaitMs:this.downloadWaitMs,kernelMs:null,wallMs:null};return(async()=>{if(_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0){const e=await Promise.all(r);o.kernelMs=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}(e),o.getExtraProfileInfo=()=>e.map(((e,t)=>({name:s[t],ms:e}))).map((e=>"".concat(e.name,": ").concat(e.ms))).join(", ")}else o.kernelMs={error:"WebGL query timers are not supported in this environment."};return this.uploadWaitMs=0,this.downloadWaitMs=0,o})()}memory(){return{unreliable:!1,numBytesInGPU:this.numBytesInGPU,numBytesInGPUAllocated:this.textureManager.numBytesAllocated,numBytesInGPUFree:this.textureManager.numBytesFree}}startTimer(){return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?this.gpgpu.beginQuery():{startMs:kr(),endMs:null}}endTimer(e){return _e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0?(this.gpgpu.endQuery(),e):(e.endMs=kr(),e)}async getQueryTime(e){if(_e().getNumber("WEBGL_DISJOINT_QUERY_TIMER_EXTENSION_RELIABLE")>0)return this.gpgpu.waitForQueryAndGetTime(e);const t=e;return t.endMs-t.startMs}disposeData(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(this.pendingDisposal.has(e))return!1;if(!this.texData.has(e))return!0;if(t?this.texData.get(e).refCount=0:this.texData.get(e).refCount--,!t&&this.texData.get(e).refCount>0)return!1;if(this.pendingRead.has(e))return this.pendingDisposal.add(e),this.pendingDeletes++,!1;this.releaseGPUData(e);const{complexTensorInfos:n}=this.texData.get(e);return null!=n&&(this.disposeData(n.real.dataId,t),this.disposeData(n.imag.dataId,t)),this.texData.delete(e),!0}releaseGPUData(e){const{texture:t,dtype:n,texShape:a,usage:r,isPacked:s,slice:o}=this.texData.get(e),i=o&&o.origDataId||e,c=this.dataRefCount.get(i);c>1?this.dataRefCount.set(i,c-1):(this.dataRefCount.delete(i),null!=t&&(this.numBytesInGPU-=this.computeBytes(a,n),this.textureManager.releaseTexture(t,a,r,s)));const l=this.texData.get(e);l.texture=null,l.texShape=null,l.isPacked=!1,l.slice=null}getTexture(e){return this.uploadToGPU(e),this.texData.get(e).texture.texture}getDataInfo(e){return this.texData.get(e)}shouldExecuteOnCPU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:xA;return _e().getBool("WEBGL_CPU_FORWARD")&&e.every((e=>null==this.texData.get(e.dataId).texture&&ee(e.shape)<t))}getGPGPUContext(){return this.gpgpu}where(e){Xa("tf.where() in webgl locks the UI thread. Call tf.whereAsync() instead");const t=e.dataSync();return bA(e.shape,t)}packedUnaryOp(e,t,n){const a=new gA(e.shape,t),r=this.compileAndRun(a,[e],n);return Ns().makeTensorFromTensorInfo(r)}abs(e){if(this.shouldExecuteOnCPU([e])&&"complex64"!==e.dtype){const t=DR(this.texData.get(e.dataId).values);return this.makeOutput(e.shape,e.dtype,t)}if(_e().getBool("WEBGL_PACK_UNARY_OPERATIONS"))return this.packedUnaryOp(e,sA,e.dtype);const t=new nA(e.shape,sA),n=this.compileAndRun(t,[e]);return Ns().makeTensorFromTensorInfo(n)}makeTensorInfo(e,t,n){let a;if("string"===t&&null!=n&&n.length>0&&pe(n[0])){const r=n.map((e=>Sr(e)));a=this.write(r,e,t)}else a=this.write(n,e,t);return this.texData.get(a).usage=null,{dataId:a,shape:e,dtype:t}}makeOutput(e,t,n){return Ns().makeTensorFromTensorInfo(this.makeTensorInfo(e,t,n),this)}unpackTensor(e){const t=new yA(e.shape);return this.runWebGLProgram(t,[e],e.dtype)}packTensor(e){const t=new QR(e.shape);return this.runWebGLProgram(t,[e],e.dtype,null,!0)}packedReshape(e,t){const n=[ZE(e.shape),...$E(e.shape)],a={dtype:e.dtype,shape:n,dataId:e.dataId},r=[ZE(t),...$E(t)],s=new JR(r,n),o=[n],i=this.runWebGLProgram(s,[a],e.dtype,o,!0);return{dataId:i.dataId,shape:t,dtype:i.dtype}}decode(e,t){const n=this.texData.get(e),{isPacked:a,shape:r,dtype:s}=n;if(null!=t){J(ee(r)<=t[0]*t[1]*4,(()=>"customTexShape is too small. Row * Column * 4 should be equal or larger than the size of the tensor data."))}const o=eC(r);let i;i=a?new LC(o):new MC(o);const c=[null!=t?t:LE(o)];return{dtype:s,shape:r,dataId:this.runWebGLProgram(i,[{shape:o,dtype:s,dataId:e}],s,c,!0,t).dataId}}runWebGLProgram(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5?arguments[5]:void 0;const o=this.makeTensorInfo(e.outputShape,n),i=this.texData.get(o.dataId);if(e.packedOutput&&(i.isPacked=!0),e.outPackingScheme===DE.DENSE){const t=null!=s?s:LE(e.outputShape);i.texShape=t.map((e=>2*e))}if(null!=e.outTexUsage&&(i.usage=e.outTexUsage),0===ee(o.shape))return i.values=le(o.dtype,0),o;const c=[],l=t.map((t=>{if("complex64"===t.dtype)throw new Error("GPGPUProgram does not support complex64 input. For complex64 dtypes, please separate the program into real and imaginary parts.");let n=this.texData.get(t.dataId);if(null==n.texture){if(!e.packedInputs&&ee(t.shape)<=_e().getNumber("WEBGL_SIZE_UPLOAD_UNIFORM"))return{shape:t.shape,texData:null,isUniform:!0,uniformValues:n.values};e.packedInputs&&(n.isPacked=!0,n.shape=t.shape)}if(this.uploadToGPU(t.dataId),!!n.isPacked!==!!e.packedInputs)t=n.isPacked?this.unpackTensor(t):this.packTensor(t),c.push(t),n=this.texData.get(t.dataId);else if(n.isPacked&&!nC(n.shape,t.shape)){const e=t,a=t.shape;t.shape=n.shape,t=this.packedReshape(t,a),c.push(t),n=this.texData.get(t.dataId),e.shape=a}return{shape:t.shape,texData:n,isUniform:!1}}));this.uploadToGPU(o.dataId);const u={shape:o.shape,texData:i,isUniform:!1},h=function(e,t,n){let a="";t.concat(n).forEach((t=>{const r=null!=t.texData&&null!=t.texData.slice&&t.texData.slice.flatOffset>0;if(e.enableShapeUniforms&&!t.isUniform){const s=t.texData.texShape,{useSqueezeShape:o,uniformShape:i,keptDims:c}=CC(e.packedInputs,t.shape,s);let l="",u="",h="";if(1===i.length&&e.packedInputs){const e=[Math.ceil(s[0]/2),Math.ceil(s[1]/2)];l="".concat(e[0]>1,"_").concat(e[1]>1)}else if(2!==i.length||e.packedInputs){if(i.length>2&&!e.packedInputs){const e=be(i);h="".concat(e[0]===s[1],"_").concat(e[e.length-1]===s[1])}}else u="".concat(i[0]>1,"_").concat(i[1]>1);const d=t.shape.length,p=2===i.length&&te(t.shape,s),f=1===ee(t.shape),m=Vo(t.shape,n.shape),g=!e.packedInputs&&d===n.shape.length&&te(s,n.texData.texShape),y=e.packedInputs||i.length>2?"":"".concat(s[0]>1,"_").concat(s[1]>1);a+="".concat(d,"_").concat(g,"_").concat(o?c:"","_").concat(i.length,"_").concat(f,"_").concat(m,"_").concat(p,"_").concat(l,"_").concat(u,"_").concat(h,"_").concat(y,"_").concat(r)}else{const e=t.isUniform?"uniform":t.texData.texShape;a+="".concat(t.shape,"_").concat(e,"_").concat(r)}}));const r=e.userCode;let s=e.constructor.name;return s+="_"+a+"_"+r+"".concat(_e().getNumber("WEBGL_VERSION")),s}(e,l,u),d=this.getAndSaveBinary(h,(()=>_C(this.gpgpu,e,l,u))),p=null!=this.activeTimers;let f;p&&(f=this.startTimer()),_e().get("ENGINE_COMPILE_ONLY")||function(e,t,n,a,r){t.program.enableShapeUniforms||(FC(t.inShapeInfos,n),FC([t.outShapeInfo],[a]));const s=a.texData.texture,o=a.texData.texShape;a.texData.isPacked?e.setOutputPackedMatrixTexture(s.texture,o[0],o[1]):e.setOutputMatrixTexture(s.texture,o[0],o[1]),e.setProgram(t.webGLProgram),e.bindVertexArray(t.webGLProgram.vao),1===_e().getNumber("WEBGL_VERSION")&&null!==t.infLoc&&e.gl.uniform1f(t.infLoc,1/0),null!==t.nanLoc&&e.gl.uniform1f(t.nanLoc,NaN);for(let c=0;c<n.length;++c){const a=n[c],{uniform:r,offset:s,shape:o,texShape:i}=t.variablesLocations[c];if(o){const{uniformShape:n}=CC(t.program.packedInputs,a.shape,a.texData.texShape);switch(n.length){case 1:e.gl.uniform1iv(o,new Int32Array(n));break;case 2:e.gl.uniform2iv(o,new Int32Array(n));break;case 3:e.gl.uniform3iv(o,new Int32Array(n));break;case 4:e.gl.uniform4iv(o,new Int32Array(n))}}if(i&&e.gl.uniform2i(i,a.texData.texShape[0],a.texData.texShape[1]),null!=r)if(a.isUniform)if(ee(a.shape)<2)e.gl.uniform1f(r,a.uniformValues[0]);else{let t=a.uniformValues;t instanceof Float32Array||(t=new Float32Array(t)),e.gl.uniform1fv(r,t)}else null!=a.texData.slice&&null!=s&&e.gl.uniform1i(s,a.texData.slice.flatOffset),e.setInputMatrixTexture(a.texData.texture.texture,r,c)}const i=t.outShapeLocation;if(i)switch(a.shape.length){case 1:e.gl.uniform1iv(i,new Int32Array(a.shape));break;case 2:e.gl.uniform2iv(i,new Int32Array(a.shape));break;case 3:e.gl.uniform3iv(i,new Int32Array(a.shape));break;case 4:e.gl.uniform4iv(i,new Int32Array(a.shape))}if(t.outShapeStridesLocation){const n=be(a.shape);switch(a.shape.length){case 2:e.gl.uniform1iv(t.outShapeStridesLocation,new Int32Array(n));break;case 3:e.gl.uniform2iv(t.outShapeStridesLocation,new Int32Array(n));break;case 4:e.gl.uniform3iv(t.outShapeStridesLocation,new Int32Array(n))}}if(t.outTexShapeLocation&&e.gl.uniform2i(t.outTexShapeLocation,a.texData.texShape[0],a.texData.texShape[1]),t.program.customUniforms&&r)for(let c=0;c<t.program.customUniforms.length;++c){const n=t.program.customUniforms[c],a=t.customUniformLocations[c],s=r[c];if("float"===n.type)e.gl.uniform1fv(a,s);else if("vec2"===n.type)e.gl.uniform2fv(a,s);else if("vec3"===n.type)e.gl.uniform3fv(a,s);else if("vec4"===n.type)e.gl.uniform4fv(a,s);else if("int"===n.type)e.gl.uniform1iv(a,s);else if("ivec2"===n.type)e.gl.uniform2iv(a,s);else if("ivec3"===n.type)e.gl.uniform3iv(a,s);else{if("ivec4"!==n.type)throw Error("uniform type ".concat(n.type," is not supported yet."));e.gl.uniform4iv(a,s)}}e.executeProgram()}(this.gpgpu,d,l,u,a),c.forEach((e=>this.disposeIntermediateTensorInfo(e))),p&&(f=this.endTimer(f),this.activeTimers.push({name:e.constructor.name,query:this.getQueryTime(f)}));const m=_e().getNumber("WEBGL_FLUSH_THRESHOLD");if(m>0){const e=kr();e-this.lastGlFlushTime>m&&(this.gpgpu.gl.flush(),this.lastGlFlushTime=e)}if(!_e().getBool("WEBGL_LAZILY_UNPACK")&&i.isPacked&&!1===r){const e=this.unpackTensor(o);return this.disposeIntermediateTensorInfo(o),e}return o}compileAndRun(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];n=n||t[0].dtype;return this.runWebGLProgram(e,t,n,a,r)}getAndSaveBinary(e,t){return e in this.binaryCache||(this.binaryCache[e]=t()),this.binaryCache[e]}getTextureManager(){return this.textureManager}dispose(){if(!this.disposed){if(!_e().getBool("IS_TEST")){Object.keys(this.binaryCache).forEach((e=>{this.gpgpu.deleteProgram(this.binaryCache[e].webGLProgram),delete this.binaryCache[e]}))}this.textureManager.dispose(),null!=this.canvas&&"undefined"!==typeof HTMLCanvasElement&&this.canvas instanceof HTMLCanvasElement?this.canvas.remove():this.canvas=null,this.gpgpuCreatedLocally&&(this.gpgpu.program=null,this.gpgpu.dispose()),this.disposed=!0}}floatPrecision(){return null==this.floatPrecisionValue&&(this.floatPrecisionValue=Es((()=>{if(!_e().get("WEBGL_RENDER_FLOAT32_ENABLED")){const e=_e().getBool("DEBUG");_e().set("DEBUG",!1);const t=this.abs(Eo(1e-8)).dataSync()[0];if(_e().set("DEBUG",e),t>0)return 32}return 16}))),this.floatPrecisionValue}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}uploadToGPU(e){const t=this.texData.get(e),{shape:n,dtype:a,values:r,texture:s,usage:o,isPacked:i}=t;if(null!=s)return;const c=null!=this.activeTimers;let l;c&&(l=kr());let u=t.texShape;if(null==u&&(u=function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=_e().getNumber("WEBGL_MAX_TEXTURE_SIZE"),a=_e().getNumber("WEBGL_MAX_SIZE_FOR_NARROW_TEXTURE");if(a===1/0&&_e().getBool("WEBGL_AUTO_SQUARIFY_NARROW_TEXTURE_SHAPE")&&(a=n/2),t&&(n*=2,a*=2,1===(e=e.map(((t,n)=>n>=e.length-2?Y(e[n]):e[n]))).length&&(e=[2,e[0]])),2!==e.length){const t=ce(e);e=t.newShape}let r=ee(e),s=null;e.length<=1&&r<=n?s=[1,r]:2===e.length&&e[0]<=n&&e[1]<=n?s=e:3===e.length&&e[0]*e[1]<=n&&e[2]<=n?s=[e[0]*e[1],e[2]]:3===e.length&&e[0]<=n&&e[1]*e[2]<=n?s=[e[0],e[1]*e[2]]:4===e.length&&e[0]*e[1]*e[2]<=n&&e[3]<=n?s=[e[0]*e[1]*e[2],e[3]]:4===e.length&&e[0]<=n&&e[1]*e[2]*e[3]<=n&&(s=[e[0],e[1]*e[2]*e[3]]);const o=null!=s&&Math.max(...s)>a&&Math.min(...s)<=(t?2:1)&&Math.min(...s)>0;if(null==s||o)if(t){const t=ZE(e);let n=2,a=2;e.length&&([n,a]=$E(e)),r=t*(n/2)*(a/2),s=ae(r).map((e=>2*e))}else s=ae(r);return s}(n,i),t.texShape=u),null!=r){const e=eC(n);let s,o=u[1],h=u[0];const d=r instanceof Uint8Array||r instanceof Uint8ClampedArray;!i&&d||([o,h]=zE(u[0],u[1])),s=i?new VC(e,d):new WC(e,d);const p=d?[h,o]:u,f=this.makeTensorInfo(p,a),m=this.texData.get(f.dataId);m.usage=d?FE.PIXELS:FE.UPLOAD,m.texShape=p,this.gpgpu.uploadDenseMatrixToTexture(this.getTexture(f.dataId),o,h,r);const g=[[h,o]],y=!0,b=this.runWebGLProgram(s,[f],a,g,y),v=this.texData.get(b.dataId);t.texShape=v.texShape,t.isPacked=v.isPacked,t.usage=v.usage,_e().get("ENGINE_COMPILE_ONLY")?this.disposeData(b.dataId):(t.texture=v.texture,t.values=null,this.texData.delete(b.dataId)),this.disposeIntermediateTensorInfo(f),c&&(this.uploadWaitMs+=kr()-l)}else{const e=this.acquireTexture(u,o,a,i);t.texture=e}}convertAndCacheOnCPU(e,t){const n=this.texData.get(e),{dtype:a}=n;return null!=t&&(n.values=function(e,t){if("float32"===t||"complex64"===t)return e;if("int32"===t||"bool"===t){const n="int32"===t?new Int32Array(e.length):new Uint8Array(e.length);for(let t=0;t<n.length;++t)n[t]=Math.round(e[t]);return n}throw new Error("Unknown dtype ".concat(t))}(t,a)),n.values}acquireTexture(e,t,n,a){if(this.numBytesInGPU+=this.computeBytes(e,n),!this.warnedAboutMemory&&this.numBytesInGPU>1024*this.numMBBeforeWarning*1024){const e=(this.numBytesInGPU/1024/1024).toFixed(2);this.warnedAboutMemory=!0,console.warn("High memory usage in GPU: ".concat(e," MB, ")+"most likely due to a memory leak")}return this.textureManager.acquireTexture(e,t,a)}computeBytes(e,t){return e[0]*e[1]*de(t)}checkCompileCompletion(){for(const[,e]of Object.entries(this.binaryCache))this.checkCompletion_(e)}async checkCompileCompletionAsync(){const e=[];if(this.gpgpu.parallelCompilationExtension){for(const[,t]of Object.entries(this.binaryCache))e.push(this.checkCompletionAsync_(t));return Promise.all(e)}for(const[,t]of Object.entries(this.binaryCache)){const n=new Promise((e=>{try{this.checkCompletion_(t),e(!0)}catch(n){throw n}}));e.push(n)}return Promise.all(e)}async checkCompletionAsync_(e){return this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.parallelCompilationExtension.COMPLETION_STATUS_KHR)?this.checkCompletion_(e):(await Du(),this.checkCompletionAsync_(e))}checkCompletion_(e){if(!1===this.gpgpu.gl.getProgramParameter(e.webGLProgram,this.gpgpu.gl.LINK_STATUS)){if(console.log(this.gpgpu.gl.getProgramInfoLog(e.webGLProgram)),!1===this.gpgpu.gl.getShaderParameter(e.fragmentShader,this.gpgpu.gl.COMPILE_STATUS))throw GE(e.source,this.gpgpu.gl.getShaderInfoLog(e.fragmentShader)),new Error("Failed to compile fragment shader.");throw new Error("Failed to link vertex and fragment shaders.")}return!0}getUniformLocations(){for(const e of Object.values(this.binaryCache)){this.gpgpu.buildVao(e.webGLProgram);const{variablesLocations:t,customUniformLocations:n,infLoc:a,nanLoc:r,outShapeLocation:s,outShapeStridesLocation:o,outTexShapeLocation:i}=DC(this.gpgpu,e.program,e.webGLProgram);e.variablesLocations=t,e.customUniformLocations=n,e.infLoc=a,e.nanLoc=r,e.outShapeLocation=s,e.outShapeStridesLocation=o,e.outTexShapeLocation=i}}createTensorFromGPUData(e,t,n){e.channels=e.channels||"RGBA";const{texture:a,height:r,width:s,channels:o}=e,i=Ns().backend;if(!i.gpgpu.gl.isTexture(a))throw new Error("The texture is invalid. Also, please make sure the texture and the TFJS WebGL backend are using the same canvas. If you want to use your own custom canvas, you have to create and use the custom TFJS WebGL backend created from the canvas through 'new tf.MathBackendWebGL(customCanvas)'.");const c=i.writeTexture(a,t,n,r,s,o);return Ns().makeTensorFromDataId(c,t,n,i)}}wA.nextDataId=0;ps()&&As("webgl",(()=>new wA),2);const kA="\n  if (isnan(a)) return a;\n  if (isnan(b)) return b;\n";class SA{constructor(e,t,n){this.variableNames=["A","B"],this.outputShape=Go(t,n),this.enableShapeUniforms=OC(this.outputShape.length),this.userCode="\n      float binaryOperation(float a, float b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float a = getAAtOutCoords();\n        float b = getBAtOutCoords();\n        setOutput(binaryOperation(a, b));\n      }\n    ")}}const IA="\n  result.r = isNaN.r ? NAN : result.r;\n  result.g = isNaN.g ? NAN : result.g;\n  result.b = isNaN.b ? NAN : result.b;\n  result.a = isNaN.a ? NAN : result.a;\n";class NA{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];this.variableNames=["A","B"],this.supportsBroadcasting=!0,this.packedInputs=!0,this.packedOutput=!0,this.outputShape=Go(t,n);const r=this.outputShape.length;this.enableShapeUniforms=OC(r);let s="";if(a)if(0===r||1===ee(this.outputShape))s="\n          result.y = 0.;\n          result.z = 0.;\n          result.w = 0.;\n        ";else{const e=EC(r);if(s="\n          ".concat(e," coords = getOutputCoords();\n        "),1===r)this.enableShapeUniforms?s+="\n            result.y = (coords + 1) >= outShape ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ":s+="\n            result.y = (coords + 1) >= ".concat(this.outputShape[0]," ? 0. : result.y;\n            result.z = 0.;\n            result.w = 0.;\n          ");else{const e=YR("coords",r);this.enableShapeUniforms?s+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= outShape[").concat(r," - 2];\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= outShape[").concat(r," - 1];\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          "):s+="\n            bool nextRowOutOfBounds =\n              (".concat(e[r-2]," + 1) >= ").concat(this.outputShape[r-2],";\n            bool nextColOutOfBounds =\n              (").concat(e[r-1]," + 1) >= ").concat(this.outputShape[r-1],";\n            result.y = nextColOutOfBounds ? 0. : result.y;\n            result.z = nextRowOutOfBounds ? 0. : result.z;\n            result.w = nextColOutOfBounds || nextRowOutOfBounds ? 0. : result.w;\n          ")}}this.userCode="\n      vec4 binaryOperation(vec4 a, vec4 b) {\n        ".concat(e,"\n      }\n\n      void main() {\n        vec4 a = getAAtOutCoords();\n        vec4 b = getBAtOutCoords();\n\n        vec4 result = binaryOperation(a, b);\n        ").concat(s,"\n\n        setOutput(result);\n      }\n    ")}}function TA(e){const{inputs:t,backend:n}=e,{x:a}=t;return n.incRef(a.dataId),{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}const EA={kernelName:Jt,backendName:"webgl",kernelFunc:TA};function CA(e){const{inputs:t,backend:n}=e,{real:a,imag:r}=t,s=n.makeTensorInfo(a.shape,"complex64"),o=n.texData.get(s.dataId),i=TA({inputs:{x:a},backend:n}),c=TA({inputs:{x:r},backend:n});return o.complexTensorInfos={real:i,imag:c},s}const RA={kernelName:ct,backendName:"webgl",kernelFunc:CA},AA="return (a < 0.) ? b * a : a;",_A="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const DA={kernelName:an,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{alpha:s}=a,o=n.makeTensorInfo([],"float32",xr(s,"float32")),i=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new NA(_A,r.shape,o.shape):new SA(AA,r.shape,o.shape),c=n.runWebGLProgram(i,[r,o],"float32");return n.disposeIntermediateTensorInfo(o),c}},FA="return (a < 0.) ? b * a : a;",OA="\n  vec4 aLessThanZero = vec4(lessThan(a, vec4(0.)));\n  return (aLessThanZero * (b * a)) + ((vec4(1.0) - aLessThanZero) * a);\n";const MA={kernelName:Bn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a,alpha:r}=t,s=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new NA(OA,a.shape,r.shape):new SA(FA,a.shape,r.shape);return n.runWebGLProgram(s,[a,r],"float32")}},LA="if (isnan(x)) return x;";function zA(e){let{opSnippet:t,packedOpSnippet:n,cpuKernelImpl:a,dtype:r}=e;return e=>{let{inputs:s,backend:o}=e;const{x:i}=s,c=o,l=r||i.dtype;if(c.shouldExecuteOnCPU([i])&&null!=a){const e=c.texData.get(i.dataId),t=a(e.values,l);return c.makeTensorInfo(i.shape,l,t)}let u;return u=_e().getBool("WEBGL_PACK_UNARY_OPERATIONS")&&null!=n?new gA(i.shape,n):new nA(i.shape,t),c.runWebGLProgram(u,[i],l)}}function PA(e){let{opSnippet:t,packedOpSnippet:n,checkOutOfBounds:a=!1,supportsComplex:r=!1,cpuKernelImpl:s,dtype:o}=e;return e=>{let{inputs:i,backend:c}=e;const{a:l,b:u}=i,h=c;if(r&&"complex64"===l.dtype){const e=h.texData.get(l.dataId),n=h.texData.get(u.dataId),[a,r]=[[e.complexTensorInfos.real,n.complexTensorInfos.real],[e.complexTensorInfos.imag,n.complexTensorInfos.imag]].map((e=>{const[n,a]=e,r={dataId:n.dataId,dtype:n.dtype,shape:l.shape},s={dataId:a.dataId,dtype:a.dtype,shape:u.shape},o=new SA(t,l.shape,u.shape);return h.runWebGLProgram(o,[r,s],Jr(n.dtype,a.dtype))})),s=CA({inputs:{real:a,imag:r},backend:h});return h.disposeIntermediateTensorInfo(a),h.disposeIntermediateTensorInfo(r),s}const d=o||Jr(l.dtype,u.dtype);if(("string"===l.dtype||"string"===u.dtype||h.shouldExecuteOnCPU([l,u]))&&null!=s){const e=h.texData.get(l.dataId).values,t=h.texData.get(u.dataId).values,n="string"===l.dtype?Wh(e):e,a="string"===l.dtype?Wh(t):t,[r,o]=s(l.shape,u.shape,n,a,d),i=h.makeTensorInfo(o,d);return h.texData.get(i.dataId).values=r,i}let p;return p=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")&&null!=n?new NA(n,l.shape,u.shape,a):new SA(t,l.shape,u.shape),h.runWebGLProgram(p,[l,u],d)}}function BA(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if("linear"===e)return t?hA:rA;if("relu"===e)return t?pA:iA;if("elu"===e)return t?dA:oA;if("relu6"===e)return t?fA:cA;if("prelu"===e)return t?OA:FA;if("leakyrelu"===e)return t?_A:AA;if("sigmoid"===e)return t?mA:uA;throw new Error("Activation ".concat(e," has not been implemented for the WebGL backend."))}class WA{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4],s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null,i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];this.variableNames=["matrixA","matrixB"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=n,this.enableShapeUniforms=OC(this.outputShape.length);const l=a?e[1]:e[2],u=Math.ceil(l/2),h=a?"i * 2, rc.y":"rc.y, i * 2",d=r?"rc.z, i * 2":"i * 2, rc.z",p=a?["a.xxyy","a.zzww"]:["a.xxzz","a.yyww"],f=r?["b.xzxz","b.ywyw"]:["b.xyxy","b.zwzw"];let m="",g="";o&&(m=i?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(o,"\n        }"):c?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(o,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(o,"\n        }"),g="result = activation(result);");const y=s?"result += getBiasAtOutCoords();":"";s&&this.variableNames.push("bias"),i&&this.variableNames.push("preluActivationWeights"),c&&this.variableNames.push("leakyreluAlpha");let b="rc.x",v="rc.x";e[0]<t[0]?b="imod(rc.x, ".concat(e[0],")"):t[0]<e[0]&&(v="imod(rc.x, ".concat(t[0],")")),this.userCode="\n      ".concat(m,"\n      // Don't use uniform for sharedDimensionPacked for performance.\n      const float sharedDimension = ").concat(u,".0;\n\n      vec4 dot2x2ARowBCol(ivec3 rc) {\n        vec4 result = vec4(0);\n        int batchA = ").concat(b,";\n        int batchB = ").concat(v,";\n        for (int i = 0; i < ").concat(u,"; i++) {\n          vec4 a = getMatrixA(batchA, ").concat(h,");\n          vec4 b = getMatrixB(batchB, ").concat(d,");\n\n          // These swizzled products need to be separately added.\n          // See: https://github.com/tensorflow/tfjs/issues/1735\n          result += (").concat(p[0]," * ").concat(f[0],");\n          result += (").concat(p[1]," * ").concat(f[1],");\n        }\n        return result;\n      }\n\n      void main() {\n        ivec3 rc = getOutputCoords();\n        vec4 result = dot2x2ARowBCol(rc);\n\n        ").concat(y,"\n\n        ").concat(g,"\n\n        setOutput(result);\n      }\n    ")}}const VA={REAL:"return areal * breal - aimag * bimag;",IMAG:"return areal * bimag + aimag * breal;"};class UA{constructor(e,t,n){this.variableNames=["AReal","AImag","BReal","BImag"],this.outputShape=Go(t,n),this.userCode="\n      float binaryOpComplex(\n          float areal, float aimag, float breal, float bimag) {\n        ".concat(e,"\n      }\n\n      void main() {\n        float areal = getARealAtOutCoords();\n        float aimag = getAImagAtOutCoords();\n        float breal = getBRealAtOutCoords();\n        float bimag = getBImagAtOutCoords();\n        setOutput(binaryOpComplex(areal, aimag, breal, bimag));\n      }\n    ")}}const GA="return a * b;";function HA(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,s=Jr(a.dtype,r.dtype);if("complex64"===a.dtype){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),s=new UA(VA.REAL,a.shape,r.shape),o=new UA(VA.IMAG,a.shape,r.shape),i=[{dataId:e.complexTensorInfos.real.dataId,dtype:e.complexTensorInfos.real.dtype,shape:a.shape},{dataId:e.complexTensorInfos.imag.dataId,dtype:e.complexTensorInfos.imag.dtype,shape:a.shape},{dataId:t.complexTensorInfos.real.dataId,dtype:t.complexTensorInfos.real.dtype,shape:r.shape},{dataId:t.complexTensorInfos.imag.dataId,dtype:t.complexTensorInfos.imag.dtype,shape:r.shape}],c=n.runWebGLProgram(s,i,"float32"),l=n.runWebGLProgram(o,i,"float32"),u=CA({inputs:{real:c,imag:l},backend:n});return n.disposeIntermediateTensorInfo(c),n.disposeIntermediateTensorInfo(l),u}if(n.shouldExecuteOnCPU([a,r])){const e=n.texData.get(a.dataId),t=n.texData.get(r.dataId),[o,i]=wR(a.shape,r.shape,e.values,t.values,s),c=n.makeTensorInfo(i,s);return n.texData.get(c.dataId).values=o,c}let o;return o=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new NA(GA,a.shape,r.shape):new SA(GA,a.shape,r.shape),n.runWebGLProgram(o,[a,r],s)}const jA={kernelName:Cn,backendName:"webgl",kernelFunc:HA};function KA(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{shape:s}=a,o=n,i=ee(r.shape),c=oe(s,i),l=ee(c);J(i===l,(()=>"The new shape (".concat(c,") has ").concat(l," elements and the old ")+"shape (".concat(r.shape,") has ").concat(i," elements. The new shape and old ")+"shape must have the same number of elements."));const u=o.texData.get(r.dataId);return!u.isPacked||nC(r.shape,c)||null!==u.texture&&nC(u.shape,c)?(o.incRef(r.dataId),{dataId:r.dataId,shape:c,dtype:r.dtype}):function(e,t,n){const a=[ZE(e.shape),...$E(e.shape)],r={dtype:e.dtype,shape:a,dataId:e.dataId},s=[ZE(t),...$E(t)],o=new JR(s,a),i=[a],c=n.runWebGLProgram(o,[r],e.dtype,i,!0);return{dataId:c.dataId,shape:t,dtype:c.dtype}}(r,c,o)}const qA={kernelName:Xn,backendName:"webgl",kernelFunc:KA};class XA{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];const o=4*Math.floor(n/4),i=n%4;let c="sumValue += dot(values, ones);";if(null!=t){const e=1/t;c="sumValue += dot(values * ".concat(ne(e)?e.toPrecision(2):e,", ones);")}let l="";r%n>0&&(l="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return 0.0;\n        }\n      ")),this.userCode="\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ".concat(l,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(o,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(c,"\n        }\n\n        int inIdx = inOffset + ").concat(o,";\n        if (").concat(1===i,") {\n          vec4 values = vec4(getValue(batch, inIdx), 0.0, 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(2===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1), 0.0, 0.0);\n\n          ").concat(c,"\n        } else if (").concat(3===i,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2), 0.0);\n\n          ").concat(c,"\n        }\n        setOutput(sumValue);\n      }\n    ")}}class YA{constructor(e,t){this.variableNames=["x"];const{windowSize:n,batchSize:a,inSize:r,outSize:s}=e;this.outputShape=[a,s];let o="0.0",i="";"prod"===t?o="1.0":"min"===t?(o="1.0 / 1e-20",i="min"):"max"===t&&(o="-1.0 / 1e-20",i="max");let c="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"sum"===t?c="sumValue":"prod"===t?c="prodValue":"all"===t?c="allValue":"any"===t&&(c="anyValue");const l=4*Math.floor(n/4),u=n%4;let h="\n      if (".concat("sum"===t,") {\n        sumValue += dot(values, ones);\n      } else if (").concat("prod"===t,") {\n        vec2 tmp = vec2(values[0], values[1]) * vec2(values[2], values[3]);\n        prodValue *= tmp[0] * tmp[1];\n      } else {\n        minMaxValue = ").concat(i,"(values, minMaxValue);\n        if (").concat("min"===t," || ").concat("max"===t,") {\n          minMaxValue = ").concat(i,"(values, minMaxValue);\n          bvec4 isNaN = isnan(values);\n          if (isNaN.r || isNaN.g || isNaN.b || isNaN.a) {\n            minMaxValue = vec4(NAN);\n          }\n        }\n      }\n    "),d="vec4";"all"===t?(o="1.0",h="\n        bool reducedAllValue = all(values);\n        float floatedReducedAllValue = float(reducedAllValue);\n        allValue = float(allValue >= 1.0 && floatedReducedAllValue >= 1.0);\n      ",d="bvec4"):"any"===t&&(o="0.0",h="\n        bool reducedAnyValue = any(values);\n        float floatedReducedAnyValue = float(reducedAnyValue);\n        anyValue = float(anyValue >= 1.0 || floatedReducedAnyValue >= 1.0);\n      ",d="bvec4");let p="";r%n>0&&(p="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat(o,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float getValue(int batch, int inIdx) {\n        ").concat(p,"\n        return getX(batch, inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ").concat(n,";\n\n        vec4 minMaxValue = vec4(").concat(o,");\n        float prodValue = 1.0;\n        float sumValue = 0.0;\n        float allValue = 1.0;\n        float anyValue = 0.0;\n\n        for (int i = 0; i < ").concat(l,"; i += 4) {\n          int inIdx = inOffset + i;\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          ").concat(h,"\n        }\n\n        int inIdx = inOffset + ").concat(l,";\n        if (").concat(1===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(2===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          ").concat(h,"\n        } else if (").concat(3===u,") {\n          ").concat(d," values = ").concat(d,"(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          ").concat(h,"\n        }\n        setOutput(").concat(c,");\n      }\n    ")}}function QA(e,t,n,a){const r=function(e){const t=[];for(;0===t.length||1!==t[t.length-1].outSize;){const n=t.length?t[t.length-1].outSize:e[1],a=Vu(n);t.push({inSize:n,windowSize:a,outSize:Math.ceil(n/a)})}return t}(e.shape);let s=e;for(let o=0;o<r.length;o++){const{inSize:i,windowSize:c,outSize:l}=r[o];let u,h;u="mean"===n?0===o?new XA({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},i):new XA({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l}):new YA({windowSize:c,inSize:i,batchSize:e.shape[0],outSize:l},n),h=s,s=a.runWebGLProgram(u,[s],t),h.dataId!==e.dataId&&a.disposeIntermediateTensorInfo(h)}return s}class JA{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[t[s]];this.outputShape=n,this.rank=n.length;const a=EC(this.rank),r=function(e){const t=e.length;if(t>6)throw Error("Transpose for rank ".concat(t," is not yet supported"));const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u","resRC.v"],a=new Array(t);for(let r=0;r<e.length;r++)a[e[r]]=n[r];return a.join()}(t);this.userCode="\n    void main() {\n      ".concat(a," resRC = getOutputCoords();\n      setOutput(getA(").concat(r,"));\n    }\n    ")}}class ZA{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0;const n=new Array(e.length);for(let l=0;l<n.length;l++)n[l]=e[t[l]];if(this.outputShape=n,this.rank=n.length,this.rank>6)throw Error("Packed transpose for rank ".concat(this.rank," is not yet supported."));const a=EC(this.rank),r=XR("rc",this.rank),s=new Array(this.rank);for(let l=0;l<t.length;l++)s[t[l]]=r[l];const o="vec2(".concat(s.slice(-2).join(),")"),i="++".concat(r[this.rank-1]," < ").concat(n[this.rank-1]),c="getChannel(getA(".concat(s.join(),"), ").concat(o,")");this.userCode="\n    void main() {\n      ".concat(a," rc = getOutputCoords();\n      vec4 result = vec4(0.);\n      result[0] = ").concat(c,";\n      if(").concat(i,") {\n        result[1] = ").concat(c,";\n      }\n      --").concat(r[this.rank-1],";\n      if(++").concat(r[this.rank-2]," < ").concat(n[this.rank-2],") {\n        result[2] = ").concat(c,";\n        if(").concat(i,") {\n          result[3] = ").concat(c,";\n        }\n      }\n      setOutput(result);\n    }\n    ")}}function $A(e,t,n){const a=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ZA(e.shape,t):new JA(e.shape,t);return n.runWebGLProgram(a,[e],e.dtype)}function e_(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a;return function(e,t,n,a){const r=t,s=e.shape.length,o=ie(r,e.shape);let i=o;const c=Dc(i,s),l=null!=c;let u=e;l&&(u=$A(e,c,a),i=Oc(i.length,s)),_c("sum",i,s);const[h,d]=Rc(u.shape,i);let p=h;n&&(p=Ac(h,o));const f=ee(d),m=KA({inputs:{x:u},attrs:{shape:[ee(e.shape)/f,f]},backend:a}),g=QA(m,Zr(e.dtype),"sum",a),y=KA({inputs:{x:g},attrs:{shape:p},backend:a});return a.disposeIntermediateTensorInfo(m),a.disposeIntermediateTensorInfo(g),l&&a.disposeIntermediateTensorInfo(u),y}(r,s,o,n)}const t_={kernelName:ma,backendName:"webgl",kernelFunc:e_};function n_(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{perm:s}=a,o=n,i=r.shape.length,c=new Array(i);for(let u=0;u<c.length;u++)c[u]=r.shape[s[u]];let l;if(o.shouldExecuteOnCPU([r])){const e=o.texData.get(r.dataId).values,t=KR(e,r.shape,r.dtype,s,c);l=o.makeTensorInfo(c,r.dtype);o.texData.get(l.dataId).values=t}else l=$A(r,s,o);return l}const a_={kernelName:za,backendName:"webgl",kernelFunc:n_},r_=1e3;function s_(e){let{a:t,b:n,transposeA:a,transposeB:r,backend:s,bias:o=null,preluActivationWeights:i=null,leakyreluAlpha:c=0,activation:l=null}=e;const u=t.shape.length,h=n.shape.length,d=a?t.shape[u-2]:t.shape[u-1],p=r?n.shape[h-1]:n.shape[h-2],f=a?t.shape[u-1]:t.shape[u-2],m=r?n.shape[h-2]:n.shape[h-1],g=t.shape.slice(0,-2),y=n.shape.slice(0,-2),b=ee(g),v=ee(y),x=Go(t.shape.slice(0,-2),n.shape.slice(0,-2)).concat([f,m]);J(d===p,(()=>"Error in matMul: inner shapes (".concat(d,") and (")+"".concat(p,") of Tensors with shapes ").concat(t.shape," and ")+"".concat(n.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const w=a?[b,d,f]:[b,f,d],k=r?[v,m,p]:[v,p,m],S=KA({inputs:{x:t},backend:s,attrs:{shape:w}}),I=KA({inputs:{x:n},backend:s,attrs:{shape:k}}),N=[S,I],T=Math.max(b,v),E=a?S.shape[1]:S.shape[2],C=null!=o,R=null!=i,A="leakyrelu"===l,_=null!=l?BA(l,!0):null;let D;if((1===f||1===m)&&E>r_&&!1===(C||R||A||null!=_)){let e=S,t=I;a&&(e=n_({inputs:{x:S},backend:s,attrs:{perm:[0,2,1]}}),N.push(e)),r&&(t=n_({inputs:{x:I},backend:s,attrs:{perm:[0,2,1]}}),N.push(t));const n=1===m;let o=e;1!==m&&(o=KA({inputs:{x:e},backend:s,attrs:{shape:[T,E,1]}}),N.push(o));const i=1===m?2:1;let c=t;n&&(c=KA({inputs:{x:t},backend:s,attrs:{shape:[T,1,E]}}),N.push(c));const l=HA({inputs:{a:o,b:c},backend:s});D=e_({inputs:{x:l},backend:s,attrs:{axis:i,keepDims:!0}}),N.push(l)}else{const e=Jr(t.dtype,n.dtype),l=new WA(w,k,[T,f,m],a,r,C,_,R,A),u=[S,I];if(null!=o&&u.push(o),R&&u.push(i),A){const e=s.makeTensorInfo([],"float32",xr(c,"float32"));u.push(e),N.push(e)}D=s.runWebGLProgram(l,u,e)}const F=KA({inputs:{x:D},backend:s,attrs:{shape:x}});N.push(D);for(const O of N)s.disposeIntermediateTensorInfo(O);return F}const o_={kernelName:ja,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s,bias:o,preluActivationWeights:i}=t,{transposeA:c,transposeB:l,activation:u,leakyreluAlpha:h}=a;return s_({a:r,b:s,transposeA:c,transposeB:l,backend:n,bias:o,preluActivationWeights:i,leakyreluAlpha:h,activation:u})}},i_="return abs(x);";const c_={kernelName:Le,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])&&"complex64"!==a.dtype){const e=n.texData.get(a.dataId),t=DR(e.values);return n.makeTensorInfo(a.shape,a.dtype,t)}let r;return r=_e().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new gA(a.shape,i_):new nA(a.shape,i_),n.runWebGLProgram(r,[a],a.dtype)}},l_=zA({opSnippet:aA+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return acos(x);\n"}),u_={kernelName:ze,backendName:"webgl",kernelFunc:l_},h_=zA({opSnippet:aA+"\n  if (x < 1.0) return NAN;\nreturn log(x + sqrt(x * x - 1.0));"}),d_={kernelName:Pe,backendName:"webgl",kernelFunc:h_},p_="return a + b;",f_=PA({opSnippet:p_,packedOpSnippet:p_,supportsComplex:!0,cpuKernelImpl:$C}),m_={kernelName:Be,backendName:"webgl",kernelFunc:f_};class g_{constructor(e,t){this.outputShape=[],this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("float v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        float result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}class y_{constructor(e,t){this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.variableNames=t.map(((e,t)=>"T".concat(t)));const n=[];this.variableNames.forEach((e=>{n.push("vec4 v".concat(e," = get").concat(e,"AtOutCoords();"))}));const a=this.variableNames.map((e=>"v".concat(e))).join(" + ");this.userCode="\n      void main() {\n        ".concat(n.join("\n        "),"\n\n        vec4 result = ").concat(a,";\n        setOutput(result);\n      }\n    ")}}const b_={kernelName:We,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,r=n;if(1===r.length)return TA({inputs:{x:r[0]},backend:a});if(r.length>_e().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER")){const t=Math.floor(r.length/2),n=e({inputs:r.slice(0,t),backend:a}),s=e({inputs:r.slice(t),backend:a});return e({inputs:[n,s],backend:a})}const s=r.map((e=>e.dtype)).reduce(((e,t)=>Jr(e,t))),o=r.map((e=>e.shape)),i=_e().getBool("WEBGL_PACK")?new y_(r[0].shape,o):new g_(r[0].shape,o);return a.runWebGLProgram(i,r,s)}};const v_={kernelName:Ve,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,c=ie(s,r.shape);let l=c;const u=Dc(l,i);let h=r;null!=u&&(h=n_({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Oc(l.length,i)),_c("all",l,i);const[d,p]=Rc(h.shape,l),f=KA({inputs:{x:h},backend:n,attrs:{shape:[-1,ee(p)]}}),m=QA(f,f.dtype,"all",n);let g;if(o){g=KA({inputs:{x:m},backend:n,attrs:{shape:Ac(d,c)}})}else g=KA({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}};const x_={kernelName:Ue,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,c=ie(s,r.shape);let l=c;const u=Dc(l,i);let h=r;null!=u&&(h=n_({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Oc(l.length,i)),_c("any",l,i);const[d,p]=Rc(h.shape,l),f=KA({inputs:{x:h},backend:n,attrs:{shape:[-1,ee(p)]}}),m=QA(f,f.dtype,"any",n);let g;if(o){g=KA({inputs:{x:m},backend:n,attrs:{shape:Ac(d,c)}})}else g=KA({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}};class w_{constructor(e,t,n){this.variableNames=["A"];const{windowSize:a,batchSize:r,outSize:s}=e;n||this.variableNames.push("bestIndicesA"),this.outputShape=[r,s];const o="max"===t?">":"<",i=n?"inOffset + i;":"round(getBestIndicesA(batch, inOffset + i));";this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = outIdx * ".concat(a,";\n\n        int bestIndex = inOffset;\n        float bestValue = getA(batch, bestIndex);\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          int inIdx = ").concat(i,";\n          float candidate = getA(batch, inIdx);\n          if (candidate ").concat(o," bestValue) {\n            bestValue = candidate;\n            bestIndex = inIdx;\n          }\n        }\n        setOutput(float(bestIndex));\n      }\n    ")}}class k_{constructor(e,t,n,a){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,J(e.length>2,(()=>"Packed arg".concat(n.charAt(0).toUpperCase()+n.slice(1)," supports only inputs with rank above 2.")));const r=e[e.length-1],s=Math.ceil(r/t);this.outputShape=e.slice(0,-1),s>1&&this.outputShape.push(s),a||this.variableNames.push("bestIndicesA");const o=this.outputShape,i=o.length,c=EC(i),l=YR("coords",i);let u,h;if(1===s){h=i+1;const e=EC(h);u="\n        ".concat(e," sourceLocR = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-1],";\n        ").concat(e," sourceLocG = ").concat(e,"(").concat(l.join(),", 0);\n        ++").concat(l[i-2],";\n        ").concat(e," sourceLocA = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-1],";\n        ").concat(e," sourceLocB = ").concat(e,"(").concat(l.join(),", 0);\n        --").concat(l[i-2],";")}else h=i,u="\n        ".concat(c," sourceLocR = coords;\n        ++").concat(l[i-1],";\n        ").concat(c," sourceLocG = coords;\n        ++").concat(l[i-2],";\n        ").concat(c," sourceLocA = coords;\n        --").concat(l[i-1],";\n        ").concat(c," sourceLocB = coords;\n        --").concat(l[i-2],";");const d=["x","y","z","w","u","v"].slice(0,h),p="."+d[h-1],f=d.map((e=>"int "+e)),m=YR("sourceLocR",h-1).concat("inIdx.r"),g=YR("sourceLocG",h-1).concat("inIdx.g"),y=YR("sourceLocB",h-1).concat("inIdx.b"),b=YR("sourceLocA",h-1).concat("inIdx.a"),v="max"===n?"greaterThan":"lessThan",x=a?"":"\n          inIdx = round(vec4(getBestIndicesAChannel(".concat(m.join(),"),\n                             getBestIndicesAChannel(").concat(g.join(),"),\n                             getBestIndicesAChannel(").concat(y.join(),"),\n                             getBestIndicesAChannel(").concat(b.join(),")));"),w="vec4(\n            getAChannel(".concat(m.join(),"),\n            hasNextCol ? getAChannel(").concat(g.join(),") : 0.,\n            hasNextRow ? getAChannel(").concat(y.join(),") : 0.,\n            hasNextRow && hasNextCol ? getAChannel(").concat(b.join(),") : 0.)"),k=a?"":"\n      float getBestIndicesAChannel(".concat(f.join(),") {\n        return getChannel(getBestIndicesA(").concat(d.join(),"),\n                                          vec2(").concat(d.slice(-2).join(),"));\n      }");this.userCode="\n      float getAChannel(".concat(f.join(),") {\n        return getChannel(getA(").concat(d.join(),"),\n                               vec2(").concat(d.slice(-2).join(),"));\n      }\n      ").concat(k,"\n      void main() {\n        ").concat(c," coords = getOutputCoords();\n        bool hasNextCol = ").concat(l[i-1]," < ").concat(o[i-1]-1,";\n        bool hasNextRow = ").concat(l[i-2]," < ").concat(o[i-2]-1,";\n        ").concat(u,"\n        ivec4 srcIdx = ivec4(sourceLocR").concat(p,", sourceLocG").concat(p,",\n          sourceLocB").concat(p,", sourceLocA").concat(p,") * ").concat(t,";\n        ivec4 inIdx = srcIdx;\n        vec4 bestIndex = vec4(inIdx);\n        vec4 bestValue = ").concat(w,";\n\n        for (int i = 0; i < ").concat(t,"; i++) {\n          inIdx = srcIdx;\n          ").concat(x,"\n          vec4 candidate = ").concat(w,";\n          bvec4 nan = isnan(candidate);\n          bvec4 replace = bvec4(\n            vec4(").concat(v,"(candidate, bestValue)) * (vec4(1.0) - vec4(nan)));\n\n          bestValue = vec4(replace.x  ? candidate.x : bestValue.x,\n                           replace.y  ? candidate.y : bestValue.y,\n                           replace.z  ? candidate.z : bestValue.z,\n                           replace.w  ? candidate.w : bestValue.w);\n          bestIndex = mix(bestIndex, vec4(inIdx), vec4(replace));\n          srcIdx++;\n        }\n        setOutput(bestIndex);\n      }\n    ")}}function S_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=t.shape[0],s=t.shape[1];null!=a&&(r=a.shape[0],s=a.shape[1]);const o=Vu(s),i={windowSize:o,inSize:s,batchSize:r,outSize:Math.ceil(s/o)},c=new w_(i,n,null==a),l=[t];null!=a&&l.push(a);const u=e.runWebGLProgram(c,l,"int32");if(1===u.shape[1])return u;const h=S_(e,t,n,u);return e.disposeIntermediateTensorInfo(u),h}function I_(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;const r=null!=a?a.shape:t.shape,s=Vu(r[r.length-1]),o=new k_(r,s,n,null==a),i=null==a?[t]:[t,a],c=e.runWebGLProgram(o,i,"int32");if(c.shape.length===t.shape.length){const a=I_(e,t,n,c);return e.disposeIntermediateTensorInfo(c),a}return c}function N_(e,t,n,a){const r=[n];if(_c("arg"+a.charAt(0).toUpperCase()+a.slice(1),r,t.shape.length),!_e().getBool("WEBGL_PACK_REDUCE")||t.shape.length<=2){const n=[],s=e.texData.get(t.dataId);let o=t;null!==s&&s.isPacked&&(o=e.unpackTensor(t),n.push(o));const[i,c]=Rc(o.shape,r),l=ee(c),u=KA({inputs:{x:o},backend:e,attrs:{shape:[-1,l]}});n.push(u);const h=S_(e,u,a);n.push(h);const d=KA({inputs:{x:h},backend:e,attrs:{shape:i}});return n.forEach((t=>e.disposeIntermediateTensorInfo(t))),d}return I_(e,t,a)}const T_={kernelName:Ge,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let o=ie(s,r.shape);const i=Dc(o,r.shape.length);let c=r;const l=[];null!=i&&(c=n_({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),o=Oc(o.length,c.shape.length)),_c("argMax",[o[0]],c.shape.length);const u=N_(n,c,o[0],"max");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}};const E_={kernelName:He,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s}=a;let o=ie(s,r.shape);const i=Dc(o,r.shape.length);let c=r;const l=[];null!=i&&(c=n_({inputs:{x:r},backend:n,attrs:{perm:i}}),l.push(c),o=Oc(o.length,c.shape.length)),_c("argMin",[o[0]],c.shape.length);const u=N_(n,c,o[0],"min");return l.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}},C_=zA({opSnippet:aA+"\n  if (abs(x) > 1.) {\n    return NAN;\n  }\n  return asin(x);\n"}),R_={kernelName:je,backendName:"webgl",kernelFunc:C_},A_=zA({opSnippet:aA+"return log(x + sqrt(x * x + 1.0));"}),__={kernelName:Ke,backendName:"webgl",kernelFunc:A_},D_=zA({opSnippet:aA+"\n  return atan(x);\n"}),F_={kernelName:qe,backendName:"webgl",kernelFunc:D_},O_=PA({opSnippet:kA+"\n  return atan(a, b);\n",packedOpSnippet:"\n  vec4 result = atan(a, b);\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+IA+"\n  return result;\n"}),M_={kernelName:Ye,backendName:"webgl",kernelFunc:O_},L_=zA({opSnippet:aA+"\n  if ((x < -1.0) || (x > 1.0)) return NAN;\nreturn (log(1.0 + x) - log(1.0 - x)) / 2.0;"}),z_={kernelName:Xe,backendName:"webgl",kernelFunc:L_};class P_{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideHeight,i=e.strideWidth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterHeight,h=e.effectiveFilterWidth,d=e.padInfo.top,p=e.padInfo.left;this.outputShape=e.outShape;const f="avg"===t,m="((batch  * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + d"),g="(xR * ".concat(e.inWidth," + xC) * ").concat(e.inChannels," + d");let y="0.0";if(f||(y="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n        const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int batch = coords[0];\n          int d = coords[3];\n\n          ivec2 xRCCorner = coords.yz * strides - pads;\n          int xRCorner = xRCCorner.x;\n          int xCCorner = xRCCorner.y;\n\n          // max/min x(?, ?, d) to get y(yR, yC, d).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n          float avgValue = 0.0;\n\n          for (int wR = 0; wR < ").concat(u,";\n              wR += ").concat(c,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(h,";\n                wC += ").concat(l,") {\n              int xC = xCCorner + wC;\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float value = getX(batch, xR, xC, d);\n\n              // If a min / max value has already been found, use it. If not,\n              // use the current value.\n              float currMinMaxValue = mix(\n                  value, minMaxValue, minMaxValueFound);\n              if (value ").concat(t," currMinMaxValue) {\n                minMaxValue = value;\n                minMaxValueFound = 1.0;\n                minMaxPosition = ").concat(a?r?m:g:"wR * ".concat(h," + wC"),";\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let b="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(b="avgValue / max(count, 1.0)");const v=4*Math.floor(s/4),x=s%4,w="\n      if (".concat(f,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec2 strides = ivec2(".concat(o,", ").concat(i,");\n      const ivec2 pads = ivec2(").concat(d,", ").concat(p,");\n      const float initializationValue = ").concat(y,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xR, int xC, int d) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xR, xC, d);\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d = coords[3];\n\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // max/min x(?, ?, d) to get y(yR, yC, d).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(y,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wR = 0; wR < ").concat(u,";\n            wR += ").concat(c,") {\n          int xR = xRCorner + wR;\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(v,"; wC += 4) {\n            int xC = xCCorner + wC * ").concat(l,";\n\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              getValue(batch, xR, xC + 3 * ").concat(l,", d)\n            );\n\n            ").concat(w,"\n          }\n\n          int xC = xCCorner + ").concat(v,";\n          if (").concat(1===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              initializationValue,\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(2===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              initializationValue,\n              initializationValue\n            );\n\n            ").concat(w,"\n          } else if (").concat(3===x,") {\n            vec4 values = vec4(\n              getValue(batch, xR, xC, d),\n              getValue(batch, xR, xC + ").concat(l,", d),\n              getValue(batch, xR, xC + 2 * ").concat(l,", d),\n              initializationValue\n            );\n\n            ").concat(w,"\n          }\n        }\n        setOutput(").concat(b,");\n      }\n    ")}}class B_{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(this.variableNames=["x"],"avg"===t&&n)throw new Error("Cannot compute positions for average pool.");const s=e.filterWidth,o=e.strideDepth,i=e.strideHeight,c=e.strideWidth,l=e.dilationDepth,u=e.dilationHeight,h=e.dilationWidth,d=e.effectiveFilterDepth,p=e.effectiveFilterHeight,f=e.effectiveFilterWidth,m=e.padInfo.front,g=e.padInfo.top,y=e.padInfo.left;this.outputShape=e.outShape;const b="avg"===t;let v="0.0";if(b||(v="-1.0 / 1e-20"),n){const t=">=";return void(this.userCode="\n        const ivec3 strides =\n            ivec3(".concat(o,", ").concat(i,", ").concat(c,");\n        const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(y,");\n\n        void main() {\n          ivec5 coords = getOutputCoords();\n          int batch = coords.x;\n          int ch = coords.u;\n\n          ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n          int xDCorner = xCorner.x;\n          int xRCorner = xCorner.y;\n          int xCCorner = xCorner.z;\n\n          // max/min x(?, ?, ?, ch) to get y(yD, yR, yC, ch).\n          // ? = to be determined\n          float minMaxValue = 0.0;\n          float minMaxValueFound = 0.0;\n          int minMaxPosition = 0;\n\n          for (int wD = 0; wD < ").concat(d,";\n              wD += ").concat(l,") {\n            int xD = xDCorner + wD;\n\n            if (xD < 0 || xD >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int wR = 0; wR < ").concat(p,";\n                wR += ").concat(u,") {\n              int xR = xRCorner + wR;\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int wC = 0; wC < ").concat(f,";\n                  wC += ").concat(h,") {\n                int xC = xCCorner + wC;\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float value = getX(batch, xD, xR, xC, ch);\n\n                // If a min / max value has already been found, use it. If not,\n                // use the current value.\n                float currMinMaxValue = mix(\n                    value, minMaxValue, minMaxValueFound);\n                if (value ").concat(t," currMinMaxValue) {\n                  minMaxValue = value;\n                  minMaxValueFound = 1.0;\n                  minMaxPosition = ").concat(a?r?"(((batch * ".concat(e.inDepth," + xD) * ").concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"((xD * ".concat(e.inHeight," + xR) * ").concat(e.inWidth," + xC) * ").concat(e.inChannels," + ch"):"wD * ".concat(p," * ").concat(f," +\n                      wR * ").concat(f," + wC"),";\n                }\n              }\n            }\n          }\n          setOutput(float(minMaxPosition));\n        }\n      "))}let x="".concat(t,"(").concat(t,"(").concat(t,"(")+"minMaxValue[0], minMaxValue[1]), minMaxValue[2]), minMaxValue[3])";"avg"===t&&(x="avgValue / max(count, 1.0)");const w=4*Math.floor(s/4),k=s%4,S="\n      if (".concat(b,") {\n        avgValue += dot(values, ones);\n      } else {\n        minMaxValue = ").concat("max","(values, minMaxValue);\n      }\n    ");this.userCode="\n      const ivec3 strides =\n        ivec3(".concat(o,", ").concat(i,", ").concat(c,");\n      const ivec3 pads = ivec3(").concat(m,", ").concat(g,", ").concat(y,");\n      const float initializationValue = ").concat(v,";\n      const vec4 ones = vec4(1.0, 1.0, 1.0, 1.0);\n\n      float count = 0.0;\n\n      float getValue(int batch, int xD, int xR, int xC, int ch) {\n        if (xC < 0 || xC >= ").concat(e.inWidth,") {\n          return initializationValue;\n        }\n        count += 1.0;\n        return getX(batch, xD, xR, xC, ch);\n      }\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 xCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xDCorner = xCorner.x;\n        int xRCorner = xCorner.y;\n        int xCCorner = xCorner.z;\n\n        // max/min x(?, ?, ?, d) to get y(yD, yR, yC, ch).\n        // ? = to be determined\n        vec4 minMaxValue = vec4(").concat(v,");\n        float avgValue = 0.0;\n        count = 0.0;\n\n        for (int wD = 0; wD < ").concat(d,";\n            wD += ").concat(l,") {\n          int xD = xDCorner + wD;\n\n          if (xD < 0 || xD >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(p,";\n            wR += ").concat(u,") {\n            int xR = xRCorner + wR;\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(w,"; wC += 4) {\n              int xC = xCCorner + wC * ").concat(h,";\n\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 3 * ").concat(h,", ch)\n              );\n\n              ").concat(S,"\n            }\n\n            int xC = xCCorner + ").concat(w,";\n            if (").concat(1===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                initializationValue,\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(2===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                initializationValue,\n                initializationValue\n              );\n\n              ").concat(S,"\n            } else if (").concat(3===k,") {\n              vec4 values = vec4(\n                getValue(batch, xD, xR, xC, ch),\n                getValue(batch, xD, xR, xC + ").concat(h,", ch),\n                getValue(batch, xD, xR, xC + 2 * ").concat(h,", ch),\n                initializationValue\n              );\n\n              ").concat(S,"\n            }\n          }\n        }\n        setOutput(").concat(x,");\n      }\n    ")}}const W_={kernelName:Qe,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;lC(r,"avgPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:c}=a;J(zi(o,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const l=Ei(r.shape,s,o,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&te(l.inShape,l.outShape))return TA({inputs:{x:r},backend:n});const u=new P_(l,"avg",!1);return n.runWebGLProgram(u,[r],"float32")}};const V_={kernelName:Ze,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dimRoundingMode:c,dataFormat:l}=a,u=Ci(r.shape,s,o,[1,1,1],i,c,l),h=new B_(u,"avg",!1);return n.runWebGLProgram(h,[r],"float32")}};class U_{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterHeight,c=e.effectiveFilterWidth,l=i-1-e.padInfo.top,u=c-1-e.padInfo.left,h=1/(t*n);this.userCode="\n      const ivec2 pads = ivec2(".concat(l,", ").concat(u,");\n      const float avgMultiplier = float(").concat(h,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(i,";\n            wR += ").concat(s,") {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(c,";\n            wC+= ").concat(o,") {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n\n            dotProd += dyValue * avgMultiplier;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class G_{constructor(e){this.variableNames=["dy"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.effectiveFilterDepth,h=e.effectiveFilterHeight,d=e.effectiveFilterWidth,p=u-1-e.padInfo.front,f=h-1-e.padInfo.top,m=d-1-e.padInfo.left,g=1/(t*n*a);this.userCode="\n      const ivec3 pads = ivec3(".concat(p,", ").concat(f,", ").concat(m,");\n      const float avgMultiplier = float(").concat(g,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, d) with pos mask(:, :, :, ch) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(u,";\n            wD += ").concat(i,") {\n          float dyD = float(dyDCorner + wD) / ").concat(r,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(h,";\n              wR += ").concat(c,") {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(d,";\n                wC += ").concat(l,") {\n              float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n\n              dotProd += dyValue * avgMultiplier;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const H_={kernelName:$e,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,h=Ci(o.shape,i,c,[1,1,1],l,u),d=new G_(h);return n.runWebGLProgram(d,[r],o.dtype)}};const j_={kernelName:Je,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s;lC([r,s],"avgPoolGrad");const{filterSize:i,strides:c,pad:l}=a,u=Ei(o.shape,i,c,1,l),h=new U_(u);return n.runWebGLProgram(h,[r],o.dtype)}};const K_={kernelName:et,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{a:r,b:s}=t,{transposeA:o,transposeB:i}=a;return s_({a:r,b:s,transposeA:o,transposeB:i,backend:n})}};class q_{constructor(e,t,n,a,r,s){this.outputShape=[],this.variableNames=["x","mean","variance"],Go(e,t),Go(e,n);let o="0.0";null!=a&&(Go(e,a),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="1.0";null!=r&&(Go(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        float x = getXAtOutCoords();\n        float mean = getMeanAtOutCoords();\n        float variance = getVarianceAtOutCoords();\n        float offset = ".concat(o,";\n        float scale = ").concat(i,";\n        float inv = scale * inversesqrt(variance + float(").concat(s,"));\n        setOutput(dot(vec3(x, -mean, offset), vec3(inv, inv, 1)));\n      }\n    ")}}class X_{constructor(e,t,n,a,r,s){this.packedInputs=!0,this.packedOutput=!0,this.variableNames=["x","mean","variance"],Go(e,t),Go(e,n);let o="vec4(0.0)";null!=a&&(Go(e,a),this.variableNames.push("offset"),o="getOffsetAtOutCoords()");let i="vec4(1.0)";null!=r&&(Go(e,r),this.variableNames.push("scale"),i="getScaleAtOutCoords()"),this.outputShape=e,this.userCode="\n      void main() {\n        vec4 offset = ".concat(o,";\n        vec4 scale = ").concat(i,";\n\n        vec4 x = getXAtOutCoords();\n        vec4 mean = getMeanAtOutCoords();\n        vec4 variance = getVarianceAtOutCoords();\n\n        vec4 inv = scale * inversesqrt(variance + vec4(").concat(s,"));\n\n        setOutput((x - mean) * inv + offset);\n      }\n    ")}}const Y_={kernelName:Kt,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r,mean:s,variance:o,offset:i,scale:c}=t;J(s.shape.length===o.shape.length,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),J(null==i||s.shape.length===i.shape.length,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),J(null==c||s.shape.length===c.shape.length,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));let{varianceEpsilon:l}=a;null==l&&(l=.001);const u=[r,s,o];let h=null;null!=i&&(h=i.shape,u.push(i));let d=null;null!=c&&(d=c.shape,u.push(c));const p=_e().getBool("WEBGL_PACK_NORMALIZATION")?new X_(r.shape,s.shape,o.shape,h,d,l):new q_(r.shape,s.shape,o.shape,h,d,l);return n.runWebGLProgram(p,u,u[0].dtype)}};class Q_{constructor(e){this.variableNames=["source"],this.outputShape=e,this.rank=e.length;const t=EC(this.rank);this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const n=function(e){if(1===e)return"sourceLoc";if(e<=6)return J_.slice(0,e).map((e=>"sourceLoc."+e)).join(",");throw Error("Slicing for rank ".concat(e," is not yet supported"))}(this.rank);let a;const r=e.map(((e,t)=>"sourceLoc.".concat(J_[t]," = start[").concat(t,"] + coords.").concat(J_[t],";")));a="\n        ".concat(t," sourceLoc;\n        ").concat(t," coords = getOutputCoords();\n        ").concat(r.join("\n"),"\n      "),this.userCode="\n      void main() {\n        ".concat(a,"\n        setOutput(getSource(").concat(n,"));\n      }\n    ")}}const J_=["x","y","z","w","u","v"];class Z_{constructor(e){this.variableNames=["source"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=e,this.rank=e.length,this.customUniforms=[{name:"start",arrayIndex:this.rank,type:"int"}];const t=EC(this.rank),n=YR("coords",this.rank),a=YR("sourceLoc",this.rank),r=1===this.rank?"sourceLoc":"vec2(".concat(a.slice(-2).join(),")"),s="getChannel(getSource(".concat(a.join(),"), ").concat(r,")"),o="\n      result.x = ".concat(s,";\n      if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n        ++").concat(a[this.rank-1],";\n        result.y = ").concat(s,";\n        --").concat(a[this.rank-1],";\n      }\n    "),i=1===this.rank?"":"\n      --".concat(n[this.rank-1],";\n      if (++").concat(n[this.rank-2]," < ").concat(e[this.rank-2],") {\n        ++").concat(a[this.rank-2],";\n        result.z = ").concat(s,";\n        if (++").concat(n[this.rank-1]," < ").concat(e[this.rank-1],") {\n          ++").concat(a[this.rank-1],";\n          result.w = ").concat(s,";\n        }\n      }\n    "),c=this.rank<=4?"sourceLoc = coords +\n            ".concat(t,"(").concat(e.map(((e,t)=>"start[".concat(t,"]"))).join(),");"):e.map(((e,t)=>"".concat(a[t]," = ").concat(n[t]," + start[").concat(t,"];"))).join("\n");this.userCode="\n      void main() {\n        ".concat(t," coords = getOutputCoords();\n        ").concat(t," sourceLoc;\n        ").concat(c,"\n        vec4 result = vec4(0.);\n        ").concat(o,"\n        ").concat(i,"\n        setOutput(result);\n      }\n    ")}}function $_(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,size:o}=a,[i,c]=xi(r,s,o);if(oi(r,i,c),0===ee(c))return n.makeTensorInfo(c,r.dtype,[]);if(n.shouldExecuteOnCPU([r])||"string"===r.dtype){const e=n.texData.get(r.dataId),t=FR(e.values,i,c,r.shape,r.dtype);return n.makeTensorInfo(c,r.dtype,t)}const{isPacked:l}=n.texData.get(r.dataId),u=bi(r.shape,i,c);if(l||!u){const e=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new Z_(c):new Q_(c),t=[i];return n.runWebGLProgram(e,[r],r.dtype,t)}return n.uploadToGPU(r.dataId),function(e,t,n,a){const r=a.texData.get(e.dataId),s=a.makeTensorInfo(n,e.dtype),o=a.texData.get(s.dataId);Object.assign(o,r),o.refCount=1,o.shape=n,o.dtype=e.dtype;let i=vi(t,be(e.shape));r.slice&&(i+=r.slice.flatOffset),o.slice={flatOffset:i,origDataId:r.slice&&r.slice.origDataId||e.dataId};const c=a.dataRefCount.get(o.slice.origDataId)||1;return a.dataRefCount.set(o.slice.origDataId,c+1),s}(r,i,c,n)}const eD={kernelName:ca,backendName:"webgl",kernelFunc:$_},tD={kernelName:tt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,crops:o}=a;J(r.shape.length<=4,(()=>"batchToSpaceND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),c=Gu(r.shape,s,i),l=Hu(c.length,s.length),u=ju(r.shape,s,i),h=Ku(o,s.length),d=qu(u,o,s.length),p=[],f=KA({inputs:{x:r},backend:n,attrs:{shape:c}}),m=n_({inputs:{x:f},backend:n,attrs:{perm:l}}),g=KA({inputs:{x:m},backend:n,attrs:{shape:u}}),y=$_({inputs:{x:g},backend:n,attrs:{begin:h,size:d}});return p.push(f),p.push(m),p.push(g),p.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}};const nD={kernelName:nt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o}=a,i=n.readSync(r.dataId),c=n.readSync(s.dataId),l=eR(i,c,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,l)}};const aD={kernelName:at,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{a:a,b:r}=t,s=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS"),o=_e().getNumber("WEBGL_VERSION");if(n.shouldExecuteOnCPU([a,r])||1===o){const e=n.texData.get(a.dataId).values,t=n.texData.get(r.dataId).values,[s,o]=nR(a.shape,r.shape,e,t,a.dtype),i=n.makeTensorInfo(o,a.dtype);return n.texData.get(i.dataId).values=s,i}let i;return i=s?new NA("\n  int r = int(a.r) & int(b.r);\n  int g = int(a.g) & int(b.g);\n  int rb = int(a.b) & int(b.b);\n  int ra = int(a.a) & int(b.a);\n  return vec4(r, g, rb, ra);\n",a.shape,r.shape,!1):new SA("\n  return float(int(a.r) & int(b.r));\n",a.shape,r.shape),n.runWebGLProgram(i,[a,r],a.dtype)}};const rD={kernelName:rt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{s0:a,s1:r}=t,s=n.readSync(a.dataId),o=n.readSync(r.dataId),i=Go(Array.from(s),Array.from(o));return n.makeTensorInfo([i.length],"int32",Int32Array.from(i))}},sD=PA({opSnippet:"return float(a != b);",cpuKernelImpl:SR,dtype:"bool"}),oD={kernelName:An,backendName:"webgl",kernelFunc:sD};function iD(e){const{inputs:t,backend:n}=e,{input:a}=t;return TA({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.real},backend:n})}const cD={kernelName:jn,backendName:"webgl",kernelFunc:iD},lD="return float(int(x));";const uD={kernelName:st,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a,attrs:r}=t,{x:s}=n,{dtype:o}=r;if("complex64"===o){if("complex64"===s.dtype)return TA({inputs:{x:s},backend:a});const t=qc(s.shape),n=e({inputs:{x:s},backend:a,attrs:{dtype:"float32"}}),r=CA({inputs:{real:n,imag:t},backend:a});return t.dispose(),a.disposeIntermediateTensorInfo(n),r}if("complex64"===s.dtype){const t=iD({inputs:{input:s},backend:a}),n=e({inputs:{x:t},backend:a,attrs:{dtype:o}});return a.disposeIntermediateTensorInfo(t),n}if(!he(s.dtype,o)){const e=TA({inputs:{x:s},backend:a});return{dataId:e.dataId,shape:e.shape,dtype:o}}if(a.shouldExecuteOnCPU([s])){const e=a.texData.get(s.dataId).values,[t,n,r]=aR(e,s.shape,s.dtype,o);return a.makeTensorInfo(t,n,r)}if("int32"===o)return function(e,t){const n=new nA(e.shape,lD),a=t.runWebGLProgram(n,[e],"int32");return{dataId:a.dataId,shape:a.shape,dtype:a.dtype}}(s,a);if("bool"===o){const e=a.makeTensorInfo([],"bool",le("bool",1)),t=sD({inputs:{a:s,b:e},backend:a});return a.disposeIntermediateTensorInfo(e),t}throw new Error("Error in Cast: failed to cast ".concat(s.dtype," to ").concat(o))}},hD="return ceil(x);",dD=zA({opSnippet:hD,packedOpSnippet:hD,cpuKernelImpl:rR}),pD={kernelName:ot,backendName:"webgl",kernelFunc:dD};class fD{constructor(e){this.variableNames=["A"],this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n\n      void main() {\n        float value = getAAtOutCoords();\n        if (isnan(value)) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, minVal, maxVal));\n      }\n    "}}class mD{constructor(e){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"minVal",type:"float"},{name:"maxVal",type:"float"}],this.outputShape=e,this.userCode="\n      void main() {\n        vec4 value = getAAtOutCoords();\n\n        if (any(isnan(value))) {\n          setOutput(value);\n          return;\n        }\n\n        setOutput(clamp(value, vec4(minVal), vec4(maxVal)));\n      }\n    "}}const gD={kernelName:it,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{clipValueMin:s,clipValueMax:o}=a;let i;i=_e().getBool("WEBGL_PACK_CLIP")?new mD(r.shape):new fD(r.shape);const c=[[s],[o]];return n.runWebGLProgram(i,[r],r.dtype,c)}};class yD{constructor(e){this.variableNames=["real","imag"],this.outputShape=e,this.userCode="\n      void main() {\n        float re = abs(getRealAtOutCoords());\n        float im = abs(getImagAtOutCoords());\n        float mx = max(re, im);\n\n        // sadly the length function in glsl is not underflow-safe\n        // (at least not on Intel GPUs). So the safe solution is\n        // to ensure underflow-safety in all cases.\n        setOutput(\n          mx == 0.0 ? 0.0 : mx * length(vec2(1, min(re, im)/mx))\n        );\n      }\n    "}}function bD(e,t){return{dataId:t.dataId,dtype:t.dtype,shape:e.shape}}const vD={kernelName:lt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=n.texData.get(a.dataId),s=new yD(a.shape),o=[bD(a,r.complexTensorInfos.real),bD(a,r.complexTensorInfos.imag)];return n.runWebGLProgram(s,o,o[0].dtype)}};class xD{constructor(e){this.outputShape=[],this.outputShape=Ou(e,1),this.variableNames=e.map(((e,t)=>"T".concat(t)));const t=new Array(e.length-1);t[0]=e[0][1];for(let s=1;s<t.length;s++)t[s]=t[s-1]+e[s][1];const n=["if (yC < ".concat(t[0],") setOutput(getT0(yR, yC));")];for(let s=1;s<t.length;s++){const e=t[s-1];n.push("else if (yC < ".concat(t[s],") ")+"setOutput(getT".concat(s,"(yR, yC-").concat(e,"));"))}const a=t.length,r=t[t.length-1];n.push("else setOutput(getT".concat(a,"(yR, yC-").concat(r,"));")),this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int yR = coords.x;\n        int yC = coords.y;\n\n        ".concat(n.join("\n        "),"\n      }\n    ")}}class wD{constructor(e,t){this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[],this.outputShape=Ou(e,t);const n=this.outputShape,a=n.length,r=EC(a),s=YR("coords",a),o=["x","y","z","w","u","v"].slice(0,a);this.variableNames=e.map(((e,t)=>"T".concat(t)));const i=new Array(e.length-1);i[0]=e[0][t];for(let f=1;f<i.length;f++)i[f]=i[f-1]+e[f][t];const c=o[t],l=o.slice(-2),u=o.join();let h="if (".concat(c," < ").concat(i[0],") {\n        return getChannel(\n            getT0(").concat(u,"), vec2(").concat(l.join(),"));\n        }");for(let f=1;f<i.length;f++){const e=i[f-1];h+="\n        if (".concat(c," < ").concat(i[f],"  && ").concat(c," >= ").concat(i[f-1],") {\n          return getChannel(\n            getT").concat(f,"(").concat(kD(o,c,e),"),\n            vec2(").concat(kD(l,c,e),"));\n        }")}const d=i.length,p=i[i.length-1];h+="\n        return getChannel(\n          getT".concat(d,"(").concat(kD(o,c,p),"),\n          vec2(").concat(kD(l,c,p),"));"),this.userCode="\n      float getValue(".concat(o.map((e=>"int "+e)),") {\n        ").concat(h,"\n      }\n\n      void main() {\n        ").concat(r," coords = getOutputCoords();\n        vec4 result = vec4(getValue(").concat(s,"), 0., 0., 0.);\n\n        ").concat(s[a-1]," = ").concat(s[a-1]," + 1;\n        if (").concat(s[a-1]," < ").concat(n[a-1],") {\n          result.g = getValue(").concat(s,");\n        }\n\n        ").concat(s[a-2]," = ").concat(s[a-2]," + 1;\n        if (").concat(s[a-2]," < ").concat(n[a-2],") {\n          result.a = getValue(").concat(s,");\n        }\n\n        ").concat(s[a-1]," = ").concat(s[a-1]," - 1;\n        if (").concat(s[a-2]," < ").concat(n[a-2]," &&\n            ").concat(s[a-1]," < ").concat(n[a-1],") {\n          result.b = getValue(").concat(s,");\n        }\n        setOutput(result);\n      }\n    ")}}function kD(e,t,n){const a=e.indexOf(t);return e.map(((e,t)=>t===a?"".concat(e," - ").concat(n):e)).join()}function SD(e){const{inputs:t,backend:n}=e,{input:a}=t;return TA({inputs:{x:n.texData.get(a.dataId).complexTensorInfos.imag},backend:n})}const ID={kernelName:$t,backendName:"webgl",kernelFunc:SD};function ND(e,t,n){const a=e[0].dtype;if("complex64"===a){const a=e.map((e=>iD({inputs:{input:e},backend:n}))),r=e.map((e=>SD({inputs:{input:e},backend:n}))),s=ND(a,t,n),o=ND(r,t,n),i=CA({inputs:{real:s,imag:o},backend:n});return a.forEach((e=>n.disposeIntermediateTensorInfo(e))),r.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.disposeIntermediateTensorInfo(s),n.disposeIntermediateTensorInfo(o),i}let r=n.shouldExecuteOnCPU(e);if("string"===a&&(r=!0),r){const r=e.map((e=>{const a=ee(e.shape.slice(t));return KA({inputs:{x:e},backend:n,attrs:{shape:[-1,a]}})})),s=r.map((e=>({vals:n.readSync(e.dataId),shape:e.shape}))),o=Ou(r.map((e=>e.shape)),1),i=1===r[0].shape[0],c=sR(s,o,a,i),l=Ou(e.map((e=>e.shape)),t),u=n.makeTensorInfo(l,a,c);return r.forEach((e=>n.disposeIntermediateTensorInfo(e))),u}const s=e.filter((e=>ee(e.shape)>0)),o=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")&&s[0].shape.length>1;if(1===s.length){const t=o?new nA(e[0].shape,lA):new gA(e[0].shape,lA);return n.runWebGLProgram(t,e,a)}const i=_e().getNumber("WEBGL_MAX_TEXTURES_IN_SHADER");if(s.length>i){const e=[];for(let r=0;r<s.length;r+=i){const a=s.slice(r,r+i);e.push(ND(a,t,n))}const a=ND(e,t,n);for(const t of e)n.disposeIntermediateTensorInfo(t);return a}if(o){const e=new wD(s.map((e=>e.shape)),t);return n.runWebGLProgram(e,s,a)}const{tensors2D:c,outShape:l}=function(e,t,n){const a=Ou(e.map((e=>e.shape)),t),r=e.map((e=>KA({inputs:{x:e},attrs:{shape:[-1,ee(e.shape.slice(t))]},backend:n})));return{tensors2D:r,outShape:a}}(s,t,n),u=new xD(c.map((e=>e.shape))),h=n.runWebGLProgram(u,c,a);c.forEach((e=>n.disposeIntermediateTensorInfo(e)));const d=KA({inputs:{x:h},attrs:{shape:l},backend:n});return n.disposeIntermediateTensorInfo(h),d}function TD(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a,s=ie(r,t[0].shape)[0];Fu(t.map((e=>e.shape)),s);const o=Ou(t.map((e=>e.shape)),s);if(0===ee(o))return n.makeTensorInfo(o,t[0].dtype,[]);const i=t.filter((e=>ee(e.shape)>0));return 1===i.length?TA({inputs:{x:i[0]},backend:n}):ND(i,s,n)}const ED={kernelName:ut,backendName:"webgl",kernelFunc:TD};class CD{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.outputShape=e.outShape;const s=e.padInfo.top,o=e.padInfo.left,i=e.strideHeight,c=e.strideWidth,l=e.dilationHeight,u=e.dilationWidth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4,m="channelsLast"===e.dataFormat,g=m?1:2,y=m?2:3,b=m?3:1;let v="",x="";n&&(v=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),x="result = activation(result);");const w=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(v,"\n\n      const ivec2 strides = ivec2(").concat(i,", ").concat(c,");\n      const ivec2 pads = ivec2(").concat(s,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d2 = coords[").concat(b,"];\n\n        ivec2 xRCCorner =\n            ivec2(coords[").concat(g,"], coords[").concat(y,"]) * strides - pads;\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, d2) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(h,"; wR++) {\n          int xR = xRCorner + wR * ").concat(l,";\n\n          if (xR < 0 || xR >= ").concat(e.inHeight,") {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(d,"; wC++) {\n            int xC = xCCorner + wC * ").concat(u,";\n\n            if (xC < 0 || xC >= ").concat(e.inWidth,") {\n              continue;\n            }\n\n            for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n              vec4 wValues = vec4(\n                getW(wR, wC, d1, d2),\n                getW(wR, wC, d1 + 1, d2),\n                getW(wR, wC, d1 + 2, d2),\n                getW(wR, wC, d1 + 3, d2)\n              );\n\n              if (").concat(m,") {\n                vec4 xValues = vec4(\n                  getX(batch, xR, xC, d1),\n                  getX(batch, xR, xC, d1 + 1),\n                  getX(batch, xR, xC, d1 + 2),\n                  getX(batch, xR, xC, d1 + 3)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec4 xValues = vec4(\n                  getX(batch, d1, xR, xC),\n                  getX(batch, d1 + 1, xR, xC),\n                  getX(batch, d1 + 2, xR, xC),\n                  getX(batch, d1 + 3, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n\n            if (").concat(1===f,") {\n\n              if (").concat(m,") {\n                dotProd +=\n                    getX(batch, xR, xC, ").concat(p,") *\n                    getW(wR, wC, ").concat(p,", d2);\n              } else {\n                dotProd +=\n                    getX(batch, ").concat(p,", xR, xC) *\n                    getW(wR, wC, ").concat(p,", d2);\n              }\n\n            } else if (").concat(2===f,") {\n              vec2 wValues = vec2(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2)\n              );\n\n              if (").concat(m,") {\n                vec2 xValues = vec2(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec2 xValues = vec2(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            } else if (").concat(3===f,") {\n              vec3 wValues = vec3(\n                getW(wR, wC, ").concat(p,", d2),\n                getW(wR, wC, ").concat(p," + 1, d2),\n                getW(wR, wC, ").concat(p," + 2, d2)\n              );\n\n              if (").concat(m,") {\n                vec3 xValues = vec3(\n                  getX(batch, xR, xC, ").concat(p,"),\n                  getX(batch, xR, xC, ").concat(p," + 1),\n                  getX(batch, xR, xC, ").concat(p," + 2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else {\n                vec3 xValues = vec3(\n                  getX(batch, ").concat(p,", xR, xC),\n                  getX(batch, ").concat(p," + 1, xR, xC),\n                  getX(batch, ").concat(p," + 2, xR, xC)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n\n            }\n          }\n        }\n\n        float result = dotProd;\n        ").concat(w,"\n        ").concat(x,"\n        setOutput(result);\n      }\n    ")}}class RD{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const t=e.padInfo.front,n=e.padInfo.top,a=e.padInfo.left,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=e.dilationDepth,c=e.dilationHeight,l=e.dilationWidth,u=e.filterDepth,h=e.filterHeight,d=e.filterWidth,p=4*Math.floor(e.inChannels/4),f=e.inChannels%4;this.userCode="\n      const ivec3 strides = ivec3(".concat(r,", ").concat(s,", ").concat(o,");\n      const ivec3 pads = ivec3(").concat(t,", ").concat(n,", ").concat(a,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d2 = coords.u;\n\n        ivec3 xFRCCorner = ivec3(coords.y, coords.z, coords.w) * strides - pads;\n        int xFCorner = xFRCCorner.x;\n        int xRCorner = xFRCCorner.y;\n        int xCCorner = xFRCCorner.z;\n\n        // Convolve x(?, ?, ?, d1) with w(:, :, :, d1, d2) to get\n        // y(yF, yR, yC, d2). ? = to be determined. : = across all\n        // values in that axis.\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(u,"; wF++) {\n          int xF = xFCorner + wF * ").concat(i,";\n\n          if (xF < 0 || xF >= ").concat(e.inDepth,") {\n            continue;\n          }\n\n          for (int wR = 0; wR < ").concat(h,"; wR++) {\n            int xR = xRCorner + wR * ").concat(c,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int wC = 0; wC < ").concat(d,"; wC++) {\n              int xC = xCCorner + wC * ").concat(l,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              for (int d1 = 0; d1 < ").concat(p,"; d1 += 4) {\n                vec4 xValues = vec4(\n                  getX(batch, xF, xR, xC, d1),\n                  getX(batch, xF, xR, xC, d1 + 1),\n                  getX(batch, xF, xR, xC, d1 + 2),\n                  getX(batch, xF, xR, xC, d1 + 3)\n                );\n                vec4 wValues = vec4(\n                  getW(wF, wR, wC, d1, d2),\n                  getW(wF, wR, wC, d1 + 1, d2),\n                  getW(wF, wR, wC, d1 + 2, d2),\n                  getW(wF, wR, wC, d1 + 3, d2)\n                );\n\n                dotProd += dot(xValues, wValues);\n              }\n\n              if (").concat(1===f,") {\n                dotProd +=\n                  getX(batch, xF, xR, xC, ").concat(p,") *\n                  getW(wF, wR, wC, ").concat(p,", d2);\n              } else if (").concat(2===f,") {\n                vec2 xValues = vec2(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1)\n                );\n                vec2 wValues = vec2(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              } else if (").concat(3===f,") {\n                vec3 xValues = vec3(\n                  getX(batch, xF, xR, xC, ").concat(p,"),\n                  getX(batch, xF, xR, xC, ").concat(p," + 1),\n                  getX(batch, xF, xR, xC, ").concat(p," + 2)\n                );\n                vec3 wValues = vec3(\n                  getW(wF, wR, wC, ").concat(p,", d2),\n                  getW(wF, wR, wC, ").concat(p," + 1, d2),\n                  getW(wF, wR, wC, ").concat(p," + 2, d2)\n                );\n                dotProd += dot(xValues, wValues);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class AD{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=OC(this.outputShape.length);const s=e.padInfo.left,o=e.strideWidth,i=e.dilationWidth,c=e.filterHeight,l=e.filterWidth,u=l;let h="\n       int xR; int xC; int xCOffset;\n       vec4 wTexel; vec4 previous; vec4 final;";for(let m=0;m<l;m++)h+="\n           vec4 xTexelC".concat(2*m,";\n           int xTexelC").concat(2*m,"Ready;\n           vec4 xTexelC").concat(2*m+1,";\n           int xTexelC").concat(2*m+1,"Ready;\n           vec4 xC").concat(m,";");h+="\n     for (int r = 0; r < ".concat(c,"; r++) {\n      for (int d1 = 0; d1 < ").concat(e.inChannels,"; d1 += 2) {\n       ");for(let m=0;m<l;m++)h+="\n           xTexelC".concat(2*m," = vec4(0.0);\n           xTexelC").concat(2*m,"Ready = 0;\n           xTexelC").concat(2*m+1," = vec4(0.0);\n           xTexelC").concat(2*m+1,"Ready = 0;\n           xC").concat(m," = vec4(0.0);");h+="\n         xR = xRCorner + r * dilations[0];\n         if (xR >=0 && xR < inDims[0]) {\n       ";for(let m=0;m<(u+1)/2;m++){const t=2*m;if(h+="\n           xC = xCCorner + ".concat(t*i,";\n           "),1===o){if(t<l&&(s%2===1?(h+="\n                 xCOffset = xC + 1;\n                 if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n               "),h+=1===i&&t>0?"\n                 xC".concat(t," = vec4(xTexelC").concat(t-2,".zw, xTexelC").concat(t,".xy);\n                 "):"\n                   xCOffset = xC + 1 - 2;\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       previous.zw = vec2(0.0);\n                     }\n\n                     xC".concat(t," = vec4(previous.zw, xTexelC").concat(t,".xy);\n                   } else {\n                     xC").concat(t," = vec4(0.0, 0.0, xTexelC").concat(t,".xy);\n                   }\n                   ")):h+="\n                 if (xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xC").concat(t," = xTexelC").concat(t,";\n                 "),t+1<l)){const e=s%2===0?Y(i):i;i%2===0&&s%2===1||i%2!==0&&s%2!==1?(h+="\n                   xCOffset = xC + imod(pads[1], 2) + ".concat(e,";\n\n                   if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                     xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n\n                     // Need to manually clear unused channels in case\n                     // we're reading from recycled texture.\n                     if (xCOffset + 1 >= inDims[1]) {\n                       xTexelC").concat(t+1,".zw = vec2(0.0);\n                     }\n                     xTexelC").concat(t+1,"Ready = 1;\n                   }\n                   "),h+=i>1?"\n                     xCOffset -= 2;\n                     if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                      previous = getX(batch, xR, xCOffset, d1);\n                      xC".concat(t+1," = vec4(previous.zw, xTexelC").concat(t+1,".xy);\n                     } else {\n                      xC").concat(t+1," = vec4(0.0, 0.0, xTexelC").concat(t+1,".xy);\n                     }\n                     "):"\n                     xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".xy);\n                     ")):h+=1===e?"\n                     xC".concat(t+1," = xTexelC").concat(t,";\n                     "):"\n                     xCOffset = xC + ".concat(e,";\n\n                     if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                       xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                       if (xCOffset + 1 >= inDims[1]) {\n                         xTexelC").concat(t+1,".zw = vec2(0.0);\n                       }\n                       xTexelC").concat(t+1,"Ready = 1;\n                     }\n\n                     xC").concat(t+1," = xTexelC").concat(t+1,";\n                     ")}}else t<l&&(s%2===1?(h+="\n                 xCOffset = xC + 1 - strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xCOffset, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xC + 1, d1);\n                   // Need to manually clear unused channels in case\n                   // we're reading from recycled texture.\n                   if (xC + 2 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n               "),t+1<l&&(h+="\n                   final = vec4(0.0);\n                   xCOffset = xC + 1 + strides[1];\n                   if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                     final = getX(batch, xR, xCOffset, d1);\n                   }\n                   xC".concat(t+1," = vec4(xTexelC").concat(t+1,".xy, final.xy);\n                 "))):(h+="\n                 if(xC >= 0 && xC < inDims[1] && xTexelC".concat(t,"Ready == 0) {\n                   xTexelC").concat(t," = getX(batch, xR, xC, d1);\n                   if (xC + 1 >= inDims[1]) {\n                     xTexelC").concat(t,".zw = vec2(0.0);\n                   }\n                   xTexelC").concat(t,"Ready = 1;\n                 }\n\n                 xCOffset = xC + strides[1];\n                 if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(t+1,"Ready == 0) {\n                   xTexelC").concat(t+1," = getX(batch, xR, xCOffset, d1);\n                   if (xCOffset + 1 >= inDims[1]) {\n                     xTexelC").concat(t+1,".zw = vec2(0.);\n                   }\n                   xTexelC").concat(t+1,"Ready = 1;\n                 }\n\n                 xC").concat(t," = vec4(\n                   xTexelC").concat(t,".xy, xTexelC").concat(t+1,".xy);\n               "),t+1<l&&(h+="\n                   xC".concat(t+1," = vec4(xTexelC").concat(t,".zw, xTexelC").concat(t+1,".zw);\n                 "))));t<l&&(h+="\n             wTexel = getW(r, ".concat(t,", d1, d2);\n             dotProd += xC").concat(t,".xxzz * vec4(wTexel.xy, wTexel.xy);\n             if(d1 + 1 < ").concat(e.inChannels,") {\n               dotProd += xC").concat(t,".yyww * vec4(wTexel.zw, wTexel.zw);\n             }\n           "),t+1<l&&(h+="\n               wTexel = getW(r, ".concat(t+1,", d1, d2);\n               dotProd += xC").concat(t+1,".xxzz * vec4(wTexel.xy, wTexel.xy);\n               if(d1 + 1 < ").concat(e.inChannels,") {\n                 dotProd += xC").concat(t+1,".yyww * vec4(wTexel.zw, wTexel.zw);\n               }\n             ")))}h+="\n     }\n   ",h+="\n     }\n   ",h+="\n     }\n   ";let d="",p="";n&&(d=a?"vec4 activation(vec4 a) {\n           vec4 b = getPreluActivationWeightsAtOutCoords();\n           ".concat(n,"\n         }"):r?"vec4 activation(vec4 a) {\n           vec4 b = getLeakyreluAlphaAtOutCoords();\n           ".concat(n,"\n         }"):"vec4 activation(vec4 x) {\n           ".concat(n,"\n         }"),p="result = activation(result);");const f=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n       ".concat(d,"\n\n       void main() {\n         ivec4 coords = getOutputCoords();\n         int batch = coords.x;\n         ivec2 xRCCorner = coords.yz * strides - pads;\n         int d2 = coords.w;\n         int xRCorner = xRCCorner.x;\n         int xCCorner = xRCCorner.y;\n\n         //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n         vec4 dotProd = vec4(0.000000000000001);\n\n         ").concat(h,"\n\n         vec4 result = dotProd - vec4(0.000000000000001);\n         ").concat(f,"\n         ").concat(p,"\n         setOutput(result);\n       }\n     ")}}class _D{constructor(e,t){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"inputShape",type:"ivec4"},{name:"pad",type:"ivec2"},{name:"stride",type:"ivec2"},{name:"dilation",type:"ivec2"},{name:"inChannels",type:"int"},{name:"itemsPerBlockRow",type:"int"},{name:"outWidth",type:"int"}],this.outputShape=e,this.enableShapeUniforms=OC(this.outputShape.length);const{dataFormat:n}=t,a=hC(),r="channelsLast"===n,s=r?1:2,o=r?2:3,i=this.enableShapeUniforms?"if(blockIndex < outShape[2] && pos < outShape[1]) {":"if(blockIndex < ".concat(e[2]," && pos < ").concat(e[1],") {");let c="";for(let l=0;l<=1;l++)for(let e=0;e<=1;e++)c+="\n          blockIndex = rc.z + ".concat(e,";\n          pos = rc.y + ").concat(l,";\n\n          ").concat(i,"\n            offsetY = int(blockIndex / outWidth) * stride[0] - pad[0];\n            d0 = offsetY + dilation[0] * (pos / itemsPerBlockRow);\n\n            if(d0 < inputShape[").concat(s,"] && d0 >= 0) {\n              // Use custom imod instead mod. On Intel GPU, mod may generate\n              // unexpected value.\n              // https://github.com/tensorflow/tfjs/issues/5447\n              offsetX = imod(blockIndex, outWidth) * stride[1] - pad[1];\n              d1 = offsetX + dilation[1] * (imod(pos, itemsPerBlockRow) /\n                  inChannels);\n\n              if(d1 < inputShape[").concat(o,"] && d1 >= 0) {\n\n                ch = imod(pos, inChannels);\n\n                if (").concat(r,") {\n                  innerDims = vec2(d1, ch);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, d0, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                } else {\n                  innerDims = vec2(d0, d1);\n                  result[").concat(2*l+e,"] = getChannel(\n                    getA(rc.x, ch, int(innerDims.x),\n                    int(innerDims.y)), innerDims);\n                }\n              }\n            }\n          }\n        ");this.userCode="\n      void main() {\n        ivec3 rc = getOutputCoords();\n\n        vec4 result = vec4(0);\n\n        int blockIndex, pos, offsetY, d0, offsetX, d1, ch;\n        vec2 innerDims;\n\n        ".concat(c,"\n\n        ").concat(a.output," = result;\n      }\n    ")}}function DD(e,t){const n=e.length;return n>=3?t?[...e.slice(0,-3),e[n-3]*e[n-2],e[n-1]]:[...e.slice(0,-3),e[n-3],e[n-2]*e[n-1]]:!t&&1===n&&e[0]>1?[e[0],1]:null}function FD(e){let{x:t,filter:n,convInfo:a,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:c=null}=e;const l=t.shape,u=r.texData.get(t.dataId),h=a.inChannels,d=l[0]*l[1]*l[2],p=a.outChannels,f="channelsLast"===a.dataFormat,m=!1;let g;const y=[];if(null!=o){const e=DD(o.shape,f);null!=e&&(o=KA({inputs:{x:o},backend:r,attrs:{shape:e}}),y.push(o))}if(null!=s){const e=DD(s.shape,f);null!=e&&(s=KA({inputs:{x:s},backend:r,attrs:{shape:e}}),y.push(s))}if(!((1===d||1===p)&&h>r_)&&u.isPacked&&f&&null!=u.texture&&l[2]%2!==0&&te(u.shape.slice(-3),l.slice(-3))){const e=l[0]*l[1]*(l[2]+1),h={dataId:t.dataId,shape:[1,e,a.inChannels],dtype:t.dtype},d=u.shape;u.shape=u.shape.slice(),u.shape[u.shape.length-2]++,J(nC(u.shape,h.shape),(()=>"packed reshape ".concat(u.shape," to ").concat(h.shape," isn't free")));const p=KA({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}});y.push(p);const f=s_({a:h,b:p,backend:r,transposeA:false,transposeB:m,bias:s,activation:c,preluActivationWeights:o,leakyreluAlpha:i}),b=r.texData.get(f.dataId);J(b.isPacked,(()=>"batchMatMul result is expected to be packed")),u.shape=d,b.shape=a.outShape,g=TA({inputs:{x:f},backend:r}),g.shape=a.outShape,y.push(f)}else{const e=a.outHeight*a.outWidth,l=KA({inputs:{x:t},backend:r,attrs:{shape:f?[a.batchSize,e,a.inChannels]:[a.batchSize,a.inChannels,e]}}),u=KA({inputs:{x:n},backend:r,attrs:{shape:[1,a.inChannels,a.outChannels]}}),h=s_({a:f?l:u,b:f?u:l,transposeA:!f,transposeB:m,backend:r,bias:s,activation:c,preluActivationWeights:o,leakyreluAlpha:i});g=KA({inputs:{x:h},backend:r,attrs:{shape:a.outShape}}),y.push(l),y.push(u),y.push(h)}for(const b of y)r.disposeIntermediateTensorInfo(b);return g}function OD(e){let{x:t,filter:n,convInfo:a,backend:r,bias:s=null,preluActivationWeights:o=null,leakyreluAlpha:i=0,activation:c=null}=e;const{filterWidth:l,filterHeight:u,inChannels:h,outWidth:d,outHeight:p,dataFormat:f}=a,m="channelsLast"===f,g=l*u*h,y=p*d,b=[a.batchSize,g,y],v=[];if(null!=o){const e=DD(o.shape,m);null!=e&&(o=KA({inputs:{x:o},backend:r,attrs:{shape:e}}),v.push(o))}if(null!=s){const e=DD(s.shape,m);null!=e&&(s=KA({inputs:{x:s},backend:r,attrs:{shape:e}}),v.push(s))}const x=KA({inputs:{x:n},backend:r,attrs:{shape:[1,g,ee(n.shape)/g]}});v.push(x);const w=new _D(b,a),k=[t.shape,[a.padInfo.top,a.padInfo.left],[a.strideHeight,a.strideWidth],[a.dilationHeight,a.dilationWidth],[a.inChannels],[a.filterWidth*a.inChannels],[a.outWidth]],S=r.runWebGLProgram(w,[t],"float32",k),I=KA({inputs:{x:S},backend:r,attrs:{shape:b}});v.push(S),v.push(I);const N=null!=s,T=null!=o,E="leakyrelu"===c,C=c?BA(c,!0):null,R=new WA(m?I.shape:x.shape,m?x.shape:I.shape,m?[a.batchSize,y,a.outChannels]:[a.batchSize,a.outChannels,y],!0,!1,N,C,T,E),A=m?[I,x]:[x,I];if(s&&A.push(s),T&&A.push(o),E){const e=r.makeTensorInfo([],"float32",xr(i,"float32"));A.push(e),v.push(e)}const _=r.runWebGLProgram(R,A,"float32"),D=KA({inputs:{x:_},backend:r,attrs:{shape:a.outShape}});v.push(_);for(const F of v)r.disposeIntermediateTensorInfo(F);return D}const MD={kernelName:ht,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dataFormat:c,dilations:l,dimRoundingMode:u}=a,h=Bi(c),d=Ri(r.shape,s.shape,o,l,i,u,!1,h);let p;if(1!==d.filterHeight||1!==d.filterWidth||1!==d.dilationHeight||1!==d.dilationWidth||1!==d.strideHeight||1!==d.strideWidth||"SAME"!==d.padInfo.type&&"VALID"!==d.padInfo.type)if(d.strideWidth<=2&&"channelsLast"===h&&_e().getBool("WEBGL_EXP_CONV")){const e=new AD(d),t=[[d.padInfo.top,d.padInfo.left],[d.strideHeight,d.strideWidth],[d.dilationHeight,d.dilationWidth],[d.inHeight,d.inWidth]];p=n.runWebGLProgram(e,[r,s],"float32",t)}else if(_e().getBool("WEBGL_CONV_IM2COL"))p=OD({x:r,filter:s,convInfo:d,backend:n});else{const e=new CD(d);p=n.runWebGLProgram(e,[r,s],"float32")}else p=FD({x:r,filter:s,convInfo:d,backend:n});const f=KA({inputs:{x:p},backend:n,attrs:{shape:d.outShape}});return n.disposeIntermediateTensorInfo(p),f}};class LD{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s="channelsLast"===e.dataFormat;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int d2 = coords.w;\n\n        // Convolve x(?, ?, d1) with dy(:, :, d2) to get dw(wR, wC, d1, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              ").concat(s?"float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);":"float dyValue = getDy(b, d2, yR, yC);\n              float xValue = getX(b, d1, xR, xC);\n              dotProd += (xValue * dyValue);","\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class zD{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s="channelsLast"===e.dataFormat,o=t-1-e.padInfo.top,i=n-1-e.padInfo.left,c=s?1:2,l=s?2:3,u=s?3:1;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[").concat(u,"];\n\n        ivec2 dyCorner = ivec2(coords[").concat(c,"], coords[").concat(l,"]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        // Convolve dy(?, ?, d2) with w(:, :, d1, d2) to compute dx(xR, xC, d1).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n\n              if (").concat(s,") {\n                float xValue = getDy(batch, idyR, idyC, d2);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              } else {\n                float xValue = getDy(batch, d2, idyR, idyC);\n                float wValue = getW(wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class PD{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.padInfo.front,s=e.padInfo.top,o=e.padInfo.left;this.userCode="\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int wF = coords.x;\n        int wR = coords.y;\n        int wC = coords.z;\n        int d1 = coords.w;\n        int d2 = coords.u;\n\n        float dotProd = 0.0;\n\n        for (int b = 0; b < ".concat(e.batchSize,"; b++) {\n          for (int yF = 0; yF < ").concat(e.outDepth,"; yF++) {\n            int xF = wF + yF * ").concat(t," - ").concat(r,";\n\n            if (xF < 0 || xF >= ").concat(e.inDepth,") {\n              continue;\n            }\n\n            for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n              int xR = wR + yR * ").concat(n," - ").concat(s,";\n\n              if (xR < 0 || xR >= ").concat(e.inHeight,") {\n                continue;\n              }\n\n              for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n                int xC = wC + yC * ").concat(a," - ").concat(o,";\n\n                if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                  continue;\n                }\n\n                float dyValue = getDy(b, yF, yR, yC, d2);\n                float xValue = getX(b, xF, xR, xC, d1);\n                dotProd += (xValue * dyValue);\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class BD{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterDepth,n=e.filterHeight,a=e.filterWidth,r=e.strideDepth,s=e.strideHeight,o=e.strideWidth,i=t-1-e.padInfo.front,c=n-1-e.padInfo.top,l=a-1-e.padInfo.left;this.userCode="\n      const ivec3 pads = ivec3(".concat(i,", ").concat(c,", ").concat(l,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.u;\n\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyFCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        float dotProd = 0.0;\n        for (int wF = 0; wF < ").concat(t,"; wF++) {\n          float dyF = float(dyFCorner + wF) / ").concat(r,".0;\n\n          if (dyF < 0.0 || dyF >= ").concat(e.outDepth,".0 || fract(dyF) > 0.0) {\n            continue;\n          }\n          int idyF = int(dyF);\n\n          int wFPerm = ").concat(t," - 1 - wF;\n\n          for (int wR = 0; wR < ").concat(n,"; wR++) {\n            float dyR = float(dyRCorner + wR) / ").concat(s,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n              fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            int wRPerm = ").concat(n," - 1 - wR;\n\n            for (int wC = 0; wC < ").concat(a,"; wC++) {\n              float dyC = float(dyCCorner + wC) / ").concat(o,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              int wCPerm = ").concat(a," - 1 - wC;\n\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2++) {\n                float xValue = getDy(batch, idyF, idyR, idyC, d2);\n                float wValue = getW(wFPerm, wRPerm, wCPerm, d1, d2);\n                dotProd += xValue * wValue;\n              }\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const WD={kernelName:dt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,dataFormat:c,dimRoundingMode:l,filterShape:u}=a,h=Bi(c),d=Ri(r.shape,u,o,1,i,l,!1,h),p=new LD(d);return n.runWebGLProgram(p,[r,s],"float32")}};class VD{constructor(e){this.variableNames=["dy","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"strides",type:"vec2"}],this.outputShape=e.inShape,this.enableShapeUniforms=OC(this.outputShape.length);const t=e.filterHeight,n=e.filterWidth,a=t-1-e.padInfo.top,r=n-1-e.padInfo.left;this.userCode="\n      const ivec2 pads = ivec2(".concat(a,", ").concat(r,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n\n        ivec2 dyCorner = ivec2(coords[1], coords[2]) - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        vec4 result = vec4(0.);\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / strides[0];\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            float dyC = float(dyCCorner + wC) / strides[1];\n            bool idyCVal = (dyC >= 0.0) && (dyC < ").concat(e.outWidth,".0)\n              && (fract(dyC) == 0.0);\n            int idyC = int(dyC);\n\n            float dyC2 = float(dyCCorner + wC + 1) / strides[1];\n            bool idyCVal2 = (dyC2 >= 0.0) && (dyC2 < ").concat(e.outWidth,".0)\n              && (fract(dyC2) == 0.0);\n            int idyC2 = int(dyC2);\n\n            if (idyCVal && idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec4 dySample2 = (idyC / 2 == idyC2 / 2) ?\n                  dySample : getDy(batch, idyR, idyC2, d2);\n\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n\n                dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample2.xy : dySample2.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC, d2);\n                vec2 dyValue = mod(float(idyC), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.xy += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            } else if (idyCVal2) {\n              for (int d2 = 0; d2 < ").concat(e.outChannels,"; d2 += 2) {\n                vec4 wValue = getW(wRPerm, wCPerm, d1, d2);\n                vec4 dySample = getDy(batch, idyR, idyC2, d2);\n                vec2 dyValue = mod(float(idyC2), 2.) == 0. ?\n                  dySample.xy : dySample.zw;\n                result.zw += vec2(dot(dyValue, wValue.xy),\n                  dot(dyValue, wValue.zw));\n              }\n            }\n          }\n        }\n        setOutput(result);\n      }\n    ")}}const UD={kernelName:pt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{inputShape:o,strides:i,pad:c,dataFormat:l,dimRoundingMode:u}=a,h=Bi(l),d=Ri(o,s.shape,i,1,c,u,!1,h);if(_e().getBool("WEBGL_PACK_CONV2DTRANSPOSE")&&"channelsLast"===h){const e=[[d.strideHeight,d.strideWidth]],t=new VD(d);return n.runWebGLProgram(t,[r,s],"float32",e)}{const e=new zD(d);return n.runWebGLProgram(e,[r,s],"float32")}}};const GD={kernelName:ft,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:c}=a,l=Ai(r.shape,s.shape,o,c,i),u=new RD(l);return n.runWebGLProgram(u,[r,s],"float32")}};const HD={kernelName:mt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,pad:i,filterShape:c}=a,l=Ai(r.shape,c,o,1,i),u=new PD(l);return n.runWebGLProgram(u,[r,s],"float32")}};const jD={kernelName:gt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{pad:o,strides:i,inputShape:c}=a,l=Ai(c,s.shape,i,1,o),u=new BD(l);return n.runWebGLProgram(u,[r,s],"float32")}},KD=zA({opSnippet:LA+"\n  return cos(x);\n",packedOpSnippet:"\n  vec4 result = cos(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(IA,"\n  return result;\n")}),qD={kernelName:yt,backendName:"webgl",kernelFunc:KD},XD=zA({opSnippet:"\n  float e2x = exp(-x);\n  return (e2x + 1.0 / e2x) / 2.0;\n"}),YD={kernelName:bt,backendName:"webgl",kernelFunc:XD};class QD{constructor(e,t,n,a,r){this.variableNames=["Image","Boxes","BoxInd"],this.outputShape=[];const[s,o,i,c]=e,[l]=t,[u,h]=n;this.outputShape=[l,u,h,c];const d="bilinear"===a?1:0,[p,f]=["".concat(o-1,".0"),"".concat(i-1,".0")],[m,g,y]=u>1?["".concat((o-1)/(u-1)),"(y2-y1) * height_ratio","y1*".concat(p," + float(y)*(height_scale)")]:["0.0","0.0","0.5 * (y1+y2) * ".concat(p)],[b,v,x]=h>1?["".concat((i-1)/(h-1)),"(x2-x1) * width_ratio","x1*".concat(f," + float(x)*(width_scale)")]:["0.0","0.0","0.5 * (x1+x2) * ".concat(f)];this.userCode="\n      const float height_ratio = float(".concat(m,");\n      const float width_ratio = float(").concat(b,");\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int y = coords[1];\n        int x = coords[2];\n        int d = coords[3];\n\n        // get box vals\n        float y1 = getBoxes(b,0);\n        float x1 = getBoxes(b,1);\n        float y2 = getBoxes(b,2);\n        float x2 = getBoxes(b,3);\n\n        // get image in batch index\n        int bInd = round(getBoxInd(b));\n        if(bInd < 0 || bInd >= ").concat(s,") {\n          return;\n        }\n\n        float height_scale = ").concat(g,";\n        float width_scale = ").concat(v,";\n\n        float in_y = ").concat(y,";\n        if( in_y < 0.0 || in_y > ").concat(p," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n        float in_x = ").concat(x,";\n        if( in_x < 0.0 || in_x > ").concat(f," ) {\n          setOutput(float(").concat(r,"));\n          return;\n        }\n\n        vec2 sourceFracIndexCR = vec2(in_x,in_y);\n        if(").concat(d," == 1) {\n          // Compute the four integer indices.\n          ivec2 sourceFloorCR = ivec2(sourceFracIndexCR);\n          ivec2 sourceCeilCR = ivec2(ceil(sourceFracIndexCR));\n\n          float topLeft = getImage(b, sourceFloorCR.y, sourceFloorCR.x, d);\n          float bottomLeft = getImage(b, sourceCeilCR.y, sourceFloorCR.x, d);\n          float topRight = getImage(b, sourceFloorCR.y, sourceCeilCR.x, d);\n          float bottomRight = getImage(b, sourceCeilCR.y, sourceCeilCR.x, d);\n\n          vec2 fracCR = sourceFracIndexCR - vec2(sourceFloorCR);\n\n          float top = topLeft + (topRight - topLeft) * fracCR.x;\n          float bottom = bottomLeft + (bottomRight - bottomLeft) * fracCR.x;\n          float newValue = top + (bottom - top) * fracCR.y;\n          setOutput(newValue);\n        } else {\n          // Compute the coordinators of nearest neighbor point.\n          ivec2 sourceNearestCR = ivec2(floor(\n            sourceFracIndexCR + vec2(0.5,0.5)));\n          float newValue = getImage(b, sourceNearestCR.y, sourceNearestCR.x, d);\n          setOutput(newValue);\n        }\n      }\n    ")}}const JD={kernelName:wt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{image:r,boxes:s,boxInd:o}=t,{cropSize:i,method:c,extrapolationValue:l}=a,u=new QD(r.shape,s.shape,i,c,l);return n.runWebGLProgram(u,[r,s,o],"float32")}};var ZD;!function(e){e.Prod="*",e.Sum="+"}(ZD||(ZD={}));class $D{constructor(e,t,n,a){this.op=e,this.outputShape=t,this.variableNames=["x"],this.customUniforms=[{name:"index",type:"float"}];const r=this.outputShape.length,s=this.op===ZD.Prod?"1.0":"0.0",o=n?s:"getX(".concat(eF(r,"coords",this.op),")"),i=this.outputShape[this.outputShape.length-1];let c="",l="";n?(c=a?"end != ".concat(i-1):"end != 0",l=a?"end + 1":"end - 1"):(c=a?"end + pow2 < ".concat(i):"end >= pow2",l=a?"end + pow2":"end - pow2"),this.userCode="\n      void main() {\n        ".concat(EC(r)," coords = getOutputCoords();\n        int end = ").concat(tF(r,"coords",this.op),";\n        float val = ").concat(o,";\n        int pow2 = int(pow(2.0, index));\n        if (").concat(c,") {\n          int idx = ").concat(l,";\n          ").concat(tF(r,"coords",this.op)," = idx;\n          val ").concat(this.op,"= getX(").concat(eF(r,"coords",this.op),");\n        }\n        setOutput(val);\n      }\n    ")}}function eF(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".x, ").concat(t,".y");if(3===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z");if(4===e)return"".concat(t,".x, ").concat(t,".y, ").concat(t,".z, ").concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function tF(e,t,n){if(1===e)return"".concat(t);if(2===e)return"".concat(t,".y");if(3===e)return"".concat(t,".z");if(4===e)return"".concat(t,".w");throw new Error("Cumulative ".concat(n," for rank ").concat(e," is not yet supported"))}function nF(e,t,n,a,r,s){const o=t.shape.length,i=Dc([a],o);let c=t;null!=i&&(c=n_({inputs:{x:t},backend:n,attrs:{perm:i}}));const l=Oc(1,o)[0];if(l!==o-1)throw new Error("WebGL cumprod shader expects an inner-most axis=".concat(t.shape.length-1," ")+"but got axis=".concat(a));const u=c.shape[l];let h=TA({inputs:{x:c},backend:n});for(let d=0;d<=Math.ceil(Math.log2(u))-1;d++){const t=new $D(e,c.shape,!1,s),a=[[d]],r=h;h=n.runWebGLProgram(t,[h],h.dtype,a),n.disposeIntermediateTensorInfo(r)}if(r){const t=new $D(e,c.shape,r,s),a=h;h=n.runWebGLProgram(t,[h],h.dtype),n.disposeIntermediateTensorInfo(a)}if(null!=i){const e=n_({inputs:{x:h},backend:n,attrs:{perm:Fc(i)}});return n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(c),e}return h}const aF={kernelName:vt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a;return nF(ZD.Prod,r,n,s,o,i)}};const rF={kernelName:xt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,exclusive:o,reverse:i}=a;return nF(ZD.Sum,r,n,s,o,i)}};const sF={kernelName:kt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,weights:s}=t,{size:o,binaryOutput:i}=a;if(1===r.shape.length){const e=n.readSync(r.dataId),t=n.readSync(s.dataId),a=eR(e,t,s.dtype,s.shape,o);return n.makeTensorInfo([o],s.dtype,a)}if(2===r.shape.length){const e=n.bufferSync(r),t=n.bufferSync(s),a=tR(e,t,o,i);return n.makeTensorInfo(a.shape,s.dtype,a.values)}throw new Error("Error in denseBincount: input must be at most rank 2, but got rank"+"".concat(r.shape.length,"."))}};class oF{constructor(e,t,n){this.variableNames=["x"],this.outputShape=[],this.outputShape=e,this.blockSize=t,this.dataFormat=n,this.userCode="\n    void main() {\n      ivec4 coords = getOutputCoords();\n      int b = coords[0];\n      int h = ".concat(this.getHeightCoordString(),";\n      int w = ").concat(this.getWidthCoordString(),";\n      int d = ").concat(this.getDepthCoordString(),";\n\n      int in_h = h / ").concat(t,";\n      int offset_h = imod(h, ").concat(t,");\n      int in_w = w / ").concat(t,";\n      int offset_w = imod(w, ").concat(t,");\n      int offset_d = (offset_h * ").concat(t," + offset_w) *\n        ").concat(this.getOutputDepthSize(),";\n      int in_d = d + offset_d;\n\n      float result = ").concat(this.getInputSamplingString(),";\n      setOutput(result);\n    }\n  ")}getHeightCoordString(){return"NHWC"===this.dataFormat?"coords[1]":"coords[2]"}getWidthCoordString(){return"NHWC"===this.dataFormat?"coords[2]":"coords[3]"}getDepthCoordString(){return"NHWC"===this.dataFormat?"coords[3]":"coords[1]"}getOutputDepthSize(){return"NHWC"===this.dataFormat?this.outputShape[3]:this.outputShape[1]}getInputSamplingString(){return"NHWC"===this.dataFormat?"getX(b, in_h, in_w, in_d)":"getX(b, in_d, in_h, in_w)"}}const iF={kernelName:St,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockSize:s,dataFormat:o}=a,i=r.shape[0],c=("NHWC"===o?r.shape[1]:r.shape[2])*s,l=("NHWC"===o?r.shape[2]:r.shape[3])*s,u=("NHWC"===o?r.shape[3]:r.shape[1])/(s*s),h=new oF("NHWC"===o?[i,c,l,u]:[i,u,c,l],s,o);return n.runWebGLProgram(h,[r],r.dtype)}};class cF{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=OC(this.outputShape.length);const s=e.filterHeight,o=e.filterWidth,i=e.outChannels/e.inChannels;let c="",l="";n&&(c=a?"float activation(float a) {\n          float b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"float activation(float a) {\n          float b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"\n          float activation(float x) {\n            ".concat(n,"\n          }\n        "),l="result = activation(result);");const u=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(c,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(i,";\n        int q = d2 - d1 * ").concat(i,";\n\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        // Convolve x(?, ?, d1) with w(:, :, d1, q) to get y(yR, yC, d2).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        // TO DO(dsmilkov): Flatten the two for loops and vec4 the operations.\n        for (int wR = 0; wR < ").concat(s,"; wR++) {\n          int xR = xRCorner + wR * dilations[0];\n\n          if (xR < 0 || xR >= inDims[0]) {\n            continue;\n          }\n\n          for (int wC = 0; wC < ").concat(o,"; wC++) {\n            int xC = xCCorner + wC * dilations[1];\n\n            if (xC < 0 || xC >= inDims[1]) {\n              continue;\n            }\n\n            float xVal = getX(batch, xR, xC, d1);\n            float wVal = getW(wR, wC, d1, q);\n            dotProd += xVal * wVal;\n          }\n        }\n\n        float result = dotProd;\n        ").concat(u,"\n        ").concat(l,"\n        setOutput(result);\n      }\n    ")}}class lF{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];this.variableNames=["x","W"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"pads",type:"ivec2"},{name:"strides",type:"ivec2"},{name:"dilations",type:"ivec2"},{name:"inDims",type:"ivec2"}],this.outputShape=e.outShape,this.enableShapeUniforms=OC(this.outputShape.length);const s=e.outChannels/e.inChannels,o=e.padInfo.left,i=e.strideWidth,c=e.dilationWidth,l=e.filterHeight,u=e.filterWidth,h=u;let d="\n      int xR; int xC; int xCOffset;\n      vec4 wTexel; vec4 previous; vec4 final;";for(let g=0;g<u;g++)d+="\n          vec4 xTexelC".concat(2*g,";\n          int xTexelC").concat(2*g,"Ready;\n          vec4 xTexelC").concat(2*g+1,";\n          int xTexelC").concat(2*g+1,"Ready;\n          vec4 xC").concat(g,";");d+="\n    for (int r = 0; r < ".concat(l,"; r++) {\n      ");for(let g=0;g<u;g++)d+="\n          xTexelC".concat(2*g," = vec4(0.0);\n          xTexelC").concat(2*g,"Ready = 0;\n          xTexelC").concat(2*g+1," = vec4(0.0);\n          xTexelC").concat(2*g+1,"Ready = 0;\n          xC").concat(g," = vec4(0.0);");d+="\n        xR = xRCorner + r * dilations[0];\n        if (xR >=0 && xR < inDims[0]) {\n      ";for(let g=0;g<(h+1)/2;g++){const e=2*g;if(d+="\n          xC = xCCorner + ".concat(e*c,";\n          "),1===i){if(e<u&&(o%2===1?(d+="\n                xCOffset = xC + 1;\n                if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n              "),d+=1===c&&e>0?"\n                xC".concat(e," = vec4(xTexelC").concat(e-2,".zw, xTexelC").concat(e,".xy);\n                "):"\n                  xCOffset = xC + 1 - 2;\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                    previous = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      previous.zw = vec2(0.0);\n                    }\n\n                    xC".concat(e," = vec4(previous.zw, xTexelC").concat(e,".xy);\n                  } else {\n                    xC").concat(e," = vec4(0.0, 0.0, xTexelC").concat(e,".xy);\n                  }\n                  ")):d+="\n                if (xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xC").concat(e," = xTexelC").concat(e,";\n                "),e+1<u)){const t=o%2===0?Y(c):c;c%2===0&&o%2===1||c%2!==0&&o%2!==1?(d+="\n                  xCOffset = xC + imod(pads[1], 2) + ".concat(t,";\n\n                  if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                    xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n\n                    // Need to manually clear unused channels in case\n                    // we're reading from recycled texture.\n                    if (xCOffset + 1 >= inDims[1]) {\n                      xTexelC").concat(e+1,".zw = vec2(0.0);\n                    }\n                    xTexelC").concat(e+1,"Ready = 1;\n                  }\n                  "),d+=c>1?"\n                    xCOffset -= 2;\n                    if (xCOffset >= 0 && xCOffset < inDims[1]) {\n                     previous = getX(batch, xR, xCOffset, d1);\n                     xC".concat(e+1," = vec4(previous.zw, xTexelC").concat(e+1,".xy);\n                    } else {\n                     xC").concat(e+1," = vec4(0.0, 0.0, xTexelC").concat(e+1,".xy);\n                    }\n                    "):"\n                    xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".xy);\n                    ")):d+=1===t?"\n                    xC".concat(e+1," = xTexelC").concat(e,";\n                    "):"\n                    xCOffset = xC + ".concat(t,";\n\n                    if (xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                      xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                      if (xCOffset + 1 >= inDims[1]) {\n                        xTexelC").concat(e+1,".zw = vec2(0.0);\n                      }\n                      xTexelC").concat(e+1,"Ready = 1;\n                    }\n\n                    xC").concat(e+1," = xTexelC").concat(e+1,";\n                    ")}}else e<u&&(o%2===1?(d+="\n                xCOffset = xC + 1 - strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xCOffset, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                if(xC + 1 >= 0 && xC + 1 < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xC + 1, d1);\n                  // Need to manually clear unused channels in case\n                  // we're reading from recycled texture.\n                  if (xC + 2 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n              "),e+1<u&&(d+="\n                  final = vec4(0.0);\n                  xCOffset = xC + 1 + strides[1];\n                  if(xCOffset >= 0 && xCOffset < inDims[1]) {\n                    final = getX(batch, xR, xCOffset, d1);\n                  }\n                  xC".concat(e+1," = vec4(xTexelC").concat(e+1,".xy, final.xy);\n                "))):(d+="\n                if(xC >= 0 && xC < inDims[1] && xTexelC".concat(e,"Ready == 0) {\n                  xTexelC").concat(e," = getX(batch, xR, xC, d1);\n                  if (xC + 1 >= inDims[1]) {\n                    xTexelC").concat(e,".zw = vec2(0.0);\n                  }\n                  xTexelC").concat(e,"Ready = 1;\n                }\n\n                xCOffset = xC + strides[1];\n                if(xCOffset >= 0 && xCOffset < inDims[1] && xTexelC").concat(e+1,"Ready == 0) {\n                  xTexelC").concat(e+1," = getX(batch, xR, xCOffset, d1);\n                  if (xCOffset + 1 >= inDims[1]) {\n                    xTexelC").concat(e+1,".zw = vec2(0.);\n                  }\n                  xTexelC").concat(e+1,"Ready = 1;\n                }\n\n                xC").concat(e," = vec4(\n                  xTexelC").concat(e,".xy, xTexelC").concat(e+1,".xy);\n              "),e+1<u&&(d+="\n                  xC".concat(e+1," = vec4(xTexelC").concat(e,".zw, xTexelC").concat(e+1,".zw);\n                "))));e<u&&(d+="\n            wTexel = getW(r, ".concat(e,", d1, q);\n            dotProd += xC").concat(e," * vec4(wTexel.xz, wTexel.xz);\n          "),e+1<u&&(d+="\n              wTexel = getW(r, ".concat(e+1,", d1, q);\n              dotProd += xC").concat(e+1," * vec4(wTexel.xz, wTexel.xz);\n            ")))}d+="\n    }\n  ",d+="\n      }\n    ";let p="",f="";n&&(p=a?"vec4 activation(vec4 a) {\n          vec4 b = getPreluActivationWeightsAtOutCoords();\n          ".concat(n,"\n        }"):r?"vec4 activation(vec4 a) {\n          vec4 b = getLeakyreluAlphaAtOutCoords();\n          ".concat(n,"\n        }"):"vec4 activation(vec4 x) {\n          ".concat(n,"\n        }"),f="result = activation(result);");const m=t?"result += getBiasAtOutCoords();":"";t&&this.variableNames.push("bias"),a&&this.variableNames.push("preluActivationWeights"),r&&this.variableNames.push("leakyreluAlpha"),this.userCode="\n      ".concat(p,"\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        ivec2 xRCCorner = coords.yz * strides - pads;\n        int d2 = coords.w;\n        int d1 = d2 / ").concat(s,";\n        int q = d2 - d1 * ").concat(s,";\n        int xRCorner = xRCCorner.x;\n        int xCCorner = xRCCorner.y;\n\n        //intialize dotProd with a small epsilon seems to reduce GPU accuracy loss.\n        vec4 dotProd = vec4(0.000000000000001);\n\n        ").concat(d,"\n\n        vec4 result = dotProd - vec4(0.000000000000001);\n        ").concat(m,"\n        ").concat(f,"\n        setOutput(result);\n      }\n    ")}}const uF={kernelName:It,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:c,dimRoundingMode:l}=a;let u=c;null==u&&(u=[1,1]),J(zi(o,u),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(o," and dilations '").concat(u,"'")));const h=Ri(r.shape,s.shape,o,u,i,l,!0);let d;d=_e().getBool("WEBGL_PACK_DEPTHWISECONV")&&h.strideWidth<=2&&h.outChannels/h.inChannels===1?new lF(h):new cF(h);const p=[[h.padInfo.top,h.padInfo.left],[h.strideHeight,h.strideWidth],[h.dilationHeight,h.dilationWidth],[h.inHeight,h.inWidth]];return n.runWebGLProgram(d,[r,s],"float32",p)}};class hF{constructor(e){this.variableNames=["x","dy"],this.outputShape=e.filterShape;const t=e.strideHeight,n=e.strideWidth,a=e.padInfo.top,r=e.padInfo.left,s=e.outChannels/e.inChannels;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int wR = coords.x;\n        int wC = coords.y;\n        int d1 = coords.z;\n        int dm = coords.w;\n        int d2 = d1 * ".concat(s," + dm;\n\n        float dotProd = 0.0;\n\n        // TO DO: Vec4 over the batch size\n        for (int b = 0; b < ").concat(e.batchSize,"; b++) {\n          for (int yR = 0; yR < ").concat(e.outHeight,"; yR++) {\n            int xR = wR + yR * ").concat(t," - ").concat(a,";\n\n            if (xR < 0 || xR >= ").concat(e.inHeight,") {\n              continue;\n            }\n\n            for (int yC = 0; yC < ").concat(e.outWidth,"; yC++) {\n              int xC = wC + yC * ").concat(n," - ").concat(r,";\n\n              if (xC < 0 || xC >= ").concat(e.inWidth,") {\n                continue;\n              }\n\n              float dyValue = getDy(b, yR, yC, d2);\n              float xValue = getX(b, xR, xC, d1);\n              dotProd += (xValue * dyValue);\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class dF{constructor(e){this.variableNames=["dy","W"],this.outputShape=e.inShape;const t=e.filterHeight,n=e.filterWidth,a=e.strideHeight,r=e.strideWidth,s=t-1-e.padInfo.top,o=n-1-e.padInfo.left,i=e.outChannels/e.inChannels;this.userCode="\n      const ivec2 pads = ivec2(".concat(s,", ").concat(o,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords[0];\n        int d1 = coords[3];\n        ivec2 dyCorner = coords.yz - pads;\n        int dyRCorner = dyCorner.x;\n        int dyCCorner = dyCorner.y;\n\n        float dotProd = 0.0;\n\n        for (int wR = 0; wR < ").concat(t,"; wR++) {\n          float dyR = float(dyRCorner + wR) / ").concat(a,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          int wRPerm = ").concat(t," - 1 - wR;\n\n          for (int wC = 0; wC < ").concat(n,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(r,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            int wCPerm = ").concat(n," - 1 - wC;\n\n            // TO DO: Vec4 over the channelMul\n            for (int dm = 0; dm < ").concat(i,"; dm++) {\n              int d2 = d1 * ").concat(i," + dm;\n              float xValue = getDy(batch, idyR, idyC, d2);\n              float wValue = getW(wRPerm, wCPerm, d1, dm);\n              dotProd += xValue * wValue;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const pF={kernelName:Nt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,dy:s}=t,{strides:o,dilations:i,pad:c,dimRoundingMode:l,filterShape:u}=a,h=Ri(r.shape,u,o,i,c,l,!0),d=new hF(h);return n.runWebGLProgram(d,[r,s],"float32")}};const fF={kernelName:Tt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,filter:s}=t,{strides:o,dilations:i,pad:c,dimRoundingMode:l,inputShape:u}=a,h=Ri(u,s.shape,o,i,c,l,!0),d=new dF(h);return n.runWebGLProgram(d,[r,s],"float32")}};class mF{constructor(e){this.variableNames=["X"],this.outputShape=[e,e],this.userCode="\n      void main() {\n          ivec2 coords = getOutputCoords();\n          float val = coords[0] == coords[1] ? getX(coords[0]) : 0.0;\n          setOutput(val);\n      }\n    "}}const gF={kernelName:Et,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t,r=[...a.shape,...a.shape],s=ee(a.shape),o=KA({inputs:{x:a},backend:n,attrs:{shape:[s]}}),i=new mF(s),c=n.runWebGLProgram(i,[o],o.dtype),l=KA({inputs:{x:c},backend:n,attrs:{shape:r}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(c),l}};class yF{constructor(e){this.variableNames=["x","W"],this.outputShape=e.outShape;const{inHeight:t,inWidth:n,padInfo:a,strideHeight:r,strideWidth:s,filterHeight:o,filterWidth:i,dilationHeight:c,dilationWidth:l}=e,{top:u,left:h}=a;this.userCode="\n      const ivec2 strides = ivec2(".concat(r,", ").concat(s,");\n      const ivec2 pads = ivec2(").concat(u,", ").concat(h,");\n      const float neg_infinity = -3.4e38;\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int batch = coords.x;\n        int d1 = coords.w;\n        ivec2 outTopLeftCorner =\n            coords.yz * strides - pads;\n        int hBeg = outTopLeftCorner.x;\n        int wBeg = outTopLeftCorner.y;\n\n        float curVal = neg_infinity;\n        for (int h = 0; h < ").concat(o,"; h++) {\n          int hIn = hBeg + h * ").concat(c,";\n\n          if (hIn >= 0 && hIn < ").concat(t,") {\n            for (int w = 0; w < ").concat(i,"; w++) {\n              int wIn = wBeg + w * ").concat(l,";\n\n              if (wIn >= 0 && wIn < ").concat(n,") {\n                float xVal = getX(batch, hIn, wIn, d1);\n                float wVal = getW(h, w, d1);\n\n                float val = xVal + wVal;\n                if (val > curVal) {\n                  curVal = val;\n                }\n              }\n            }\n          }\n        }\n\n        float result = curVal;\n        setOutput(result);\n      }\n    ")}}const bF={kernelName:Ct,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s}=t,{strides:o,pad:i,dilations:c}=a,l=Ti(r.shape,s.shape,o,i,"NHWC",c);let u;const h=new yF(l);u=n.runWebGLProgram(h,[r,s],"float32");const d=KA({inputs:{x:u},backend:n,attrs:{shape:l.outShape}});return n.disposeIntermediateTensorInfo(u),d}};const vF={kernelName:Ft,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{equation:r}=a,s=t,{allDims:o,summedDims:i,idDims:c}=bh(r,s.length);xh(o.length,c,s);const{path:l,steps:u}=wh(i,c),h=u.length;let d=null,p=o.length;const f=[];for(let m=0;m<h;++m){for(const e of u[m]){const{permutationIndices:t,expandDims:a}=vh(p,c[e]);let r;kh(t)?r=s[e]:(r=n_({inputs:{x:s[e]},backend:n,attrs:{perm:t}}),f.push(r));const o=r.shape.slice();for(let e=0;e<a.length;++e)o.splice(a[e],0,1);te(r.shape,o)||(r=KA({inputs:{x:r},backend:n,attrs:{shape:o}}),f.push(r)),null===d?d=r:(d=HA({inputs:{a:r,b:d},backend:n}),f.push(d))}m<h-1&&(l[m]>=0&&(d=e_({inputs:{x:d},backend:n,attrs:{axis:l[m]-(o.length-p),keepDims:!1}}),f.push(d)),p--)}for(const m of f)m!==d&&n.disposeIntermediateTensorInfo(m);return d}},xF=zA({opSnippet:"return (x >= 0.0) ? x : (exp(x) - 1.0);",packedOpSnippet:"\n  vec4 result;\n\n  result.r = (x.r >= 0.0) ? x.r : (exp(x.r) - 1.0);\n  result.g = (x.g >= 0.0) ? x.g : (exp(x.g) - 1.0);\n  result.b = (x.b >= 0.0) ? x.b : (exp(x.b) - 1.0);\n  result.a = (x.a >= 0.0) ? x.a : (exp(x.a) - 1.0);\n\n  return result;\n"}),wF={kernelName:Ot,backendName:"webgl",kernelFunc:xF},kF={kernelName:Mt,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n}=e,{dy:a,y:r}=t,s=_e().getBool("WEBGL_PACK_BINARY_OPERATIONS")?new NA("\n  vec4 bGTEZero = vec4(greaterThanEqual(b, vec4(0.)));\n  return (bGTEZero * a) + ((vec4(1.0) - bGTEZero) * (a * (b + vec4(1.0))));\n",a.shape,r.shape):new SA("return (b >= 0.0) ? a : a * (b + 1.0);",a.shape,r.shape);return n.runWebGLProgram(s,[a,r],a.dtype)}},SF=PA({opSnippet:"return float(a == b);",packedOpSnippet:"\n  return vec4(equal(a, b));\n",dtype:"bool",cpuKernelImpl:oR}),IF={kernelName:zt,backendName:"webgl",kernelFunc:SF},NF=zA({opSnippet:'\n  // Error function is calculated approximately with elementary function.\n  // See "Handbook of Mathematical Functions with Formulas,\n  // Graphs, and Mathematical Tables", Abramowitz and Stegun.\n  float p = '.concat(eh,";\n  float a1 = ").concat(th,";\n  float a2 = ").concat(nh,";\n  float a3 = ").concat(ah,";\n  float a4 = ").concat(rh,";\n  float a5 = ").concat(sh,";\n\n  float sign = sign(x);\n  x = abs(x);\n  float t = 1.0 / (1.0 + p * x);\n  return sign * (1.0 - (((((a5*t + a4)*t) + a3)*t + a2)*t + a1)*t*exp(-x*x));\n")}),TF={kernelName:Lt,backendName:"webgl",kernelFunc:NF},EF=zA({opSnippet:LA+"\n  return exp(x);\n",packedOpSnippet:"\n  vec4 result = exp(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:iR,dtype:"float32"}),CF={kernelName:Pt,backendName:"webgl",kernelFunc:EF};function RF(e){const{inputs:t,attrs:n,backend:a}=e,{dim:r}=n,{input:s}=t,o=s.shape.length,i=s.shape.slice();let c=r;return r<0&&(J(-(o+1)<=r,(()=>"Axis must be in the interval [".concat(-(o+1),", ").concat(o,"]"))),c=o+r+1),i.splice(c,0,1),KA({inputs:{x:s},backend:a,attrs:{shape:i}})}const AF={kernelName:Bt,backendName:"webgl",kernelFunc:RF},_F="return exp(x) - 1.0;",DF=zA({opSnippet:_F,packedOpSnippet:_F,cpuKernelImpl:cR}),FF={kernelName:Wt,backendName:"webgl",kernelFunc:DF};class OF{constructor(e,t,n){this.variableNames=["real","imag"];const a=t[1];this.outputShape=t;const r=n?"2.0 * ".concat(Math.PI):"-2.0 * ".concat(Math.PI),s=n?"".concat(a,".0"):"1.0";let o;if("real"===e)o="return real * expR - imag * expI;";else{if("imag"!==e)throw new Error('FFT component must be either "real" or "imag", got '.concat(e,"."));o="return real * expI + imag * expR;"}this.userCode="\n      const float exponentMultiplier = ".concat(r,";\n\n      float unaryOpComplex(float real, float expR, float imag, float expI) {\n        ").concat(o,"\n      }\n\n      float mulMatDFT(int batch, int index) {\n        float indexRatio = float(index) / float(").concat(a,");\n        float exponentMultiplierTimesIndexRatio =\n            exponentMultiplier * indexRatio;\n\n        float result = 0.0;\n\n        for (int i = 0; i < ").concat(a,"; i++) {\n          // x = (-2|2 * PI / N) * index * i;\n          float x = exponentMultiplierTimesIndexRatio * float(i);\n          float expR = cos(x);\n          float expI = sin(x);\n          float real = getReal(batch, i);\n          float imag = getImag(batch, i);\n\n          result +=\n              unaryOpComplex(real, expR, imag, expI) / ").concat(s,";\n        }\n\n        return result;\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        setOutput(mulMatDFT(coords[0], coords[1]));\n      }\n    ")}}function MF(e,t,n){const a=n.texData.get(e.dataId),r=ee(e.shape),s=e.shape[e.shape.length-1],o=KA({inputs:{x:e},backend:n,attrs:{shape:[r/s,s]}}),i=o.shape,c=new OF("real",i,t),l=new OF("imag",i,t),u=[{dataId:a.complexTensorInfos.real.dataId,dtype:a.complexTensorInfos.real.dtype,shape:i},{dataId:a.complexTensorInfos.imag.dataId,dtype:a.complexTensorInfos.imag.dtype,shape:i}],h=n.runWebGLProgram(c,u,"float32"),d=n.runWebGLProgram(l,u,"float32"),p=CA({inputs:{real:h,imag:d},backend:n});n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d);const f=KA({inputs:{x:p},backend:n,attrs:{shape:e.shape}});return n.disposeIntermediateTensorInfo(o),n.disposeIntermediateTensorInfo(p),f}const LF={kernelName:Vt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return MF(a,!1,n)}};class zF{constructor(e,t){this.outputShape=[],this.customUniforms=[{name:"value",type:"float"}],this.variableNames=["x"],this.outputShape=e,this.userCode="\n      void main() {\n        // Input can be obtained from uniform value.\n        setOutput(value);\n      }\n    "}}function PF(e){const{backend:t,attrs:n}=e,{shape:a,value:r}=n;let{dtype:s}=n;if(s=s||me(r),"string"===s){const e=ue(s,ee(a));return e.fill(r),t.makeTensorInfo(a,s,e)}{const e=new zF(a,r),n=[[r]];return t.runWebGLProgram(e,[],s,n)}}const BF={kernelName:Ut,backendName:"webgl",kernelFunc:PF};class WF{constructor(e){this.variableNames=["Image"],this.outputShape=[];const t=e[2];this.outputShape=e,this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n\n          int coordX = ".concat(t," - x - 1;\n          float outputValue;\n          if(coordX >= 0 && coordX < ").concat(t,") {\n            outputValue = getImage(coords[0], coords[1], coordX, coords[3]);\n          } else {\n            outputValue = getImage(coords[0], coords[1], coords[2], coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const VF={kernelName:Gt,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n}=e;const{image:a}=t,r=n,s=new WF(a.shape);return r.runWebGLProgram(s,[a],a.dtype)}},UF="return floor(x);",GF=zA({opSnippet:UF,packedOpSnippet:UF,cpuKernelImpl:lR}),HF={kernelName:Ht,backendName:"webgl",kernelFunc:GF},jF=PA({opSnippet:"\n  float s = sign(a) * sign(b);\n  int ia = round(a);\n  int ib = round(b);\n  if (ib != 0) {\n    // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n    return float(idiv(ia, ib, s));\n  } else {\n    return NAN;\n  }\n",packedOpSnippet:"\n  ivec4 ia = round(a);\n  ivec4 ib = round(b);\n  bvec4 cond = notEqual(ib, ivec4(0));\n  ivec4 result = ivec4(0);\n  vec4 s = sign(a) * sign(b);\n\n  // Windows (D3D) wants guaranteed non-zero int division at compile-time.\n  if (cond[0]) {\n    result[0] = idiv(ia[0], ib[0], s[0]);\n  }\n  if (cond[1]) {\n    result[1] = idiv(ia[1], ib[1], s[1]);\n  }\n  if (cond[2]) {\n    result[2] = idiv(ia[2], ib[2], s[2]);\n  }\n  if (cond[3]) {\n    result[3] = idiv(ia[3], ib[3], s[3]);\n  }\n  return vec4(result);\n",dtype:"int32"}),KF={kernelName:jt,backendName:"webgl",kernelFunc:jF};class qF{constructor(e){this.variableNames=["A"];const t=hC(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n        vec2 uv = (vec2(texC, texR) + halfCR) / vec2(".concat(a,".0, ").concat(n,".0);\n\n        vec4 values = ").concat(t.texture2D,"(A, uv);\n        float value;\n        if (depth == 0) {\n          value = values.r;\n        } else if (depth == 1) {\n          value = values.g;\n        } else if (depth == 2) {\n          value = values.b;\n        } else if (depth == 3) {\n          value = values.a;\n        }\n\n        setOutput(floor(value * 255.0 + 0.5));\n      }\n    ")}}class XF{constructor(e){this.variableNames=["A"],this.packedInputs=!1,this.packedOutput=!0;const t=hC(),[n,a]=e;this.outputShape=e,this.userCode="\n      void main() {\n        ivec3 coords = getOutputCoords();\n        int texR = coords[0];\n        int texC = coords[1];\n        int depth = coords[2];\n\n        vec4 result = vec4(0.);\n\n        for(int row=0; row<=1; row++) {\n          for(int col=0; col<=1; col++) {\n            texC = coords[1] + row;\n            depth = coords[2] + col;\n\n            vec2 uv = (vec2(texC, texR) + halfCR) /\n                       vec2(".concat(a,".0, ").concat(n,".0);\n            vec4 values = ").concat(t.texture2D,"(A, uv);\n            float value;\n            if (depth == 0) {\n              value = values.r;\n            } else if (depth == 1) {\n              value = values.g;\n            } else if (depth == 2) {\n              value = values.b;\n            } else if (depth == 3) {\n              value = values.a;\n            }\n\n            result[row * 2 + col] = floor(value * 255.0 + 0.5);\n          }\n        }\n\n        ").concat(t.output," = result;\n      }\n    ")}}const YF={kernelName:Ga,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e;let{pixels:r}=t;const{numChannels:s}=a,o="undefined"!==typeof HTMLVideoElement&&r instanceof HTMLVideoElement,i="undefined"!==typeof HTMLImageElement&&r instanceof HTMLImageElement,[c,l]=o?[r.videoWidth,r.videoHeight]:[r.width,r.height],u=[l,c],h=[l,c,s];if(i||o){const e=_e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");null!=QF&&e===JF||(JF=e,QF=document.createElement("canvas").getContext("2d",{willReadFrequently:JF})),QF.canvas.width=c,QF.canvas.height=l,QF.drawImage(r,0,0,c,l),r=QF.canvas}const d=n.makeTensorInfo(u,"int32");n.texData.get(d.dataId).usage=FE.PIXELS,n.gpgpu.uploadPixelDataToTexture(n.getTexture(d.dataId),r);const p=_e().getBool("WEBGL_PACK")?new XF(h):new qF(h),f=n.runWebGLProgram(p,[d],"int32");return n.disposeData(d.dataId),f}};let QF,JF=_e().getBool("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU");const ZF={kernelName:Ka,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:c,pad:l,dataFormat:u,dilations:h,dimRoundingMode:d,activation:p,leakyreluAlpha:f}=a,m=Bi(u),g=Ri(r.shape,s.shape,c,h,l,d,!1,m);let y;const b=[],v=null!=o,x=null!=i,w="leakyrelu"===p,k=()=>{const e=[r,s],t=(e,t)=>{if("NCHW"===t&&1===e.shape.length&&1!==e.shape[0]){const t=KA({inputs:{x:e},backend:n,attrs:{shape:[e.shape[0],1,1]}});return b.push(t),t}return e};if(v&&e.push(t(o,u)),x&&e.push(t(i,u)),w){const t=n.makeTensorInfo([],"float32",xr(f,"float32"));e.push(t),b.push(t)}return e};if(1!==g.filterHeight||1!==g.filterWidth||1!==g.dilationHeight||1!==g.dilationWidth||1!==g.strideHeight||1!==g.strideWidth||"SAME"!==g.padInfo.type&&"VALID"!==g.padInfo.type)if(g.strideWidth<=2&&"channelsLast"===m&&_e().getBool("WEBGL_EXP_CONV")){const e=p?BA(p,!0):null,t=new AD(g,v,e,x,w),a=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],r=k();y=n.runWebGLProgram(t,r,"float32",a)}else if(_e().getBool("WEBGL_CONV_IM2COL"))y=OD({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});else{const e=p?BA(p,!1):null,t=new CD(g,v,e,x,w),a=k();y=n.runWebGLProgram(t,a,"float32")}else y=FD({x:r,filter:s,convInfo:g,backend:n,bias:o,activation:p,preluActivationWeights:i,leakyreluAlpha:f});const S=KA({inputs:{x:y},backend:n,attrs:{shape:g.outShape}});return b.push(y),b.forEach((e=>n.disposeIntermediateTensorInfo(e))),S}};const $F={kernelName:qa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,filter:s,bias:o,preluActivationWeights:i}=t,{strides:c,pad:l,dilations:u,dimRoundingMode:h,activation:d,leakyreluAlpha:p}=a,f=[];let m=u;null==m&&(m=[1,1]),J(zi(c,m),(()=>"Error in depthwiseConv2d: Either strides or dilations must be "+"1. Got strides ".concat(c," and dilations '").concat(m,"'")));const g=Ri(r.shape,s.shape,c,m,l,h,!0),y=_e().getBool("WEBGL_PACK_DEPTHWISECONV")&&g.strideWidth<=2&&g.outChannels/g.inChannels===1,b=d?BA(d,y):null,v=[r,s],x=null!=o,w=null!=i,k="leakyrelu"===d;if(x&&v.push(o),w&&v.push(i),k){const e=n.makeTensorInfo([],"float32",xr(p,"float32"));v.push(e),f.push(e)}let S;S=y?new lF(g,x,b,w,k):new cF(g,x,b,w,k);const I=[[g.padInfo.top,g.padInfo.left],[g.strideHeight,g.strideWidth],[g.dilationHeight,g.dilationWidth],[g.inHeight,g.inWidth]],N=n.runWebGLProgram(S,v,"float32",I);return f.forEach((e=>n.disposeIntermediateTensorInfo(e))),N}};class eO{constructor(e,t,n,a){this.sliceDim=e,this.strides=t,this.paramsShape=a,this.variableNames=["x","indices"],this.outputShape=n;const r=EC(n.length);let s="\n    int index;";for(let o=0;o<this.sliceDim;o++)s+="\n          index = round(getIndices(coords[0], ".concat(o,"));\n          out_of_bounds = out_of_bounds || index < 0;\n          out_of_bounds = out_of_bounds || index >= ").concat(this.paramsShape[o],";\n          flattenIndex += index * ").concat(this.strides[o],";");this.userCode="\n         void main() {\n          ".concat(r," coords = getOutputCoords();\n          int flattenIndex = 0;\n          bool out_of_bounds = false;\n\n          ").concat(s,"\n\n          setOutput(out_of_bounds ? 0.0 : getX(flattenIndex, coords[1]));\n        }\n      ")}}const tO={kernelName:Xt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{params:a,indices:r}=t,s=r.shape,o=s[s.length-1],i=ee(a.shape),[c,l,u,h]=Xu(a,r),d=KA({inputs:{x:r},backend:n,attrs:{shape:[l,o]}}),p=KA({inputs:{x:a},backend:n,attrs:{shape:[ee(a.shape)/u,u]}});if(n.shouldExecuteOnCPU([a,r])||"string"===a.dtype){const e=n.readSync(r.dataId),t=n.bufferSync(a),s=uR(e,t,a.dtype,l,o,u,h,a.shape,i);return n.makeTensorInfo(c,a.dtype,s.values)}const f=new eO(o,h,[l,u],a.shape),m=n.runWebGLProgram(f,[p,d],p.dtype),g=KA({inputs:{x:m},backend:n,attrs:{shape:c}});return n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(m),g}};class nO{constructor(e,t){this.variableNames=["A","indices"],this.outputShape=t,this.rank=t.length;const n=EC(this.rank),a=function(e,t){const n=["resRC.x","resRC.y","resRC.z","resRC.w"],a=[];for(let r=0;r<e.length;r++)2===r?a.push("index"):a.push("".concat(n[r]));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(n," resRC = getOutputCoords();\n        int index = int(getIndices(resRC.x, resRC.z));\n        float inBounds = (index >= 0) && (index < ").concat(e[2],") ? 1.0 : 0.0;\n        setOutput(inBounds * getA(").concat(a,"));\n      }\n    ")}}function aO(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,indices:s}=t,{axis:o,batchDims:i}=a,c=ie(o,r.shape)[0];if(_e().get("DEBUG")){const e=n.readSync(s.dataId),t=r.shape[c];for(let n=0;n<e.length;++n){const a=e[n];J(a<=t-1&&a>=0,(()=>"GatherV2: the index value ".concat(a," is not in [0, ").concat(t-1,"]")))}}const l=Bh(r,s,c,i),u=ee(s.shape),h=[],d=KA({inputs:{x:r},backend:n,attrs:{shape:[l.batchSize,l.outerSize,l.dimSize,l.sliceSize]}}),p=KA({inputs:{x:s},backend:n,attrs:{shape:[l.batchSize,u/l.batchSize]}});h.push(d),h.push(p);const f=[l.batchSize,l.outerSize,u/l.batchSize,l.sliceSize];if(n.shouldExecuteOnCPU([r,s])||"string"===r.dtype){const e=n.bufferSync(p),t=n.bufferSync(d),a=hR(t,e,f);return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),n.makeTensorInfo(l.outputShape,a.dtype,a.values)}const m=new nO(d.shape,f),g=n.runWebGLProgram(m,[d,p],d.dtype);h.push(g);const y=KA({inputs:{x:g},backend:n,attrs:{shape:l.outputShape}});return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),y}const rO={kernelName:qt,backendName:"webgl",kernelFunc:aO},sO=PA({opSnippet:"return float(a > b);",packedOpSnippet:"\n  return vec4(greaterThan(a, b));\n",cpuKernelImpl:dR,dtype:"bool"}),oO={kernelName:Yt,backendName:"webgl",kernelFunc:sO},iO=PA({opSnippet:"return float(a >= b);",packedOpSnippet:"\n  return vec4(greaterThanEqual(a, b));\n",dtype:"bool",cpuKernelImpl:pR}),cO={kernelName:Qt,backendName:"webgl",kernelFunc:iO};const lO={kernelName:Zt,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{input:a}=t;return MF(a,!0,n)}},uO=zA({opSnippet:"return float(!isnan(x) && !isinf(x));",dtype:"bool"}),hO={kernelName:en,backendName:"webgl",kernelFunc:uO},dO=zA({opSnippet:"return float(isinf(x));",dtype:"bool"}),pO={kernelName:tn,backendName:"webgl",kernelFunc:dO},fO=zA({opSnippet:"return float(isnan(x));",dtype:"bool"}),mO={kernelName:nn,backendName:"webgl",kernelFunc:fO},gO=PA({opSnippet:"return float(a < b);",packedOpSnippet:"\n  return vec4(lessThan(a, b));\n",cpuKernelImpl:fR,dtype:"bool"}),yO={kernelName:rn,backendName:"webgl",kernelFunc:gO},bO=PA({opSnippet:"return float(a <= b);",packedOpSnippet:"\n  return vec4(lessThanEqual(a, b));\n",cpuKernelImpl:mR,dtype:"bool"}),vO={kernelName:sn,backendName:"webgl",kernelFunc:bO};const xO={kernelName:on,backendName:"webgl",kernelFunc:function(e){const{backend:t,attrs:n}=e,{start:a,stop:r,num:s}=n,o=gR(a,r,s);return t.makeTensorInfo([o.length],"float32",o)}},wO=zA({opSnippet:LA+"\n  return x < 0.0 ? 0./0. : log(x);\n",packedOpSnippet:"\n  vec4 result = log(x);\n  bvec4 isNaN = isnan(x);\n  result.r = isNaN.r ? x.r : (x.r < 0.0 ? 0./0. : result.r);\n  result.g = isNaN.g ? x.g : (x.g < 0.0 ? 0./0. : result.g);\n  result.b = isNaN.b ? x.b : (x.b < 0.0 ? 0./0. : result.b);\n  result.a = isNaN.a ? x.a : (x.a < 0.0 ? 0./0. : result.a);\n  return result;\n",cpuKernelImpl:yR}),kO={kernelName:cn,backendName:"webgl",kernelFunc:wO},SO=zA({opSnippet:LA+"\n  return log(1.0 + x);\n"}),IO={kernelName:ln,backendName:"webgl",kernelFunc:SO},NO=PA({opSnippet:"return float(a >= 1.0 && b >= 1.0);",packedOpSnippet:"\n  return vec4(\n    vec4(greaterThanEqual(a, vec4(1.0))) *\n    vec4(greaterThanEqual(b, vec4(1.0))));\n",dtype:"bool"}),TO={kernelName:un,backendName:"webgl",kernelFunc:NO},EO=zA({opSnippet:"return float(!(x >= 1.0));"}),CO={kernelName:hn,backendName:"webgl",kernelFunc:EO},RO=PA({opSnippet:"return float(a >= 1.0 || b >= 1.0);",packedOpSnippet:"\n  return min(\n    vec4(greaterThanEqual(a, vec4(1.0))) +\n    vec4(greaterThanEqual(b, vec4(1.0))),\n    vec4(1.0));\n",dtype:"bool"}),AO={kernelName:dn,backendName:"webgl",kernelFunc:RO};class _O{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[];const s=t,o=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n        int d = coords[3];\n        float x = getX(b, r, c, d);\n        float sum = 0.0;\n        for (int j = -".concat(s,"; j <= ").concat(s,"; j++) {\n          int idx = d + j;\n          if (idx >= 0 && idx <=  ").concat(o,") {\n            float z = getX(b, r, c, idx);\n            sum += z * z;\n          }\n        }\n        float val = x * ").concat(i,";\n        setOutput(val);\n      }\n    ")}}class DO{constructor(e,t,n,a,r){this.variableNames=["x"],this.outputShape=[],this.packedInputs=!0,this.packedOutput=!0;const s=t,o=e[3]-1;let i;this.outputShape=e;const c="float(".concat(n,") + float(").concat(a,") * sum");i=.5===r?"inversesqrt(".concat(c,")"):1===r?"1.0/(".concat(c,")"):"exp(log(".concat(c,") * float(-").concat(r,"));"),this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords.x;\n        int r = coords.y;\n        int c = coords.z;\n        int d = coords.w;\n\n        bool hasNextCol = d < ".concat(this.outputShape[3],";\n        bool hasNextRow = c < ").concat(this.outputShape[2],";\n\n        vec4 sum = vec4(0.);\n        vec4 xFragAtOutputCoords = getX(b, r, c, d);\n\n        vec4 xAtOutputCoords = vec4(\n          getChannel(xFragAtOutputCoords, vec2(c, d)),\n          hasNextCol ?\n            getChannel(xFragAtOutputCoords, vec2(c, d + 1)) : 0.0,\n          hasNextRow ?\n            getChannel(xFragAtOutputCoords , vec2(c + 1, d)) : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getChannel(xFragAtOutputCoords, vec2(c + 1, d + 1)) : 0.0\n        );\n\n        int firstChannel = d - ").concat(s,";\n        vec2 cache = vec2(0.);\n        if(firstChannel >= 0){\n          vec4 firstChannelFrag = getX(b, r, c, firstChannel);\n          cache.x = getChannel(firstChannelFrag, vec2(c, firstChannel));\n            if(hasNextRow){\n              cache.y = getChannel(firstChannelFrag, vec2(c + 1, firstChannel));\n            }\n        }\n\n        ivec2 depth = ivec2(d, d + 1);\n        for (int j = - ").concat(s,"; j <= ").concat(s,"; j++) {\n          ivec2 idx = depth + j;\n          bvec2 aboveLowerBound = greaterThanEqual(idx, ivec2(0));\n          bvec2 belowUpperBound = lessThanEqual(idx, ivec2(").concat(o,"));\n\n          bool depthInRange = aboveLowerBound.x && belowUpperBound.x;\n          bool depthPlusOneInRange = aboveLowerBound.y && belowUpperBound.y;\n\n          if(depthInRange || depthPlusOneInRange){\n            vec4 z = vec4(0.);\n            vec4 xFragAtCurrentDepth;\n            z.xz = cache.xy;\n            if(depthPlusOneInRange && hasNextCol){\n              xFragAtCurrentDepth = idx.y != d ?\n                getX(b, r, c, idx.y) : xFragAtOutputCoords;\n              z.y = getChannel(xFragAtCurrentDepth, vec2(c, idx.y));\n              if(hasNextRow){\n                z.w = getChannel(xFragAtCurrentDepth, vec2(c + 1, idx.y));\n              }\n            }\n            cache.xy = z.yw;\n            sum += z * z;\n          }\n        }\n        vec4 result = xAtOutputCoords * ").concat(i,";\n        setOutput(result);\n      }\n    ")}}const FO={kernelName:pn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{depthRadius:s,bias:o,alpha:i,beta:c}=a,l=_e().getBool("WEBGL_PACK_NORMALIZATION")?new DO(r.shape,s,o,i,c):new _O(r.shape,s,o,i,c);return n.runWebGLProgram(l,[r],r.dtype)}};class OO{constructor(e,t,n,a,r){this.variableNames=["inputImage","outputImage","dy"],this.outputShape=[],this.outputShape=e,this.depth=e[3],this.depthRadius=t,this.bias=n,this.alpha=a,this.beta=r,this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int r = coords[1];\n        int c = coords[2];\n\n        float result = 0.0;\n        for (int d = 0; d < ".concat(this.depth,"; ++d) {\n          int depthBegin = int(max(0.0, float(d - ").concat(t,")));\n          int depthEnd = int(min(float(").concat(this.depth,"),\n              float(d + ").concat(t," + 1)));\n\n          const int MIN_DEPTH_BEGIN = 0;\n          const int MAX_DEPTH_END = ").concat(this.depth,";\n\n          float norm = 0.0;\n          for (int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k) {\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd) {\n              norm += getInputImage(b, r, c, k) * getInputImage(b, r, c, k);\n            }\n            else {\n              break;\n            }\n          }\n\n          norm = float(").concat(a,") * norm + float(").concat(n,");\n\n          for(int k = MIN_DEPTH_BEGIN; k < MAX_DEPTH_END; ++k){\n            if (k < depthBegin){\n              continue;\n            }\n            else if (k >= depthBegin && k < depthEnd){\n              float dyi = -2.0 * float(").concat(a,")\n                * float(").concat(r,")\n                * getInputImage(b, r, c, k) * getOutputImage(b, r, c, d)\n                / norm;\n              if (k == d) {\n                dyi += pow(norm, -1.0 * ").concat(r,");\n              }\n              if (k == coords[3]) {\n                dyi *= getDy(b, r, c, d);\n                result += dyi;\n              }\n            }\n            else {\n              break;\n            }\n          }\n      }\n      setOutput(result);\n      }\n    ")}}const MO={kernelName:fn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r,y:s,dy:o}=t,{depthRadius:i,bias:c,alpha:l,beta:u}=a,h=new OO(r.shape,i,c,l,u);return n.runWebGLProgram(h,[r,s,o],r.dtype)}};function LO(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reductionIndices:s,keepDims:o}=a,i=r.shape.length,c=ie(s,r.shape);let l=c;const u=Dc(l,i),h=null!=u,d=n.shouldExecuteOnCPU([r]);let p=r;if(h){if(d){const e=n.texData.get(p.dataId).values,t=new Array(i);for(let n=0;n<t.length;n++)t[n]=r.shape[u[n]];const a=KR(e,r.shape,r.dtype,u,t);p=n.makeTensorInfo(t,r.dtype);n.texData.get(p.dataId).values=a}else p=$A(r,u,n);l=Oc(l.length,i)}_c("max",l,i);const[f,m]=Rc(p.shape,l);let g,y=f;if(o&&(y=Ac(f,c)),d){const e=n.texData.get(p.dataId).values,t=bR(e,ee(m),y,r.dtype);g=n.makeTensorInfo(y,r.dtype);n.texData.get(g.dataId).values=t}else g=function(e,t,n,a){const r=ee(t),s=KA({inputs:{x:e},attrs:{shape:[ee(e.shape)/r,r]},backend:a}),o=QA(s,e.dtype,"max",a),i=KA({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}(p,m,y,n);return h&&n.disposeIntermediateTensorInfo(p),g}const zO={kernelName:mn,backendName:"webgl",kernelFunc:LO},PO=PA({opSnippet:kA+"\n  return max(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(max(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+IA+"\n  return result;\n",cpuKernelImpl:vR}),BO={kernelName:gn,backendName:"webgl",kernelFunc:PO};const WO={kernelName:yn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;lC(r,"maxPool");const{filterSize:s,strides:o,pad:i,dimRoundingMode:c}=a;J(zi(o,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(1,"'")));const l=Ei(r.shape,s,o,1,i,c);if(1===l.filterWidth&&1===l.filterHeight&&te(l.inShape,l.outShape))return TA({inputs:{x:r},backend:n});const u=new P_(l,"max",!1);return n.runWebGLProgram(u,[r],r.dtype)}};const VO={kernelName:vn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{filterSize:s,strides:o,pad:i,dataFormat:c,dimRoundingMode:l}=a,u=Ci(r.shape,s,o,[1,1,1],i,l,c),h=new B_(u,"max",!1);return n.runWebGLProgram(h,[r],r.dtype)}};class UO{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideHeight,n=e.strideWidth,a=e.dilationHeight,r=e.effectiveFilterHeight,s=e.effectiveFilterWidth,o=r-1-e.padInfo.top,i=s-1-e.padInfo.left,c=r*s-1;this.userCode="\n      const ivec2 pads = ivec2(".concat(o,", ").concat(i,");\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n\n        ivec2 dyRCCorner = coords.yz - pads;\n        int dyRCorner = dyRCCorner.x;\n        int dyCCorner = dyRCCorner.y;\n\n        // Convolve dy(?, ?, d) with pos mask(:, :, d) to get dx(xR, xC, d).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n        for (int wR = 0; wR < ").concat(r,";\n          wR += ").concat(a,") {\n          float dyR = float(dyRCorner + wR) / ").concat(t,".0;\n\n          if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 || fract(dyR) > 0.0) {\n            continue;\n          }\n          int idyR = int(dyR);\n\n          for (int wC = 0; wC < ").concat(s,"; wC++) {\n            float dyC = float(dyCCorner + wC) / ").concat(n,".0;\n\n            if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                fract(dyC) > 0.0) {\n              continue;\n            }\n            int idyC = int(dyC);\n\n            float dyValue = getDy(b, idyR, idyC, d);\n            int maxPosValue = ").concat(c," - int(getMaxPos(b, idyR, idyC, d));\n\n            // Get the current value, check it against the value from the\n            // position matrix.\n            int curPosValue = wR * ").concat(s," + wC;\n            float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n            dotProd += dyValue * mask;\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}class GO{constructor(e){this.variableNames=["dy","maxPos"],this.outputShape=e.inShape;const t=e.strideDepth,n=e.strideHeight,a=e.strideWidth,r=e.dilationDepth,s=e.dilationHeight,o=e.dilationWidth,i=e.effectiveFilterDepth,c=e.effectiveFilterHeight,l=e.effectiveFilterWidth,u=i-1-e.padInfo.front,h=c-1-e.padInfo.top,d=l-1-e.padInfo.left,p=i*c*l-1;this.userCode="\n      const ivec3 pads = ivec3(".concat(u,", ").concat(h,", ").concat(d,");\n\n      void main() {\n        ivec5 coords = getOutputCoords();\n        int batch = coords.x;\n        int ch = coords.u;\n\n        ivec3 dyCorner = ivec3(coords.y, coords.z, coords.w) - pads;\n        int dyDCorner = dyCorner.x;\n        int dyRCorner = dyCorner.y;\n        int dyCCorner = dyCorner.z;\n\n        // Convolve dy(?, ?, ?, ch) with pos mask(:, :, :, d) to get\n        // dx(xD, xR, xC, ch).\n        // ? = to be determined. : = across all values in that axis.\n        float dotProd = 0.0;\n\n        for (int wD = 0; wD < ").concat(i,";\n           wD += ").concat(r,") {\n          float dyD = float(dyDCorner + wD) / ").concat(t,".0;\n\n          if (dyD < 0.0 || dyD >= ").concat(e.outDepth,".0 || fract(dyD) > 0.0) {\n            continue;\n          }\n          int idyD = int(dyD);\n\n          for (int wR = 0; wR < ").concat(c,";\n              wR += ").concat(s,") {\n            float dyR = float(dyRCorner + wR) / ").concat(n,".0;\n\n            if (dyR < 0.0 || dyR >= ").concat(e.outHeight,".0 ||\n                fract(dyR) > 0.0) {\n              continue;\n            }\n            int idyR = int(dyR);\n\n            for (int wC = 0; wC < ").concat(l,";\n                wC += ").concat(o,") {\n              float dyC = float(dyCCorner + wC) / ").concat(a,".0;\n\n              if (dyC < 0.0 || dyC >= ").concat(e.outWidth,".0 ||\n                  fract(dyC) > 0.0) {\n                continue;\n              }\n              int idyC = int(dyC);\n\n              float dyValue = getDy(batch, idyD, idyR, idyC, ch);\n              int maxPosValue = ").concat(p," -\n                  int(getMaxPos(batch, idyD, idyR, idyC, ch));\n\n              // Get the current value, check it against the value from the\n              // position matrix.\n              int curPosValue =\n                  wD * ").concat(c," * ").concat(l," +\n                  wR * ").concat(l," + wC;\n              float mask = float(maxPosValue == curPosValue ? 1.0 : 0.0);\n\n              dotProd += dyValue * mask;\n            }\n          }\n        }\n        setOutput(dotProd);\n      }\n    ")}}const HO={kernelName:xn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s}=t,o=s,{filterSize:i,strides:c,pad:l,dimRoundingMode:u}=a,h=Ci(o.shape,i,c,[1,1,1],l,u),d=new B_(h,"max",!0),p=n.runWebGLProgram(d,[o],o.dtype),f=new GO(h),m=n.runWebGLProgram(f,[r,p],o.dtype);return n.disposeIntermediateTensorInfo(p),m}};const jO={kernelName:bn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{dy:r,input:s,output:o}=t,i=s;lC([s,o],"maxPoolGrad");const{filterSize:c,strides:l,pad:u,dimRoundingMode:h}=a,d=Ei(i.shape,c,l,1,u,h),p=new P_(d,"max",!0),f=n.runWebGLProgram(p,[i],i.dtype),m=new UO(d),g=n.runWebGLProgram(m,[r,f],i.dtype);return n.disposeIntermediateTensorInfo(f),g}};const KO={kernelName:wn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{filterSize:s,strides:o,pad:i,includeBatchInIndex:c}=n,l=a;J(4===r.shape.length,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(r.shape.length,".")));const u=[1,1];J(zi(o,u),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(o," and dilations '").concat(u,"'")));const h=Ei(r.shape,s,o,u,i),[d,p]=function(e,t,n,a){let r=new P_(n,"max",!1);const s=a.runWebGLProgram(r,[e],"float32");return r=new P_(n,"max",!0,!0,t),[s,a.runWebGLProgram(r,[e],"float32")]}(r,c,h,l);return[d,p]}};const qO={kernelName:kn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,{keepDims:s,axis:o}=n,i=a,c=r.shape.length,l=ie(o,r.shape);let u=l;const h=Dc(u,c),d=null!=h,p=i.shouldExecuteOnCPU([r]),f=[];let m=r;if(d){if(p){const e=i.texData.get(m.dataId).values,t=new Array(c);for(let a=0;a<t.length;a++)t[a]=r.shape[h[a]];const n=KR(e,r.shape,r.dtype,h,t);m=i.makeTensorInfo(t,r.dtype);i.texData.get(m.dataId).values=n}else m=$A(r,h,i);f.push(m),u=Oc(u.length,c)}_c("sum",u,c);const[g,y]=Rc(m.shape,u);let b=g;s&&(b=Ac(g,l));const v=function(e,t,n,a){const r=ee(t),s=KA({inputs:{x:e},attrs:{shape:[ee(e.shape)/r,r]},backend:a}),o=QA(s,"float32","mean",a),i=KA({inputs:{x:o},attrs:{shape:n},backend:a});return a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}(m,y,b,i);for(const x of f)i.disposeIntermediateTensorInfo(x);return v}};const XO={kernelName:Sn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,c=ie(s,r.shape);let l=c;const u=Dc(l,i);let h=r;null!=u&&(h=n_({inputs:{x:r},backend:n,attrs:{perm:u}}),l=Oc(l.length,r.shape.length)),_c("min",l,i);const[d,p]=Rc(h.shape,l),f=KA({inputs:{x:h},backend:n,attrs:{shape:[-1,ee(p)]}}),m=QA(f,f.dtype,"min",n);let g;if(o){g=KA({inputs:{x:m},backend:n,attrs:{shape:Ac(d,c)}})}else g=KA({inputs:{x:m},backend:n,attrs:{shape:d}});return n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),null!=u&&n.disposeIntermediateTensorInfo(h),g}},YO=PA({opSnippet:kA+"\n  return min(a, b);\n",packedOpSnippet:"\n  vec4 result = vec4(min(a, b));\n  bvec4 isNaNA = isnan(a);\n  bvec4 isNaNB = isnan(b);\n  bvec4 isNaN = bvec4(isNaNA.x || isNaNB.x, isNaNA.y || isNaNB.y, isNaNA.z || isNaNB.z, isNaNA.w || isNaNB.w);\n  "+IA+"\n  return result;\n",cpuKernelImpl:xR}),QO={kernelName:In,backendName:"webgl",kernelFunc:YO};class JO{constructor(e,t,n){this.variableNames=["x"],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=EC(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a),c="reflect"===n?0:1;this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(s,");\n      ").concat(r," end = ").concat(r,"(").concat(o,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        for (int i = 0; i < ").concat(a,"; i++) {\n          if (outC[i] < start[i]) {\n            outC[i] = start[i] * 2 - outC[i] - ").concat(c,";\n          } else if(outC[i] >= end[i]) {\n            outC[i] = (end[i] - 1) * 2 - outC[i] + ").concat(c,";\n          }\n        }\n        ").concat(r," coords = outC - start;\n        setOutput(getX(").concat(i,"));\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(o,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start) {\n            outC = start * 2 - outC - ").concat(c,";\n          } else if(outC >= end) {\n            outC = (end - 1) * 2 - outC + ").concat(c,";\n          }\n          setOutput(getX(outC - start));\n        }\n      ")}}class ZO{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=EC(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=YR("rc",a),c=YR("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),h="reflect"===n?0:1;let d="";if(1===a){const e="\n        ".concat(r," source = rc;\n        if (source < start) {\n          source = start * 2 - source - ").concat(h,";\n        } else if (source >= end) {\n          source = (end - 1) * 2 - source + ").concat(h,";\n        }\n        source -= start;\n      ");d="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ")}else{const e="\n        ".concat(r," source = rc;\n        ").concat(r," lt = ").concat(r,"(lessThan(source, start));\n        ").concat(r," gte = ").concat(r,"(greaterThanEqual(source, end));\n        ").concat(r," orig = 1 - (lt + gte);\n        source = orig * source +\n                lt * (start * 2 - source - ").concat(h,") +\n                gte * ((end - 1) * 2 - source + ").concat(h,");\n        source -= start;\n      ");d="\n        ".concat(r," rc = outputLoc;\n        ").concat(e,"\n        result[0] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        ").concat(i[a-1]," += 1;\n        if(").concat(l,") {\n          ").concat(e,"\n          result[1] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n        rc = outputLoc;\n        ").concat(i[a-2]," += 1;\n        if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {\n          ").concat(e,"\n          result[2] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          ").concat(i[a-1]," += 1;\n          if(").concat(l,") {\n            ").concat(e,"\n            result[3] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n          }\n        }\n      ")}this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(s,");\n      const ").concat(r," end = ").concat(r,"(").concat(o,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(d,"\n        setOutput(result);\n      }\n    ")}}const $O={kernelName:Nn,backendName:"webgl",kernelFunc:e=>{let{inputs:t,backend:n,attrs:a}=e;const{x:r}=t,{paddings:s,mode:o}=a,i=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new ZO(r.shape,s,o):new JO(r.shape,s,o);return n.runWebGLProgram(i,[r],r.dtype)}},eM=PA({opSnippet:"if (b == 0.0) return NAN;\n  return mod(a, b);",packedOpSnippet:"\n  vec4 result = mod(a, b);\n  bvec4 isNaN = equal(b, vec4(0.0));\n  "+IA+"\n  return result;\n"}),tM={kernelName:Tn,backendName:"webgl",kernelFunc:eM};class nM{constructor(e,t,n){this.variableNames=["probs"],this.customUniforms=[{name:"seed",type:"float"}],this.outputShape=[e,n],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n\n        float r = random(seed);\n        float cdf = 0.0;\n\n        for (int i = 0; i < ".concat(t-1,"; i++) {\n          cdf += getProbs(batch, i);\n\n          if (r < cdf) {\n            setOutput(float(i));\n            return;\n          }\n        }\n\n        // If no other event happened, last event happened.\n        setOutput(float(").concat(t-1,"));\n      }\n    ")}}const aM=PA({opSnippet:"\nif (a == b) {\n  return 1.0;\n};\nreturn a / b;",packedOpSnippet:"\n  // vec4 one = vec4(equal(a, b));\n  // return one + (vec4(1.0) - one) * a / b;\n  vec4 result = a / b;\n  if(a.x == b.x) {\n    result.x = 1.;\n  }\n  if(a.y == b.y) {\n    result.y = 1.;\n  }\n  if(a.z == b.z) {\n    result.z = 1.;\n  }\n  if(a.w == b.w) {\n    result.w = 1.;\n  }\n\n  return result;\n",checkOutOfBounds:!0}),rM={kernelName:Dt,backendName:"webgl",kernelFunc:aM},sM="return a - b;",oM=PA({opSnippet:sM,packedOpSnippet:sM,supportsComplex:!0,cpuKernelImpl:GR}),iM={kernelName:_a,backendName:"webgl",kernelFunc:oM};function cM(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{dim:s}=a,o=ie([s],r.shape),i=LO({inputs:{x:r},backend:n,attrs:{reductionIndices:o,keepDims:!1}}),c=Ac(i.shape,o),l=KA({inputs:{x:i},backend:n,attrs:{shape:c}}),u=oM({inputs:{a:r,b:l},backend:n}),h=EF({inputs:{x:u},backend:n}),d=e_({inputs:{x:h},backend:n,attrs:{axis:o,keepDims:!1}}),p=KA({inputs:{x:d},backend:n,attrs:{shape:c}}),f=aM({inputs:{a:h,b:p},backend:n});return n.disposeIntermediateTensorInfo(i),n.disposeIntermediateTensorInfo(l),n.disposeIntermediateTensorInfo(u),n.disposeIntermediateTensorInfo(h),n.disposeIntermediateTensorInfo(d),n.disposeIntermediateTensorInfo(p),f}const lM={kernelName:ba,backendName:"webgl",kernelFunc:cM};const uM={kernelName:En,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{logits:r}=t,{numSamples:s,seed:o,normalized:i}=a,c=i?r:cM({inputs:{logits:r},backend:n,attrs:{dim:r.shape.length-1}}),l=c.shape[0],u=c.shape[1],h=new nM(l,u,s),d=[[o]],p=n.runWebGLProgram(h,[c],"int32",d);return i||n.disposeIntermediateTensorInfo(c),p}},hM=aA+"\n  return -x;\n";const dM={kernelName:Rn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{x:a}=t;if(n.shouldExecuteOnCPU([a])){const e=n.texData.get(a.dataId),[t,r]=kR(e.values,a.shape,a.dtype);return n.makeTensorInfo(r,a.dtype,t)}let r;return r=_e().getBool("WEBGL_PACK_UNARY_OPERATIONS")?new gA(a.shape,"\n  vec4 result = -x;\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"):new nA(a.shape,hM),n.runWebGLProgram(r,[a],a.dtype)}},pM=eu;const fM={kernelName:_n,backendName:"webgl",kernelFunc:function(e){Xa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=a,l=n.readSync(r.dataId),u=n.readSync(s.dataId),{selectedIndices:h}=pM(l,u,o,i,c);return n.makeTensorInfo([h.length],"int32",new Int32Array(h))}},mM=tu;const gM={kernelName:Dn,backendName:"webgl",kernelFunc:function(e){Xa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,padToMaxOutputSize:l}=a,u=n.readSync(r.dataId),h=n.readSync(s.dataId),{selectedIndices:d,validOutputs:p}=mM(u,h,o,i,c,l);return[n.makeTensorInfo([d.length],"int32",new Int32Array(d)),n.makeTensorInfo([],"int32",new Int32Array([p]))]}},yM=nu;const bM={kernelName:Fn,backendName:"webgl",kernelFunc:function(e){Xa("tf.nonMaxSuppression() in webgl locks the UI thread. Call tf.nonMaxSuppressionAsync() instead");const{inputs:t,backend:n,attrs:a}=e,{boxes:r,scores:s}=t,{maxOutputSize:o,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=a,u=n.readSync(r.dataId),h=n.readSync(s.dataId),d=o,p=i,f=c,m=l,{selectedIndices:g,selectedScores:y}=yM(u,h,d,p,f,m);return[n.makeTensorInfo([g.length],"int32",new Int32Array(g)),n.makeTensorInfo([y.length],"float32",new Float32Array(y))]}};class vM{constructor(e,t,n,a){this.variableNames=["indices"],this.outputShape=[e,t],this.userCode="\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int index = round(getIndices(coords.x));\n        setOutput(mix(float(".concat(a,"), float(").concat(n,"),\n                      float(index == coords.y)));\n      }\n    ")}}const xM={kernelName:Mn,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{indices:r}=t,{dtype:s,depth:o,onValue:i,offValue:c}=a,l=ee(r.shape),u=new vM(l,o,i,c),h=KA({inputs:{x:r},backend:n,attrs:{shape:[l]}}),d=n.runWebGLProgram(u,[h],s);n.disposeIntermediateTensorInfo(h);const p=KA({inputs:{x:d},backend:n,attrs:{shape:[...r.shape,o]}});return n.disposeIntermediateTensorInfo(d),p}};function wM(e){const{inputs:t,backend:n}=e,{x:a}=t;if("complex64"===a.dtype){const e=iD({inputs:{input:a},backend:n}),t=wM({inputs:{x:e},backend:n}),r=SD({inputs:{input:a},backend:n}),s=wM({inputs:{x:r},backend:n}),o=CA({inputs:{real:t,imag:s},backend:n});return n.disposeIntermediateTensorInfo(e),n.disposeIntermediateTensorInfo(t),n.disposeIntermediateTensorInfo(r),n.disposeIntermediateTensorInfo(s),o}return PF({attrs:{shape:a.shape,dtype:a.dtype,value:"string"===a.dtype?"":0},backend:n})}const kM={kernelName:Va,backendName:"webgl",kernelFunc:wM};const SM={kernelName:On,backendName:"webgl",kernelFunc:function e(t){const{inputs:n,backend:a}=t,{x:r}=n;if("string"===r.dtype)throw new Error("onesLike is not supported under string dtype");if("complex64"===r.dtype){const t=iD({inputs:{input:r},backend:a}),n=e({inputs:{x:t},backend:a}),s=SD({inputs:{input:r},backend:a}),o=wM({inputs:{x:s},backend:a}),i=CA({inputs:{real:n,imag:o},backend:a});return a.disposeIntermediateTensorInfo(t),a.disposeIntermediateTensorInfo(n),a.disposeIntermediateTensorInfo(s),a.disposeIntermediateTensorInfo(o),i}return PF({attrs:{shape:r.shape,dtype:r.dtype,value:1},backend:a})}};const IM={kernelName:Ln,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{axis:r}=a;if(1===t.length)return RF({inputs:{input:t[0]},backend:n,attrs:{dim:r}});const s=t[0].shape,o=t[0].dtype;t.forEach((e=>{Z(s,e.shape,"All tensors passed to stack must have matching shapes"),J(o===e.dtype,(()=>"All tensors passed to stack must have matching dtypes"))}));const i=[],c=TD({inputs:t.map((e=>{const t=RF({inputs:{input:e},backend:n,attrs:{dim:r}});return i.push(t),t})),backend:n,attrs:{axis:r}});return i.forEach((e=>n.disposeIntermediateTensorInfo(e))),c}};class NM{constructor(e,t,n){this.variableNames=["x"],this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=EC(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=["coords[0]","coords[1]","coords[2]","coords[3]"].slice(0,a);this.userCode=1!==a?"\n      ".concat(r," start = ").concat(r,"(").concat(s,");\n      ").concat(r," end = ").concat(r,"(").concat(o,");\n\n      void main() {\n        ").concat(r," outC = getOutputCoords();\n        if (any(lessThan(outC, start)) || any(greaterThanEqual(outC, end))) {\n          setOutput(value);\n        } else {\n          ").concat(r," coords = outC - start;\n          setOutput(getX(").concat(i,"));\n        }\n      }\n    "):"\n        int start = ".concat(s,";\n        int end = ").concat(o,";\n\n        void main() {\n          int outC = getOutputCoords();\n          if (outC < start || outC >= end) {\n            setOutput(value);\n          } else {\n            setOutput(getX(outC - start));\n          }\n        }\n      ")}}class TM{constructor(e,t,n){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0,this.customUniforms=[{name:"value",type:"float"}],this.outputShape=t.map(((t,n)=>t[0]+e[n]+t[1]));const a=e.length,r=EC(a),s=t.map((e=>e[0])).join(","),o=t.map(((t,n)=>t[0]+e[n])).join(","),i=YR("rc",a),c=YR("source",a),l="".concat(i[a-1]," < ").concat(this.outputShape[a-1]),u=1===a?"source":"vec2(".concat(c.slice(-2).join(),")"),h=["".concat(r," rc = outputLoc;"),"".concat(i[a-1]," += 1;\n       if(").concat(l,") {\n      "),1===a?"":"}\n       rc = outputLoc;\n       ".concat(i[a-2]," += 1;\n       if(").concat(i[a-2]," < ").concat(this.outputShape[a-2],") {"),1===a?"":"  ".concat(i[a-1]," += 1;\n         if(").concat(l,") {")],d=1===a?"rc < start || rc >= end":"any(lessThan(rc, start)) || any(greaterThanEqual(rc, end))";let p="";for(let f=0,m=1===a?2:4;f<m;f++)p+="\n        ".concat(h[f],"\n        if (").concat(d,") {\n          result[").concat(f,"] = float(value);\n        } else {\n          ").concat(r," source = rc - start;\n          result[").concat(f,"] = getChannel(getX(").concat(c.join(),"), ").concat(u,");\n        }\n      ");p+=1===a?"} ":"}}",this.userCode="\n      const ".concat(r," start = ").concat(r,"(").concat(s,");\n      const ").concat(r," end = ").concat(r,"(").concat(o,");\n\n      void main() {\n        ").concat(r," outputLoc = getOutputCoords();\n        vec4 result = vec4(0.);\n        ").concat(p,"\n        setOutput(result);\n      }\n    ")}}const EM=e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{paddings:s,constantValue:o}=a;if(0===ee(r.shape)){const e=s.map(((e,t)=>e[0]+r.shape[t]+e[1]));return PF({backend:n,attrs:{shape:e,value:o,dtype:r.dtype}})}const i=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new TM(r.shape,s,o):new NM(r.shape,s,o),c=[[o]];return n.runWebGLProgram(i,[r],r.dtype,c)},CM={kernelName:zn,backendName:"webgl",kernelFunc:EM},RM=PA({opSnippet:"\n  if(a < 0.0 && floor(b) < b){\n    return NAN;\n  }\n  if (b == 0.0) {\n    return 1.0;\n  }\n  return (round(mod(b, 2.0)) != 1) ?\n      pow(abs(a), b) : sign(a) * pow(abs(a), b);\n",packedOpSnippet:"\n  // isModRound1 has 1 for components with round(mod(b, 2.0)) == 1, 0 otherwise.\n  vec4 isModRound1 = vec4(equal(round(mod(b, 2.0)), ivec4(1)));\n  vec4 multiplier = sign(a) * isModRound1 + (vec4(1.0) - isModRound1);\n  vec4 result = multiplier * pow(abs(a), b);\n\n  // Ensure that a^0 = 1, including 0^0 = 1 as this correspond to TF and JS\n  bvec4 isExpZero = equal(b, vec4(0.0));\n  result.r = isExpZero.r ? 1.0 : result.r;\n  result.g = isExpZero.g ? 1.0 : result.g;\n  result.b = isExpZero.b ? 1.0 : result.b;\n  result.a = isExpZero.a ? 1.0 : result.a;\n\n  bvec4 isNaN1 = lessThan(a, vec4(0.0));\n  bvec4 isNaN2 = lessThan(floor(b), b);\n  bvec4 isNaN = bvec4(isNaN1.x && isNaN2.x, isNaN1.y && isNaN2.y, isNaN1.z && isNaN2.z, isNaN1.w && isNaN2.w);\n  "+IA+"\n  return result;\n"}),AM={kernelName:Pn,backendName:"webgl",kernelFunc:RM};const _M={kernelName:Wn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{axis:s,keepDims:o}=a,i=r.shape.length,c=[],l=ie(s,r.shape);let u=l;const h=Dc(u,i);let d,p=r;if(null!=h&&(p=n_({inputs:{x:r},backend:n,attrs:{perm:h}}),u=Oc(u.length,i),c.push(p)),_c("prod",u,i),n.shouldExecuteOnCPU([p])){const e=n.texData.get(p.dataId).values,{outVals:t,outShape:a,outDtype:r}=IR(p.shape,p.dtype,e,u);d=n.makeTensorInfo(a,r,t)}else{const[e,t]=Rc(p.shape,u),a=ee(t),s=KA({inputs:{x:p},backend:n,attrs:{shape:[-1,a]}}),o=QA(s,Zr(r.dtype),"prod",n);d=KA({inputs:{x:o},backend:n,attrs:{shape:e}}),c.push(s),c.push(o)}if(o){c.push(d);const e=Ac(d.shape,l);d=KA({inputs:{x:d},backend:n,attrs:{shape:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),d}};const DM={kernelName:Vn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{paramsNestedSplits:r,paramsDenseValues:s,indices:o}=t,{outputRaggedRank:i}=a,c=r.map((e=>n.readSync(e.dataId))),l=r.map((e=>e.shape)),u=n.readSync(s.dataId),h=n.readSync(o.dataId),[d,p,f]=NR(c,l,u,s.shape,s.dtype,h,o.shape,i),m=d.map((e=>n.makeTensorInfo([e.length],"int32",e))),g=n.makeTensorInfo(f,s.dtype,p);return m.concat([g])}};const FM={kernelName:Un,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{starts:a,limits:r,deltas:s}=t,o=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(s.dataId),[l,u]=TR(o,a.shape,a.dtype,i,r.shape,c,s.shape);return[n.makeTensorInfo([l.length],"int32",l),n.makeTensorInfo([u.length],a.dtype,u)]}};const OM={kernelName:Gn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{shape:r,values:s,defaultValue:o,rowPartitionTensors:i}=t,{rowPartitionTypes:c}=a,l=n.readSync(r.dataId),u=n.readSync(s.dataId),h=n.readSync(o.dataId),d=i.map((e=>n.readSync(e.dataId))),p=i.map((e=>e.shape)),[f,m]=ER(l,r.shape,u,s.shape,s.dtype,h,o.shape,d,p,c);return n.makeTensorInfo(f,s.dtype,m)}},MM=e=>{const{backend:t,attrs:n}=e,{start:a,stop:r,step:s,dtype:o}=n,i=CR(a,r,s,o);return t.makeTensorInfo([i.length],o,i)},LM={kernelName:Hn,backendName:"webgl",kernelFunc:MM},zM=zA({opSnippet:"return 1.0 / x;"}),PM={kernelName:Kn,backendName:"webgl",kernelFunc:zM},BM=zA({opSnippet:aA+"\n  return (x < 0.0) ? 0.0 : x;\n",packedOpSnippet:"\n  vec4 result = x * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),WM={kernelName:qn,backendName:"webgl",kernelFunc:BM},VM=zA({opSnippet:aA+"\n  return (x < 0.0) ? 0.0 : min(6.0, x);\n",packedOpSnippet:"\n  vec4 result = min(x, vec4(6.)) * vec4(greaterThanEqual(x, vec4(0.0)));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n"}),UM={kernelName:$n,backendName:"webgl",kernelFunc:VM};class GM{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let h;h=r?"(vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC - vec2(0.5)":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(o,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec2 sourceFloorRC = ivec2(max(sourceFracIndexRC, vec2(0.0)));\n        ivec2 sourceCeilRC = ivec2(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        float topLeft = getA(b, sourceFloorRC.x, sourceFloorRC.y, d);\n        float bottomLeft = getA(b, sourceCeilRC.x, sourceFloorRC.y, d);\n        float topRight = getA(b, sourceFloorRC.x, sourceCeilRC.y, d);\n        float bottomRight = getA(b, sourceCeilRC.x, sourceCeilRC.y, d);\n\n        vec2 fracRC = sourceFracIndexRC - vec2(sourceFloorRC);\n\n        float top = topLeft + (topRight - topLeft) * fracRC.y;\n        float bottom = bottomLeft + (bottomRight - bottomLeft) * fracRC.y;\n        float newValue = top + (bottom - top) * fracRC.x;\n\n        setOutput(newValue);\n      }\n    ")}}class HM{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n];let h;h=r?"(vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC - vec3(0.5)":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(o,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(h,";\n\n        // Compute the four integer indices.\n        ivec3 sourceFloorRC = ivec3(max(sourceFracIndexRC, vec3(0.0)));\n        ivec3 sourceCeilRC = ivec3(\n          min(inputShapeRC - 1.0, ceil(sourceFracIndexRC)));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        // In parallel, construct four corners for all four components in\n        // packed 2x2 cell.\n        vec4 topLeft = vec4(\n          getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 bottomLeft = vec4(\n          getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceFloorRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceFloorRC.z, d + 1) : 0.0);\n\n        vec4 topRight = vec4(\n          getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceFloorRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceFloorRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec4 bottomRight = vec4(\n          getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d),\n          hasNextCol ? getAValue(b, sourceCeilRC.x, sourceCeilRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceCeilRC.x, sourceCeilRC.z, d + 1) : 0.0);\n\n        vec3 fracRC = sourceFracIndexRC - vec3(sourceFloorRC);\n\n        vec4 top = mix(topLeft, topRight, fracRC.yyzz);\n        vec4 bottom = mix(bottomLeft, bottomRight, fracRC.yyzz);\n        vec4 newValue = mix(top, bottom, fracRC.x);\n\n        setOutput(newValue);\n      }\n    ")}}const jM={kernelName:Jn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a,[c,l]=i,u=_e().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new HM(r.shape,c,l,s,o):new GM(r.shape,c,l,s,o);return n.runWebGLProgram(u,[r],"float32")}};class KM{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,s,o]=e,i=[n&&s>1?a-1:a,n&&o>1?r-1:r],c=[n&&s>1?s-1:s,n&&o>1?o-1:o],l=i[0]/c[0],u=i[1]/c[1],h=1/l,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(startRLerp - float(winHeight / 2));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(startCLerp - float(winWidth / 2));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(o,") {\n              continue;\n            }\n\n            float dxR = float(dyR) * heightScale;\n            int topDxRIndex = int(floor(dxR));\n            int bottomDxRIndex = int(min(ceil(dxR), ").concat(a-1,".0));\n            float dxRLerp = dxR - float(topDxRIndex);\n            float inverseDxRLerp = 1.0 - dxRLerp;\n\n            float dxC = float(dyC) * widthScale;\n            int leftDxCIndex = int(floor(dxC));\n            int rightDxCIndex = int(min(ceil(dxC), ").concat(r-1,".0));\n            float dxCLerp = dxC - float(leftDxCIndex);\n            float inverseDxCLerp = 1.0 - dxCLerp;\n\n            if (r == topDxRIndex && c == leftDxCIndex) {\n              // topLeft\n              accumulator +=\n                getDy(b, dyR, dyC, d) * inverseDxRLerp * inverseDxCLerp;\n            }\n\n            if (r == topDxRIndex && c == rightDxCIndex) {\n              // topRight\n              accumulator += getDy(b, dyR, dyC, d) * inverseDxRLerp * dxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == leftDxCIndex) {\n              // bottomLeft\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * inverseDxCLerp;\n            }\n\n            if (r == bottomDxRIndex && c == rightDxCIndex) {\n              // bottomRight\n              accumulator += getDy(b, dyR, dyC, d) * dxRLerp * dxCLerp;\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const qM={kernelName:Zn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a,i=new KM(s.shape,r.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class XM{constructor(e,t,n,a,r){this.variableNames=["A"],this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";let d;d=r?"max((vec2(yRC) + vec2(0.5)) * effectiveInputOverOutputRatioRC, vec2(0.0))":"vec2(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec2 effectiveInputOverOutputRatioRC = vec2(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],");\n      const vec2 inputShapeRC = vec2(").concat(o,".0, ").concat(i,".0);\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        ivec2 yRC = coords.yz;\n\n        // Fractional source index.\n        vec2 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec2 sourceNearestRC = ivec2(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n        float newValue = getA(b, sourceNearestRC.x, sourceNearestRC.y, d);\n\n        setOutput(newValue);\n      }\n    ")}}class YM{constructor(e,t,n,a,r){this.variableNames=["A"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=[];const[s,o,i,c]=e;this.outputShape=[s,t,n,c];const l=[a&&t>1?o-1:o,a&&n>1?i-1:i],u=[a&&t>1?t-1:t,a&&n>1?n-1:n],h=a?"0.5":"0.0";let d;d=r?"max((vec3(yRC) + vec3(0.5)) * effectiveInputOverOutputRatioRC, vec3(0.0))":"vec3(yRC) * effectiveInputOverOutputRatioRC",this.userCode="\n      const vec3 effectiveInputOverOutputRatioRC = vec3(\n          ".concat(l[0]/u[0],",\n          ").concat(l[1]/u[1],",\n          ").concat(l[1]/u[1],");\n      const vec3 inputShapeRC = vec3(").concat(o,".0, ").concat(i,".0,\n                                     ").concat(i,".0);\n\n      float getAValue(int b, int r, int c, int d) {\n        return getChannel(getA(b, r, c, d), vec2(c, d));\n      }\n\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        // Calculate values for next column in yRC.z.\n        ivec3 yRC = coords.yzz + ivec3(0, 0, 1);\n\n        // Fractional source index.\n        vec3 sourceFracIndexRC = ").concat(d,";\n\n        // Compute the coordinators of nearest neighbor point.\n        ivec3 sourceNearestRC = ivec3(\n          min(inputShapeRC - 1.0, floor(sourceFracIndexRC + ").concat(h,")));\n\n        // Should we calculate next column and row elements in 2x2 packed cell.\n        bool hasNextCol = d < ").concat(c-1,";\n        bool hasNextRow = coords.z < ").concat(n-1,";\n\n        vec4 newValue = vec4(\n          getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d),\n          hasNextCol ? getAValue(b, sourceNearestRC.x, sourceNearestRC.y, d + 1)\n                     : 0.0,\n          hasNextRow ? getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d)\n                     : 0.0,\n          (hasNextRow && hasNextCol) ?\n            getAValue(b, sourceNearestRC.x, sourceNearestRC.z, d + 1) : 0.0);\n\n        setOutput(newValue);\n      }\n    ")}}const QM={kernelName:Yn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r}=t,{alignCorners:s,halfPixelCenters:o,size:i}=a,[c,l]=i,u=_e().getBool("WEBGL_PACK_IMAGE_OPERATIONS")?new YM(r.shape,c,l,s,o):new XM(r.shape,c,l,s,o);return n.runWebGLProgram(u,[r],r.dtype)}};class JM{constructor(e,t,n){this.variableNames=["dy"],this.outputShape=[],this.outputShape=t;const[,a,r]=t,[,s,o]=e,i=[n&&s>1?a-1:a,n&&o>1?r-1:r],c=[n&&s>1?s-1:s,n&&o>1?o-1:o],l=i[0]/c[0],u=i[1]/c[1],h=1/l,d=1/u,p=2*Math.ceil(h)+2,f=2*Math.ceil(d)+2;this.userCode="\n      void main() {\n        ivec4 coords = getOutputCoords();\n        int b = coords[0];\n        int d = coords[3];\n        int r = coords[1];\n        int c = coords[2];\n\n        float accumulator = 0.0;\n\n        const float heightScale = float(".concat(l,");\n        const float widthScale = float(").concat(u,");\n\n        const float invHeightScale = float(").concat(h,");\n        const float invWidthScale = float(").concat(d,");\n\n        const int winHeight = int(").concat(p,");\n        const int winWidth = int(").concat(f,");\n\n        // Compute bounds for where in dy we will look\n        float startRLerp = floor(float(r) * invHeightScale);\n        int startDyR = int(floor(startRLerp - float(winHeight / 2)));\n\n        float startCLerp = floor(float(c) * invWidthScale);\n        int startDyC = int(floor(startCLerp - float(winWidth / 2)));\n\n        // Loop over dy\n        for (int dyROffset = 0; dyROffset < winHeight; dyROffset++) {\n          int dyR = dyROffset + startDyR;\n\n          // Guard against the window exceeding the bounds of dy\n          if (dyR < 0 || dyR >= ").concat(s,") {\n            continue;\n          }\n\n          for (int dyCOffset = 0; dyCOffset < winWidth; dyCOffset++) {\n            int dyC = dyCOffset + startDyC;\n\n            // Guard against the window exceeding the bounds of dy\n            if (dyC < 0 || dyC >= ").concat(o,") {\n              continue;\n            }\n\n            float sourceFracRow =\n              float(").concat(i[0],") *\n                (float(dyR) / float(").concat(c[0],"));\n\n            float sourceFracCol =\n                float(").concat(i[1],") *\n                  (float(dyC) / float(").concat(c[1],"));\n\n            int sourceNearestRow = int(min(\n                float(int(").concat(a,") - 1),\n                ").concat(n," ? float(round(sourceFracRow)) :\n                                  float(floor(sourceFracRow))));\n\n            int sourceNearestCol = int(min(\n                float(int(").concat(r,") - 1),\n                ").concat(n," ? float(round(sourceFracCol)) :\n                                  float(floor(sourceFracCol))));\n\n            if (r == sourceNearestRow && c == sourceNearestCol) {\n              accumulator += getDy(b, dyR, dyC, d);\n            }\n          }\n        }\n        // End loop over dy\n\n        setOutput(accumulator);\n      }\n    ")}}const ZM={kernelName:Qn,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{images:r,dy:s}=t,{alignCorners:o}=a,i=new JM(s.shape,r.shape,o);return n.runWebGLProgram(i,[s],s.dtype)}};class $M{constructor(e,t){this.variableNames=["x"];const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));if(this.outputShape=e,1===n)return void(this.userCode="\n        void main() {\n          int coord = getOutputCoords();\n          setOutput(getX(".concat(e[0]," - coord - 1));\n        }\n      "));const a=e.map(((n,a)=>(n=>-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - coords[").concat(n,"] - 1"):"coords[".concat(n,"]"))(a))).join(","),r=EC(n);this.userCode="\n      void main() {\n        ".concat(r," coords = getOutputCoords();\n        setOutput(getX(").concat(a,"));\n      }\n    ")}}class eL{constructor(e,t){this.variableNames=["x"],this.packedInputs=!0,this.packedOutput=!0;const n=e.length;if(n>4)throw new Error("WebGL backend: Reverse of rank-".concat(n," tensor is not yet supported"));this.outputShape=e;const a=YR("rc",n),r="".concat(a[n-1]," + 1 < ").concat(this.outputShape[n-1]),s="".concat(a[n-2]," + 1 < ").concat(this.outputShape[n-2]),o=EC(n);function i(n){const a=e.map(((a,r)=>function(n,a){return-1!==t.indexOf(n)&&1!==e[n]?"".concat(e[n]," - ").concat(a[n]," - 1"):"".concat(a[n])}(r,n))),r=a.join(","),s=a.slice(-2).join(",");return"getChannel(getX(".concat(r,"), vec2(").concat(s,"))")}this.userCode=1===n?"\n        void main(){\n          int rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = getChannel(getX(".concat(e[0]," - rc - 1),\n            ").concat(e[0]," - rc - 1);\n          if(").concat(r,"){\n              result.g = getChannel(getX(").concat(e[0]," - (rc  + 1) - 1),\n                ").concat(e[0]," - (rc  + 1) - 1);\n          }\n          setOutput(result);\n        }\n      "):"\n        void main() {\n          ".concat(o," rc = getOutputCoords();\n          vec4 result = vec4(0.);\n          result.r = ").concat(function(e){return i(e)}(a.slice()),";\n          if(").concat(r,"){\n            result.g = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",i(e)}(a.slice()),";\n          }\n          if(").concat(s,") {\n            result.b = ").concat(function(e){return e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            if(").concat(r,") {\n              result.a = ").concat(function(e){return e[n-1]="("+e[n-1]+" + 1)",e[n-2]="("+e[n-2]+" + 1)",i(e)}(a.slice()),";\n            }\n          }\n          setOutput(result);\n        }\n    ")}}const tL={kernelName:ea,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{dims:s}=a,o=r.shape.length,i=ie(s,r.shape);if(0===o)return TA({inputs:{x:r},backend:n});const c=_e().getBool("WEBGL_PACK_ARRAY_OPERATIONS")?new eL(r.shape,i):new $M(r.shape,i);return n.runWebGLProgram(c,[r],r.dtype)}};class nL{constructor(e,t){this.variableNames=["Image"],this.outputShape=[],this.customUniforms=[{name:"params",type:"vec4"}];const n=e[1],a=e[2];this.outputShape=e;let r="";r="number"===typeof t?"float outputValue = ".concat(t.toFixed(2),";"):"\n        vec3 fill = vec3(".concat(t.join(","),");\n        float outputValue = fill[coords[3]];"),this.userCode="\n        void main() {\n          ivec4 coords = getOutputCoords();\n          int x = coords[2];\n          int y = coords[1];\n          float coordXFloat = (float(x) - params[0]) * params[3] -\n            (float(y) - params[1]) * params[2];\n          float coordYFloat = (float(x) - params[0]) * params[2] +\n            (float(y) - params[1]) * params[3];\n          int coordX = int(round(coordXFloat + params[0]));\n          int coordY = int(round(coordYFloat + params[1]));\n          ".concat(r,"\n          if(coordX >= 0 && coordX < ").concat(a," && coordY >= 0 && coordY < ").concat(n,") {\n            outputValue = getImage(coords[0], coordY, coordX, coords[3]);\n          }\n          setOutput(outputValue);\n        }\n    ")}}const aL={kernelName:Ha,backendName:"webgl",kernelFunc:e=>{let{inputs:t,attrs:n,backend:a}=e;const{image:r}=t,{radians:s,fillValue:o,center:i}=n,c=a,l=new nL(r.shape,o),[u,h]=Uu(i,r.shape[1],r.shape[2]),d=[[u,h,Math.sin(s),Math.cos(s)]];return c.runWebGLProgram(l,[r],r.dtype,d)}},rL=zA({opSnippet:"\n  // OpenGL ES does not support round function.\n  // The algorithm is based on banker's rounding.\n  float base = floor(x);\n  if ((x - base) < 0.5) {\n    return floor(x);\n  } else if ((x - base) > 0.5) {\n    return ceil(x);\n  } else {\n    if (mod(base, 2.0) == 0.0) {\n      return base;\n    } else {\n      return base + 1.0;\n    }\n  }\n"}),sL={kernelName:ta,backendName:"webgl",kernelFunc:rL},oL=zA({opSnippet:"return inversesqrt(x);",cpuKernelImpl:RR}),iL={kernelName:na,backendName:"webgl",kernelFunc:oL};class cL{constructor(e,t,n,a,r,s){let o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.outputShape=s;const i=EC(r.length),c=EC(s.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let h="";1===a?h="i":2===a&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";o&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          float sum = 0.0;\n          bool found = false;\n          for (int i = 0; i < ").concat(e,"; i++) {\n            int flattenedIndex = 0;\n            for (int j = 0; j < ").concat(t,"; j++) {\n              int index = round(").concat(u,");\n              flattenedIndex += index * ").concat(m,";\n            }\n            if (flattenedIndex == coords[0]) {\n              sum += ").concat(d,";\n              found = true;\n            }\n          }\n          setOutput(mix(").concat(f,", sum, float(found)));\n        }\n      ")}}class lL{constructor(e,t,n,a,r,s){let o=arguments.length>7&&void 0!==arguments[7]&&arguments[7];this.variableNames=["updates","indices","defaultValue"],this.packedInputs=!0,this.packedOutput=!0,this.outputShape=s;const i=EC(r.length),c=EC(s.length);let l="";1===n?l="i":2===n&&(l="i, j");const u="getIndices(".concat(l,")");let h="";1===a?h="i":2===a&&(h="i, coords[1]");const d="getUpdates(".concat(h,")");let p="";o&&(p="coords[0], coords[1]");const f="getDefaultValue(".concat(p,")"),m=t>1?"strides[j]":"strides",g=t>1?"strides[j + 1]":"strides";this.userCode="\n        ".concat(i," strides = ").concat(i,"(").concat(r,");\n\n        void main() {\n          ").concat(c," coords = getOutputCoords();\n          vec4 sum = vec4(0.);\n          vec4 found = vec4(0.);\n          for (int i = 0; i < ").concat(e,"; i+=2) {\n            ivec2 flattenedIndex = ivec2(0);\n            for (int j = 0; j < ").concat(t,"; j+=2) {\n              ivec4 index = round(").concat(u,");\n              flattenedIndex += index.xz * ").concat(m,";\n              if (j + 1 < ").concat(t,") {\n                flattenedIndex += index.yw * ").concat(g,";\n              }\n            }\n            if (flattenedIndex[0] == coords[0] || flattenedIndex[1] == coords[0] ||\n                flattenedIndex[0] == coords[0] + 1 || flattenedIndex[1] == coords[0] + 1) {\n              vec4 updVals = ").concat(d,";\n              if (flattenedIndex[0] == coords[0]) {\n                sum.xy += updVals.xy;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[0] == coords[0] + 1) {\n                sum.zw += updVals.xy;\n                found.zw = vec2(1.);\n              }\n              if (flattenedIndex[1] == coords[0]) {\n                sum.xy += updVals.zw;\n                found.xy = vec2(1.);\n              } else if (flattenedIndex[1] == coords[0] + 1) {\n                sum.zw += updVals.zw;\n                found.zw = vec2(1.);\n              }\n            }\n          }\n          setOutput(mix(").concat(f,", sum, found));\n        }\n      ")}}const uL={kernelName:aa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{indices:r,updates:s}=t,{shape:o}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=Ju(0,r,o),d=[h/l,l];if(0===h)return n.makeTensorInfo(o,r.dtype);const p=KA({inputs:{x:r},backend:n,attrs:{shape:[c,i]}}),f=KA({inputs:{x:s},backend:n,attrs:{shape:[c,l]}}),m=n.makeTensorInfo([],"float32",new Float32Array([0]));let g;g=_e().getBool("WEBGL_PACK")?new lL(c,i,p.shape.length,f.shape.length,u,d):new cL(c,i,p.shape.length,f.shape.length,u,d);const y=n.runWebGLProgram(g,[f,p,m],f.dtype),b=KA({inputs:{x:y},backend:n,attrs:{shape:o}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(y),n.disposeIntermediateTensorInfo(m),b}};class hL{constructor(e,t,n,a){this.variableNames=["sortedSequence","values"],this.customUniforms=[{name:"numInputs",type:"int"}],this.outputShape=[e,n];const r="for (int i = 0; i < ".concat(Math.ceil(Math.log2(t+1)),"; ++i) { if (left >= right) break;"),s=2===_e().getNumber("WEBGL_VERSION")?"while (left < right) {":r,o="left"===a?"<":"<=";this.userCode="\n       int findBound(int batch, float value) {\n         int left = 0;\n         int right = numInputs;\n         int mid;\n         ".concat(s,"\n           mid = (left + right) / 2;\n           if (getSortedSequence(batch, mid) ").concat(o," value) {\n             left = mid + 1;\n           } else {\n             right = mid;\n           }\n         }\n         return right;\n       }\n\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int valueIndex = coords[1];\n\n         float value = getValues(batch, valueIndex);\n\n         setOutput(float(findBound(batch, value)));\n       }\n     ")}}const dL={kernelName:sa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sortedSequence:r,values:s}=t,{side:o}=a,i=new hL(r.shape[0],r.shape[1],s.shape[1],o),c=[[r.shape[1]]];return n.runWebGLProgram(i,[r,s],"int32",c)}};class pL{constructor(e,t,n){let a,r;if(this.variableNames=["c","a","b"],this.outputShape=t,n>4)throw Error("Where for rank ".concat(n," is not yet supported"));if(1===n)r="resRC",a="resRC";else{const n=["resRC.x","resRC.y","resRC.z","resRC.w"],s=[],o=[];for(let a=0;a<t.length;a++)o.push("".concat(n[a])),a<e&&s.push("".concat(n[a]));a=s.join(),r=o.join()}const s=EC(n);this.userCode="\n      void main() {\n        ".concat(s," resRC = getOutputCoords();\n        float cVal = getC(").concat(a,");\n        if (cVal >= 1.0) {\n          setOutput(getA(").concat(r,"));\n        } else {\n          setOutput(getB(").concat(r,"));\n        }\n      }\n    ")}}const fL={kernelName:oa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{condition:a,t:r,e:s}=t,o=new pL(a.shape.length,r.shape,r.shape.length);return n.runWebGLProgram(o,[a,r,s],Jr(r.dtype,s.dtype))}},mL=zA({opSnippet:"\n  // Stable and Attracting Fixed Point (0, 1) for Normalized Weights.\n  // see: https://arxiv.org/abs/1706.02515\n  float scaleAlpha = ".concat(Zu,";\n  float scale = ").concat($u,";\n  return (x >= 0.0) ? scale * x : scaleAlpha * (exp(x) - 1.0);\n")}),gL={kernelName:ia,backendName:"webgl",kernelFunc:mL},yL=zA({opSnippet:LA+"\n  return 1.0 / (1.0 + exp(-1.0 * x));\n",packedOpSnippet:"\n  vec4 result = 1.0 / (1.0 + exp(-1.0 * x));\n  bvec4 isNaN = isnan(x);\n\n  result.r = isNaN.r ? x.r : result.r;\n  result.g = isNaN.g ? x.g : result.g;\n  result.b = isNaN.b ? x.b : result.b;\n  result.a = isNaN.a ? x.a : result.a;\n\n  return result;\n",cpuKernelImpl:_R}),bL={kernelName:da,backendName:"webgl",kernelFunc:yL},vL=zA({opSnippet:"\n  if (isnan(x)) { return 0.0; }\n  return sign(x);\n"}),xL={kernelName:ha,backendName:"webgl",kernelFunc:vL},wL=zA({opSnippet:LA+"\n  return sin(x);\n",packedOpSnippet:"\n  vec4 result = sin(x);\n  bvec4 isNaN = isnan(x);\n  ".concat(IA,"\n  return result;\n")}),kL={kernelName:la,backendName:"webgl",kernelFunc:wL},SL=zA({opSnippet:"\n  float e2x = exp(x);\n  return (e2x - 1.0 / e2x) / 2.0;\n"}),IL={kernelName:ua,backendName:"webgl",kernelFunc:SL},NL=zA({opSnippet:"\n  float epsilon = 1.1920928955078125e-7;\n  float threshold = log(epsilon) + 2.0;\n\n  bool too_large = x > -threshold;\n  bool too_small = x < threshold;\n\n  float result;\n  float exp_x = exp(x);\n\n  if (too_large){\n    result = x;\n  }\n  else if (too_small){\n    result = exp_x;\n  }\n  else{\n    result = log(exp_x + 1.0);\n  }\n  return result;\n"}),TL={kernelName:pa,backendName:"webgl",kernelFunc:NL},EL={kernelName:ga,backendName:"webgl",kernelFunc:e=>{const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{blockShape:s,paddings:o}=a;J(r.shape.length<=4,(()=>"spaceToBatchND for rank > 4 with a WebGL backend not implemented yet"));const i=s.reduce(((e,t)=>e*t)),c=[[0,0]];c.push(...o);for(let y=1+s.length;y<r.shape.length;++y)c.push([0,0]);const l=[],u=EM({inputs:{x:r},backend:n,attrs:{paddings:c,constantValue:0}}),h=Gu(u.shape,s,i,!1),d=Hu(h.length,s.length,!1),p=ju(u.shape,s,i,!1),f=KA({inputs:{x:u},backend:n,attrs:{shape:h}}),m=n_({inputs:{x:f},backend:n,attrs:{perm:d}}),g=KA({inputs:{x:m},backend:n,attrs:{shape:p}});return l.push(u),l.push(f),l.push(m),l.forEach((e=>n.disposeIntermediateTensorInfo(e))),g}};const CL={kernelName:va,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{indices:a,values:r,denseShape:s,defaultValue:o}=t;if(1!==s.shape.length)throw new Error("Dense shape must be a vector, saw:\n         ".concat(s.shape));if(2!==a.shape.length)throw new Error("Indices must be a matrix, saw:\n         ".concat(a.shape));if(1!==r.shape.length)throw new Error("Values must be a vector, saw:\n         ".concat(r.shape));if(0!==o.shape.length)throw new Error("Default value must be a scalar, saw:\n        ".concat(o.shape));const i=n.readSync(a.dataId),c=n.readSync(r.dataId),l=n.readSync(s.dataId),u=n.readSync(o.dataId)[0],[h,d,p,f,m]=OR(i,a.shape,a.dtype,c,r.dtype,l,u);return[n.makeTensorInfo(d,a.dtype,h),n.makeTensorInfo([d[0]],r.dtype,p),n.makeTensorInfo([f.length],"bool",new Uint8Array(f.map((e=>Number(e))))),n.makeTensorInfo([m.length],a.dtype,new Int32Array(m))]}};const RL={kernelName:xa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{inputIndices:a,inputShape:r,newShape:s}=t;if(2!==a.shape.length)throw new Error("Input indices should be a matrix but received shape ".concat(a.shape));if(1!==r.shape.length)throw new Error("Input shape should be a vector but received shape ".concat(r.shape));if(1!==s.shape.length)throw new Error("Target shape should be a vector but received shape ".concat(s.shape));const o=Array.from(n.readSync(r.dataId)),i=n.readSync(a.dataId),c=Array.from(n.readSync(s.dataId)),[l,u,h]=MR(i,a.shape,a.dtype,o,c);return[n.makeTensorInfo(u,a.dtype,l),n.makeTensorInfo([h.length],s.dtype,new Int32Array(h))]}};const AL={kernelName:wa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n              ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n              ".concat(s.shape));const o=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(s.dataId),[l,u]=LR(o,a.shape,a.dtype,i,c,!0);return n.makeTensorInfo(u,a.dtype,l)}};const _L={kernelName:ka,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n}=e,{data:a,indices:r,segmentIds:s}=t;if(a.shape.length<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.shape.length)throw new Error("Indices should be a vector but received shape\n             ".concat(r.shape));if(1!==s.shape.length)throw new Error("Segment ids should be a vector but received shape\n             ".concat(s.shape));const o=n.readSync(a.dataId),i=n.readSync(r.dataId),c=n.readSync(s.dataId),[l,u]=LR(o,a.shape,a.dtype,i,c);return n.makeTensorInfo(u,a.dtype,l)}};const DL={kernelName:Sa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{sparseIndices:r,sparseValues:s,defaultValue:o}=t,{outputShape:i}=a,{sliceRank:c,numUpdates:l,sliceSize:u,strides:h,outputSize:d}=Ju(0,r,i),p=!1;if("string"===s.dtype){const e=n.bufferSync(r),t=n.bufferSync(s),a=Ir(n.readSync(o.dataId)[0]),f=AR(e,t,i,d,u,l,c,h,a,p);return n.makeTensorInfo(i,f.dtype,f.values)}const f=new cL(l,c,r.shape.length,s.shape.length,h,[d,1],p),m=n.runWebGLProgram(f,[s,r,o],s.dtype),g=KA({inputs:{x:m},backend:n,attrs:{shape:i}});return n.disposeIntermediateTensorInfo(m),g}};const FL={kernelName:ya,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{numOrSizeSplits:s,axis:o}=a,i=ie(o,r.shape)[0],c=Ih(r,s,i),l=r.shape.length,u=new Array(l).fill(0),h=r.shape.slice();return c.map((e=>{const t=[...h];t[i]=e;const a=$_({inputs:{x:r},backend:n,attrs:{begin:u,size:t}});return u[i]+=e,a}))}},OL="return sqrt(x);",ML=zA({opSnippet:OL,packedOpSnippet:OL,cpuKernelImpl:zR}),LL={kernelName:fa,backendName:"webgl",kernelFunc:ML},zL={kernelName:Na,backendName:"webgl",kernelFunc:zA({opSnippet:"return x * x;"})},PL="return (a - b) * (a - b);",BL=PA({opSnippet:PL,packedOpSnippet:PL}),WL={kernelName:Ia,backendName:"webgl",kernelFunc:BL};const VL={kernelName:Ta,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t;if("string"!==r.dtype)throw new Error("Input must be of datatype string");const s=Wh(n.readSync(r.dataId)),o=PR(s,"string",a);return n.makeTensorInfo(r.shape,"string",o)}};const UL={kernelName:Ua,backendName:"webgl",kernelFunc:function(e){let{inputs:t,attrs:n,backend:a}=e;const{x:r}=t,s=aA+"\n    return x > 0.0 ? 1.0 : float(".concat(n.alpha,");\n  "),o=new nA(r.shape,s);return a.runWebGLProgram(o,[r],r.dtype)}};class GL{constructor(e,t,n){this.variableNames=["x"],this.outputShape=n;const a=n.length,r=EC(n.length),s=EC(n.length);let o="";if(1===a)o="coords * strides + begin";else{let e=0;o=n.map(((t,a)=>(e++,1===n.length?"coords * strides[".concat(a,"] + begin[").concat(a,"]"):"coords[".concat(e-1,"] * strides[").concat(a,"] + begin[").concat(a,"]")))).join(",")}this.userCode="\n      ".concat(r," begin = ").concat(r,"(").concat(e,");\n      ").concat(r," strides = ").concat(r,"(").concat(t,");\n\n      void main() {\n        ").concat(s," coords = getOutputCoords();\n        setOutput(getX(").concat(o,"));\n      }\n    ")}}const HL={kernelName:Ea,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{begin:s,end:o,strides:i,beginMask:c,endMask:l,ellipsisMask:u,newAxisMask:h,shrinkAxisMask:d}=a,{finalShapeSparse:p,finalShape:f,isIdentity:m,sliceDim0:g,isSimpleSlice:y,begin:b,end:v,strides:x}=wi(r.shape,s,o,i,c,l,u,h,d);let w;if(m)w=KA({inputs:{x:r},backend:n,attrs:{shape:f}});else if(g||y){J(r.shape.length>=1,(()=>"Input must have rank at least 1, got: ".concat(r.shape.length)));const e=ci(b,v,x),t=$_({inputs:{x:r},backend:n,attrs:{begin:b,size:e}});w=KA({inputs:{x:t},backend:n,attrs:{shape:f}}),n.disposeIntermediateTensorInfo(t)}else{if(n.shouldExecuteOnCPU([r])){const e=n.readSync(r.dataId),t=go(r.shape,r.dtype,e),a=BR(p,t,x,b);w=n.makeTensorInfo(f,r.dtype,a.values)}else{const e=new GL(b,x,p);w=n.runWebGLProgram(e,[r],r.dtype)}}const k=KA({inputs:{x:w},backend:n,attrs:{shape:f}});return n.disposeIntermediateTensorInfo(w),k}};const jL={kernelName:Ca,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{separator:r,nGramWidths:s,leftPad:o,rightPad:i,padWidth:c,preserveShortSequences:l}=a,{data:u,dataSplits:h}=t,d=n.readSync(u.dataId),p=n.readSync(h.dataId),[f,m]=WR(d,p,r,s,o,i,c,l);return[n.makeTensorInfo([f.length],"string",f),n.makeTensorInfo(h.shape,"int32",m)]}};const KL={kernelName:Ra,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{skipEmpty:r}=a,{input:s,delimiter:o}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(1!==s.shape.length)throw new Error("Input must be a vector, got shape: ".concat(s.shape));if(0!==o.shape.length)throw new Error("Delimiter must be a scalar, got shape: ".concat(o.shape));const i=n.readSync(s.dataId),c=n.readSync(o.dataId)[0],[l,u,h]=VR(i,c,r),d=u.length;return[n.makeTensorInfo([d,2],"int32",l),n.makeTensorInfo([d],"string",u),n.makeTensorInfo([2],"int32",new Int32Array(h))]}};const qL={kernelName:Aa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{numBuckets:r}=a,{input:s}=t;if("string"!==s.dtype)throw new Error("Input must be of datatype string");if(r<=0)throw new Error("Number of buckets must be at least 1");const o=n.readSync(s.dataId),i=UR(o,r);return n.makeTensorInfo(s.shape,"int32",i)}},XL=zA({opSnippet:"return tan(x);"}),YL={kernelName:Da,backendName:"webgl",kernelFunc:XL},QL=zA({opSnippet:"\n  float e2x = exp(-2.0 * abs(x));\n  return sign(x) * (1.0 - e2x) / (1.0 + e2x);\n"}),JL={kernelName:Fa,backendName:"webgl",kernelFunc:QL};const ZL={kernelName:ra,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{tensor:r,indices:s,updates:o}=t,{}=a,{sliceRank:i,numUpdates:c,sliceSize:l,strides:u,outputSize:h}=Ju(0,s,r.shape),d=[h/l,l];if(0===h)return n.makeTensorInfo(r.shape,s.dtype);const p=KA({inputs:{x:s},backend:n,attrs:{shape:[c,i]}}),f=KA({inputs:{x:o},backend:n,attrs:{shape:[c,l]}}),m=KA({inputs:{x:r},backend:n,attrs:{shape:d}}),g=new cL(c,i,p.shape.length,f.shape.length,u,d,!1,!0),y=n.runWebGLProgram(g,[f,p,m],m.dtype),b=KA({inputs:{x:y},backend:n,attrs:{shape:r.shape}});return n.disposeIntermediateTensorInfo(p),n.disposeIntermediateTensorInfo(f),n.disposeIntermediateTensorInfo(m),n.disposeIntermediateTensorInfo(y),b}};class $L{constructor(e,t){this.variableNames=["A"];const n=new Array(e.length);for(let s=0;s<n.length;s++)n[s]=e[s]*t[s];this.outputShape=n,this.rank=n.length;const a=EC(this.rank),r=function(e){const t=e.length;if(t>5)throw Error("Tile for rank ".concat(t," is not yet supported"));if(1===t)return"imod(resRC, ".concat(e[0],")");const n=["resRC.x","resRC.y","resRC.z","resRC.w","resRC.u"],a=[];for(let r=0;r<e.length;r++)a.push("imod(".concat(n[r],", ").concat(e[r],")"));return a.join()}(e);this.userCode="\n      void main() {\n        ".concat(a," resRC = getOutputCoords();\n        setOutput(getA(").concat(r,"));\n      }\n    ")}}function ez(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{reps:s}=a;if("string"===r.dtype||r.shape.length>5){const e=n.readSync(r.dataId),t="string"===r.dtype?e.map((e=>Ir(e))):e,a=go(r.shape,r.dtype,t),o=HR(a,s);return n.makeTensorInfo(o.shape,o.dtype,o.values)}const o=new $L(r.shape,s);return n.runWebGLProgram(o,[r],r.dtype)}const tz={kernelName:Oa,backendName:"webgl",kernelFunc:ez};class nz{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"negativeInf",type:"float"},{name:"dir",type:"int"},{name:"inc",type:"int"}],this.outputShape=e,this.userCode="\n       void main() {\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // We compare elements pair-wise within a group of size 2 * inc.\n         // The comparing rule for each group alternates between ascending\n         // and descending. Within each group, we compare each pair at\n         // positions i and i+inc. To decide whether an element at position i\n         // is x0 or x1, we mod it by 2 * inc, if the result is smaller than\n         // inc, it is in the first half of the group, we denote it as x0,\n         // otherwise we denote it as x1.\n         // For example, as shown in the Bitonic top K paper referenced above,\n         // Figure5(a) shows that element[1] is in the\n         // second half of the group when group size is 2, but it is in the\n         // first half of the group when group size is 4.\n\n         bool isFirstInPair = imod(elemIdx, 2 * inc) < inc;\n         int i = isFirstInPair ? elemIdx : elemIdx - inc;\n\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + inc : int(getIndices(batch, i + inc));\n         float x0 = i0 < n ? getX(batch, i0) : negativeInf;\n         float x1 = i1 < n ? getX(batch, i1) : negativeInf;\n\n         // Denotes which direction indices are in (ascending or descending).\n         bool reverse = imod(elemIdx, 2 * dir) >= dir;\n         bool isGreater = x0 > x1 || (x0 == x1 && i1 > i0);\n         if (reverse == isGreater) { // Elements in opposite order of direction\n           int iTemp = i0;\n           i0 = i1;\n           i1 = iTemp;\n         }\n         if (isFirstInPair) {\n            setOutput(float(i0));\n         } else {\n            setOutput(float(i1));\n         }\n       }\n     "}}class az{constructor(e){this.variableNames=["x","indices"],this.customUniforms=[{name:"n",type:"int"},{name:"firstPass",type:"int"},{name:"k",type:"int"}],this.outputShape=e,this.userCode="\n    void main() {\n         // Takes max of indices (0, k), (1, k + 1), (2, k + 2) ...\n         ivec2 coords = getOutputCoords();\n         int batch = coords[0];\n         int elemIdx = coords[1];\n\n         // The output size is half of the previous size.\n         // If the previous sequence is | | | | _ _ _ _  | | | |  _ _ _ _ (k=4),\n         // we only need to output the indices at positions |, the indices at\n         // positions _ can be thrown away, see Figure5(b) After Phase 2\n         // (Merge phase) in the Bitonic Top K paper referenced above.\n         // For example, the paper shows we only need to output the orange bars.\n         // The output sequence should look like this | | | | | | | |.\n         // Because the sequence is halved, to map the output index back\n         // to the previous sequence to find the corresponding value,\n         // we need to double the index. When we double the index,\n         // we basically interpolate a position, so 2i looks like\n         // | _ | _ | _ | _ | _ | _ | _. We move the | to the first k position\n         // of each 2k positions by - elemIdx % k. E.g. for output at\n         // index 4,5,6,7, we want to get the corresponding element at\n         // original index 8,9,10,11, for output at index 8,9,10,11,\n         // we want to get the corresponding element at original index\n         // 16,17,18,19, so on and so forth.\n\n         int i = elemIdx < k ? elemIdx : (elemIdx * 2 - imod(elemIdx, k));\n         int i0 = firstPass == 1 ? i : int(getIndices(batch, i));\n         int i1 = firstPass == 1 ? i + k : int(getIndices(batch, i + k));\n\n         float x0 = getX(batch, i0);\n         float x1 = i1 < n ? getX(batch, i1) : x0;\n\n         setOutput(x0 >= x1 ? float(i0) : float(i1));\n       }\n     "}}function rz(e,t){null!==t&&e.disposeIntermediateTensorInfo(t)}function sz(e){let t=1;for(;t<e;)t*=2;return t}const oz={kernelName:Ma,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r}=t,{k:s,sorted:o}=a,i=_e().getNumber("TOPK_LAST_DIM_CPU_HANDOFF_SIZE_THRESHOLD"),c=_e().getNumber("TOPK_K_CPU_HANDOFF_THRESHOLD"),l=r.shape,u=l[l.length-1];if(n.shouldExecuteOnCPU([r])||u<i||s>c){const e=n.readSync(r.dataId),[t,a]=jR(e,l,r.dtype,s,o);return[n.makeTensorInfo(t.shape,t.dtype,t.values),n.makeTensorInfo(a.shape,a.dtype,a.values)]}if(0===s)return l[l.length-1]=0,[n.makeTensorInfo(l,r.dtype,[]),n.makeTensorInfo(l,"int32",[])];if(1===u)return[r,PF({attrs:{shape:l,dtype:"int32",value:0},backend:n})];const h=n.texData.get(r.dataId),d=null!==h&&h.isPacked,p=d?n.unpackTensor(r):r,f=ee(l)/u,m=KA({inputs:{x:p},attrs:{shape:[f,u]},backend:n});d&&rz(n,p);const g=sz(s),y=sz(u);let b=null;const v=()=>null===b?[m,m]:[m,b],x=(e,t,a)=>{const r=v(),s=new nz(a),o=[[u],[null===b?1:0],[Number.NEGATIVE_INFINITY],[e],[t]],i=b;b=n.runWebGLProgram(s,r,"int32",o),rz(n,i)};for(let N=1;N<g;N*=2){const e=2*N;for(let t=N;t>=1;t/=2)x(e,t,[f,y])}for(let N=y;N>g;N/=2){const e=v(),t=new az([f,N/2]),a=[[u],[null===b?1:0],[g]],r=b;b=n.runWebGLProgram(t,e,"int32",a),rz(n,r);const s=g/2,o=2*s;for(let n=s;n>=1;n/=2)x(o,n,b.shape)}let w=b;b=$_({inputs:{x:b},backend:n,attrs:{begin:0,size:[f,s]}}),rz(n,w);let k=aO({inputs:{x:m,indices:b},backend:n,attrs:{axis:1,batchDims:1}});rz(n,m);const S=l.slice(0,-1);S.push(s),w=b,b=KA({inputs:{x:b},attrs:{shape:S},backend:n}),rz(n,w);const I=k;return k=KA({inputs:{x:k},attrs:{shape:S},backend:n}),rz(n,I),[k,b]}};class iz{constructor(e,t,n,a,r,s){this.variableNames=["Image","Transforms"],this.outputShape=s;const o="nearest"===n?1:2;let i;switch(a){case"constant":default:i=1;break;case"reflect":i=2;break;case"wrap":i=3;break;case"nearest":i=4}this.userCode="\n            float mapCoord(float outCoord, float len) {\n              float inCoord = outCoord;\n              if(".concat(i," == 2) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    if (inCoord < sz2) {\n                      inCoord = sz2 * float(int(float(-inCoord / sz2))) +\n                      inCoord;\n                    }\n                    inCoord = inCoord < -len ? inCoord + sz2 : -inCoord - 1.0;\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz2 = 2.0 * len;\n                    inCoord -= sz2 * float(int(float(inCoord / sz2)));\n                    if (inCoord >= len) {\n                      inCoord = sz2 - inCoord - 1.0;\n                    }\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 3) {\n                if (inCoord < 0.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord += len * (float(int(float(-inCoord / sz))) + 1.0);\n                  }\n                } else if (inCoord > len - 1.0) {\n                  if (len <= 1.0) {\n                    inCoord = 0.0;\n                  } else {\n                    float sz = len - 1.0;\n                    inCoord -= len * float(int(float(inCoord / sz)));\n                  }\n                }\n                return clamp(inCoord, 0.0, len - 1.0);\n              } else if (").concat(i," == 4) {\n                return clamp(outCoord, 0.0, len - 1.0);\n              } else {\n                return outCoord;\n              }\n            }\n\n            float readWithFillValue(int batch, int coordY, int coordX,\n              int channel) {\n              float outputValue;\n              if (0 <= coordY && coordY < ").concat(e," && 0 <= coordX && coordX < ").concat(t,") {\n                  outputValue = getImage(batch, coordY, coordX, channel);\n              } else {\n                outputValue = float(").concat(r,");\n              }\n              return outputValue;\n            }\n\n            void main() {\n              ivec4 coords = getOutputCoords();\n              float outputValue;\n              int batch = coords[0];\n              int x = coords[2];\n              int y = coords[1];\n              int channel = coords[3];\n              float xf = float(x);\n              float yf = float(y);\n              float a1 = getTransforms(batch, 0);\n              float a2 = getTransforms(batch, 1);\n              float a3 = getTransforms(batch, 2);\n              float b1 = getTransforms(batch, 3);\n              float b2 = getTransforms(batch, 4);\n              float b3 = getTransforms(batch, 5);\n              float c1 = getTransforms(batch, 6);\n              float c2 = getTransforms(batch, 7);\n              float projection = c1 * xf + c2 * yf + 1.0;\n              if (projection == 0.0) {\n                outputValue = float(").concat(r,");\n              } else {\n                float inX = (a1 * xf + a2 * yf + a3) / projection;\n                float inY = (b1 * xf + b2 * yf + b3) / projection;\n                float mapX = mapCoord(inX, float(").concat(t,"));\n                float mapY = mapCoord(inY, float(").concat(e,"));\n\n                if (").concat(o," == 1) {\n                  int coordY = int(round(mapY));\n                  int coordX = int(round(mapX));\n                  outputValue = readWithFillValue(batch, coordY, coordX,\n                    channel);\n                } else {\n                  float yFloor = floor(mapY);\n                  float xFloor = floor(mapX);\n                  float yCeil = yFloor + 1.0;\n                  float xCeil = xFloor + 1.0;\n                  float valueYFloor = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yFloor), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yFloor), int(xCeil), channel);\n                  float valueYCeil = (xCeil - mapX) *\n                  readWithFillValue(batch, int(yCeil), int(xFloor), channel) +\n                  (mapX - xFloor) *\n                  readWithFillValue(batch, int(yCeil), int(xCeil), channel);\n                  outputValue = (yCeil - mapY) * valueYFloor +\n                  (mapY - yFloor) * valueYCeil;\n                }\n              }\n              setOutput(outputValue);\n            }\n        ")}}const cz={kernelName:La,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{image:r,transforms:s}=t,{interpolation:o,fillMode:i,fillValue:c,outputShape:l}=a,[u,h,d,p]=r.shape,[f,m]=null!=l?l:[h,d],g=new iz(h,d,o,i,c,[u,f,m,p]);return n.runWebGLProgram(g,[r,s],"float32")}};const lz={kernelName:Pa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,attrs:n,backend:a}=e,{axis:r}=n,{x:s}=t;lC(s,"unique"),console.warn("WARNING: ","UI might be locked temporarily as data is being downloaded");const o=a.readSync(s.dataId),{outputValues:i,outputShape:c,indices:l}=qR(o,r,s.shape,s.dtype);return[a.makeTensorInfo(c,s.dtype,i),a.makeTensorInfo([l.length],"int32",l)]}};const uz={kernelName:Ba,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{value:r}=t;let{axis:s}=a;s<0&&(s+=r.shape.length);const o=r,i=o.shape.length,c=r.shape[s],l=new Array(i-1);let u=0;for(let m=0;m<i;m++)m!==s&&(l[u++]=o.shape[m]);const h=[],d=new Array(i).fill(0),p=o.shape.slice();p[s]=1;const f=new Array(c);for(let m=0;m<f.length;m++){d[s]=m;const e=$_({inputs:{x:o},backend:n,attrs:{begin:d,size:p}}),t=KA({inputs:{x:e},backend:n,attrs:{shape:l}});f[m]=t,h.push(e)}return h.forEach((e=>n.disposeIntermediateTensorInfo(e))),f}};class hz{constructor(e,t){this.variableNames=["x","segmentIds"];const n=e.windowSize,a=e.batchSize,r=e.inSize,s=e.numSegments,o=s*Math.ceil(r/n);this.outputShape=[a,o];const i=4*Math.floor(n/4),c=n%4,l="\n        sumValue += dot(values, segFilter);\n    ";let u="";r%n>0&&(u="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return initializationValue;\n        }\n      "));let h="";r%n>0&&(h="\n        if (inIdx < 0 || inIdx >= ".concat(r,") {\n          return -1.0;\n        }\n      ")),this.userCode="\n      const float initializationValue = ".concat("0.0",";\n\n      float getValue(int batch, int inIdx) {\n        ").concat(u,"\n        return getX(batch, inIdx);\n      }\n\n      float getSegmentIdAtIndex(int inIdx) {\n        ").concat(h,"\n        return getSegmentIds(inIdx);\n      }\n\n      void main() {\n        ivec2 coords = getOutputCoords();\n        int batch = coords[0];\n        int outIdx = coords[1];\n        int inOffset = int(floor(float(outIdx) / float(\n          ").concat(s,")) * float(").concat(n,"));\n        int currentSeg = int(mod(float(outIdx), float(").concat(s,")));\n\n        float sumValue = 0.0;\n\n        for (int i = 0; i < ").concat(i,"; i += 4) {\n          int inIdx = inOffset + i;\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            getValue(batch, inIdx + 3)\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 3)) == currentSeg ? 1 : 0\n          );\n\n          ").concat(l,"\n        }\n\n        int inIdx = inOffset + ").concat(i,";\n        if (").concat(1===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            initializationValue,\n            initializationValue,\n            initializationValue\n          );\n\n          int inIdxSeg = int(getSegmentIdAtIndex(inIdx));\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            0,\n            0,\n            0\n          );\n\n          ").concat(l,"\n        } else if (").concat(2===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            initializationValue,\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n              0,\n              0\n          );\n\n          ").concat(l,"\n        } else if (").concat(3===c,") {\n          vec4 values = vec4(\n            getValue(batch, inIdx),\n            getValue(batch, inIdx + 1),\n            getValue(batch, inIdx + 2),\n            initializationValue\n          );\n\n          vec4 segFilter = vec4(\n            int(getSegmentIdAtIndex(inIdx)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 1)) == currentSeg ? 1 : 0,\n            int(getSegmentIdAtIndex(inIdx + 2)) == currentSeg ? 1 : 0,\n            0\n          );\n\n          ").concat(l,"\n        }\n        setOutput(").concat("sumValue",");\n      }\n    ")}}const dz={kernelName:Wa,backendName:"webgl",kernelFunc:function(e){const{inputs:t,backend:n,attrs:a}=e,{x:r,segmentIds:s}=t,{numSegments:o}=a,i=r.shape.length,c=[];let l=0;const u=Dc([l],i);let h=r;null!=u&&(h=n_({inputs:{x:r},backend:n,attrs:{perm:u}}),c.push(h),l=Oc(1,i)[0]);const d=Ph(h.shape,l,o),p=ee([h.shape[l]]),f=KA({inputs:{x:h},backend:n,attrs:{shape:[-1,p]}});c.push(f);const m=Zr(r.dtype),g=(e,t,a,r,s)=>{const o=e.shape[0],i=e.shape[1],l=zh(i,s),u=new hz({windowSize:l,inSize:i,batchSize:o,numSegments:s},t),h=n.compileAndRun(u,[e,a],r);if(c.push(h),h.shape[1]===s)return h;const d=MM({backend:n,attrs:{start:0,stop:s,step:1,dtype:"float32"}}),p=ez({inputs:{x:d},backend:n,attrs:{reps:[i/l]}});c.push(d),c.push(p);return g(h,t,p,r,s)},y=KA({inputs:{x:g(f,"unsortedSegmentSum",s,m,o)},backend:n,attrs:{shape:d}});let b=y;if(null!=u){c.push(y);const e=Fc(u);b=n_({inputs:{x:b},backend:n,attrs:{perm:e}})}return c.forEach((e=>n.disposeIntermediateTensorInfo(e))),b}},pz=[o_,c_,u_,d_,m_,b_,v_,x_,T_,E_,R_,__,F_,M_,z_,W_,V_,H_,j_,K_,Y_,tD,nD,aD,rD,uD,pD,gD,RA,vD,ED,MD,WD,UD,GD,HD,jD,qD,YD,JD,aF,rF,sF,iF,uF,pF,fF,gF,bF,vF,wF,kF,IF,TF,CF,AF,FF,LF,BF,VF,HF,KF,YF,ZF,$F,tO,rO,oO,cO,EA,lO,ID,hO,pO,mO,DA,yO,vO,xO,kO,IO,TO,CO,AO,FO,MO,zO,BO,WO,VO,HO,jO,KO,qO,XO,QO,$O,tM,uM,jA,dM,fM,gM,bM,oD,xM,SM,IM,CM,AM,MA,_M,DM,FM,OM,LM,cD,rM,PM,WM,UM,qA,jM,qM,QM,ZM,tL,aL,sL,iL,uL,dL,fL,gL,bL,xL,kL,IL,eD,lM,TL,EL,CL,RL,AL,_L,DL,FL,LL,zL,WL,VL,UL,HL,jL,KL,qL,iM,t_,YL,JL,ZL,tz,oz,cz,a_,lz,uz,dz,kM];for(const n of pz)tr(n);class fz{constructor(e,t){this.backend=e,this.dataMover=t,this.data=new WeakMap,this.dataIdsCount=0}get(e){return this.data.has(e)||this.dataMover.moveData(this.backend,e),this.data.get(e)}set(e,t){this.dataIdsCount++,this.data.set(e,t)}has(e){return this.data.has(e)}delete(e){return this.dataIdsCount--,this.data.delete(e)}numDataIds(){return this.dataIdsCount}}class mz{refCount(e){return gz("refCount")}incRef(e){return gz("incRef")}timerAvailable(){return!0}time(e){return gz("time")}read(e){return gz("read")}readSync(e){return gz("readSync")}readToGPU(e,t){return gz("readToGPU")}numDataIds(){return gz("numDataIds")}disposeData(e,t){return gz("disposeData")}write(e,t,n){return gz("write")}move(e,t,n,a,r){return gz("move")}memory(){return gz("memory")}floatPrecision(){return gz("floatPrecision")}epsilon(){return 32===this.floatPrecision()?1e-7:1e-4}dispose(){return gz("dispose")}}function gz(e){throw new Error("'".concat(e,"' not yet implemented or not found in the registry. ")+"This kernel may not be supported by the tfjs backend you have chosen")}function yz(e){let t=e.length,n=0;for(;t>0;)n=Math.random()*t|0,t--,wz(e,t,n)}function bz(e,t){if(e.length!==t.length)throw new Error("Array sizes must match to be shuffled together "+"First array length was ".concat(e.length)+"Second array length was ".concat(t.length));let n=e.length,a=0;for(;n>0;)a=Math.random()*n|0,n--,wz(e,n,a),wz(t,n,a)}function vz(e,t,n){return Math.max(e,Math.min(t,n))}function xz(e){return e%2===0?e:e+1}function wz(e,t,n){const a=e[t];e[t]=e[n],e[n]=a}function kz(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t}function Sz(e,t){const n=Math.random();return t*n+(1-n)*e}function Iz(e,t){let n=0;for(let a=0;a<e.length;a++){const r=Number(e[a])-Number(t[a]);n+=r*r}return n}function Nz(e,t){if(!e)throw new Error("string"===typeof t?t:t())}function Tz(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";Nz(_z(e,t),(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}function Ez(e){Nz(null!=e,(()=>"The input to the tensor constructor must be a non-null value."))}function Cz(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(null==t&&(t=[]),Array.isArray(e)||Kz(e)&&!n)for(let a=0;a<e.length;++a)Cz(e[a],t,n);else t.push(e);return t}function Rz(e){if(0===e.length)return 1;let t=e[0];for(let n=1;n<e.length;n++)t*=e[n];return t}function Az(e){return 0===e.length}function _z(e,t){if(e===t)return!0;if(null==e||null==t)return!1;if(e.length!==t.length)return!1;for(let n=0;n<e.length;n++)if(e[n]!==t[n])return!1;return!0}function Dz(e){return e%1===0}function Fz(e){if(null!=Math.tanh)return Math.tanh(e);if(e===1/0)return 1;if(e===-1/0)return-1;{const t=Math.exp(2*e);return(t-1)/(t+1)}}function Oz(e){const t=Math.ceil(Math.sqrt(e));return[t,Math.ceil(e/t)]}function Mz(e){const t=new Uint32Array(e);for(let n=0;n<e;++n)t[n]=n;return yz(t),t}function Lz(e,t){return t<=e.length?e:e+" ".repeat(t-e.length)}function zz(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e=>0,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:setTimeout;return new Promise(((r,s)=>{let o=0;const i=()=>{if(e())return void r();o++;const c=t(o);null!=n&&o>=n?s():a(i,c)};i()}))}function Pz(e,t){let n=1,a=-1;for(let s=0;s<e.length;++s)if(e[s]>=0)n*=e[s];else if(-1===e[s]){if(-1!==a)throw Error("Shapes can only have 1 implicit size. "+"Found -1 at dim ".concat(a," and dim ").concat(s));a=s}else if(e[s]<0)throw Error("Shapes can not be < 0. Found ".concat(e[s]," at dim ").concat(s));if(-1===a){if(t>0&&t!==n)throw Error("Size(".concat(t,") must match the product of shape ").concat(e));return e}if(0===n)throw Error("Cannot infer the missing size in [".concat(e,"] when ")+"there are 0 elements");if(t%n!==0)throw Error("The implicit shape can't be a fractional number. "+"Got ".concat(t," / ").concat(n));const r=e.slice();return r[a]=t/n,r}function Bz(e,t){const n=t.length;return Nz((e=null==e?t.map(((e,t)=>t)):[].concat(e)).every((e=>e>=-n&&e<n)),(()=>"All values in axis param must be in range [-".concat(n,", ").concat(n,") but ")+"got axis ".concat(e))),Nz(e.every((e=>Dz(e))),(()=>"All values in axis param must be integers but "+"got axis ".concat(e))),e.map((e=>e<0?n+e:e))}function Wz(e,t){const n=[],a=[],r=null!=t&&Array.isArray(t)&&0===t.length,s=null==t||r?null:Bz(t,e).sort();let o=0;for(let i=0;i<e.length;++i){if(null!=s){if(s[o]===i&&1!==e[i])throw new Error("Can't squeeze axis ".concat(i," since its dim '").concat(e[i],"' is not 1"));(null==s[o]||s[o]>i)&&1===e[i]&&(n.push(e[i]),a.push(i)),s[o]<=i&&o++}1!==e[i]&&(n.push(e[i]),a.push(i))}return{newShape:n,keptDims:a}}function Vz(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else{if("bool"!==e)throw new Error("Unknown data type ".concat(e));n=new Uint8Array(t)}return n}function Uz(e,t){let n=null;if(null==e||"float32"===e)n=new Float32Array(t);else if("int32"===e)n=new Int32Array(t);else if("bool"===e)n=new Uint8Array(t);else{if("string"!==e)throw new Error("Unknown data type ".concat(e));n=new Array(t)}return n}function Gz(e,t){for(let n=0;n<e.length;n++){const a=e[n];if(isNaN(a)||!isFinite(a))throw Error("A tensor of type ".concat(t," being uploaded contains ").concat(a,"."))}}function Hz(e){return"bool"===e||"complex64"===e||"float32"===e||"int32"===e||"string"===e}function jz(e,t){return"complex64"!==t&&(("float32"!==t||"complex64"===e)&&(("int32"!==t||"float32"===e||"complex64"===e)&&("bool"!==t||"bool"!==e)))}function Kz(e){return e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray}function qz(e){if("float32"===e||"int32"===e)return 4;if("complex64"===e)return 8;if("bool"===e)return 1;throw new Error("Unknown dtype ".concat(e))}function Xz(e){if(null==e)return 0;let t=0;return e.forEach((e=>t+=e.length)),t}function Yz(e){return"string"===typeof e||e instanceof String}function Qz(e){return"boolean"===typeof e}function Jz(e){return"number"===typeof e}function Zz(e){return Array.isArray(e)?Zz(e[0]):e instanceof Float32Array?"float32":e instanceof Int32Array||e instanceof Uint8Array||e instanceof Uint8ClampedArray?"int32":Jz(e)?"float32":Yz(e)?"string":Qz(e)?"bool":"float32"}function $z(e){return!!(e&&e.constructor&&e.call&&e.apply)}function eP(e,t){for(let n=t;n<e;++n)if(e%n===0)return n;return e}function tP(e){const t=e.length;if(t<2)return[];const n=new Array(t-1);n[t-2]=e[t-1];for(let a=t-3;a>=0;--a)n[a]=n[a+1]*e[a+1];return n}function nP(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=new Array;if(1===t.length){const s=t[0]*(a?2:1);for(let t=0;t<s;t++)r[t]=n[e+t]}else{const s=t[0],o=t.slice(1),i=o.reduce(((e,t)=>e*t))*(a?2:1);for(let t=0;t<s;t++)r[t]=nP(e+t*i,o,n,a)}return r}function aP(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(0===e.length)return t[0];const a=e.reduce(((e,t)=>e*t))*(n?2:1);if(0===a)return[];if(a!==t.length)throw new Error("[".concat(e,"] does not match the input size ").concat(t.length).concat(n?" for a complex tensor":"","."));return nP(0,e,t,n)}function rP(e,t){const n=sP(e,t);for(let a=0;a<n.length;a++)n[a]=1;return n}function sP(e,t){if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t)return new Uint8Array(e);throw new Error("Unknown data type ".concat(t))}function oP(e,t){const n=e.reduce(((e,t)=>e*t),1);if(null==t||"float32"===t)return aP(e,new Float32Array(n));if("int32"===t)return aP(e,new Int32Array(n));if("bool"===t)return aP(e,new Uint8Array(n));throw new Error("Unknown data type ".concat(t))}function iP(e){e.forEach((t=>{Nz(Number.isInteger(t)&&t>=0,(()=>"Tensor must have a shape comprised of positive integers but got "+"shape [".concat(e,"].")))}))}function cP(e,t,n){if(0===t)return 0;if(1===t)return e[0];let a=e[e.length-1];for(let r=0;r<e.length-1;++r)a+=n[r]*e[r];return a}function lP(e,t,n){if(0===t)return[];if(1===t)return[e];const a=new Array(t);for(let r=0;r<a.length-1;++r)a[r]=Math.floor(e/n[r]),e-=a[r]*n[r];return a[a.length-1]=e,a}function uP(e){return e&&e.then&&"function"===typeof e.then}const hP="tfjsflags";class dP{constructor(e){this.global=e,this.flags={},this.flagRegistry={},this.urlFlags={},this.getQueryParams=pP,this.populateURLFlags()}setPlatform(e,t){null!=this.platform&&(fP().getBool("IS_TEST")||fP().getBool("PROD")||console.warn("Platform ".concat(this.platformName," has already been set. ")+"Overwriting the platform with ".concat(e,"."))),this.platformName=e,this.platform=t}registerFlag(e,t,n){if(this.flagRegistry[e]={evaluationFn:t,setHook:n},null!=this.urlFlags[e]){const t=this.urlFlags[e];fP().getBool("IS_TEST")||fP().getBool("PROD")||console.warn("Setting feature override from URL ".concat(e,": ").concat(t,".")),this.set(e,t)}}async getAsync(e){return e in this.flags||(this.flags[e]=await this.evaluateFlag(e)),this.flags[e]}get(e){if(e in this.flags)return this.flags[e];const t=this.evaluateFlag(e);if(uP(t))throw new Error("Flag ".concat(e," cannot be synchronously evaluated. ")+"Please use getAsync() instead.");return this.flags[e]=t,this.flags[e]}getNumber(e){return this.get(e)}getBool(e){return this.get(e)}getFlags(){return this.flags}get features(){return this.flags}set(e,t){if(null==this.flagRegistry[e])throw new Error("Cannot set flag ".concat(e," as it has not been registered."));this.flags[e]=t,null!=this.flagRegistry[e].setHook&&this.flagRegistry[e].setHook(t)}evaluateFlag(e){if(null==this.flagRegistry[e])throw new Error("Cannot evaluate flag '".concat(e,"': no evaluation function found."));return this.flagRegistry[e].evaluationFn()}setFlags(e){this.flags=Object.assign({},e)}reset(){this.flags={},this.urlFlags={},this.populateURLFlags()}populateURLFlags(){if("undefined"===typeof this.global||"undefined"===typeof this.global.location||"undefined"===typeof this.global.location.search)return;const e=this.getQueryParams(this.global.location.search);if(hP in e){e[hP].split(",").forEach((e=>{const[t,n]=e.split(":");this.urlFlags[t]=function(e,t){if("true"===(t=t.toLowerCase())||"false"===t)return"true"===t;if("".concat(+t)===t)return+t;throw new Error("Could not parse value flag value ".concat(t," for flag ").concat(e,"."))}(t,n)}))}}}function pP(e){const t={};return e.replace(/[?&]([^=?&]+)(?:=([^&]*))?/g,(function(e){for(var n=arguments.length,a=new Array(n>1?n-1:0),r=1;r<n;r++)a[r-1]=arguments[r];return function(e,t,n){e[decodeURIComponent(t)]=decodeURIComponent(n||"")}(t,a[0],a[1]),a.join("=")})),t}function fP(){return gP}let mP,gP=null;function yP(){if(null==mP){let e;if("undefined"!==typeof window)e=window;else if("undefined"!==typeof n.g)e=n.g;else if("undefined"!==typeof process)e=process;else{if("undefined"===typeof self)throw new Error("Could not find a global object");e=self}mP=e}return mP}function bP(e,t){const n=function(){const e=yP();return null==e._tfGlobals&&(e._tfGlobals=new Map),e._tfGlobals}();if(n.has(e))return n.get(e);{const a=t();return n.set(e,a),n.get(e)}}const vP="Abs",xP="Acos",wP="Acosh",kP="Add",SP="AddN",IP="All",NP="Any",TP="ArgMax",EP="ArgMin",CP="Asin",RP="Asinh",AP="Atan",_P="Atanh",DP="Atan2",FP="AvgPool",OP="AvgPoolGrad",MP="AvgPool3D",LP="AvgPool3DGrad",zP="BatchMatMul",PP="BatchToSpaceND",BP="Bincount",WP="BroadcastTo",VP="BroadcastArgs",UP="Cast",GP="Ceil",HP="ClipByValue",jP="Complex",KP="ComplexAbs",qP="Concat",XP="Conv2D",YP="Conv2DBackpropFilter",QP="Conv2DBackpropInput",JP="Conv3D",ZP="Conv3DBackpropFilterV2",$P="Conv3DBackpropInputV2",eB="Cos",tB="Cosh",nB="Cumprod",aB="Cumsum",rB="CropAndResize",sB="DenseBincount",oB="DepthToSpace",iB="DepthwiseConv2dNative",cB="DepthwiseConv2dNativeBackpropFilter",lB="DepthwiseConv2dNativeBackpropInput",uB="Diag",hB="Dilation2D",dB="Dilation2DBackpropInput",pB="Dilation2DBackpropFilter",fB="RealDiv",mB="Einsum",gB="Elu",yB="EluGrad",bB="Erf",vB="Equal",xB="Exp",wB="ExpandDims",kB="Expm1",SB="FFT",IB="Fill",NB="FlipLeftRight",TB="Floor",EB="FloorDiv",CB="FusedBatchNorm",RB="GatherV2",AB="GatherNd",_B="Greater",DB="GreaterEqual",FB="Identity",OB="IFFT",MB="Imag",LB="IsFinite",zB="IsInf",PB="IsNan",BB="LeakyRelu",WB="Less",VB="LessEqual",UB="LinSpace",GB="Log",HB="Log1p",jB="LogicalAnd",KB="LogicalNot",qB="LogicalOr",XB="LogicalXor",YB="LogSoftmax",QB="LowerBound",JB="LRN",ZB="LRNGrad",$B="Max",eW="Maximum",tW="MaxPool",nW="MaxPoolGrad",aW="MaxPool3D",rW="MaxPool3DGrad",sW="MaxPoolWithArgmax",oW="Mean",iW="Min",cW="Minimum",lW="MirrorPad",uW="Mod",hW="Multinomial",dW="Multiply",pW="Neg",fW="NotEqual",mW="NonMaxSuppressionV3",gW="NonMaxSuppressionV4",yW="NonMaxSuppressionV5",bW="OnesLike",vW="OneHot",xW="Pack",wW="PadV2",kW="Pool",SW="Pow",IW="Prelu",NW="Prod",TW="RaggedGather",EW="RaggedTensorToTensor",CW="Range",RW="Real",AW="Reciprocal",_W="Relu",DW="Reshape",FW="ResizeNearestNeighbor",OW="ResizeNearestNeighborGrad",MW="ResizeBilinear",LW="ResizeBilinearGrad",zW="Relu6",PW="Reverse",BW="Round",WW="Rsqrt",VW="ScatterNd",UW="SearchSorted",GW="Select",HW="Selu",jW="Slice",KW="Sin",qW="Sinh",XW="Sign",YW="Sigmoid",QW="Softplus",JW="Sqrt",ZW="Sum",$W="SpaceToBatchND",eV="SplitV",tV="Softmax",nV="SparseFillEmptyRows",aV="SparseReshape",rV="SparseSegmentMean",sV="SparseSegmentSum",oV="SparseToDense",iV="SquaredDifference",cV="Square",lV="StridedSlice",uV="StringNGrams",hV="StringSplit",dV="StringToHashBucketFast",pV="Sub",fV="Tan",mV="Tanh",gV="Tile",yV="TopK",bV="Transform",vV="Transpose",xV="Unique",wV="Unpack",kV="UnsortedSegmentSum",SV="UpperBound",IV="ZerosLike",NV="Step",TV="FromPixels",EV="RotateWithOffset",CV="_FusedMatMul",RV="FusedConv2D",AV="FusedDepthwiseConv2D";function _V(){fP().getBool("IS_TEST")||fP().getBool("PROD")||console.warn(...arguments)}function DV(){fP().getBool("IS_TEST")||fP().getBool("PROD")||console.log(...arguments)}const FV=bP("kernelRegistry",(()=>new Map)),OV=bP("gradRegistry",(()=>new Map));function MV(e,t){const n=GV(e,t);return FV.get(n)}function LV(e){return OV.get(e)}function zV(e){const t=FV.entries(),n=[];for(;;){const{done:a,value:r}=t.next();if(a)break;const[s,o]=r,[i]=s.split("_");i===e&&n.push(o)}return n}function PV(e){const{kernelName:t,backendName:n}=e,a=GV(t,n);FV.has(a)&&_V("The kernel '".concat(t,"' for backend ")+"'".concat(n,"' is already registered")),FV.set(a,e)}function BV(e){const{kernelName:t}=e;OV.has(t)&&fP().getBool("DEBUG")&&_V("Overriding the gradient for '".concat(t,"'")),OV.set(t,e)}function WV(e,t){const n=GV(e,t);if(!FV.has(n))throw new Error("The kernel '".concat(e,"' for backend ")+"'".concat(t,"' is not registered"));FV.delete(n)}function VV(e){if(!OV.has(e))throw new Error("The gradient '".concat(e,"' for backend is not registered"));OV.delete(e)}function UV(e,t){zV(e).forEach((e=>{PV(Object.assign({},e,{backendName:t}))}))}function GV(e,t){return"".concat(t,"_").concat(e)}const HV=or()||sr;function jV(e){return HV.fromString(e,!0,16)}const KV=jV("c3a5c85c97cb3127"),qV=jV("b492b66fbe98f273"),XV=jV("9ae16a3b2f90404f");function YV(e){return e.xor(e.shru(47))}function QV(e,t,n){const a=e.slice(t,t+n);return HV.fromBytes(Array.from(a),!0,!0)}function JV(e,t){return QV(e,t,8)}function ZV(e,t){return QV(e,t,4)}function $V(e,t){return 0===t?e:e.shru(t).or(e.shl(64-t))}function eU(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:jV("9ddfea08eb382d69"),a=e.xor(t).mul(n);a=a.xor(a.shru(47));let r=t.xor(a).mul(n);return r=r.xor(r.shru(47)),r=r.mul(n),r}function tU(e,t,n,a){return function(e,t,n,a,r,s){r=r.add(e),s=$V(s.add(r).add(a),21);const o=r;return r=(r=r.add(t)).add(n),s=s.add($V(r,44)),[r.add(a),s.add(o)]}(JV(e,t),JV(e,t+8),JV(e,t+16),JV(e,t+24),n,a)}function nU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=HV.fromNumber(81,!0);if(t<=32)return t<=16?function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;if(t>=8){const n=XV.add(2*t),a=JV(e,0).add(XV),r=JV(e,t-8);return eU($V(r,37).mul(n).add(a),$V(a,25).add(r).mul(n),n)}if(t>=4){const n=XV.add(2*t);return eU(ZV(e,0).shl(3).add(t),ZV(e,t-4),n)}if(t>0){const n=e[0]+(e[t>>1]<<8),a=t+(e[t-1]<<2);return YV(XV.mul(n).xor(KV.mul(a))).mul(XV)}return XV}(e,t):function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=XV.add(2*t),a=JV(e,0).mul(qV),r=JV(e,8),s=JV(e,t-8).mul(n),o=JV(e,t-16).mul(XV);return eU($V(a.add(r),43).add($V(s,30)).add(o),a.add($V(r.add(XV),18)).add(s),n)}(e,t);if(t<=64)return function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:e.length;const n=XV.add(2*t),a=JV(e,0).mul(XV),r=JV(e,8),s=JV(e,t-8).mul(n),o=JV(e,t-16).mul(XV),i=$V(a.add(r),43).add($V(s,30)).add(o),c=eU(i,a.add($V(r.add(XV),18)).add(s),n),l=JV(e,16).mul(n),u=JV(e,24),h=i.add(JV(e,t-32)).mul(n),d=c.add(JV(e,t-24)).mul(n);return eU($V(l.add(u),43).add($V(h,30)).add(d),l.add($V(u.add(a),18)).add(h),n)}(e,t);let a=n,r=n.mul(qV).add(113),s=YV(r.mul(XV).add(113)).mul(XV),o=[HV.UZERO,HV.UZERO],i=[HV.UZERO,HV.UZERO];a=a.mul(XV).add(JV(e,0));let c=0;const l=64*(t-1>>6),u=l+(t-1&63)-63;do{a=$V(a.add(r).add(o[0]).add(JV(e,c+8)),37).mul(qV),r=$V(r.add(o[1]).add(JV(e,c+48)),42).mul(qV),a=a.xor(i[1]),r=r.add(o[0]).add(JV(e,c+40)),s=$V(s.add(i[0]),33).mul(qV),o=tU(e,c,o[1].mul(qV),a.add(i[0])),i=tU(e,c+32,s.add(i[1]),r.add(JV(e,c+16))),[s,a]=[a,s],c+=64}while(c!==l);const h=qV.add(s.and(255).shl(1));return c=u,i[0]=i[0].add(t-1&63),o[0]=o[0].add(i[0]),i[0]=i[0].add(o[0]),a=$V(a.add(r).add(o[0]).add(JV(e,c+8)),37).mul(h),r=$V(r.add(o[1]).add(JV(e,c+48)),42).mul(h),a=a.xor(i[1].mul(9)),r=r.add(o[0].mul(9).add(JV(e,c+40))),s=$V(s.add(i[0]),33).mul(h),o=tU(e,c,o[1].mul(h),a.add(i[0])),i=tU(e,c+32,s.add(i[1]),r.add(JV(e,c+16))),[s,a]=[a,s],eU(eU(o[0],i[0],h).add(YV(r).mul(KV)).add(s),eU(o[1],i[1],h).add(a),h)}function aU(e,t){return"string"===t?iU(e):rU([e],t)}function rU(e,t){if("string"===t)throw new Error("Cannot convert a string[] to a TypedArray");if(Array.isArray(e)&&(e=Cz(e)),fP().getBool("DEBUG")&&Gz(e,t),function(e,t){return e instanceof Float32Array&&"float32"===t||e instanceof Int32Array&&"int32"===t||e instanceof Uint8Array&&"bool"===t}(e,t))return e;if(null==t||"float32"===t||"complex64"===t)return new Float32Array(e);if("int32"===t)return new Int32Array(e);if("bool"===t){const t=new Uint8Array(e.length);for(let n=0;n<t.length;++n)0!==Math.round(e[n])&&(t[n]=1);return t}throw new Error("Unknown data type ".concat(t))}function sU(){return fP().platform.now()}function oU(e,t){return fP().platform.fetch(e,t)}function iU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",fP().platform.encode(e,t)}function cU(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"utf-8";return t=t||"utf-8",fP().platform.decode(e,t)}class lU{constructor(e,t){this.backendTimer=e,this.logger=t,null==t&&(this.logger=new hU)}profileKernel(e,t,n){let a;const r=()=>{a=n()};let s;const o=sU();if(this.backendTimer.timerAvailable())s=this.backendTimer.time(r);else{r();for(const e of a)e.dataSync();s=Promise.resolve({kernelMs:sU()-o})}if(fP().getBool("CHECK_COMPUTATION_FOR_ERRORS"))for(let i=0;i<a.length;i++){const t=a[i];t.data().then((n=>{uU(n,t.dtype,e)}))}return{kernelName:e,outputs:a,inputs:t,timeMs:s.then((e=>e.kernelMs)),extraInfo:s.then((e=>null!=e.getExtraProfileInfo?e.getExtraProfileInfo():""))}}logKernelProfile(e){const{kernelName:t,outputs:n,timeMs:a,inputs:r,extraInfo:s}=e;n.forEach((e=>{Promise.all([e.data(),a,s]).then((n=>{this.logger.logKernelProfile(t,e,n[0],n[1],r,n[2])}))}))}}function uU(e,t,n){if("float32"!==t)return!1;for(let a=0;a<e.length;a++){const t=e[a];if(isNaN(t)||!isFinite(t))return console.warn("Found ".concat(t," in the result of '").concat(n,"'")),!0}return!1}class hU{logKernelProfile(e,t,n,a,r,s){const o="number"===typeof a?Lz("".concat(a,"ms"),9):a.error,i=Lz(e,25),c=t.rank,l=t.size,u=Lz(t.shape.toString(),14);let h="";for(const d in r){const e=r[d];if(null!=e){const n=e.shape||t.shape,a=n.length;h+="".concat(d,": ").concat(a,"D ").concat(a>0?n:""," ")}}console.log("%c".concat(i,"\t%c").concat(o,"\t%c").concat(c,"D ").concat(u,"\t%c").concat(l,"\t%c").concat(h,"\t%c").concat(s),"font-weight:bold","color:red","color:blue","color: orange","color: green","color: steelblue")}}const dU=20,pU=3,fU=7;function mU(e,t,n,a){const r=tP(t),s=function(e,t,n,a){const r=Rz(t),s=a[a.length-1],o=new Array(s).fill(0),i=t.length,c="complex64"===n?vU(e):e;if(i>1)for(let l=0;l<r/s;l++){const e=l*s;for(let t=0;t<s;t++)o[t]=Math.max(o[t],gU(c[e+t],0,n).length)}return o}(e,t,n,r),o=t.length,i=bU(e,t,n,r,s),c=["Tensor"];return a&&(c.push("  dtype: ".concat(n)),c.push("  rank: ".concat(o)),c.push("  shape: [".concat(t,"]")),c.push("  values:")),c.push(i.map((e=>"    "+e)).join("\n")),c.join("\n")}function gU(e,t,n){let a;return a=Array.isArray(e)?"".concat(parseFloat(e[0].toFixed(fU))," + ")+"".concat(parseFloat(e[1].toFixed(fU)),"j"):Yz(e)?"'".concat(e,"'"):"bool"===n?yU(e):parseFloat(e.toFixed(fU)).toString(),Lz(a,t)}function yU(e){return 0===e?"false":"true"}function bU(e,t,n,a,r){let s=!(arguments.length>5&&void 0!==arguments[5])||arguments[5];const o="complex64"===n?2:1,i=t[0],c=t.length;if(0===c){if("complex64"===n){return[gU(vU(e)[0],0,n)]}return"bool"===n?[yU(e[0])]:[e[0].toString()]}if(1===c){if(i>dU){const t=pU*o;let a=Array.from(e.slice(0,t)),s=Array.from(e.slice((i-pU)*o,i*o));return"complex64"===n&&(a=vU(a),s=vU(s)),["["+a.map(((e,t)=>gU(e,r[t],n))).join(", ")+", ..., "+s.map(((e,t)=>gU(e,r[i-pU+t],n))).join(", ")+"]"]}return["["+("complex64"===n?vU(e):Array.from(e)).map(((e,t)=>gU(e,r[t],n))).join(", ")+"]"]}const l=t.slice(1),u=a.slice(1),h=a[0]*o,d=[];if(i>dU){for(let t=0;t<pU;t++){const a=t*h,s=a+h;d.push(...bU(e.slice(a,s),l,n,u,r,!1))}d.push("...");for(let t=i-pU;t<i;t++){const a=t*h,s=a+h;d.push(...bU(e.slice(a,s),l,n,u,r,t===i-1))}}else for(let m=0;m<i;m++){const t=m*h,a=t+h;d.push(...bU(e.slice(t,a),l,n,u,r,m===i-1))}const p=2===c?",":"";d[0]="["+d[0]+p;for(let m=1;m<d.length-1;m++)d[m]=" "+d[m]+p;let f=",\n";for(let m=2;m<c;m++)f+="\n";return d[d.length-1]=" "+d[d.length-1]+"]"+(s?"":f),d}function vU(e){const t=[];for(let n=0;n<e.length;n+=2)t.push([e[n],e[n+1]]);return t}class xU{constructor(e,t,n){if(this.dtype=t,this.shape=e.slice(),this.size=Rz(e),null!=n){const e=n.length;Nz(e===this.size,(()=>"Length of values '".concat(e,"' does not match the size ")+"inferred by the shape '".concat(this.size,"'.")))}if("complex64"===t)throw new Error("complex64 dtype TensorBuffers are not supported. Please create a TensorBuffer for the real and imaginary parts separately and call tf.complex(real, imag).");this.values=n||Uz(t,this.size),this.strides=tP(e)}set(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];0===n.length&&(n=[0]),Nz(n.length===this.rank,(()=>"The number of provided coordinates (".concat(n.length,") must ")+"match the rank (".concat(this.rank,")")));const r=this.locToIndex(n);this.values[r]=e}get(){for(var e=arguments.length,t=new Array(e),n=0;n<e;n++)t[n]=arguments[n];0===t.length&&(t=[0]);let a=0;for(const s of t){if(s<0||s>=this.shape[a]){const e="Requested out of range element at ".concat(t,". ")+"  Buffer shape=".concat(this.shape);throw new Error(e)}a++}let r=t[t.length-1];for(let s=0;s<t.length-1;++s)r+=this.strides[s]*t[s];return this.values[r]}locToIndex(e){if(0===this.rank)return 0;if(1===this.rank)return e[0];let t=e[e.length-1];for(let n=0;n<e.length-1;++n)t+=this.strides[n]*e[n];return t}indexToLoc(e){if(0===this.rank)return[];if(1===this.rank)return[e];const t=new Array(this.shape.length);for(let n=0;n<t.length-1;++n)t[n]=Math.floor(e/this.strides[n]),e-=t[n]*this.strides[n];return t[t.length-1]=e,t}get rank(){return this.shape.length}toTensor(){return wU().makeTensor(this.values,this.shape,this.dtype)}}let wU=null,kU=null,SU=null;class IU{constructor(e,t,n,a){this.kept=!1,this.isDisposedInternal=!1,this.shape=e.slice(),this.dtype=t||"float32",this.size=Rz(e),this.strides=tP(e),this.dataId=n,this.id=a,this.rankType=this.rank<5?this.rank.toString():"higher"}get rank(){return this.shape.length}async buffer(){const e=await this.data();return kU.buffer(this.shape,this.dtype,e)}bufferSync(){return kU.buffer(this.shape,this.dtype,this.dataSync())}async array(){const e=await this.data();return aP(this.shape,e,"complex64"===this.dtype)}arraySync(){return aP(this.shape,this.dataSync(),"complex64"===this.dtype)}async data(){this.throwIfDisposed();const e=wU().read(this.dataId);if("string"===this.dtype){const n=await e;try{return n.map((e=>cU(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}}return e}dataToGPU(e){return this.throwIfDisposed(),wU().readToGPU(this.dataId,e)}dataSync(){this.throwIfDisposed();const e=wU().readSync(this.dataId);if("string"===this.dtype)try{return e.map((e=>cU(e)))}catch(t){throw new Error("Failed to decode the string bytes into utf-8. To get the original bytes, call tensor.bytes().")}return e}async bytes(){this.throwIfDisposed();const e=await wU().read(this.dataId);return"string"===this.dtype?e:new Uint8Array(e.buffer)}dispose(){this.isDisposed||(wU().disposeTensor(this),this.isDisposedInternal=!0)}get isDisposed(){return this.isDisposedInternal}throwIfDisposed(){if(this.isDisposed)throw new Error("Tensor is disposed.")}print(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return kU.print(this,e)}clone(){return this.throwIfDisposed(),kU.clone(this)}toString(){let e=arguments.length>0&&void 0!==arguments[0]&&arguments[0];return mU(this.dataSync(),this.shape,this.dtype,e)}cast(e){return this.throwIfDisposed(),kU.cast(this,e)}variable(){let e=!(arguments.length>0&&void 0!==arguments[0])||arguments[0],t=arguments.length>1?arguments[1]:void 0,n=arguments.length>2?arguments[2]:void 0;return this.throwIfDisposed(),wU().makeVariable(this,e,t,n)}}Object.defineProperty(IU,Symbol.hasInstance,{value:e=>!!e&&null!=e.data&&null!=e.dataSync&&null!=e.throwIfDisposed}),bP("Tensor",(()=>IU));class NU extends IU{constructor(e,t,n,a){super(e.shape,e.dtype,e.dataId,a),this.trainable=t,this.name=n}assign(e){if(e.dtype!==this.dtype)throw new Error("dtype of the new value (".concat(e.dtype,") and ")+"previous value (".concat(this.dtype,") must match"));if(!_z(e.shape,this.shape))throw new Error("shape of the new value (".concat(e.shape,") and ")+"previous value (".concat(this.shape,") must match"));wU().disposeTensor(this),this.dataId=e.dataId,wU().incRef(this,null)}dispose(){wU().disposeVariable(this),this.isDisposedInternal=!0}}var TU,EU,CU,RU,AU;Object.defineProperty(NU,Symbol.hasInstance,{value:e=>e instanceof IU&&null!=e.assign&&e.assign instanceof Function}),function(e){e.R0="R0",e.R1="R1",e.R2="R2",e.R3="R3",e.R4="R4",e.R5="R5",e.R6="R6"}(TU||(TU={})),function(e){e.float32="float32",e.int32="int32",e.bool="int32",e.complex64="complex64"}(EU||(EU={})),function(e){e.float32="float32",e.int32="int32",e.bool="bool",e.complex64="complex64"}(CU||(CU={})),function(e){e.float32="float32",e.int32="float32",e.bool="float32",e.complex64="complex64"}(RU||(RU={})),function(e){e.float32="complex64",e.int32="complex64",e.bool="complex64",e.complex64="complex64"}(AU||(AU={}));const _U={float32:RU,int32:EU,bool:CU,complex64:AU};function DU(e,t){if("string"===e||"string"===t){if("string"===e&&"string"===t)return"string";throw new Error("Can not upcast ".concat(e," with ").concat(t))}return _U[e][t]}function FU(e){return DU(e,"int32")}function OU(e,t){if(e.dtype===t.dtype)return[e,t];const n=DU(e.dtype,t.dtype);return[e.cast(n),t.cast(n)]}function MU(e,t){Nz(e.dtype===t.dtype,(()=>"The dtypes of the first(".concat(e.dtype,") and")+" second(".concat(t.dtype,") input must match")))}function LU(e,t){return t.some((t=>t.id===e.id))}function zU(e){const t=[];return PU(e,t,new Set),t}function PU(e,t,n){if(null==e)return;if(e instanceof IU)return void t.push(e);if(a=e,!Array.isArray(a)&&"object"!==typeof a)return;var a;const r=e;for(const s in r){const e=r[s];n.has(e)||(n.add(e),PU(e,t,n))}}function BU(e){return null!=e.kernelName}class WU{constructor(){this.registeredVariables={},this.nextTapeNodeId=0,this.numBytes=0,this.numTensors=0,this.numStringTensors=0,this.numDataBuffers=0,this.gradientDepth=0,this.kernelDepth=0,this.scopeStack=[],this.numDataMovesStack=[],this.nextScopeId=0,this.tensorInfo=new WeakMap,this.profiling=!1,this.activeProfile={newBytes:0,newTensors:0,peakBytes:0,kernels:[],result:null,get kernelNames(){return Array.from(new Set(this.kernels.map((e=>e.name))))}}}dispose(){for(const e in this.registeredVariables)this.registeredVariables[e].dispose()}}class VU{constructor(e){this.ENV=e,this.registry={},this.registryFactory={},this.pendingBackendInitId=0,this.state=new WU}async ready(){if(null!=this.pendingBackendInit)return this.pendingBackendInit.then((()=>{}));if(null!=this.backendInstance)return;const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t];if(await this.initializeBackend(n).success)return void await this.setBackend(n)}throw new Error("Could not initialize any backends, all backend initializations failed.")}get backend(){if(null!=this.pendingBackendInit)throw new Error("Backend '".concat(this.backendName,"' has not yet been initialized. Make ")+"sure to await tf.ready() or await tf.setBackend() before calling other methods");if(null==this.backendInstance){const{name:e,asyncInit:t}=this.initializeBackendsAndReturnBest();if(t)throw new Error("The highest priority backend '".concat(e,"' has not yet been ")+"initialized. Make sure to await tf.ready() or await tf.setBackend() before calling other methods");this.setBackend(e)}return this.backendInstance}backendNames(){return Object.keys(this.registryFactory)}findBackend(e){if(!(e in this.registry)){if(!(e in this.registryFactory))return null;{const{asyncInit:t}=this.initializeBackend(e);if(t)return null}}return this.registry[e]}findBackendFactory(e){return e in this.registryFactory?this.registryFactory[e].factory:null}registerBackend(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return e in this.registryFactory?(_V("".concat(e," backend was already registered. ")+"Reusing existing backend factory."),!1):(this.registryFactory[e]={factory:t,priority:n},!0)}async setBackend(e){if(null==this.registryFactory[e])throw new Error("Backend name '".concat(e,"' not found in registry"));if(this.backendName=e,null==this.registry[e]){this.backendInstance=null;const{success:t,asyncInit:n}=this.initializeBackend(e);if(!(n?await t:t))return!1}return this.backendInstance=this.registry[e],this.setupRegisteredKernels(),this.profiler=new lU(this.backendInstance),!0}setupRegisteredKernels(){zV(this.backendName).forEach((e=>{null!=e.setupFunc&&e.setupFunc(this.backendInstance)}))}disposeRegisteredKernels(e){zV(e).forEach((t=>{null!=t.disposeFunc&&t.disposeFunc(this.registry[e])}))}initializeBackend(e){const t=this.registryFactory[e];if(null==t)throw new Error("Cannot initialize backend ".concat(e,", no registration found."));try{const n=t.factory();if(!n||n instanceof mz||"function"!==typeof n.then)return this.registry[e]=n,{success:!0,asyncInit:!1};{const t=++this.pendingBackendInitId,a=n.then((n=>!(t<this.pendingBackendInitId)&&(this.registry[e]=n,this.pendingBackendInit=null,!0))).catch((n=>(t<this.pendingBackendInitId||(this.pendingBackendInit=null,_V("Initialization of backend ".concat(e," failed")),_V(n.stack||n.message)),!1)));return this.pendingBackendInit=a,{success:a,asyncInit:!0}}}catch(o1){return _V("Initialization of backend ".concat(e," failed")),_V(o1.stack||o1.message),{success:!1,asyncInit:!1}}}removeBackend(e){if(!(e in this.registryFactory))throw new Error("".concat(e," backend not found in registry"));this.backendName===e&&null!=this.pendingBackendInit&&this.pendingBackendInitId++,e in this.registry&&(this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e]),delete this.registryFactory[e],this.backendName===e&&(this.pendingBackendInit=null,this.backendName=null,this.backendInstance=null)}getSortedBackends(){if(0===Object.keys(this.registryFactory).length)throw new Error("No backend found in registry.");return Object.keys(this.registryFactory).sort(((e,t)=>this.registryFactory[t].priority-this.registryFactory[e].priority))}initializeBackendsAndReturnBest(){const e=this.getSortedBackends();for(let t=0;t<e.length;t++){const n=e[t],{success:a,asyncInit:r}=this.initializeBackend(n);if(r||a)return{name:n,asyncInit:r}}throw new Error("Could not initialize any backends, all backend initializations failed.")}moveData(e,t){const n=this.state.tensorInfo.get(t),a=n.backend,r=this.readSync(t),s=a.refCount(t);a.disposeData(t,!0),n.backend=e,e.move(t,r,n.shape,n.dtype,s),this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack[this.state.numDataMovesStack.length-1]++}tidy(e,t){let n,a=null;if(null==t){if("function"!==typeof e)throw new Error("Please provide a function to tidy()");t=e}else{if("string"!==typeof e&&!(e instanceof String))throw new Error("When calling with two arguments, the first argument to tidy() must be a string");if("function"!==typeof t)throw new Error("When calling with two arguments, the 2nd argument to tidy() must be a function");a=e}return this.scopedRun((()=>this.startScope(a)),(()=>this.endScope(n)),(()=>(n=t(),n instanceof Promise&&console.error("Cannot return a Promise inside of tidy."),n)))}scopedRun(e,t,n){e();try{const e=n();return t(),e}catch(a){throw t(),a}}nextTensorId(){return VU.nextTensorId++}nextVariableId(){return VU.nextVariableId++}clone(e){const t=GU.runKernel(FB,{x:e}),n={x:e};return this.addTapeNode(this.state.activeScope.name,n,[t],(e=>({x:()=>{const t={x:e},n={dtype:"float32"};return GU.runKernel(UP,t,n)}})),[],{}),t}runKernel(e,t,n){null==this.backendName&&this.backend;if(!(null!=MV(e,this.backendName)))throw new Error("Kernel '".concat(e,"' not registered for backend '").concat(this.backendName,"'"));return this.runKernelFunc({kernelName:e,inputs:t,attrs:n})}shouldCheckForMemLeaks(){return this.ENV.getBool("IS_TEST")}checkKernelForMemLeak(e,t,n){const a=this.backend.numDataIds();let r=0;n.forEach((e=>{r+="complex64"===e.dtype?3:1}));const s=this.state.numDataMovesStack[this.state.numDataMovesStack.length-1],o=a-t-r-s;if(o>0)throw new Error("Backend '".concat(this.backendName,"' has an internal memory leak ")+"(".concat(o," data ids) after running '").concat(e,"'"))}runKernelFunc(e){let t,n=[];const a=this.isTapeOn(),r=this.state.numBytes,s=this.state.numTensors;let o,i;this.shouldCheckForMemLeaks()&&this.state.numDataMovesStack.push(0),null==this.backendName&&this.backend;const c=BU(e)?e.kernelName:null!=this.state.activeScope?this.state.activeScope.name:"";if(BU(e)){const{kernelName:t,inputs:r,attrs:s}=e;null==this.backendName&&this.backend;const c=MV(t,this.backendName);Nz(null!=c,(()=>"Cannot find registered kernel '".concat(t,"' for backend '").concat(this.backendName,"'"))),o=()=>{const e=this.backend.numDataIds();i=c.kernelFunc({inputs:r,attrs:s,backend:this.backend});const o=Array.isArray(i)?i:[i];this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(t,e,o);const l=o.map((e=>null!=e.rank?e:this.makeTensorFromTensorInfo(e)));if(a){const e=this.getTensorsForGradient(t,r,l);n=this.saveTensorsForBackwardMode(e)}return l}}else{const{forwardFunc:t}=e,r=e=>{a&&(n=e.map((e=>this.keep(this.clone(e)))))};o=()=>{const e=this.backend.numDataIds();i=this.tidy((()=>t(this.backend,r)));const n=Array.isArray(i)?i:[i];return this.shouldCheckForMemLeaks()&&this.checkKernelForMemLeak(c,e,n),n}}const{inputs:l,attrs:u}=e,h=BU(e)?null:e.backwardsFunc;let d;return this.scopedRun((()=>this.state.kernelDepth++),(()=>this.state.kernelDepth--),(()=>{this.ENV.getBool("DEBUG")||this.state.profiling?(d=this.profiler.profileKernel(c,l,(()=>o())),this.ENV.getBool("DEBUG")&&this.profiler.logKernelProfile(d),t=d.outputs):t=o()})),a&&this.addTapeNode(c,l,t,h,n,u),this.state.profiling&&this.state.activeProfile.kernels.push({name:c,bytesAdded:this.state.numBytes-r,totalBytesSnapshot:this.state.numBytes,tensorsAdded:this.state.numTensors-s,totalTensorsSnapshot:this.state.numTensors,inputShapes:Object.keys(l).map((e=>null!=l[e]?l[e].shape:null)),outputShapes:t.map((e=>e.shape)),kernelTimeMs:d.timeMs,extraInfo:d.extraInfo}),Array.isArray(i)?t:t[0]}saveTensorsForBackwardMode(e){return e.map((e=>this.keep(this.clone(e))))}getTensorsForGradient(e,t,n){const a=LV(e);if(null!=a){const e=a.inputsToSave||[],r=a.outputsToSave||[];let s;a.saveAllInputs?(Nz(Array.isArray(t),(()=>"saveAllInputs is true, expected inputs to be an array.")),s=Object.keys(t).map((e=>t[e]))):s=e.map((e=>t[e]));const o=n.filter(((e,t)=>r[t]));return s.concat(o)}return[]}makeTensor(e,t,n,a){if(null==e)throw new Error("Values passed to engine.makeTensor() are null");n=n||"float32",a=a||this.backend;let r=e;"string"===n&&Yz(e[0])&&(r=e.map((e=>iU(e))));const s=a.write(r,t,n),o=new IU(t,n,s,this.nextTensorId());if(this.trackTensor(o,a),"string"===n){const e=this.state.tensorInfo.get(s),t=Xz(r);this.state.numBytes+=t-e.bytes,e.bytes=t}return o}makeTensorFromDataId(e,t,n,a){const r={dataId:e,shape:t,dtype:n=n||"float32"};return this.makeTensorFromTensorInfo(r,a)}makeTensorFromTensorInfo(e,t){const{dataId:n,shape:a,dtype:r}=e,s=new IU(a,r,n,this.nextTensorId());return this.trackTensor(s,t),s}makeVariable(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;n=n||this.nextVariableId().toString(),null!=a&&a!==e.dtype&&(e=e.cast(a));const r=new NU(e,t,n,this.nextTensorId());if(null!=this.state.registeredVariables[r.name])throw new Error("Variable with name ".concat(r.name," was already registered"));return this.state.registeredVariables[r.name]=r,this.incRef(r,this.backend),r}trackTensor(e,t){this.state.numTensors++,"string"===e.dtype&&this.state.numStringTensors++;let n=0;"complex64"!==e.dtype&&"string"!==e.dtype&&(n=e.size*qz(e.dtype)),this.state.numBytes+=n,this.state.tensorInfo.has(e.dataId)||(this.state.numDataBuffers++,this.state.tensorInfo.set(e.dataId,{backend:t||this.backend,dtype:e.dtype,shape:e.shape,bytes:n})),e instanceof NU||this.track(e)}incRef(e,t){this.trackTensor(e,t),this.backend.incRef(e.dataId)}removeDataId(e,t){this.state.tensorInfo.has(e)&&this.state.tensorInfo.get(e).backend===t&&(this.state.tensorInfo.delete(e),this.state.numDataBuffers--)}disposeTensor(e){if(!this.state.tensorInfo.has(e.dataId))return;const t=this.state.tensorInfo.get(e.dataId);if(this.state.numTensors--,"string"===e.dtype&&(this.state.numStringTensors--,this.state.numBytes-=t.bytes),"complex64"!==e.dtype&&"string"!==e.dtype){const t=e.size*qz(e.dtype);this.state.numBytes-=t}t.backend.disposeData(e.dataId)&&this.removeDataId(e.dataId,t.backend)}disposeVariables(){for(const e in this.state.registeredVariables){const t=this.state.registeredVariables[e];this.disposeVariable(t)}}disposeVariable(e){this.disposeTensor(e),null!=this.state.registeredVariables[e.name]&&delete this.state.registeredVariables[e.name]}memory(){const e=this.backend.memory();return e.numTensors=this.state.numTensors,e.numDataBuffers=this.state.numDataBuffers,e.numBytes=this.state.numBytes,this.state.numStringTensors>0&&(e.unreliable=!0,null==e.reasons&&(e.reasons=[]),e.reasons.push("Memory usage by string tensors is approximate (2 bytes per character)")),e}async profile(e){this.state.profiling=!0;const t=this.state.numBytes,n=this.state.numTensors;this.state.activeProfile.kernels=[],this.state.activeProfile.result=await e(),this.state.profiling=!1,this.state.activeProfile.peakBytes=Math.max(...this.state.activeProfile.kernels.map((e=>e.totalBytesSnapshot))),this.state.activeProfile.newBytes=this.state.numBytes-t,this.state.activeProfile.newTensors=this.state.numTensors-n;for(const a of this.state.activeProfile.kernels)a.kernelTimeMs=await a.kernelTimeMs,a.extraInfo=await a.extraInfo;return this.state.activeProfile}isTapeOn(){return this.state.gradientDepth>0&&0===this.state.kernelDepth}addTapeNode(e,t,n,a,r,s){const o={id:this.state.nextTapeNodeId++,kernelName:e,inputs:t,outputs:n,saved:r},i=LV(e);null!=i&&(a=i.gradFunc),null!=a&&(o.gradient=e=>(e=e.map(((e,t)=>{if(null==e){const e=n[t],a=sP(e.size,e.dtype);return this.makeTensor(a,e.shape,e.dtype)}return e})),a(e.length>1?e:e[0],r,s))),this.state.activeTape.push(o)}keep(e){return e.kept=!0,e}startTape(){0===this.state.gradientDepth&&(this.state.activeTape=[]),this.state.gradientDepth++}endTape(){this.state.gradientDepth--}startScope(e){const t={track:[],name:"unnamed scope",id:this.state.nextScopeId++};e&&(t.name=e),this.state.scopeStack.push(t),this.state.activeScope=t}endScope(e){const t=zU(e),n=new Set(t.map((e=>e.id)));for(let r=0;r<this.state.activeScope.track.length;r++){const e=this.state.activeScope.track[r];e.kept||n.has(e.id)||e.dispose()}const a=this.state.scopeStack.pop();this.state.activeScope=0===this.state.scopeStack.length?null:this.state.scopeStack[this.state.scopeStack.length-1],t.forEach((e=>{e.kept||e.scopeId!==a.id||this.track(e)}))}gradients(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];if(Nz(t.length>0,(()=>"gradients() received an empty list of xs.")),null!=n&&"float32"!==n.dtype)throw new Error("dy must have 'float32' dtype, but has '".concat(n.dtype,"'"));const r=this.scopedRun((()=>this.startTape()),(()=>this.endTape()),(()=>this.tidy("forward",e)));Nz(r instanceof IU,(()=>"The result y returned by f() must be a tensor."));const s=function(e,t,n){const a={},r={};for(let c=0;c<t.length;c++)a[t[c].id]=!0;for(let c=0;c<e.length;c++){const n=e[c],s=n.inputs;for(const e in s){const o=s[e];let i=!1;for(let e=0;e<t.length;e++)if(a[o.id]){n.outputs.forEach((e=>a[e.id]=!0)),i=!0,r[n.id]=!0;break}if(i)break}}const s={};s[n.id]=!0;const o={};for(let c=e.length-1;c>=0;c--){const t=e[c],n=t.inputs;for(let e=0;e<t.outputs.length;e++)if(s[t.outputs[e].id]){for(const e in n)s[n[e].id]=!0,o[t.id]=!0;break}}const i=[];for(let c=0;c<e.length;c++){const t=e[c];if(r[t.id]&&o[t.id]){const e={};for(const r in t.inputs){const n=t.inputs[r];a[n.id]&&(e[r]=n)}const n=Object.assign({},t);n.inputs=e,n.outputs=t.outputs,i.push(n)}}return i}(this.state.activeTape,t,r);if(!a&&0===s.length&&t.length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that the f you passed encloses all operations that lead from x to y.");return this.tidy("backward",(()=>{const e={};e[r.id]=null==n?function(e){const t=rP(Rz(e),"float32");return GU.makeTensor(t,e,"float32")}(r.shape):n,function(e,t,n,a){for(let r=t.length-1;r>=0;r--){const s=t[r],o=[];if(s.outputs.forEach((t=>{const n=e[t.id];null!=n?o.push(n):o.push(null)})),null==s.gradient)throw new Error("Cannot compute gradient: gradient function not found "+"for ".concat(s.kernelName,"."));const i=s.gradient(o);for(const t in s.inputs){if(!(t in i))throw new Error("Cannot backprop through input ".concat(t,". ")+"Available gradients found: ".concat(Object.keys(i),"."));const r=n((()=>i[t]()));if("float32"!==r.dtype)throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"".concat(t," must have 'float32' dtype, but has '").concat(r.dtype,"'"));const o=s.inputs[t];if(!_z(r.shape,o.shape))throw new Error("Error in gradient for op ".concat(s.kernelName,". The gradient of input ")+"'".concat(t,"' has shape '").concat(r.shape,"', which does not match ")+"the shape of the input '".concat(o.shape,"'"));if(null==e[o.id])e[o.id]=r;else{const t=e[o.id];e[o.id]=a(t,r),t.dispose()}}}}(e,s,(e=>this.tidy(e)),HU);const a=t.map((t=>e[t.id]));return 0===this.state.gradientDepth&&(this.state.activeTape.forEach((e=>{for(const t of e.saved)t.dispose()})),this.state.activeTape=null),{value:r,grads:a}}))}customGrad(e){var t=this;return Nz($z(e),(()=>"The f passed in customGrad(f) must be a function.")),function(){for(var n=arguments.length,a=new Array(n),r=0;r<n;r++)a[r]=arguments[r];let s;Nz(a.every((e=>e instanceof IU)),(()=>"The args passed in customGrad(f)(x1, x2,...) must all be tensors"));const o={};a.forEach(((e,t)=>{o[t]=e}));return t.runKernelFunc({forwardFunc:(t,n)=>(s=e(...a,n),Nz(s.value instanceof IU,(()=>"The function f passed in customGrad(f) must return an object where `obj.value` is a tensor")),Nz($z(s.gradFunc),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function.")),s.value),backwardsFunc:(e,t)=>{const n=s.gradFunc(e,t),r=Array.isArray(n)?n:[n];Nz(r.length===a.length,(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns the same number of tensors as inputs passed to f(...).")),Nz(r.every((e=>e instanceof IU)),(()=>"The function f passed in customGrad(f) must return an object where `obj.gradFunc` is a function that returns a list of only tensors."));const o={};return r.forEach(((e,t)=>{o[t]=()=>e})),o},inputs:o})}}readSync(e){return this.state.tensorInfo.get(e).backend.readSync(e)}read(e){return this.state.tensorInfo.get(e).backend.read(e)}readToGPU(e,t){return this.state.tensorInfo.get(e).backend.readToGPU(e,t)}async time(e){const t=sU(),n=await this.backend.time(e);return n.wallMs=sU()-t,n}track(e){return null!=this.state.activeScope&&(e.scopeId=this.state.activeScope.id,this.state.activeScope.track.push(e)),e}get registeredVariables(){return this.state.registeredVariables}reset(){this.pendingBackendInitId++,this.state.dispose(),this.ENV.reset(),this.state=new WU;for(const e in this.registry)this.disposeRegisteredKernels(e),this.registry[e].dispose(),delete this.registry[e];this.backendName=null,this.backendInstance=null,this.pendingBackendInit=null}}function UU(){const e=yP();if(null==e._tfengine){const t=new dP(e);e._tfengine=new VU(t)}var t;return t=e._tfengine.ENV,gP=t,function(e){wU=e}((()=>e._tfengine)),e._tfengine}VU.nextTensorId=0,VU.nextVariableId=0;const GU=UU();function HU(e,t){const n={a:e,b:t};return GU.runKernel(kP,n)}let jU;function KU(e){jU=e}function qU(e){if(void 0!==jU)return jU;if(e||"undefined"!==typeof navigator&&null!=navigator){if(e||(e=navigator),"ReactNative"===e.product)return!0;const t=e.userAgent||e.vendor||("undefined"!==typeof window?window.opera:"");if(!t){const t=e;return t.userAgentData&&t.userAgentData.mobile}return/(android|bb\d+|meego).+mobile|avantgo|bada\/|blackberry|blazer|compal|elaine|fennec|hiptop|iemobile|ip(hone|od)|iris|kindle|lge |maemo|midp|mmp|mobile.+firefox|netfront|opera m(ob|in)i|palm( os)?|phone|p(ixi|re)\/|plucker|pocket|psp|series(4|6)0|symbian|treo|up\.(browser|link)|vodafone|wap|windows ce|xda|xiino/i.test(t)||/1207|6310|6590|3gso|4thp|50[1-6]i|770s|802s|a wa|abac|ac(er|oo|s\-)|ai(ko|rn)|al(av|ca|co)|amoi|an(ex|ny|yw)|aptu|ar(ch|go)|as(te|us)|attw|au(di|\-m|r |s )|avan|be(ck|ll|nq)|bi(lb|rd)|bl(ac|az)|br(e|v)w|bumb|bw\-(n|u)|c55\/|capi|ccwa|cdm\-|cell|chtm|cldc|cmd\-|co(mp|nd)|craw|da(it|ll|ng)|dbte|dc\-s|devi|dica|dmob|do(c|p)o|ds(12|\-d)|el(49|ai)|em(l2|ul)|er(ic|k0)|esl8|ez([4-7]0|os|wa|ze)|fetc|fly(\-|_)|g1 u|g560|gene|gf\-5|g\-mo|go(\.w|od)|gr(ad|un)|haie|hcit|hd\-(m|p|t)|hei\-|hi(pt|ta)|hp( i|ip)|hs\-c|ht(c(\-| |_|a|g|p|s|t)|tp)|hu(aw|tc)|i\-(20|go|ma)|i230|iac( |\-|\/)|ibro|idea|ig01|ikom|im1k|inno|ipaq|iris|ja(t|v)a|jbro|jemu|jigs|kddi|keji|kgt( |\/)|klon|kpt |kwc\-|kyo(c|k)|le(no|xi)|lg( g|\/(k|l|u)|50|54|\-[a-w])|libw|lynx|m1\-w|m3ga|m50\/|ma(te|ui|xo)|mc(01|21|ca)|m\-cr|me(rc|ri)|mi(o8|oa|ts)|mmef|mo(01|02|bi|de|do|t(\-| |o|v)|zz)|mt(50|p1|v )|mwbp|mywa|n10[0-2]|n20[2-3]|n30(0|2)|n50(0|2|5)|n7(0(0|1)|10)|ne((c|m)\-|on|tf|wf|wg|wt)|nok(6|i)|nzph|o2im|op(ti|wv)|oran|owg1|p800|pan(a|d|t)|pdxg|pg(13|\-([1-8]|c))|phil|pire|pl(ay|uc)|pn\-2|po(ck|rt|se)|prox|psio|pt\-g|qa\-a|qc(07|12|21|32|60|\-[2-7]|i\-)|qtek|r380|r600|raks|rim9|ro(ve|zo)|s55\/|sa(ge|ma|mm|ms|ny|va)|sc(01|h\-|oo|p\-)|sdk\/|se(c(\-|0|1)|47|mc|nd|ri)|sgh\-|shar|sie(\-|m)|sk\-0|sl(45|id)|sm(al|ar|b3|it|t5)|so(ft|ny)|sp(01|h\-|v\-|v )|sy(01|mb)|t2(18|50)|t6(00|10|18)|ta(gt|lk)|tcl\-|tdg\-|tel(i|m)|tim\-|t\-mo|to(pl|sh)|ts(70|m\-|m3|m5)|tx\-9|up(\.b|g1|si)|utst|v400|v750|veri|vi(rg|te)|vk(40|5[0-3]|\-v)|vm40|voda|vulc|vx(52|53|60|61|70|80|81|83|85|98)|w3c(\-| )|webc|whit|wi(g |nc|nw)|wmlb|wonu|x700|yas\-|your|zeto|zte\-/i.test(t.substr(0,4))}return!1}function XU(){return"undefined"!==typeof window&&null!=window.document||"undefined"!==typeof WorkerGlobalScope}const YU=fP();function QU(e,t){let n=e;if(Kz(e))return"string"===t?[]:[e.length];if(!Array.isArray(e))return[];const a=[];for(;Array.isArray(n)||Kz(n)&&"string"!==t;)a.push(n.length),n=n[0];return Array.isArray(e)&&fP().getBool("TENSORLIKE_CHECK_SHAPE_CONSISTENCY")&&JU(e,a,[]),a}function JU(e,t,n){if(n=n||[],!Array.isArray(e)&&!Kz(e))return void Nz(0===t.length,(()=>"Element arr[".concat(n.join("]["),"] is a primitive, ")+"but should be an array/TypedArray of ".concat(t[0]," elements")));Nz(t.length>0,(()=>"Element arr[".concat(n.join("]["),"] should be a primitive, ")+"but is an array of ".concat(e.length," elements"))),Nz(e.length===t[0],(()=>"Element arr[".concat(n.join("]["),"] should have ").concat(t[0]," ")+"elements, but has ".concat(e.length," elements")));const a=t.slice(1);for(let r=0;r<e.length;++r)JU(e[r],a,n.concat(r))}function ZU(e,t,n,a){if("string_or_numeric"!==e){if(null==e)throw new Error("Expected dtype cannot be null.");if("numeric"!==e&&e!==t||"numeric"===e&&"string"===t)throw new Error("Argument '".concat(n,"' passed to '").concat(a,"' must ")+"be ".concat(e," tensor, but got ").concat(t," tensor"))}}function $U(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(e instanceof IU)return ZU(a,e.dtype,t,n),e;let r=Zz(e);if("string"!==r&&["bool","int32","float32"].indexOf(a)>=0&&(r=a),ZU(a,r,t,n),null==e||!Kz(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e){const a=null==e?"null":e.constructor.name;throw new Error("Argument '".concat(t,"' passed to '").concat(n,"' must be a ")+"Tensor or TensorLike, but got '".concat(a,"'"))}const s=QU(e,r);Kz(e)||Array.isArray(e)||(e=[e]);const o="string"!==r?rU(e,r):Cz(e,[],!0);return GU.makeTensor(o,s,r)}function eG(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"numeric";if(!Array.isArray(e))throw new Error("Argument ".concat(t," passed to ").concat(n," must be a ")+"`Tensor[]` or `TensorLike[]`");return e.map(((e,r)=>$U(e,"".concat(t,"[").concat(r,"]"),n,a)))}YU.registerFlag("DEBUG",(()=>!1),(e=>{e&&console.warn("Debugging mode is ON. The output of every math call will be downloaded to CPU and checked for NaNs. This significantly impacts performance.")})),YU.registerFlag("IS_BROWSER",(()=>XU())),YU.registerFlag("IS_NODE",(()=>"undefined"!==typeof process&&"undefined"!==typeof process.versions&&"undefined"!==typeof process.versions.node)),YU.registerFlag("IS_CHROME",(()=>"undefined"!==typeof navigator&&null!=navigator&&null!=navigator.userAgent&&/Chrome/.test(navigator.userAgent)&&/Google Inc/.test(navigator.vendor))),YU.registerFlag("PROD",(()=>!1)),YU.registerFlag("TENSORLIKE_CHECK_SHAPE_CONSISTENCY",(()=>YU.getBool("DEBUG"))),YU.registerFlag("DEPRECATION_WARNINGS_ENABLED",(()=>!0)),YU.registerFlag("IS_TEST",(()=>!1)),YU.registerFlag("CHECK_COMPUTATION_FOR_ERRORS",(()=>!0)),YU.registerFlag("WRAP_TO_IMAGEBITMAP",(()=>!1)),YU.registerFlag("ENGINE_COMPILE_ONLY",(()=>!1)),YU.registerFlag("CANVAS2D_WILL_READ_FREQUENTLY_FOR_GPU",(()=>!1)),YU.registerFlag("USE_SETTIMEOUTCUSTOM",(()=>!1));const tG="__op";function nG(e){const t=Object.keys(e);if(1!==t.length)throw new Error("Please provide an object with a single key (operation name) mapping to a function. Got an object with "+"".concat(t.length," keys."));let n=t[0];const a=e[n];n.endsWith("_")&&(n=n.substring(0,n.length-1)),n+=tG;const r=function(){GU.startScope(n);try{const e=a(...arguments);return uP(e)&&console.error("Cannot return a Promise inside of tidy."),GU.endScope(e),e}catch(e){throw GU.endScope(null),e}};return Object.defineProperty(r,"name",{value:n,configurable:!0}),r}const aG=nG({complex_:function(e,t){const n=$U(e,"real","complex"),a=$U(t,"imag","complex");Tz(n.shape,a.shape,"real and imag shapes, ".concat(n.shape," and ").concat(a.shape,", ")+"must match in call to tf.complex().");const r={real:n,imag:a};return GU.runKernel(jP,r)}});function rG(e,t,n,a){if(null==a&&(a=Zz(e)),"complex64"===a)throw new Error("Cannot construct a complex64 tensor directly. Please use tf.complex(real, imag).");if(!Kz(e)&&!Array.isArray(e)&&"number"!==typeof e&&"boolean"!==typeof e&&"string"!==typeof e)throw new Error("values passed to tensor(values) must be a number/boolean/string or an array of numbers/booleans/strings, or a TypedArray");if(null!=t){iP(t);const e=Rz(t),a=Rz(n);Nz(e===a,(()=>"Based on the provided shape, [".concat(t,"], the tensor should have ")+"".concat(e," values but has ").concat(a)));for(let r=0;r<n.length;++r){const e=n[r],a=r!==n.length-1||e!==Rz(t.slice(r));Nz(n[r]===t[r]||!a,(()=>"Error creating a new Tensor. Inferred shape "+"(".concat(n,") does not match the provided ")+"shape (".concat(t,"). ")))}}return Kz(e)||Array.isArray(e)||(e=[e]),t=t||n,e="string"!==a?rU(e,a):Cz(e,[],!0),GU.makeTensor(e,t,a)}function sG(e,t,n){return rG(e,t,QU(e,n),n)}const oG={float32:4,float16:2,int32:4,uint16:2,uint8:1,bool:1,complex64:8},iG=4;async function cG(e,t){const n=[],a=[],r=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);for(let s=0;s<r.length;++s){const o=r[s],i=Array.isArray(e)?e[s].tensor:e[o];if("float32"!==i.dtype&&"int32"!==i.dtype&&"bool"!==i.dtype&&"string"!==i.dtype&&"complex64"!==i.dtype)throw new Error("Unsupported dtype in weight '".concat(o,"': ").concat(i.dtype));const c={name:o,shape:i.shape,dtype:i.dtype};if("string"===i.dtype){const e=new Promise((async e=>{const t=await i.bytes(),n=t.reduce(((e,t)=>e+t.length),0)+iG*t.length,a=new Uint8Array(n);let r=0;for(let s=0;s<t.length;s++){const e=t[s],n=new Uint8Array(new Uint32Array([e.length]).buffer);a.set(n,r),r+=iG,a.set(e,r),r+=e.length}e(a)}));a.push(e)}else a.push(i.data());null!=t&&(c.group=t),n.push(c)}return{data:uG(await Promise.all(a)),specs:n}}function lG(e,t){const n={};let a,r=0;for(const s of t){const t=s.name,o=s.dtype,i=s.shape,c=Rz(i);let l;if("quantization"in s){const n=s.quantization;if("uint8"===n.dtype||"uint16"===n.dtype){if(!("min"in n)||!("scale"in n))throw new Error("Weight ".concat(s.name," with quantization ").concat(n.dtype," ")+"doesn't have corresponding metadata min and scale.")}else{if("float16"!==n.dtype)throw new Error("Weight ".concat(s.name," has unknown ")+"quantization dtype ".concat(n.dtype,". ")+"Supported quantization dtypes are: 'uint8', 'uint16', and 'float16'.");if("float32"!==o)throw new Error("Weight ".concat(s.name," is quantized with ").concat(n.dtype," ")+"which only supports weights of type float32 not ".concat(o,"."))}const i=oG[n.dtype],u=e.slice(r,r+c*i),h="uint8"===n.dtype?new Uint8Array(u):new Uint16Array(u);if("float32"===o)if("uint8"===n.dtype||"uint16"===n.dtype){l=new Float32Array(h.length);for(let e=0;e<h.length;e++){const t=h[e];l[e]=t*n.scale+n.min}}else{if("float16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type float32.");void 0===a&&(a=xG()),l=a(h)}else{if("int32"!==o)throw new Error("Unsupported dtype in weight '".concat(t,"': ").concat(o));if("uint8"!==n.dtype&&"uint16"!==n.dtype)throw new Error("Unsupported quantization type ".concat(n.dtype," ")+"for weight type int32.");l=new Int32Array(h.length);for(let e=0;e<h.length;e++){const t=h[e];l[e]=Math.round(t*n.scale+n.min)}}r+=c*i}else if("string"===o){const t=Rz(s.shape);l=[];for(let n=0;n<t;n++){const t=new Uint32Array(e.slice(r,r+iG))[0];r+=iG;const n=new Uint8Array(e.slice(r,r+t));l.push(n),r+=t}}else{const a=oG[o],s=e.slice(r,r+c*a);if("float32"===o)l=new Float32Array(s);else if("int32"===o)l=new Int32Array(s);else if("bool"===o)l=new Uint8Array(s);else{if("complex64"!==o)throw new Error("Unsupported dtype in weight '".concat(t,"': ").concat(o));{l=new Float32Array(s);const e=new Float32Array(l.length/2),a=new Float32Array(l.length/2);for(let t=0;t<e.length;t++)e[t]=l[2*t],a[t]=l[2*t+1];const r=sG(e,i,"float32"),o=sG(a,i,"float32");n[t]=aG(r,o),r.dispose(),o.dispose()}}r+=c*a}"complex64"!==o&&(n[t]=sG(l,i,o))}return n}function uG(e){if(null===e)throw new Error("Invalid input value: ".concat(JSON.stringify(e)));let t=0;const n=[];e.forEach((e=>{if(t+=e.byteLength,n.push(e.byteLength===e.buffer.byteLength?e:new e.constructor(e)),!(e instanceof Float32Array||e instanceof Int32Array||e instanceof Uint8Array))throw new Error("Unsupported TypedArray subtype: ".concat(e.constructor.name))}));const a=new Uint8Array(t);let r=0;return n.forEach((e=>{a.set(new Uint8Array(e.buffer),r),r+=e.byteLength})),a.buffer}const hG="undefined"!==typeof Buffer&&("undefined"===typeof Blob||"undefined"===typeof atob||"undefined"===typeof btoa);function dG(e){return hG?Buffer.byteLength(e):new Blob([e]).size}function pG(e){if(1===e.length)return e[0];let t=0;e.forEach((e=>{t+=e.byteLength}));const n=new Uint8Array(t);let a=0;return e.forEach((e=>{n.set(new Uint8Array(e),a),a+=e.byteLength})),n.buffer}function fG(e){for(e=e.trim();e.endsWith("/");)e=e.slice(0,e.length-1);const t=e.split("/");return t[t.length-1]}function mG(e,t){const n={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,weightsManifest:t};return null!=e.signature&&(n.signature=e.signature),null!=e.userDefinedMetadata&&(n.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(n.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(n.trainingConfig=e.trainingConfig),n}function gG(e,t,n){const a={modelTopology:e.modelTopology,format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy};if(null!=e.trainingConfig&&(a.trainingConfig=e.trainingConfig),null!=e.weightsManifest){if(!t)throw new Error("modelJSON has weightsManifest but weightSpecs is null");if(!n)throw new Error("modelJSON has weightsManifest but weightData is null");a.weightSpecs=t,a.weightData=n}return null!=e.signature&&(a.signature=e.signature),null!=e.userDefinedMetadata&&(a.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(a.modelInitializer=e.modelInitializer),a}async function yG(e,t){let n,a;return null!=e.weightsManifest&&([n,a]=await t(e.weightsManifest)),gG(e,n,a)}function bG(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("Expected JSON model topology, received ArrayBuffer.");return{dateSaved:new Date,modelTopologyType:"JSON",modelTopologyBytes:null==e.modelTopology?0:dG(JSON.stringify(e.modelTopology)),weightSpecsBytes:null==e.weightSpecs?0:dG(JSON.stringify(e.weightSpecs)),weightDataBytes:null==e.weightData?0:e.weightData.byteLength}}function vG(e){const t=[];for(const n of e)t.push(...n.weights);return t}function xG(){const e=function(){const e=e=>{let t=e<<13,n=0;for(;0===(8388608&t);)n-=8388608,t<<=1;return t&=-8388609,n+=947912704,t|n},t=new Uint32Array(2048);t[0]=0;for(let n=1;n<1024;n++)t[n]=e(n);for(let n=1024;n<2048;n++)t[n]=939524096+(n-1024<<13);return t}(),t=function(){const e=new Uint32Array(64);e[0]=0,e[31]=1199570944,e[32]=2147483648,e[63]=3347054592;for(let t=1;t<31;t++)e[t]=t<<23;for(let t=33;t<63;t++)e[t]=2147483648+(t-32<<23);return e}(),n=function(){const e=new Uint32Array(64);for(let t=0;t<64;t++)e[t]=1024;return e[0]=e[32]=0,e}();return a=>{const r=new ArrayBuffer(4*a.length),s=new Uint32Array(r);for(let o=0;o<a.length;o++){const r=a[o],i=e[n[r>>10]+(1023&r)]+t[r>>10];s[o]=i}return new Float32Array(r)}}class wG{constructor(){this.saveRouters=[],this.loadRouters=[]}static getInstance(){return null==wG.instance&&(wG.instance=new wG),wG.instance}static registerSaveRouter(e){wG.getInstance().saveRouters.push(e)}static registerLoadRouter(e){wG.getInstance().loadRouters.push(e)}static getSaveHandlers(e){return wG.getHandlers(e,"save")}static getLoadHandlers(e,t){return wG.getHandlers(e,"load",t)}static getHandlers(e,t,n){const a=[];return("load"===t?wG.getInstance().loadRouters:wG.getInstance().saveRouters).forEach((t=>{const r=t(e,n);null!==r&&a.push(r)})),a}}const kG=e=>wG.registerSaveRouter(e),SG=e=>wG.registerLoadRouter(e),IG=e=>wG.getSaveHandlers(e),NG=(e,t)=>wG.getLoadHandlers(e,t),TG="tensorflowjs",EG="models_store",CG="model_info_store";function RG(){if(!fP().getBool("IS_BROWSER"))throw new Error("Failed to obtain IndexedDB factory because the current environmentis not a web browser.");const e="undefined"===typeof window?self:window,t=e.indexedDB||e.mozIndexedDB||e.webkitIndexedDB||e.msIndexedDB||e.shimIndexedDB;if(null==t)throw new Error("The current browser does not appear to support IndexedDB.");return t}function AG(e){const t=e.result;t.createObjectStore(EG,{keyPath:"modelPath"}),t.createObjectStore(CG,{keyPath:"modelPath"})}class _G{constructor(e){if(this.indexedDB=RG(),null==e||!e)throw new Error("For IndexedDB, modelPath must not be null, undefined or empty.");this.modelPath=e}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");return this.databaseAction(this.modelPath,e)}async load(){return this.databaseAction(this.modelPath)}databaseAction(e,t){return new Promise(((e,n)=>{const a=this.indexedDB.open(TG,1);a.onupgradeneeded=()=>AG(a),a.onsuccess=()=>{const r=a.result;if(null==t){const t=r.transaction(EG,"readonly"),a=t.objectStore(EG).get(this.modelPath);a.onsuccess=()=>{if(null==a.result)return r.close(),n(new Error("Cannot find model with path '".concat(this.modelPath,"' ")+"in IndexedDB."));e(a.result.modelArtifacts)},a.onerror=e=>(r.close(),n(a.error)),t.oncomplete=()=>r.close()}else{const a=bG(t),s=r.transaction(CG,"readwrite");let o=s.objectStore(CG);const i=o.put({modelPath:this.modelPath,modelArtifactsInfo:a});let c;i.onsuccess=()=>{c=r.transaction(EG,"readwrite");const i=c.objectStore(EG).put({modelPath:this.modelPath,modelArtifacts:t,modelArtifactsInfo:a});i.onsuccess=()=>e({modelArtifactsInfo:a}),i.onerror=e=>{o=s.objectStore(CG);const t=o.delete(this.modelPath);t.onsuccess=()=>(r.close(),n(i.error)),t.onerror=e=>(r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}}},a.onerror=e=>n(a.error)}))}}_G.URL_SCHEME="indexeddb://";const DG=e=>{return fP().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(_G.URL_SCHEME)?(t=e.slice(_G.URL_SCHEME.length),new _G(t)):null;var t};wG.registerSaveRouter(DG),wG.registerLoadRouter(DG);class FG{constructor(){this.indexedDB=RG()}async listModels(){return new Promise(((e,t)=>{const n=this.indexedDB.open(TG,1);n.onupgradeneeded=()=>AG(n),n.onsuccess=()=>{const a=n.result,r=a.transaction(CG,"readonly"),s=r.objectStore(CG).getAll();s.onsuccess=()=>{const t={};for(const e of s.result)t[e.modelPath]=e.modelArtifactsInfo;e(t)},s.onerror=e=>(a.close(),t(s.error)),r.oncomplete=()=>a.close()},n.onerror=e=>t(n.error)}))}async removeModel(e){var t;return e=(t=e).startsWith(_G.URL_SCHEME)?t.slice(_G.URL_SCHEME.length):t,new Promise(((t,n)=>{const a=this.indexedDB.open(TG,1);a.onupgradeneeded=()=>AG(a),a.onsuccess=()=>{const r=a.result,s=r.transaction(CG,"readwrite"),o=s.objectStore(CG),i=o.get(e);let c;i.onsuccess=()=>{if(null==i.result)return r.close(),n(new Error("Cannot find model with path '".concat(e,"' ")+"in IndexedDB."));{const a=o.delete(e),s=()=>{c=r.transaction(EG,"readwrite");const a=c.objectStore(EG).delete(e);a.onsuccess=()=>t(i.result.modelArtifactsInfo),a.onerror=e=>n(i.error)};a.onsuccess=s,a.onerror=e=>(s(),r.close(),n(i.error))}},i.onerror=e=>(r.close(),n(i.error)),s.oncomplete=()=>{null==c?r.close():c.oncomplete=()=>r.close()}},a.onerror=e=>n(a.error)}))}}const OG="/",MG="tensorflowjs_models",LG="info",zG="model_topology",PG="weight_specs",BG="weight_data",WG="model_metadata";function VG(e){return{info:[MG,e,LG].join(OG),topology:[MG,e,zG].join(OG),weightSpecs:[MG,e,PG].join(OG),weightData:[MG,e,BG].join(OG),modelMetadata:[MG,e,WG].join(OG)}}function UG(e){for(const t of Object.values(e))window.localStorage.removeItem(t)}function GG(e){const t=e.split(OG);if(t.length<3)throw new Error("Invalid key format: ".concat(e));return t.slice(1,t.length-1).join(OG)}class HG{constructor(e){if(!fP().getBool("IS_BROWSER")||"undefined"===typeof window||"undefined"===typeof window.localStorage)throw new Error("The current environment does not support local storage.");if(this.LS=window.localStorage,null==e||!e)throw new Error("For local storage, modelPath must not be null, undefined or empty.");this.modelPath=e,this.keys=VG(this.modelPath)}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserLocalStorage.save() does not support saving model topology in binary formats yet.");{const t=JSON.stringify(e.modelTopology),n=JSON.stringify(e.weightSpecs),a=bG(e);try{this.LS.setItem(this.keys.info,JSON.stringify(a)),this.LS.setItem(this.keys.topology,t),this.LS.setItem(this.keys.weightSpecs,n),this.LS.setItem(this.keys.weightData,function(e){if(hG)return Buffer.from(e).toString("base64");const t=new Uint8Array(e);let n="";for(let a=0,r=t.length;a<r;a++)n+=String.fromCharCode(t[a]);return btoa(n)}(e.weightData));const r={format:e.format,generatedBy:e.generatedBy,convertedBy:e.convertedBy,signature:null!=e.signature?e.signature:void 0,userDefinedMetadata:null!=e.userDefinedMetadata?e.userDefinedMetadata:void 0,modelInitializer:null!=e.modelInitializer?e.modelInitializer:void 0,trainingConfig:null!=e.trainingConfig?e.trainingConfig:void 0};return this.LS.setItem(this.keys.modelMetadata,JSON.stringify(r)),{modelArtifactsInfo:a}}catch(o1){throw UG(this.keys),new Error("Failed to save model '".concat(this.modelPath,"' to local storage: ")+"size quota being exceeded is a possible cause of this failure: "+"modelTopologyBytes=".concat(a.modelTopologyBytes,", ")+"weightSpecsBytes=".concat(a.weightSpecsBytes,", ")+"weightDataBytes=".concat(a.weightDataBytes,"."))}}}async load(){const e=JSON.parse(this.LS.getItem(this.keys.info));if(null==e)throw new Error("In local storage, there is no model with name '".concat(this.modelPath,"'"));if("JSON"!==e.modelTopologyType)throw new Error("BrowserLocalStorage does not support loading non-JSON model topology yet.");const t={},n=JSON.parse(this.LS.getItem(this.keys.topology));if(null==n)throw new Error("In local storage, the topology of model '".concat(this.modelPath,"' ")+"is missing.");t.modelTopology=n;const a=JSON.parse(this.LS.getItem(this.keys.weightSpecs));if(null==a)throw new Error("In local storage, the weight specs of model '".concat(this.modelPath,"' ")+"are missing.");t.weightSpecs=a;const r=this.LS.getItem(this.keys.modelMetadata);if(null!=r){const e=JSON.parse(r);t.format=e.format,t.generatedBy=e.generatedBy,t.convertedBy=e.convertedBy,null!=e.signature&&(t.signature=e.signature),null!=e.userDefinedMetadata&&(t.userDefinedMetadata=e.userDefinedMetadata),null!=e.modelInitializer&&(t.modelInitializer=e.modelInitializer),null!=e.trainingConfig&&(t.trainingConfig=e.trainingConfig)}const s=this.LS.getItem(this.keys.weightData);if(null==s)throw new Error("In local storage, the binary weight values of model "+"'".concat(this.modelPath,"' are missing."));return t.weightData=function(e){if(hG){const t=Buffer.from(e,"base64");return t.buffer.slice(t.byteOffset,t.byteOffset+t.byteLength)}const t=atob(e),n=new Uint8Array(t.length);for(let a=0;a<t.length;++a)n.set([t.charCodeAt(a)],a);return n.buffer}(s),t}}HG.URL_SCHEME="localstorage://";const jG=e=>{return fP().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(HG.URL_SCHEME)?(t=e.slice(HG.URL_SCHEME.length),new HG(t)):null;var t};wG.registerSaveRouter(jG),wG.registerLoadRouter(jG);class KG{constructor(){Nz(fP().getBool("IS_BROWSER"),(()=>"Current environment is not a web browser")),Nz("undefined"===typeof window||"undefined"!==typeof window.localStorage,(()=>"Current browser does not appear to support localStorage")),this.LS=window.localStorage}async listModels(){const e={},t=MG+OG,n=OG+LG;for(let a=0;a<this.LS.length;++a){const r=this.LS.key(a);if(r.startsWith(t)&&r.endsWith(n)){e[GG(r)]=JSON.parse(this.LS.getItem(r))}}return e}async removeModel(e){var t;const n=VG(e=(t=e).startsWith(HG.URL_SCHEME)?t.slice(HG.URL_SCHEME.length):t);if(null==this.LS.getItem(n.info))throw new Error("Cannot find model at path '".concat(e,"'"));const a=JSON.parse(this.LS.getItem(n.info));return UG(n),a}}const qG="://";class XG{constructor(){this.managers={}}static getInstance(){return null==XG.instance&&(XG.instance=new XG),XG.instance}static registerManager(e,t){Nz(null!=e,(()=>"scheme must not be undefined or null.")),e.endsWith(qG)&&(e=e.slice(0,e.indexOf(qG))),Nz(e.length>0,(()=>"scheme must not be an empty string."));const n=XG.getInstance();Nz(null==n.managers[e],(()=>"A model store manager is already registered for scheme '".concat(e,"'."))),n.managers[e]=t}static getManager(e){const t=XG.getInstance().managers[e];if(null==t)throw new Error("Cannot find model manager for scheme '".concat(e,"'"));return t}static getSchemes(){return Object.keys(XG.getInstance().managers)}}function YG(e){if(-1===e.indexOf(qG))throw new Error("The url string provided does not contain a scheme. Supported schemes are: "+"".concat(XG.getSchemes().join(",")));return{scheme:e.split(qG)[0],path:e.split(qG)[1]}}async function QG(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];Nz(e!==t,(()=>"Old path and new path are the same: '".concat(e,"'")));const a=wG.getLoadHandlers(e);Nz(a.length>0,(()=>"Copying failed because no load handler is found for source URL ".concat(e,"."))),Nz(a.length<2,(()=>"Copying failed because more than one (".concat(a.length,") ")+"load handlers for source URL ".concat(e,".")));const r=a[0],s=wG.getSaveHandlers(t);Nz(s.length>0,(()=>"Copying failed because no save handler is found for destination "+"URL ".concat(t,"."))),Nz(s.length<2,(()=>"Copying failed because more than one (".concat(a.length,") ")+"save handlers for destination URL ".concat(t,".")));const o=s[0],i=YG(e).scheme,c=YG(e).path,l=i===YG(e).scheme,u=await r.load();n&&l&&await XG.getManager(i).removeModel(c);const h=await o.save(u);return n&&!l&&await XG.getManager(i).removeModel(c),h.modelArtifactsInfo}async function JG(){const e=XG.getSchemes(),t={};for(const n of e){const e=await XG.getManager(n).listModels();for(const a in e){t[n+qG+a]=e[a]}}return t}async function ZG(e){const t=YG(e);return XG.getManager(t.scheme).removeModel(t.path)}async function $G(e,t){return QG(e,t,!1)}async function eH(e,t){return QG(e,t,!0)}class tH{constructor(){this.messageName="setTimeoutCustom",this.functionRefs=[],this.handledMessageCount=0,this.hasEventListener=!1}fetch(e,t){return fetch(e,t)}now(){return performance.now()}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Browser's encoder only supports utf-8, but got ".concat(t));return null==this.textEncoder&&(this.textEncoder=new TextEncoder),this.textEncoder.encode(e)}decode(e,t){return new TextDecoder(t).decode(e)}setTimeoutCustom(e,t){window&&fP().getBool("USE_SETTIMEOUTCUSTOM")?(this.functionRefs.push(e),setTimeout((()=>{window.postMessage({name:this.messageName,index:this.functionRefs.length-1},"*")}),t),this.hasEventListener||(this.hasEventListener=!0,window.addEventListener("message",(e=>{if(e.source===window&&e.data.name===this.messageName){e.stopPropagation();(0,this.functionRefs[e.data.index])(),this.handledMessageCount++,this.handledMessageCount===this.functionRefs.length&&(this.functionRefs=[],this.handledMessageCount=0)}}),!0))):setTimeout(e,t)}}if(fP().get("IS_BROWSER")){fP().setPlatform("browser",new tH);try{XG.registerManager(HG.URL_SCHEME,new KG)}catch(o1){}try{XG.registerManager(_G.URL_SCHEME,new FG)}catch(o1){}}const nH=()=>n(817);let aH;class rH{constructor(){this.util=n(590),this.textEncoder=new this.util.TextEncoder}fetch(e,t){return null!=fP().global.fetch?fP().global.fetch(e,t):(null==aH&&(aH=nH()),aH(e,t))}now(){const e=process.hrtime();return 1e3*e[0]+e[1]/1e6}encode(e,t){if("utf-8"!==t&&"utf8"!==t)throw new Error("Node built-in encoder only supports utf-8, but got ".concat(t));return this.textEncoder.encode(e)}decode(e,t){return 0===e.length?"":new this.util.TextDecoder(t).decode(e)}}function sH(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32",n=arguments.length>2?arguments[2]:void 0;return t=t||"float32",iP(e),new xU(e,t,n)}fP().get("IS_NODE")&&!fP().get("IS_BROWSER")&&fP().setPlatform("node",new rH);const oH=nG({cast_:function(e,t){const n=$U(e,"x","cast");if(!Hz(t))throw new Error("Failed to cast to unknown dtype ".concat(t));if("string"===t&&"string"!==n.dtype||"string"!==t&&"string"===n.dtype)throw new Error("Only strings can be casted to strings");const a={x:n},r={dtype:t};return GU.runKernel(UP,a,r)}});const iH=nG({clone_:function(e){const t={x:$U(e,"x","clone","string_or_numeric")};return GU.runKernel(FB,t)}});function cH(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];console.log(e.toString(t))}UU();!function(e){kU=e}({buffer:sH,cast:oH,clone:iH,print:cH});function lH(e){return new Promise((e=>setTimeout(e))).then(e)}class uH{constructor(e){if(!fP().getBool("IS_BROWSER"))throw new Error("browserDownloads() cannot proceed because the current environment is not a browser.");e.startsWith(uH.URL_SCHEME)&&(e=e.slice(uH.URL_SCHEME.length)),null!=e&&0!==e.length||(e="model"),this.modelJsonFileName=e+".json",this.weightDataFileName=e+".weights.bin"}async save(e){if("undefined"===typeof document)throw new Error("Browser downloads are not supported in this environment since `document` is not present");const t=window.URL.createObjectURL(new Blob([e.weightData],{type:"application/octet-stream"}));if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserDownloads.save() does not support saving model topology in binary formats yet.");{const n=mG(e,[{paths:["./"+this.weightDataFileName],weights:e.weightSpecs}]),a=window.URL.createObjectURL(new Blob([JSON.stringify(n)],{type:"application/json"})),r=null==this.modelJsonAnchor?document.createElement("a"):this.modelJsonAnchor;if(r.download=this.modelJsonFileName,r.href=a,await lH((()=>r.dispatchEvent(new MouseEvent("click")))),null!=e.weightData){const e=null==this.weightDataAnchor?document.createElement("a"):this.weightDataAnchor;e.download=this.weightDataFileName,e.href=t,await lH((()=>e.dispatchEvent(new MouseEvent("click"))))}return{modelArtifactsInfo:bG(e)}}}}uH.URL_SCHEME="downloads://";class hH{constructor(e){if(null==e||e.length<1)throw new Error("When calling browserFiles, at least 1 file is required, "+"but received ".concat(e));this.jsonFile=e[0],this.weightsFiles=e.slice(1)}async load(){return new Promise(((e,t)=>{const n=new FileReader;n.onload=n=>{const a=JSON.parse(n.target.result),r=a.modelTopology;if(null==r)return void t(new Error("modelTopology field is missing from file ".concat(this.jsonFile.name)));if(null==a.weightsManifest)return void t(new Error("weightManifest field is missing from file ".concat(this.jsonFile.name)));if(0===this.weightsFiles.length)return void e({modelTopology:r});const s=yG(a,(e=>this.loadWeights(e)));e(s)},n.onerror=e=>t("Failed to read model topology and weights manifest JSON "+"from file '".concat(this.jsonFile.name,"'. BrowserFiles supports loading ")+"Keras-style tf.Model artifacts only."),n.readAsText(this.jsonFile)}))}loadWeights(e){const t=[],n=[];for(const s of e)t.push(...s.weights),n.push(...s.paths);const a=this.checkManifestAndWeightFiles(e),r=n.map((e=>this.loadWeightsFile(e,a[e])));return Promise.all(r).then((e=>[t,pG(e)]))}loadWeightsFile(e,t){return new Promise(((n,a)=>{const r=new FileReader;r.onload=e=>{const t=e.target.result;n(t)},r.onerror=t=>a("Failed to weights data from file of path '".concat(e,"'.")),r.readAsArrayBuffer(t)}))}checkManifestAndWeightFiles(e){const t=[],n=this.weightsFiles.map((e=>fG(e.name))),a={};for(const r of e)r.paths.forEach((e=>{const r=fG(e);if(-1!==t.indexOf(r))throw new Error("Duplicate file basename found in weights manifest: "+"'".concat(r,"'"));if(t.push(r),-1===n.indexOf(r))throw new Error("Weight file with basename '".concat(r,"' is not provided."));a[e]=this.weightsFiles[n.indexOf(r)]}));if(t.length!==this.weightsFiles.length)throw new Error("Mismatch in the number of files in weights manifest "+"(".concat(t.length,") and the number of weight files provided ")+"(".concat(this.weightsFiles.length,")."));return a}}function dH(e){return new hH(e)}function pH(e,t,n,a){!function(e){Nz(null!=e&&Array.isArray(e)&&e.length>0,(()=>"promises must be a none empty array"))}(e),function(e,t){Nz(e>=0&&e<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got startFraction ".concat(e))),Nz(t>=0&&t<=1,(()=>"Progress fraction must be in range [0, 1], but "+"got endFraction ".concat(t))),Nz(t>=e,(()=>"startFraction must be no more than endFraction, but "+"got startFraction ".concat(e," and endFraction ")+"".concat(t)))}(n=null==n?0:n,a=null==a?1:a);let r=0;return Promise.all(e.map((s=>(s.then((s=>{const o=n+ ++r/e.length*(a-n);return t(o),s})),s))))}async function fH(e,t){null==t&&(t={});const n=null==t.fetchFunc?fP().platform.fetch:t.fetchFunc,a=e.map((e=>n(e,t.requestInit,{isBinary:!0}))),r=(null==t.onProgress?await Promise.all(a):await pH(a,t.onProgress,0,.5)).map((e=>e.arrayBuffer()));return null==t.onProgress?await Promise.all(r):await pH(r,t.onProgress,.5,1)}async function mH(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return gH((e=>fH(e,{requestInit:a})))(e,t,n)}function gH(e){return async function(t){let n=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"",a=arguments.length>2?arguments[2]:void 0;const r=t.map((()=>!1)),s={},o=null!=a?a.map((()=>!1)):[],i=[];if(t.forEach(((e,t)=>{let n=0;e.weights.forEach((e=>{const c="quantization"in e?e.quantization.dtype:e.dtype,l=oG[c]*Rz(e.shape),u=()=>{r[t]=!0,null==s[t]&&(s[t]=[]),s[t].push({manifestEntry:e,groupOffset:n,sizeBytes:l})};null!=a?a.forEach(((t,n)=>{t===e.name&&(u(),o[n]=!0)})):u(),i.push(e.name),n+=l}))})),!o.every((e=>e))){const e=a.filter(((e,t)=>!o[t]));throw new Error("Could not find weights in manifest with names: "+"".concat(e.join(", "),". \n")+"Manifest JSON has weights with names: "+"".concat(i.join(", "),"."))}const c=r.reduce(((e,t,n)=>(t&&e.push(n),e)),[]),l=[];c.forEach((e=>{t[e].paths.forEach((e=>{const t=n+(n.endsWith("/")?"":"/")+e;l.push(t)}))}));const u=await e(l),h={};let d=0;return c.forEach((e=>{const n=t[e].paths.length;let a=0;for(let t=0;t<n;t++)a+=u[d+t].byteLength;const r=new ArrayBuffer(a),o=new Uint8Array(r);let i=0;for(let t=0;t<n;t++){const e=new Uint8Array(u[d+t]);o.set(e,i),i+=e.byteLength}s[e].forEach((e=>{const t=lG(r.slice(e.groupOffset,e.groupOffset+e.sizeBytes),[e.manifestEntry]);for(const n in t)h[n]=t[n]})),d+=n})),h}}wG.registerSaveRouter((e=>fP().getBool("IS_BROWSER")&&!Array.isArray(e)&&e.startsWith(uH.URL_SCHEME)?function(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"model";return new uH(e)}(e.slice(uH.URL_SCHEME.length)):null));class yH{constructor(e,t){if(this.DEFAULT_METHOD="POST",null==t&&(t={}),this.weightPathPrefix=t.weightPathPrefix,this.onProgress=t.onProgress,this.weightUrlConverter=t.weightUrlConverter,null!=t.fetchFunc?(Nz("function"===typeof t.fetchFunc,(()=>"Must pass a function that matches the signature of `fetch` (see https://developer.mozilla.org/en-US/docs/Web/API/Fetch_API)")),this.fetch=t.fetchFunc):this.fetch=fP().platform.fetch,Nz(null!=e&&e.length>0,(()=>"URL path for http must not be null, undefined or empty.")),Array.isArray(e)&&Nz(2===e.length,(()=>"URL paths for http must have a length of 2, "+"(actual length is ".concat(e.length,")."))),this.path=e,null!=t.requestInit&&null!=t.requestInit.body)throw new Error("requestInit is expected to have no pre-existing body, but has one.");this.requestInit=t.requestInit||{}}async save(e){if(e.modelTopology instanceof ArrayBuffer)throw new Error("BrowserHTTPRequest.save() does not support saving model topology in binary formats yet.");const t=Object.assign({method:this.DEFAULT_METHOD},this.requestInit);t.body=new FormData;const n=mG(e,[{paths:["./model.weights.bin"],weights:e.weightSpecs}]);t.body.append("model.json",new Blob([JSON.stringify(n)],{type:"application/json"}),"model.json"),null!=e.weightData&&t.body.append("model.weights.bin",new Blob([e.weightData],{type:"application/octet-stream"}),"model.weights.bin");const a=await this.fetch(this.path,t);if(a.ok)return{modelArtifactsInfo:bG(e),responses:[a]};throw new Error("BrowserHTTPRequest.save() failed due to HTTP response status "+"".concat(a.status,"."))}async load(){const e=await this.fetch(this.path,this.requestInit);if(!e.ok)throw new Error("Request to ".concat(this.path," failed with status code ")+"".concat(e.status,". Please verify this URL points to ")+"the model JSON of the model to load.");let t;try{t=await e.json()}catch(r){let e="Failed to parse model JSON of response from ".concat(this.path,".");throw this.path.endsWith(".pb")?e+=" Your path contains a .pb file extension. Support for .pb models have been removed in TensorFlow.js 1.0 in favor of .json models. You can re-convert your Python TensorFlow model using the TensorFlow.js 1.0 conversion scripts or you can convert your.pb models with the 'pb2json'NPM script in the tensorflow/tfjs-converter repository.":e+=" Please make sure the server is serving valid JSON for this request.",new Error(e)}const n=t.modelTopology,a=t.weightsManifest;if(null==n&&null==a)throw new Error("The JSON from HTTP path ".concat(this.path," contains neither model ")+"topology or manifest for weights.");return yG(t,(e=>this.loadWeights(e)))}async loadWeights(e){const t=Array.isArray(this.path)?this.path[1]:this.path,[n,a]=function(e){const t=e.lastIndexOf("/"),n=e.lastIndexOf("?"),a=e.substring(0,t),r=n>t?e.substring(n):"";return[a+"/",r]}(t),r=this.weightPathPrefix||n,s=vG(e),o=[],i=[];for(const c of e)for(const e of c.paths)null!=this.weightUrlConverter?i.push(this.weightUrlConverter(e)):o.push(r+e+a);this.weightUrlConverter&&o.push(...await Promise.all(i));return[s,pG(await fH(o,{requestInit:this.requestInit,fetchFunc:this.fetch,onProgress:this.onProgress}))]}}function bH(e){return null!=e.match(yH.URL_SCHEME_REGEX)}yH.URL_SCHEME_REGEX=/^https?:\/\//;const vH=(e,t)=>{if("undefined"===typeof fetch&&(null==t||null==t.fetchFunc))return null;{let n=!0;if(n=Array.isArray(e)?e.every((e=>bH(e))):bH(e),n)return xH(e,t)}return null};function xH(e,t){return new yH(e,t)}function wH(e,t){return xH(e,t)}wG.registerSaveRouter(vH),wG.registerLoadRouter(vH);class kH{constructor(e){this.modelArtifacts=e}load(){return this.modelArtifacts}}class SH{constructor(e){this.saveHandler=e}save(e){return this.saveHandler(e)}}class IH{constructor(e){e.load&&(this.load=()=>Promise.resolve(e.load())),e.save&&(this.save=t=>Promise.resolve(e.save(t)))}}function NH(e,t,n,a){return new IH(TH(...arguments))}function TH(e,t,n,a){if(1===arguments.length){return null!=e.modelTopology||null!=e.weightSpecs?new kH(e):(console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new kH({modelTopology:e}))}return console.warn("Please call tf.io.fromMemory() with only one argument. The argument should be of type ModelArtifacts. The multi-argument signature of tf.io.fromMemory() has been deprecated and will be removed in a future release."),new kH({modelTopology:e,weightSpecs:t,weightData:n,trainingConfig:a})}function EH(e){return new SH(e)}function CH(e){return new SH(e)}const RH=nG({matMul_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=$U(e,"a","matMul"),s=$U(t,"b","matMul");[r,s]=OU(r,s);const o={a:r,b:s},i={transposeA:n,transposeB:a};return GU.runKernel(zP,o,i)}});const AH=nG({oneHot_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"int32";if(t<2)throw new Error("Error in oneHot: depth must be >=2, but it is ".concat(t));const s={indices:$U(e,"indices","oneHot","int32")},o={dtype:r,depth:t,onValue:n,offValue:a};return GU.runKernel(vW,s,o)}});function _H(){fP().set("PROD",!0)}function DH(){fP().set("DEBUG",!0)}function FH(){fP().set("DEPRECATION_WARNINGS_ENABLED",!1),console.warn("TensorFlow.js deprecation warnings have been disabled.")}function OH(e){fP().getBool("DEPRECATION_WARNINGS_ENABLED")&&console.warn(e+" You can disable deprecation warnings with tf.disableDeprecationWarnings().")}function MH(){GU.disposeVariables()}function LH(){return GU}function zH(){return GU.memory()}function PH(e){return GU.profile(e)}function BH(e,t){return GU.tidy(e,t)}function WH(e){zU(e).forEach((e=>e.dispose()))}function VH(e){return GU.keep(e)}function UH(e){return GU.time(e)}function GH(e){return GU.setBackend(e)}function HH(){return GU.ready()}function jH(){return GU.backendName}function KH(e){GU.removeBackend(e)}function qH(e){return GU.findBackend(e)}function XH(e){return GU.findBackendFactory(e)}function YH(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;return GU.registerBackend(e,t,n)}function QH(){return GU.backend}function JH(e,t){fP().setPlatform(e,t)}!function(e){SU=e}(OH);const ZH=nG({imag_:function(e){const t={input:$U(e,"input","imag")};return GU.runKernel(MB,t)}});const $H=nG({neg_:function(e){const t={x:$U(e,"x","neg")};return GU.runKernel(pW,t)}});const ej=nG({real_:function(e){const t={input:$U(e,"input","real")};return GU.runKernel(RW,t)}});const tj=nG({transpose_:function(e,t,n){const a=$U(e,"x","transpose");if(null==t&&(t=a.shape.map(((e,t)=>t)).reverse()),Nz(a.rank===t.length,(()=>"Error in transpose: rank of input ".concat(a.rank," ")+"must match length of perm ".concat(t,"."))),t.forEach((e=>{Nz(e>=0&&e<a.rank,(()=>"All entries in 'perm' must be between 0 and ".concat(a.rank-1)+" but got ".concat(t)))})),a.rank<=1)return a.clone();const r={x:a},s={perm:t};return"complex64"===a.dtype?BH((()=>{let e=ej(a),t=ZH(a);return e=GU.runKernel(vV,{x:e},s),t=GU.runKernel(vV,{x:t},s),n&&(t=$H(t)),aG(e,t)})):GU.runKernel(vV,r,s)}});const nj=nG({confusionMatrix_:function(e,t,n){const a=$U(e,"labels","confusionMatrix"),r=$U(t,"predictions","confusionMatrix");Nz(null==n||n>0&&Number.isInteger(n),(()=>"If provided, numClasses must be a positive integer, "+"but got ".concat(n))),Nz(1===a.rank,(()=>"Expected the rank of labels to be 1, but got ".concat(a.rank))),Nz(1===r.rank,(()=>"Expected the rank of predictions to be 1, "+"but got ".concat(r.rank))),Nz(a.shape[0]===r.shape[0],(()=>"Mismatch in the number of examples: "+"".concat(a.shape[0]," vs. ").concat(r.shape[0],". ")+"Labels and predictions should have the same number of elements.")),Nz(n>0&&Number.isInteger(n),(()=>"numClasses is required to be a positive integer, but got "+"".concat(n)));const s=AH(oH(a,"int32"),n),o=AH(oH(r,"int32"),n),i=tj(s),c=RH(i,o);return oH(c,"int32")}});function aj(e,t){const n=e.length,a=[];for(let r=0;r<n;r++){const s=n-1-r,o=e[s]||1;(t[t.length-1-r]||1)>1&&1===o&&a.unshift(s)}return a}function rj(e,t){const n=[];for(let a=0;a<t.length;a++){const r=e[e.length-a-1],s=t.length-a-1,o=t[s];(null==r||1===r&&o>1)&&n.unshift(s)}return n}function sj(e,t){const n=[],a=Math.max(e.length,t.length);for(let r=0;r<a;r++){let a=e[e.length-r-1];null==a&&(a=1);let s=t[t.length-r-1];if(null==s&&(s=1),1===a)n.unshift(s);else if(1===s)n.unshift(a);else{if(a!==s){const n="Operands could not be broadcast together with shapes "+"".concat(e," and ").concat(t,".");throw Error(n)}n.unshift(a)}}return n}function oj(e,t,n){if(Ez(e),null!=t&&3!==t.length)throw new Error("tensor3d() requires shape to have three numbers");const a=QU(e,n);if(3!==a.length&&1!==a.length)throw new Error("tensor3d() requires values to be number[][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor3d() requires shape to be provided when `values` are a flat array");return rG(e,t,a,n)}let ij;function cj(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3;if(t>4)throw new Error("Cannot construct Tensor with more than 4 channels from pixels.");if(null==e)throw new Error("pixels passed to tf.browser.fromPixels() can not be null");let n=!1,a=!1,r=!1,s=!1,o=!1,i=!1;if(e.data instanceof Uint8Array)n=!0;else if("undefined"!==typeof ImageData&&e instanceof ImageData)a=!0;else if("undefined"!==typeof HTMLVideoElement&&e instanceof HTMLVideoElement)r=!0;else if("undefined"!==typeof HTMLImageElement&&e instanceof HTMLImageElement)s=!0;else if(null!=e.getContext)o=!0;else{if(!("undefined"!==typeof ImageBitmap&&e instanceof ImageBitmap))throw new Error("pixels passed to tf.browser.fromPixels() must be either an HTMLVideoElement, HTMLImageElement, HTMLCanvasElement, ImageData in browser, or OffscreenCanvas, ImageData in webworker or {data: Uint32Array, width: number, height: number}, "+"but was ".concat(e.constructor.name));i=!0}if(null!=MV(TV,GU.backendName)){const n={pixels:e},a={numChannels:t};return GU.runKernel(TV,n,a)}const[c,l]=r?[e.videoWidth,e.videoHeight]:[e.width,e.height];let u,h;if(o)u=e.getContext("2d").getImageData(0,0,c,l).data;else if(a||n)u=e.data;else if(s||r||i){if(null==ij)if("undefined"===typeof document){if("undefined"===typeof OffscreenCanvas||"undefined"===typeof OffscreenCanvasRenderingContext2D)throw new Error("Cannot parse input in current context. Reason: OffscreenCanvas Context2D rendering is not supported.");ij=new OffscreenCanvas(1,1).getContext("2d")}else ij=document.createElement("canvas").getContext("2d",{willReadFrequently:!0});ij.canvas.width=c,ij.canvas.height=l,ij.drawImage(e,0,0,c,l),u=ij.getImageData(0,0,c,l).data}if(4===t)h=new Int32Array(u);else{const e=c*l;h=new Int32Array(e*t);for(let n=0;n<e;n++)for(let e=0;e<t;++e)h[n*t+e]=u[4*n+e]}return oj(h,[l,c,t],"int32")}function lj(e){return"undefined"!==typeof window&&"undefined"!==typeof ImageBitmap&&window.hasOwnProperty("createImageBitmap")&&!(e instanceof ImageBitmap)&&function(e){return null!=e&&0!==e.width&&0!==e.height}(e)&&!function(e){return null!=e&&e.data instanceof Uint8Array}(e)}async function uj(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:3,n=null;if(fP().getBool("WRAP_TO_IMAGEBITMAP")&&lj(e)){let t;try{t=await createImageBitmap(e,{premultiplyAlpha:"none"})}catch(a){t=null}n=null!=t&&t.width===e.width&&t.height===e.height?t:e}else n=e;return cj(n,t)}async function hj(e,t){let n=$U(e,"img","toPixels");if(!(e instanceof IU)){const e=n;n=oH(e,"int32"),e.dispose()}if(2!==n.rank&&3!==n.rank)throw new Error("toPixels only supports rank 2 or 3 tensors, got rank ".concat(n.rank,"."));const[a,r]=n.shape.slice(0,2),s=2===n.rank?1:n.shape[2];if(s>4||2===s)throw new Error("toPixels only supports depth of size "+"1, 3 or 4 but got ".concat(s));if("float32"!==n.dtype&&"int32"!==n.dtype)throw new Error("Unsupported type for toPixels: ".concat(n.dtype,".")+" Please use float32 or int32 tensors.");const o=await n.data(),i="float32"===n.dtype?255:1,c=new Uint8ClampedArray(r*a*4);for(let l=0;l<a*r;++l){const e=[0,0,0,255];for(let a=0;a<s;a++){const t=o[l*s+a];if("float32"===n.dtype){if(t<0||t>1)throw new Error("Tensor values for a float32 Tensor must be in the "+"range [0 - 1] but encountered ".concat(t,"."))}else if("int32"===n.dtype&&(t<0||t>255))throw new Error("Tensor values for a int32 Tensor must be in the "+"range [0 - 255] but encountered ".concat(t,"."));1===s?(e[0]=t*i,e[1]=t*i,e[2]=t*i):e[a]=t*i}const t=4*l;c[t+0]=Math.round(e[0]),c[t+1]=Math.round(e[1]),c[t+2]=Math.round(e[2]),c[t+3]=Math.round(e[3])}if(null!=t){t.width=r,t.height=a;const e=t.getContext("2d"),n=new ImageData(c,r,a);e.putImageData(n,0,0)}return n!==e&&n.dispose(),c}const dj=nG({fromPixels_:cj});function pj(e,t){const n=e.shape.length,a=t.shape.length;if(n<1)throw new Error("tf.gatherND() expects the input to be rank 1 or higher,"+" but the rank was ".concat(n,"."));if(a<1)throw new Error("tf.gatherND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(a,"."));if("int32"!==t.dtype)throw new Error("tf.gatherND() expects the indices to be int32 type,"+" but the dtype was ".concat(t.dtype,"."));if(t.shape[a-1]>n)throw new Error("index innermost dimension length must be <= tensor rank; saw: "+"".concat(t.shape[a-1]," vs. ").concat(n));if(0===Rz(e.shape))throw new Error("Requested more than 0 entries, but input is empty."+" Input shape: ".concat(e.shape,"."));const r=t.shape,s=r[r.length-1];let o=1;for(let h=0;h<r.length-1;++h)o*=r[h];const i=e.shape,c=r.slice();c.pop();let l=1;for(let h=s;h<n;++h)l*=i[h],c.push(i[h]);const u=[...tP(e.shape).map((e=>e/l)),1].slice(0,s);return[c,o,l,u]}function fj(e,t,n){const a=t.rank>1?t.shape[t.rank-1]:1,r=t.rank>1?t.rank-1:1,s="Must have updates.shape = indices.shape[:batchDim] + "+"shape[sliceDim:], got updates.shape: ".concat(n.shape)+", indices.shape: ".concat(t.shape,", shape: ").concat(e)+", sliceDim: ".concat(a,", and batchDim: ").concat(r,".");if(n.rank<r)throw new Error(s+" update.rank < ".concat(r,". "));if(e.length<a+(n.rank-r))throw new Error(s+" Output shape length < ".concat(a+(n.rank-r)));if(n.rank!==r+e.length-a)throw new Error(s+" update.rank != ".concat(r+e.length-a));for(let o=0;o<r;++o)if(n.shape[o]!==t.shape[o])throw new Error(s+" updates.shape[".concat(o,"] (").concat(n.shape[o],") != indices.shape[").concat(o,"] (").concat(t.shape[o],")."));for(let o=0;o<n.rank-r;++o)if(n.shape[o+r]!==e[o+a])throw new Error(s+" updates.shape[".concat(o+r,"] (").concat(n.shape[o+r],") != shape[").concat(o+r,"] (").concat(e[o+r],")"))}function mj(e,t,n){if(t.rank<1)throw new Error("tf.scatterND() expects the indices to be rank 1 or higher,"+" but the rank was ".concat(t.rank,"."));if(e.rank<1)throw new Error("tf.scatterND() expects the updates to be rank 1 or higher,"+" but the rank was ".concat(e.rank,"."));if("int32"!==t.dtype)throw new Error("The dtype of 'indices' should be int32, but got dtype: ".concat(t.dtype));if(n.length<1)throw new Error("Output rank must be greater or equal to 1, but got shape: ".concat(n));if(0===n.length){if(0===t.size)throw new Error("Indices specified for empty output. indices shape: ".concat(t.shape));if(0===e.size)throw new Error("Updates specified for empty output. updates shape: ".concat(e.shape))}fj(n,t,e)}function gj(e,t,n){const a=t.shape.length,r=a>1?t.shape[a-1]:1,s=n.length;let o=1;for(let c=r;c<s;++c)o*=n[c];const i=r<1?1:r;return{sliceRank:r,numUpdates:Rz(t.shape)/i,sliceSize:o,strides:[...tP(n.slice(0,r)),1],outputSize:Rz(n)}}const yj=-2,bj=-1;function vj(e,t,n){const a=e.shape.length;Nz(a===t.length,(()=>"Error in slice".concat(a,"D: Length of begin ").concat(t," must ")+"match the rank of the array (".concat(a,")."))),Nz(a===n.length,(()=>"Error in slice".concat(a,"D: Length of size ").concat(n," must ")+"match the rank of the array (".concat(a,").")));for(let r=0;r<a;++r)Nz(t[r]+n[r]<=e.shape[r],(()=>"Error in slice".concat(a,"D: begin[").concat(r,"] + size[").concat(r,"] ")+"(".concat(t[r]+n[r],") would overflow input.shape[").concat(r,"] (").concat(e.shape[r],")")))}function xj(e){const t=[];let n=0;for(;e>0;)1&e&&t.push(n),e/=2,n++;return t}function wj(e,t,n){const a=[];for(let r=0;r<e.length;r++)a[r]=Math.ceil((t[r]-e[r])/n[r]);return a}function kj(e,t,n,a){const r=[...e];for(let s=r.length;s<a.length;s++)r.push(1);for(let s=0;s<n;s++)0===s?r[t]=1:(r.splice(t,0,1),r.pop());return r}function Sj(e,t,n){return n<=e?n:n-(t-1)}function Ij(e,t){const n=[];for(let a=0;a<e;a++)n.push(t+a);return n}function Nj(e,t,n,a,r,s,o,i,c){const l=e.length;let u=new Array(l),h=new Array(l),d=new Array(l);if(t.length&&n>0){const c=t[0],l=n+1;u=Tj(o,c,l,a,e),h=Ej(i,c,l,r,e),d=kj(s,c,l,e)}else for(let p=0;p<l;p++)u[p]=Rj(o,a,s,e,p,c),h[p]=Aj(i,r,s,e,p,c),d[p]=Cj(s,p,c);return{begin:u,end:h,strides:d}}function Tj(e,t,n,a,r){const s=[...r],o=Ij(n,t);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=0;else{const r=Sj(t,n,i);let o=a[r];e&1<<r&&(o=0),s[i]=o}return s}function Ej(e,t,n,a,r){const s=[...r],o=Ij(n,t);for(let i=0;i<s.length;i++)if(o.indexOf(i)>-1)s[i]=Number.MAX_SAFE_INTEGER;else{const r=Sj(t,n,i);let o=a[r];e&1<<r&&(o=Number.MAX_SAFE_INTEGER),s[i]=o}for(let i=0;i<s.length;i++){const e=r[i];s[i]<0&&(s[i]+=e),s[i]=vz(0,s[i],r[i])}return s}function Cj(e,t,n){let a=e[t];return(n&1<<t||null==a)&&(a=1),a}function Rj(e,t,n,a,r,s){let o=t[r];const i=n[r]||1;(e&1<<r||s&1<<r||null==o)&&(o=i>0?Number.MIN_SAFE_INTEGER:Number.MAX_SAFE_INTEGER);const c=a[r];return o<0&&(o+=c),o=vz(0,o,c-1),o}function Aj(e,t,n,a,r,s){let o=t[r];const i=n[r]||1;(e&1<<r||s&1<<r||null==o)&&(o=i>0?Number.MAX_SAFE_INTEGER:Number.MIN_SAFE_INTEGER);const c=a[r];return o<0&&(o+=c),o=i>0?vz(0,o,c):vz(-1,o,c-1),o}function _j(e,t,n){let a=n.length;for(let r=0;r<n.length;r++)if(n[r]>1){a=r;break}for(let r=a+1;r<n.length;r++)if(t[r]>0||n[r]!==e[r])return!1;return!0}function Dj(e,t){let n=e.length>0?e[e.length-1]:1;for(let a=0;a<e.length-1;a++)n+=e[a]*t[a];return n}function Fj(e,t,n){let a;const r=e.shape.length;let s;return a="number"===typeof t?[t,...new Array(r-1).fill(0)]:t.length<r?t.concat(new Array(r-t.length).fill(0)):t.slice(),a.forEach((e=>{Nz(-1!==e,(()=>"slice() does not support negative begin indexing."))})),s=null==n?new Array(r).fill(-1):"number"===typeof n?[n,...new Array(r-1).fill(-1)]:n.length<r?n.concat(new Array(r-n.length).fill(-1)):n,s=s.map(((t,n)=>t>=0?t:(Nz(-1===t,(()=>"Negative size values should be exactly -1 but got "+"".concat(t," for the slice() size at index ").concat(n,"."))),e.shape[n]-a[n]))),[a,s]}function Oj(e,t,n,a,r,s,o,i,c){let l;if(null==a?(l=new Array(t.length),l.fill(1)):l=a,null!=o&&0!==(o&o-1))throw new Error("Multiple ellipses in slice is not allowed.");let u=!1;const h={dims:l.length,numAddAxisAfterEllipsis:0,begin:t.slice(),end:n.slice(),strides:l.slice(),beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:c};for(let b=0;b<h.dims;b++)u&&0!==(1<<b&i)&&h.numAddAxisAfterEllipsis++,1<<b&o&&(u=!0);u||(h.ellipsisMask|=1<<h.dims,h.dims++);const d={dims:e.length,beginMask:0,endMask:0,beginValid:!1,endValid:!1};!function(e,t){t.beginMask=0,t.endMask=0,t.shrinkAxisMask=0;let n=0;t.beginValid=null!=e.begin,t.endValid=null!=e.end,t.begin=new Array(t.dims),t.end=new Array(t.dims),t.strides=new Array(t.dims),t.finalShapeGatherIndices=[],t.finalShapeGatherIndicesSparse=[],t.inputShapeGatherIndicesSparse=new Array(t.dims);for(let a=0;a<e.dims;a++)if(1<<a&e.ellipsisMask){const r=Math.min(t.dims-(e.dims-a)+1+e.numAddAxisAfterEllipsis,t.dims);for(;n<r;n++)t.begin[n]=0,t.end[n]=0,t.strides[n]=1,t.beginMask|=1<<n,t.endMask|=1<<n,t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(-1),t.inputShapeGatherIndicesSparse[n]=a}else if(1<<a&e.newAxisMask)t.finalShapeGatherIndices.push(yj),t.finalShapeGatherIndicesSparse.push(-1);else{if(n===t.begin.length)throw Error("Index out of range using input dim ".concat(n,"; input ")+"has only ".concat(t.dims," dims, ").concat(t.begin.length,"."));null!=e.begin&&(t.begin[n]=e.begin[a]),null!=e.end&&(t.end[n]=e.end[a]),t.strides[n]=e.strides[a],e.beginMask&1<<a&&(t.beginMask|=1<<n),e.endMask&1<<a&&(t.endMask|=1<<n),e.shrinkAxisMask&1<<a?(t.finalShapeGatherIndices.push(bj),t.finalShapeGatherIndicesSparse.push(-1),t.shrinkAxisMask|=1<<n):(t.finalShapeGatherIndices.push(n),t.finalShapeGatherIndicesSparse.push(a)),t.inputShapeGatherIndicesSparse[n]=a,n++}}(h,d);let p=!0,f=!0,m=!0;const g=[],y=[];for(let b=0;b<e.length;++b){if(0===d.strides[b])throw Error("strides[".concat(b,"] must be non-zero"));const t=!!(d.shrinkAxisMask&1<<b),n=e[b];if(-1===n){g.push(t?1:-1);continue}const a=[d.beginMask&1<<b,d.endMask&1<<b],r=[d.strides[b]>0?0:-1,d.strides[b]>0?n:n-1];if(t&&d.strides[b]<=0)throw Error("only stride 1 allowed on non-range indexing.");m=m&&1===d.strides[b];const s=!!(d.beginMask&1<<b&&d.endMask&1<<b);if(d.beginValid&&d.endValid){if(t){const e=d.begin[b]<0?n+d.begin[b]:d.begin[b];if(d.begin[b]=e,d.end[b]=d.begin[b]+1,e<0||e>=n)throw Error("slice index ".concat(d.begin[b]," of dimension ").concat(b," out of bounds."))}else d.begin[b]=Mj(d.begin[b],0,d.strides[b],n,a,r),d.end[b]=Mj(d.end[b],1,d.strides[b],n,a,r);const e=1===d.strides[b]&&0===d.begin[b]&&d.end[b]===n;p=p&&e,f=f&&(0===b&&1===d.strides[b]||e)}else p=p&&1===d.strides[b]&&s,f=f&&(0===b&&1===d.strides[b]||s);let o,i=!1;if(d.beginValid&&d.endValid?(o=d.end[b]-d.begin[b],i=!0):t?(o=1,i=!0):s&&n>=0&&(o=d.strides[b]<0?-n:n,i=!0),i){let e;e=0===o||o<0!==d.strides[b]<0?0:Math.trunc(o/d.strides[b])+(o%d.strides[b]!==0?1:0),g.push(e)}else g.push(-1)}for(let b=0;b<d.finalShapeGatherIndices.length;++b){const e=d.finalShapeGatherIndices[b];e>=0?y.push(g[e]):e===yj&&y.push(1)}return{finalShapeSparse:y.filter(((e,t)=>d.finalShapeGatherIndices[t]!==yj)),finalShape:y,isIdentity:p,sliceDim0:f,isSimpleSlice:m,begin:d.begin,end:d.end,strides:d.strides}}function Mj(e,t,n,a,r,s){if(r[t])return n>0?s[t]:s[t+1&1];{const t=e<0?a+e:e;return t<s[0]?s[0]:t>s[1]?s[1]:t}}class Lj{getClassName(){return this.constructor.className}static fromConfig(e,t){return new e(t)}}class zj{constructor(){this.classNameMap={}}static getMap(){return null==zj.instance&&(zj.instance=new zj),zj.instance}static register(e){zj.getMap().classNameMap[e.className]=[e,e.fromConfig]}}function Pj(e){Nz(null!=e.className,(()=>"Class being registered does not have the static className property defined.")),Nz("string"===typeof e.className,(()=>"className is required to be a string, but got type "+typeof e.className)),Nz(e.className.length>0,(()=>"Class being registered has an empty-string as its className, which is disallowed.")),zj.register(e)}const Bj=.001,Wj=.1;function Vj(e,t,n){return null==n&&(n=Uj()),Gj(e,t,((e,t)=>qj(e,t,n)))}function Uj(){return 32===GU.backend.floatPrecision()?Bj:Wj}function Gj(e,t,n){let a=!0;if((Kz(e)||Kz(t))&&(a=!1),Kz(e)&&Kz(t)&&(a=!0),a){const n=e.constructor.name,a=t.constructor.name;if(n!==a)throw new Error("Arrays are of different type. Actual: ".concat(n,". ")+"Expected: ".concat(a))}if(Array.isArray(e)&&Array.isArray(t)){const n=QU(e),a=QU(t);if(!_z(n,a))throw new Error("Arrays have different shapes. "+"Actual: [".concat(n,"]. Expected: [").concat(a,"]"))}const r=Kz(e)?e:Cz(e),s=Kz(t)?t:Cz(t);if(r.length!==s.length)throw new Error("Arrays have different lengths actual: ".concat(r.length," vs ")+"expected: ".concat(s.length,".\n")+"Actual:   ".concat(r,".\n")+"Expected: ".concat(s,"."));for(let o=0;o<s.length;++o){const e=r[o],t=s[o];if(!n(e,t))throw new Error("Arrays differ: actual[".concat(o,"] = ").concat(e,", expected[").concat(o,"] = ").concat(t,".\n")+"Actual:   ".concat(r,".\n")+"Expected: ".concat(s,"."))}"undefined"!==typeof expect&&expect().nothing()}function Hj(e,t){e().then((()=>t.fail()),(()=>t())),"undefined"!==typeof expect&&expect().nothing()}function jj(e,t){const n="string"===typeof t||"number"===typeof t||"boolean"===typeof t?[t]:t;return Yz(e)||Yz(e[0])||Yz(t)||Yz(t[0])?Gj(e,n,((e,t)=>e==t)):Gj(e,t,((e,t)=>qj(e,t,0)))}function Kj(e,t,n){if(null==n&&(n=Uj()),!qj(e,t,n))throw new Error("Numbers differ: actual === ".concat(e,", expected === ").concat(t));"undefined"!==typeof expect&&expect().nothing()}function qj(e,t,n){return!isFinite(e)&&!isFinite(t)||!(isNaN(e)||isNaN(t)||Math.abs(e-t)>n)}function Xj(e,t,n){for(let a=0;a<e.length;a++)if(e[a]<t||e[a]>n)throw new Error("Value out of range:".concat(e[a]," low: ").concat(t,", high: ").concat(n))}function Yj(e,t){const n=new Float32Array(e),a=new Float32Array(t);if(n.length!==a.length)throw new Error("Expected ArrayBuffer to be of length "+"".concat(a.length,", but it was ").concat(n.length));for(let r=0;r<a.length;r++)if(n[r]!==a[r])throw new Error("Expected ArrayBuffer value at ".concat(r," to be ")+"".concat(a[r]," but got ").concat(n[r]," instead"))}function Qj(e){for(let t=0;t<e.length;t++){const n=e[t];Array.isArray(n)?Qj(n):e[t]=iU(n)}return e}function Jj(e){const t=document.createElement("video");return"playsInline"in t&&(t.playsInline=!0),t.muted=!0,t.loop=!0,t.style.position="fixed",t.style.left="0px",t.style.top="0px",t.preload="auto",t.appendChild(e),new Promise((e=>{t.addEventListener("loadeddata",(n=>e(t))),t.load()}))}async function Zj(e){await e.play(),"requestVideoFrameCallback"in e&&await new Promise((t=>{e.requestVideoFrameCallback(t)}))}const $j="3.21.0";const eK=nG({add_:function(e,t){let n=$U(e,"a","add"),a=$U(t,"b","add");[n,a]=OU(n,a);const r={a:n,b:a};return GU.runKernel(kP,r)}});const tK=nG({floorDiv_:function(e,t){let n=$U(e,"a","floorDiv"),a=$U(t,"b","floorDiv");[n,a]=OU(n,a);const r={a:n,b:a};return GU.runKernel(EB,r)}});const nK=nG({div_:function(e,t){let n=$U(e,"a","div"),a=$U(t,"b","div");if([n,a]=OU(n,a),"int32"===n.dtype&&"int32"===a.dtype)return tK(n,a);const r={a:n,b:a};return GU.runKernel(fB,r,{})}});const aK=nG({mul_:function(e,t){let n=$U(e,"a","mul"),a=$U(t,"b","mul");[n,a]=OU(n,a);const r={a:n,b:a};return GU.runKernel(dW,r)}});const rK=nG({sqrt_:function(e){const t={x:$U(e,"x","sqrt","float32")};return GU.runKernel(JW,t)}});const sK=nG({square_:function(e){const t=$U(e,"x","square");return GU.runKernel("Square",{x:t},{})}});const oK=nG({zerosLike_:function(e){const t={x:$U(e,"x","zerosLike")};return GU.runKernel(IV,t)}});function iK(e){return Nz($z(e),(()=>"The f passed in grad(f) must be a function")),(t,n)=>{const a=$U(t,"x","tf.grad","string_or_numeric"),r=null!=n?$U(n,"dy","tf.grad"):null;return GU.tidy((()=>{const{value:t,grads:n}=GU.gradients((()=>e(a)),[a],r);return null!=r&&Tz(t.shape,r.shape,"The shape of dy passed in grad(f)(x, dy) must match the shape returned by f(x)"),pK(n),n[0]}))}}function cK(e){return Nz($z(e),(()=>"The f passed in grads(f) must be a function")),(t,n)=>{Nz(Array.isArray(t),(()=>"The args passed in grads(f)(args) must be an array of `Tensor`s or `TensorLike`s"));const a=eG(t,"args","tf.grads","string_or_numeric"),r=null!=n?$U(n,"dy","tf.grads"):null;return GU.tidy((()=>{const{value:t,grads:n}=GU.gradients((()=>e(...a)),a,r);return null!=r&&Tz(t.shape,r.shape,"The shape of dy passed in grads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),pK(n),n}))}}function lK(e){return Nz($z(e),(()=>"The f passed in valueAndGrad(f) must be a function")),(t,n)=>{Nz(t instanceof IU,(()=>"The x passed in valueAndGrad(f)(x) must be a tensor")),Nz(null==n||n instanceof IU,(()=>"The dy passed in valueAndGrad(f)(x, dy) must be a tensor"));const{grads:a,value:r}=GU.gradients((()=>e(t)),[t],n);return pK(a),{grad:a[0],value:r}}}function uK(e){return Nz($z(e),(()=>"The f passed in valueAndGrads(f) must be a function")),(t,n)=>{Nz(Array.isArray(t)&&t.every((e=>e instanceof IU)),(()=>"The args passed in valueAndGrads(f)(args) must be array of tensors")),Nz(null==n||n instanceof IU,(()=>"The dy passed in valueAndGrads(f)(args, dy) must be a tensor"));const a=GU.gradients((()=>e(...t)),t,n);return null!=n&&Tz(a.value.shape,n.shape,"The shape of dy passed in valueAndGrads(f)([x1,...], dy) must match the shape returned by f([x1,...])"),pK(a.grads),a}}function hK(e,t){Nz($z(e),(()=>"The f passed in variableGrads(f) must be a function")),Nz(null==t||Array.isArray(t)&&t.every((e=>e instanceof NU)),(()=>"The varList passed in variableGrads(f, varList) must be an array of variables"));const n=null!=t;if(!n){t=[];for(const e in GU.registeredVariables)t.push(GU.registeredVariables[e])}const a=n?t.filter((e=>!e.trainable)):null,r=t.length;t=t.filter((e=>e.trainable)),Nz(t.length>0,(()=>"variableGrads() expects at least one of the input variables to "+"be trainable, but none of the ".concat(r," variables is ")+"trainable."));const{value:s,grads:o}=GU.gradients(e,t,null,!0);Nz(o.some((e=>null!=e)),(()=>"Cannot find a connection between any variable and the result of the loss function y=f(x). Please make sure the operations that use variables are inside the function f passed to minimize().")),Nz(0===s.rank,(()=>"The f passed in variableGrads(f) must return a scalar, but it "+"returned a rank-".concat(s.rank," tensor")));const i={};return t.forEach(((e,t)=>{null!=o[t]&&(i[e.name]=o[t])})),null!=a&&a.forEach((e=>i[e.name]=null)),{value:s,grads:i}}function dK(e){return GU.customGrad(e)}function pK(e){if(e.filter((e=>null==e)).length>0)throw new Error("Cannot compute gradient of y=f(x) with respect to x. Make sure that\n    the f you passed encloses all operations that lead from x to y.")}function fK(e,t){if((Kz(e)&&"string"!==t||Array.isArray(e))&&"complex64"!==t)throw new Error("Error creating a new Scalar: value must be a primitive (number|boolean|string)");if("string"===t&&Kz(e)&&!(e instanceof Uint8Array))throw new Error("When making a scalar from encoded string, the value must be `Uint8Array`.");return rG(e,[],[],t)}class mK extends Lj{minimize(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1],n=arguments.length>2?arguments[2]:void 0;const{value:a,grads:r}=this.computeGradients(e,n);if(null!=n){const e=n.map((e=>({name:e.name,tensor:r[e.name]})));this.applyGradients(e)}else this.applyGradients(r);return WH(r),t?a:(a.dispose(),null)}get iterations(){return null==this.iterations_&&(this.iterations_=0),this.iterations_}incrementIterations(){this.iterations_=this.iterations+1}computeGradients(e,t){return hK(e,t)}dispose(){null!=this.iterations_&&WH(this.iterations_)}async saveIterations(){return null==this.iterations_&&(this.iterations_=0),{name:"iter",tensor:fK(this.iterations_,"int32")}}async getWeights(){throw new Error("getWeights() is not implemented for this optimizer yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for this optimizer class "+"".concat(this.getClassName()))}async extractIterations(e){return this.iterations_=(await e[0].tensor.data())[0],e.slice(1)}}Object.defineProperty(mK,Symbol.hasInstance,{value:e=>null!=e.minimize&&null!=e.computeGradients&&null!=e.applyGradients});class gK extends mK{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;super(),this.learningRate=e,this.rho=t,this.epsilon=n,this.accumulatedGrads=[],this.accumulatedUpdates=[],null==n&&(this.epsilon=GU.backend.epsilon())}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=GU.registeredVariables[t],r=!1;null==this.accumulatedGrads[n]&&(this.accumulatedGrads[n]={originalName:"".concat(t,"/accum_grad"),variable:BH((()=>oK(a).variable(r)))}),null==this.accumulatedUpdates[n]&&(this.accumulatedUpdates[n]={originalName:"".concat(t,"/accum_var"),variable:BH((()=>oK(a).variable(r)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const o=this.accumulatedGrads[n].variable,i=this.accumulatedUpdates[n].variable;BH((()=>{const e=eK(aK(o,this.rho),aK(sK(s),1-this.rho)),t=aK(nK(rK(eK(i,this.epsilon)),rK(eK(o,this.epsilon))),s),n=eK(aK(i,this.rho),aK(sK(t),1-this.rho));o.assign(e),i.assign(n);const r=eK(aK(t,-this.learningRate),a);a.assign(r)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedUpdates&&(WH(this.accumulatedGrads.map((e=>e.variable))),WH(this.accumulatedUpdates.map((e=>e.variable))))}async getWeights(){const e=[...this.accumulatedGrads,...this.accumulatedUpdates];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){const t=(e=await this.extractIterations(e)).length/2,n=!1;this.accumulatedGrads=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedUpdates=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,rho:this.rho,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.rho,t.epsilon)}}function yK(e,t,n){const a={shape:e,value:t,dtype:n};return GU.runKernel(IB,{},a)}gK.className="Adadelta",Pj(gK);class bK extends mK{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1;super(),this.learningRate=e,this.initialAccumulatorValue=t,this.accumulatedGrads=[]}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=GU.registeredVariables[t];if(null==this.accumulatedGrads[n]){const e=!1;this.accumulatedGrads[n]={originalName:"".concat(t,"/accumulator"),variable:BH((()=>yK(a.shape,this.initialAccumulatorValue).variable(e)))}}const r=Array.isArray(e)?e[n].tensor:e[t];if(null==r)return;const s=this.accumulatedGrads[n].variable;BH((()=>{const e=eK(s,sK(r));s.assign(e);const t=eK(aK(nK(r,rK(eK(e,GU.backend.epsilon()))),-this.learningRate),a);a.assign(t)}))})),this.incrementIterations()}dispose(){null!=this.accumulatedGrads&&WH(this.accumulatedGrads.map((e=>e.variable)))}async getWeights(){return[await this.saveIterations()].concat(this.accumulatedGrads.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulatedGrads=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,initialAccumulatorValue:this.initialAccumulatorValue}}static fromConfig(e,t){return new e(t.learningRate,t.initialAccumulatorValue)}}bK.className="Adagrad",Pj(bK);const vK=nG({pow_:function(e,t){let n=$U(e,"base","pow"),a=$U(t,"exp","pow");[n,a]=OU(n,a);const r={a:n,b:a};return GU.runKernel(SW,r)}});const xK=nG({sub_:function(e,t){let n=$U(e,"a","sub"),a=$U(t,"b","sub");[n,a]=OU(n,a);const r={a:n,b:a};return GU.runKernel(pV,r)}});class wK extends mK{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.accumulatedFirstMoment=[],this.accumulatedSecondMoment=[],BH((()=>{this.accBeta1=fK(t).variable(),this.accBeta2=fK(n).variable()})),null==a&&(this.epsilon=GU.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);BH((()=>{const n=xK(1,this.accBeta1),a=xK(1,this.accBeta2);t.forEach(((t,r)=>{const s=GU.registeredVariables[t],o=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:BH((()=>oK(s).variable(o)))}),null==this.accumulatedSecondMoment[r]&&(this.accumulatedSecondMoment[r]={originalName:"".concat(t,"/v"),variable:BH((()=>oK(s).variable(o)))});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedSecondMoment[r].variable,u=eK(aK(c,this.beta1),aK(i,1-this.beta1)),h=eK(aK(l,this.beta2),aK(sK(i),1-this.beta2)),d=nK(u,n),p=nK(h,a);c.assign(u),l.assign(h);const f=eK(aK(nK(d,eK(rK(p),this.epsilon)),-this.learningRate),s);s.assign(f)})),this.accBeta1.assign(aK(this.accBeta1,this.beta1)),this.accBeta2.assign(aK(this.accBeta2,this.beta2))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.accBeta2.dispose(),null!=this.accumulatedFirstMoment&&WH(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedSecondMoment&&WH(this.accumulatedSecondMoment.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedFirstMoment,...this.accumulatedSecondMoment];return[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e),BH((()=>{this.accBeta1.assign(vK(this.beta1,this.iterations_+1)),this.accBeta2.assign(vK(this.beta2,this.iterations_+1))}));const t=e.length/2,n=!1;this.accumulatedFirstMoment=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedSecondMoment=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)})))}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon)}}wK.className="Adam",Pj(wK);const kK=nG({abs_:function(e){const t=$U(e,"x","abs");if("complex64"===t.dtype){const e={x:t};return GU.runKernel(KP,e)}{const e={x:t};return GU.runKernel(vP,e)}}});const SK=nG({maximum_:function(e,t){let n=$U(e,"a","maximum"),a=$U(t,"b","maximum");[n,a]=OU(n,a),"bool"===n.dtype&&(n=oH(n,"int32"),a=oH(a,"int32")),sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(eW,r)}});class IK extends mK{constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0;super(),this.learningRate=e,this.beta1=t,this.beta2=n,this.epsilon=a,this.decay=r,this.accumulatedFirstMoment=[],this.accumulatedWeightedInfNorm=[],BH((()=>{this.iteration=fK(0).variable(),this.accBeta1=fK(t).variable()})),null==a&&(this.epsilon=GU.backend.epsilon())}applyGradients(e){const t=Array.isArray(e)?e.map((e=>e.name)):Object.keys(e);BH((()=>{const n=xK(1,this.accBeta1),a=nK(-this.learningRate,eK(aK(this.iteration,this.decay),1));t.forEach(((t,r)=>{const s=GU.registeredVariables[t],o=!1;null==this.accumulatedFirstMoment[r]&&(this.accumulatedFirstMoment[r]={originalName:"".concat(t,"/m"),variable:oK(s).variable(o)}),null==this.accumulatedWeightedInfNorm[r]&&(this.accumulatedWeightedInfNorm[r]={originalName:"".concat(t,"/v"),variable:oK(s).variable(o)});const i=Array.isArray(e)?e[r].tensor:e[t];if(null==i)return;const c=this.accumulatedFirstMoment[r].variable,l=this.accumulatedWeightedInfNorm[r].variable,u=eK(aK(c,this.beta1),aK(i,1-this.beta1)),h=aK(l,this.beta2),d=kK(i),p=SK(h,d);c.assign(u),l.assign(p);const f=eK(aK(nK(a,n),nK(u,eK(p,this.epsilon))),s);s.assign(f)})),this.iteration.assign(eK(this.iteration,1)),this.accBeta1.assign(aK(this.accBeta1,this.beta1))})),this.incrementIterations()}dispose(){this.accBeta1.dispose(),this.iteration.dispose(),null!=this.accumulatedFirstMoment&&WH(this.accumulatedFirstMoment.map((e=>e.variable))),null!=this.accumulatedWeightedInfNorm&&WH(this.accumulatedWeightedInfNorm.map((e=>e.variable)))}async getWeights(){throw new Error("getWeights() is not implemented for Adamax yet.")}async setWeights(e){throw new Error("setWeights() is not implemented for Adamax yet.")}getConfig(){return{learningRate:this.learningRate,beta1:this.beta1,beta2:this.beta2,epsilon:this.epsilon,decay:this.decay}}static fromConfig(e,t){return new e(t.learningRate,t.beta1,t.beta2,t.epsilon,t.decay)}}IK.className="Adamax",Pj(IK);class NK extends mK{constructor(e){super(),this.learningRate=e,this.setLearningRate(e)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=Array.isArray(e)?e[n].tensor:e[t];if(null==a)return;const r=GU.registeredVariables[t];BH((()=>{const e=eK(aK(this.c,a),r);r.assign(e)}))})),this.incrementIterations()}setLearningRate(e){this.learningRate=e,null!=this.c&&this.c.dispose(),this.c=VH(fK(-e))}dispose(){this.c.dispose()}async getWeights(){return[await this.saveIterations()]}async setWeights(e){if(0!==(e=await this.extractIterations(e)).length)throw new Error("SGD optimizer does not have settable weights.")}getConfig(){return{learningRate:this.learningRate}}static fromConfig(e,t){return new e(t.learningRate)}}NK.className="SGD",Pj(NK);class TK extends NK{constructor(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];super(e),this.learningRate=e,this.momentum=t,this.useNesterov=n,this.accumulations=[],this.m=fK(this.momentum)}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=GU.registeredVariables[t];if(null==this.accumulations[n]){const e=!1;this.accumulations[n]={originalName:"".concat(t,"/momentum"),variable:BH((()=>oK(a).variable(e)))}}const r=this.accumulations[n].variable,s=Array.isArray(e)?e[n].tensor:e[t];null!=s&&BH((()=>{let e;const t=eK(aK(this.m,r),s);e=this.useNesterov?eK(aK(this.c,eK(s,aK(t,this.m))),a):eK(aK(this.c,t),a),r.assign(t),a.assign(e)}))})),this.incrementIterations()}dispose(){this.m.dispose(),null!=this.accumulations&&WH(this.accumulations.map((e=>e.variable)))}setMomentum(e){this.momentum=e}async getWeights(){return[await this.saveIterations()].concat(this.accumulations.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);this.accumulations=e.map((e=>({originalName:e.name,variable:e.tensor.variable(false)})))}getConfig(){return{learningRate:this.learningRate,momentum:this.momentum,useNesterov:this.useNesterov}}static fromConfig(e,t){return new e(t.learningRate,t.momentum,t.useNesterov)}}TK.className="Momentum",Pj(TK);class EK extends mK{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];if(super(),this.learningRate=e,this.decay=t,this.momentum=n,this.epsilon=a,this.accumulatedMeanSquares=[],this.accumulatedMoments=[],this.accumulatedMeanGrads=[],this.centered=r,null==a&&(this.epsilon=GU.backend.epsilon()),null==e)throw new Error("learningRate for RMSPropOptimizer must be defined.")}applyGradients(e){(Array.isArray(e)?e.map((e=>e.name)):Object.keys(e)).forEach(((t,n)=>{const a=GU.registeredVariables[t],r=!1;null==this.accumulatedMeanSquares[n]&&(this.accumulatedMeanSquares[n]={originalName:"".concat(t,"/rms"),variable:BH((()=>oK(a).variable(r)))}),null==this.accumulatedMoments[n]&&(this.accumulatedMoments[n]={originalName:"".concat(t,"/momentum"),variable:BH((()=>oK(a).variable(r)))}),null==this.accumulatedMeanGrads[n]&&this.centered&&(this.accumulatedMeanGrads[n]={originalName:"".concat(t,"/mg"),variable:BH((()=>oK(a).variable(r)))});const s=Array.isArray(e)?e[n].tensor:e[t];if(null==s)return;const o=this.accumulatedMeanSquares[n].variable,i=this.accumulatedMoments[n].variable;BH((()=>{const e=eK(aK(o,this.decay),aK(sK(s),1-this.decay));if(this.centered){const t=this.accumulatedMeanGrads[n].variable,r=eK(aK(t,this.decay),aK(s,1-this.decay)),c=nK(aK(s,this.learningRate),rK(xK(e,eK(sK(r),this.epsilon)))),l=eK(aK(i,this.momentum),c);o.assign(e),t.assign(r),i.assign(l);const u=xK(a,l);a.assign(u)}else{const e=eK(aK(o,this.decay),aK(sK(s),1-this.decay)),t=eK(aK(i,this.momentum),nK(aK(s,this.learningRate),rK(eK(e,this.epsilon))));o.assign(e),i.assign(t);const n=xK(a,t);a.assign(n)}}))})),this.incrementIterations()}dispose(){null!=this.accumulatedMeanSquares&&WH(this.accumulatedMeanSquares.map((e=>e.variable))),null!=this.accumulatedMeanGrads&&this.centered&&WH(this.accumulatedMeanGrads.map((e=>e.variable))),null!=this.accumulatedMoments&&WH(this.accumulatedMoments.map((e=>e.variable)))}async getWeights(){const e=[...this.accumulatedMeanSquares,...this.accumulatedMoments];return this.centered&&e.push(...this.accumulatedMeanGrads),[await this.saveIterations()].concat(e.map((e=>({name:e.originalName,tensor:e.variable}))))}async setWeights(e){e=await this.extractIterations(e);const t=this.centered?e.length/3:e.length/2,n=!1;this.accumulatedMeanSquares=e.slice(0,t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.accumulatedMoments=e.slice(t,2*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))),this.centered&&(this.accumulatedMeanGrads=e.slice(2*t,3*t).map((e=>({originalName:e.name,variable:e.tensor.variable(n)}))))}getConfig(){return{learningRate:this.learningRate,decay:this.decay,momentum:this.momentum,epsilon:this.epsilon,centered:this.centered}}static fromConfig(e,t){return new e(t.learningRate,t.decay,t.momentum,t.epsilon,t.centered)}}EK.className="RMSProp",Pj(EK);class CK{static sgd(e){return new NK(e)}static momentum(e,t){return new TK(e,t,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}static rmsprop(e){return new EK(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]&&arguments[4])}static adam(){return new wK(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null)}static adadelta(){return new gK(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.001,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.95,arguments.length>2&&void 0!==arguments[2]?arguments[2]:null)}static adamax(){return new IK(arguments.length>0&&void 0!==arguments[0]?arguments[0]:.002,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.9,arguments.length>2&&void 0!==arguments[2]?arguments[2]:.999,arguments.length>3&&void 0!==arguments[3]?arguments[3]:null,arguments.length>4&&void 0!==arguments[4]?arguments[4]:0)}static adagrad(e){return new bK(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:.1)}}const RK=nG({acos_:function(e){const t={x:$U(e,"x","acos")};return GU.runKernel(xP,t)}});const AK=nG({acosh_:function(e){const t={x:$U(e,"x","acosh")};return GU.runKernel(wP,t)}});const _K=nG({addN_:function(e){Nz(Array.isArray(e),(()=>"The argument passed to tf.addN() must be a list of tensors")),Nz(e.length>=1,(()=>"Must pass at least one tensor to tf.addN(), but got "+"".concat(e.length)));const t=e.map(((e,t)=>$U(e,"tensors".concat(t),"addN"))),n=t[0];t.forEach((e=>{if(e.dtype!==n.dtype)throw new Error("All tensors passed to tf.addN() must have the same dtype")})),t.forEach((e=>{if(!_z(e.shape,n.shape))throw new Error("All tensors passed to tf.addN() must have the same shape")}));const a=t;return GU.runKernel(SP,a)}});const DK=nG({all_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:$U(e,"x","all","bool")},r={axis:t,keepDims:n};return GU.runKernel(IP,a,r)}});const FK=nG({any_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:$U(e,"x","any","bool")},r={axis:t,keepDims:n};return GU.runKernel(NP,a,r)}});const OK=nG({argMax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:$U(e,"x","argMax")},a={axis:t};return GU.runKernel(TP,n,a)}});const MK=nG({argMin_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:$U(e,"x","argMin")},a={axis:t};return GU.runKernel(EP,n,a)}});const LK=nG({asin_:function(e){const t={x:$U(e,"x","asin")};return GU.runKernel(CP,t)}});const zK=nG({asinh_:function(e){const t={x:$U(e,"x","asinh")};return GU.runKernel(RP,t)}});const PK=nG({atan_:function(e){const t={x:$U(e,"x","atan")};return GU.runKernel(AP,t)}});const BK=nG({atan2_:function(e,t){let n=$U(e,"a","atan2"),a=$U(t,"b","atan2");[n,a]=OU(n,a);const r={a:n,b:a};return GU.runKernel(DP,r)}});const WK=nG({atanh_:function(e){const t={x:$U(e,"x","atanh")};return GU.runKernel(_P,t)}});function VK(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5?arguments[5]:void 0;return HK(e,[...t,e[3]],n,s,a,null,null,$K(r))}function UK(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast";const[i,c]=qK(t);let l;if("channelsLast"===o)l=[i,c,e[3],e[3]];else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));l=[i,c,e[1],e[1]]}return HK(e,l,n,a,r,s,!1,o)}function GK(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NDHWC";const[i,c,l]=XK(t);let u,h;if("NDHWC"===o)h="channelsLast",u=[i,c,l,e[4],e[4]];else{if("NCDHW"!==o)throw new Error("Unknown dataFormat ".concat(o));h="channelsFirst",u=[i,c,l,e[1],e[1]]}return jK(e,u,n,a,r,!1,h,s)}function HK(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:"channelsLast",[c,l,u,h]=[-1,-1,-1,-1];if("channelsLast"===i)[c,l,u,h]=e;else{if("channelsFirst"!==i)throw new Error("Unknown dataFormat ".concat(i));[c,h,l,u]=e}const[d,p,,f]=t,[m,g]=qK(n),[y,b]=qK(a),v=YK(d,y),x=YK(p,b),{padInfo:w,outHeight:k,outWidth:S}=function(e,t,n,a,r,s,o,i,c){let l,u,h;if("number"===typeof e){l={top:e,bottom:e,left:e,right:e,type:0===e?"VALID":"NUMBER"};const r=function(e,t,n,a,r){null==a&&(a=KK(e,t,n));const s=e[0],o=e[1],i=QK((s-t+2*a)/n+1,r),c=QK((o-t+2*a)/n+1,r);return[i,c]}([t,n],s,a,e,i);u=r[0],h=r[1]}else if("same"===e){u=Math.ceil(t/a),h=Math.ceil(n/r);const e=Math.max(0,(u-1)*a+s-t),i=Math.max(0,(h-1)*r+o-n),c=Math.floor(e/2),d=e-c,p=Math.floor(i/2);l={top:c,bottom:d,left:p,right:i-p,type:"SAME"}}else if("valid"===e)l={top:0,bottom:0,left:0,right:0,type:"VALID"},u=Math.ceil((t-s+1)/a),h=Math.ceil((n-o+1)/r);else{if("object"!==typeof e)throw Error("Unknown padding parameter: ".concat(e));{const d="channelsLast"===c?e[1][0]:e[2][0],p="channelsLast"===c?e[1][1]:e[2][1],f="channelsLast"===c?e[2][0]:e[3][0],m="channelsLast"===c?e[2][1]:e[3][1];l={top:d,bottom:p,left:f,right:m,type:0===d&&0===p&&0===f&&0===m?"VALID":"EXPLICIT"},u=QK((t-s+d+p)/a+1,i),h=QK((n-o+f+m)/r+1,i)}}return{padInfo:l,outHeight:u,outWidth:h}}(r,l,u,m,g,v,x,s,i),I=o?f*h:f;let N;return"channelsFirst"===i?N=[c,I,k,S]:"channelsLast"===i&&(N=[c,k,S,I]),{batchSize:c,dataFormat:i,inHeight:l,inWidth:u,inChannels:h,outHeight:k,outWidth:S,outChannels:I,padInfo:w,strideHeight:m,strideWidth:g,filterHeight:d,filterWidth:p,effectiveFilterHeight:v,effectiveFilterWidth:x,dilationHeight:y,dilationWidth:b,inShape:e,outShape:N,filterShape:t}}function jK(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]&&arguments[5],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"channelsLast",i=arguments.length>7?arguments[7]:void 0,[c,l,u,h,d]=[-1,-1,-1,-1,-1];if("channelsLast"===o)[c,l,u,h,d]=e;else{if("channelsFirst"!==o)throw new Error("Unknown dataFormat ".concat(o));[c,d,l,u,h]=e}const[p,f,m,,g]=t,[y,b,v]=XK(n),[x,w,k]=XK(a),S=YK(p,x),I=YK(f,w),N=YK(m,k),{padInfo:T,outDepth:E,outHeight:C,outWidth:R}=function(e,t,n,a,r,s,o,i,c,l,u){let h,d,p,f;if("number"===typeof e){h={top:e,bottom:e,left:e,right:e,front:e,back:e,type:0===e?"VALID":"NUMBER"};const s=function(e,t,n,a,r,s){null==r&&(r=KK(e,t,a));const o=e[0],i=e[1],c=e[2],l=QK((o-t+2*r)/a+1,s),u=QK((i-t+2*r)/a+1,s),h=QK((c-t+2*r)/a+1,s);return[l,u,h,n]}([t,n,a,1],i,1,r,e,u);d=s[0],p=s[1],f=s[2]}else if("same"===e){d=Math.ceil(t/r),p=Math.ceil(n/s),f=Math.ceil(a/o);const e=(d-1)*r+i-t,u=(p-1)*s+c-n,m=(f-1)*o+l-a,g=Math.floor(e/2),y=e-g,b=Math.floor(u/2),v=u-b,x=Math.floor(m/2);h={top:b,bottom:v,left:x,right:m-x,front:g,back:y,type:"SAME"}}else{if("valid"!==e)throw Error("Unknown padding parameter: ".concat(e));h={top:0,bottom:0,left:0,right:0,front:0,back:0,type:"VALID"},d=Math.ceil((t-i+1)/r),p=Math.ceil((n-c+1)/s),f=Math.ceil((a-l+1)/o)}return{padInfo:h,outDepth:d,outHeight:p,outWidth:f}}(r,l,u,h,y,b,v,S,I,N,i),A=s?g*d:g;let _;return"channelsFirst"===o?_=[c,A,E,C,R]:"channelsLast"===o&&(_=[c,E,C,R,A]),{batchSize:c,dataFormat:o,inDepth:l,inHeight:u,inWidth:h,inChannels:d,outDepth:E,outHeight:C,outWidth:R,outChannels:A,padInfo:T,strideDepth:y,strideHeight:b,strideWidth:v,filterDepth:p,filterHeight:f,filterWidth:m,effectiveFilterDepth:S,effectiveFilterHeight:I,effectiveFilterWidth:N,dilationDepth:x,dilationHeight:w,dilationWidth:k,inShape:e,outShape:_,filterShape:t}}function KK(e,t,n){const a=YK(t,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1);return Math.floor((e[0]*(n-1)-n+a)/2)}function qK(e){return"number"===typeof e?[e,e,e]:2===e.length?[e[0],e[1],1]:e}function XK(e){return"number"===typeof e?[e,e,e]:e}function YK(e,t){return t<=1?e:e+(e-1)*(t-1)}function QK(e,t){if(!t)return Math.trunc(e);switch(t){case"round":return Math.round(e);case"ceil":return Math.ceil(e);case"floor":return Math.floor(e);default:throw new Error("Unknown roundingMode ".concat(t))}}function JK(e){const[t,n,a]=qK(e);return 1===t&&1===n&&1===a}function ZK(e,t){return JK(e)||JK(t)}function $K(e){if("NHWC"===e)return"channelsLast";if("NCHW"===e)return"channelsFirst";throw new Error("Unknown dataFormat ".concat(e))}function eq(e,t,n){if(null!=n){if("string"===typeof t)throw Error("Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,"."));if("number"===typeof t)Nz(Dz(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")));else{if("object"!==typeof t)throw Error("Error in ".concat(e,": Unknown padding parameter: ").concat(t));t.forEach((t=>{t.forEach((t=>{Nz(Dz(t),(()=>"Error in ".concat(e,": pad must be an integer when using ")+"dimRoundingMode ".concat(n," but got pad ").concat(t,".")))}))}))}}}const tq=nG({reshape_:function(e,t){const n={x:$U(e,"x","reshape","string_or_numeric")},a={shape:t};return GU.runKernel(DW,n,a)}});const nq=nG({avgPool_:function(e,t,n,a,r){const s=$U(e,"x","avgPool","float32");Nz(ZK(n,1),(()=>"Error in avgPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'")));let o=s,i=!1;3===s.rank&&(i=!0,o=tq(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Nz(4===o.rank,(()=>"Error in avgPool: x must be rank 4 but got rank ".concat(o.rank,"."))),eq("avgPool",a,r);const c={x:o},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r};let u=GU.runKernel(FP,c,l);return u=oH(u,s.dtype),i?tq(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const aq=nG({avgPool3d_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=$U(e,"x","avgPool3d","float32");let i=o,c=!1;4===o.rank&&(c=!0,i=tq(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Nz(5===i.rank,(()=>"Error in avgPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Nz("NDHWC"===s,(()=>"Error in avgPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),eq("avgPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s};let h=GU.runKernel(MP,l,u);return h=oH(h,i.dtype),c?tq(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const rq=nG({concat_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;Nz(e.length>=1,(()=>"Pass at least one tensor to concat"));const n=eG(e,"tensors","concat","string_or_numeric");if("complex64"===n[0].dtype&&n.forEach((e=>{if("complex64"!==e.dtype)throw new Error("Cannot concatenate complex64 tensors with a tensor\n          with dtype ".concat(e.dtype,". "))})),1===n.length)return iH(n[0]);const a=n,r={axis:t};return GU.runKernel(qP,a,r)}});const sq=nG({sigmoid_:function(e){const t={x:$U(e,"x","sigmoid","float32")};return GU.runKernel(YW,t)}});const oq=nG({slice_:function(e,t,n){const a=$U(e,"x","slice","string_or_numeric");if(0===a.rank)throw new Error("Slicing scalar is not possible");const r={x:a},s={begin:t,size:n};return GU.runKernel(jW,r,s)}});const iq=nG({tanh_:function(e){const t={x:$U(e,"x","tanh","float32")};return GU.runKernel(mV,t)}});const cq=nG({basicLSTMCell_:function(e,t,n,a,r,s){const o=$U(e,"forgetBias","basicLSTMCell"),i=$U(t,"lstmKernel","basicLSTMCell"),c=$U(n,"lstmBias","basicLSTMCell"),l=$U(a,"data","basicLSTMCell"),u=$U(r,"c","basicLSTMCell"),h=$U(s,"h","basicLSTMCell"),d=rq([l,h],1),p=RH(d,i),f=eK(p,c),m=f.shape[0],g=f.shape[1]/4,y=[m,g],b=oq(f,[0,0],y),v=oq(f,[0,g],y),x=oq(f,[0,2*g],y),w=oq(f,[0,3*g],y),k=eK(aK(sq(b),iq(v)),aK(u,sq(eK(o,x))));return[k,aK(iq(k),sq(w))]}});const lq=nG({batchToSpaceND_:function(e,t,n){const a=$U(e,"x","batchToSpaceND"),r=t.reduce(((e,t)=>e*t));Nz(a.rank>=1+t.length,(()=>"input rank is ".concat(a.rank," but should be > than blockShape.length ").concat(t.length))),Nz(n.length===t.length,(()=>"crops.length is ".concat(n.length," but should be equal to blockShape.length  ").concat(t.length))),Nz(a.shape[0]%r===0,(()=>"input tensor batch is ".concat(a.shape[0]," but is not divisible by the product of ")+"the elements of blockShape ".concat(t.join(" * ")," === ").concat(r)));const s={x:a},o={blockShape:t,crops:n};return GU.runKernel(PP,s,o)}});const uq=nG({batchNorm_:function(e,t,n,a,r,s){null==s&&(s=.001);const o=$U(e,"x","batchNorm"),i=$U(t,"mean","batchNorm"),c=$U(n,"variance","batchNorm");let l,u;null!=r&&(l=$U(r,"scale","batchNorm")),null!=a&&(u=$U(a,"offset","batchNorm")),Nz(i.rank===c.rank,(()=>"Batch normalization gradient requires mean and variance to have equal ranks.")),Nz(null==u||i.rank===u.rank,(()=>"Batch normalization gradient requires mean and offset to have equal ranks.")),Nz(null==l||i.rank===l.rank,(()=>"Batch normalization gradient requires mean and scale to have equal ranks."));const h={x:function(e){let t;return t=0===e.rank||1===e.rank?tq(e,[1,1,1,e.size]):2===e.rank?tq(e,[1,1,e.shape[0],e.shape[1]]):3===e.rank?tq(e,[1,e.shape[0],e.shape[1],e.shape[2]]):e,t}(o),scale:l,offset:u,mean:i,variance:c},d={varianceEpsilon:s},p=GU.runKernel(CB,h,d);return tq(p,o.shape)}});const hq=nG({batchNorm2d_:function(e,t,n,a,r,s){const o=$U(e,"x","batchNorm"),i=$U(t,"mean","batchNorm"),c=$U(n,"variance","batchNorm");let l,u;return null!=r&&(l=$U(r,"scale","batchNorm")),null!=a&&(u=$U(a,"offset","batchNorm")),Nz(2===o.rank,(()=>"Error in batchNorm2D: x must be rank 2 but got rank "+"".concat(o.rank,"."))),Nz(2===i.rank||1===i.rank,(()=>"Error in batchNorm2D: mean must be rank 2 or rank 1 but "+"got rank ".concat(i.rank,"."))),Nz(2===c.rank||1===c.rank,(()=>"Error in batchNorm2D: variance must be rank 2 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Nz(2===l.rank||1===l.rank,(()=>"Error in batchNorm2D: scale must be rank 2 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&Nz(2===u.rank||1===u.rank,(()=>"Error in batchNorm2D: offset must be rank 2 or rank 1 "+"but got rank ".concat(u.rank,"."))),uq(o,i,c,u,l,s)}});const dq=nG({batchNorm3d_:function(e,t,n,a,r,s){const o=$U(e,"x","batchNorm"),i=$U(t,"mean","batchNorm"),c=$U(n,"variance","batchNorm");let l,u;return null!=r&&(l=$U(r,"scale","batchNorm")),null!=a&&(u=$U(a,"offset","batchNorm")),Nz(3===o.rank,(()=>"Error in batchNorm3D: x must be rank 3 but got rank "+"".concat(o.rank,"."))),Nz(3===i.rank||1===i.rank,(()=>"Error in batchNorm3D: mean must be rank 3 or rank 1 but "+"got rank ".concat(i.rank,"."))),Nz(3===c.rank||1===c.rank,(()=>"Error in batchNorm3D: variance must be rank 3 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Nz(3===l.rank||1===l.rank,(()=>"Error in batchNorm3D: scale must be rank 3 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&Nz(3===u.rank||1===u.rank,(()=>"Error in batchNorm3D: offset must be rank 3 or rank 1 "+"but got rank ".concat(u.rank,"."))),uq(o,i,c,u,l,s)}});const pq=nG({batchNorm4d_:function(e,t,n,a,r,s){const o=$U(e,"x","batchNorm"),i=$U(t,"mean","batchNorm"),c=$U(n,"variance","batchNorm");let l,u;return null!=r&&(l=$U(r,"scale","batchNorm")),null!=a&&(u=$U(a,"offset","batchNorm")),Nz(4===o.rank,(()=>"Error in batchNorm4D: x must be rank 4 but got rank "+"".concat(o.rank,"."))),Nz(4===i.rank||1===i.rank,(()=>"Error in batchNorm4D: mean must be rank 4 or rank 1 but "+"got rank ".concat(i.rank,"."))),Nz(4===c.rank||1===c.rank,(()=>"Error in batchNorm4D: variance must be rank 4 or rank 1 "+"but got rank ".concat(c.rank,"."))),null!=l&&Nz(4===l.rank||1===l.rank,(()=>"Error in batchNorm4D: scale must be rank 4 or rank 1 "+"but got rank ".concat(l.rank,"."))),null!=u&&Nz(4===u.rank||1===u.rank,(()=>"Error in batchNorm4D: offset must be rank 4 or rank 1 "+"but got rank ".concat(u.rank,"."))),uq(o,i,c,u,l,s)}});const fq=nG({bincount_:function(e,t,n){const a=$U(e,"x","bincount"),r=$U(t,"weights","bincount");Nz("int32"===a.dtype,(()=>"Error in bincount: input "+"dtype must be int32, but got ".concat(a.dtype))),Nz(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Nz(r.size===a.size||0===r.size,(()=>"Error in bincount: weights must have the same size as input or"+"0-length, but got input shape: ".concat(a.shape,", weights shape: ")+"".concat(r.shape,".")));const s={x:a,weights:r},o={size:n};return GU.runKernel(BP,s,o)}});const mq=nG({broadcastArgs_:function(e,t){const n=$U(e,"s0","broadcastArgs","int32"),a=$U(t,"s1","broadcastArgs","int32");if(1!==n.rank)throw new Error("broadcastArgs(): first input must be a vector (rank=1). "+"Has rank ".concat(n.rank));if(1!==a.rank)throw new Error("broadcastArgs(): second input must be a vector (rank=1). "+"Has rank ".concat(a.rank));const r={s0:n,s1:a};return GU.runKernel(VP,r)}});const gq=nG({broadcastTo_:function(e,t){let n=$U(e,"broadcastTo","x");const a=n.shape;if(t.some((e=>!(e>0)||e%1!==0)))throw new Error("broadcastTo(): Invalid broadcast shape [".concat(t,"]."));if(t.length<n.rank)throw new Error("broadcastTo(): shape.length=".concat(t.length," < input.rank=").concat(n.rank,"."));if(t.length>n.rank){const e=n.shape.slice();for(;e.length<t.length;)e.unshift(1);n=tq(n,e)}const r=n.shape,s=Array.from(t);for(let c=t.length-1;c>=0;c--)if(r[c]===t[c])s[c]=1;else if(1!==n.shape[c])throw new Error("broadcastTo(): [".concat(a,"] cannot be broadcast to [").concat(t,"]."));if(0===s.map(((e,t)=>e>1?t:-1)).filter((e=>e>=0)).length)return iH(n);const o={x:n},i={reps:s};return GU.runKernel(gV,o,i)}});const yq=nG({ceil_:function(e){const t={x:$U(e,"x","ceil","float32")};return GU.runKernel(GP,t)}});const bq=nG({clipByValue_:function(e,t,n){const a=$U(e,"x","clipByValue");if(Nz(t<=n,(()=>"Error in clip: min (".concat(t,") must be ")+"less than or equal to max (".concat(n,")."))),t===n)return yK(a.shape,t,a.dtype);const r={x:a},s={clipValueMin:t,clipValueMax:n};return GU.runKernel(HP,r,s)}});const vq=nG({concat1d_:function(e){return rq(e,0)}});const xq=nG({concat2d_:function(e,t){return rq(e,t)}});const wq=nG({concat3d_:function(e,t){return rq(e,t)}});const kq=nG({concat4d_:function(e,t){return rq(e,t)}});const Sq=nG({conv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=$U(e,"x","conv2d","float32"),c=$U(t,"filter","conv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=tq(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Nz(4===l.rank,(()=>"Error in conv2d: input must be rank 4, but got rank ".concat(l.rank,"."))),Nz(4===c.rank,(()=>"Error in conv2d: filter must be rank 4, but got rank "+"".concat(c.rank,"."))),eq("conv2d",a,o);const h="NHWC"===r?l.shape[3]:l.shape[1];Nz(h===c.shape[2],(()=>"Error in conv2d: depth of input (".concat(h,") must match ")+"input depth for filter ".concat(c.shape[2],"."))),Nz(ZK(n,s),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'")));const d={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o},f=GU.runKernel(XP,d,p);return u?tq(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Iq=nG({conv1d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:1,o=arguments.length>6?arguments[6]:void 0;const i=$U(e,"x","conv1d"),c=$U(t,"filter","conv1d");let l=i,u=!1;2===i.rank&&(u=!0,l=tq(i,[1,i.shape[0],i.shape[1]])),Nz(3===l.rank,(()=>"Error in conv1d: input must be rank 3, but got rank ".concat(l.rank,"."))),Nz(3===c.rank,(()=>"Error in conv1d: filter must be rank 3, but got rank "+"".concat(c.rank,"."))),eq("conv1d",a,o),Nz(l.shape[2]===c.shape[1],(()=>"Error in conv1d: depth of input (".concat(l.shape[2],") must match ")+"input depth for filter ".concat(c.shape[1],"."))),Nz(ZK(n,s),(()=>"Error in conv1D: Either stride or dilation must be 1. "+"Got stride ".concat(n," and dilation '").concat(s,"'"))),Nz("NWC"===r,(()=>"Error in conv1d: got dataFormat of ".concat(r," but only NWC is currently supported.")));const h=tq(c,[1,c.shape[0],c.shape[1],c.shape[2]]),d=tq(l,[l.shape[0],1,l.shape[1],l.shape[2]]),p=Sq(d,h,[1,n],a,"NHWC",[1,s],o);return tq(p,u?[p.shape[2],p.shape[3]]:[p.shape[0],p.shape[2],p.shape[3]])}});const Nq=nG({conv2DBackpropInput_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0;Nz(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let i=e,c=t,l=!1;3===t.rank&&(l=!0,c=tq(t,[1,t.shape[0],t.shape[1],t.shape[2]]),i=[1,e[0],e[1],e[2]]),Nz(4===i.length,(()=>"Error in conv2dDerInput: inShape must be length 4, but got length "+"".concat(i.length,"."))),Nz(4===c.rank,(()=>"Error in conv2dDerInput: dy must be rank 4, but got "+"rank ".concat(c.rank))),Nz(4===n.rank,(()=>"Error in conv2dDerInput: filter must be rank 4, but got "+"rank ".concat(n.rank)));const u="NHWC"===s?i[3]:i[1],h="NHWC"===s?c.shape[3]:c.shape[1];Nz(u===n.shape[2],(()=>"Error in conv2dDerInput: depth of input (".concat(u,") must ")+"match input depth for filter ".concat(n.shape[2],"."))),Nz(h===n.shape[3],(()=>"Error in conv2dDerInput: depth of output (".concat(h,") must ")+"match output depth for filter ".concat(n.shape[3],"."))),eq("conv2dDerInput",r,o);const d={dy:c,filter:n},p={strides:a,pad:r,dataFormat:s,dimRoundingMode:o,inputShape:i},f=GU.runKernel(QP,d,p);return l?tq(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const Tq=nG({conv2dTranspose_:function(e,t,n,a,r,s){const o=$U(e,"x","conv2dTranspose"),i=$U(t,"filter","conv2dTranspose");return Nq(n,o,i,a,r,"NHWC",s)}});const Eq=nG({conv3d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NDHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1,1];const o=$U(e,"x","conv3d"),i=$U(t,"filter","conv3d");let c=o,l=!1;4===o.rank&&(l=!0,c=tq(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Nz(5===c.rank,(()=>"Error in conv3d: input must be rank 5, but got rank ".concat(c.rank,"."))),Nz(5===i.rank,(()=>"Error in conv3d: filter must be rank 5, but got rank "+"".concat(i.rank,"."))),Nz(c.shape[4]===i.shape[3],(()=>"Error in conv3d: depth of input (".concat(c.shape[4],") must match ")+"input depth for filter ".concat(i.shape[3],"."))),Nz(ZK(n,s),(()=>"Error in conv3D: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(s,"'"))),Nz("NDHWC"===r,(()=>"Error in conv3d: got dataFormat of ".concat(r," but only NDHWC is currently supported.")));const u={x:c,filter:i},h={strides:n,pad:a,dataFormat:r,dilations:s},d=GU.runKernel(JP,u,h);return l?tq(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Cq=nG({conv3DBackpropInput_:function(e,t,n,a,r){Nz(e.length===t.rank,(()=>"Length of inShape "+"(".concat(e.length,") and rank of dy (").concat(t.rank,") must match")));let s=e,o=t,i=!1;4===t.rank&&(i=!0,o=tq(t,[1,t.shape[0],t.shape[1],t.shape[2],t.shape[3]]),s=[1,e[0],e[1],e[2],e[3]]);const c=s[4],l=o.shape[4];Nz(5===s.length,(()=>"Error in conv3dDerInput: inShape must be length 5, but got length "+"".concat(s.length,"."))),Nz(5===o.rank,(()=>"Error in conv3dDerInput: dy must be rank 5, but got "+"rank ".concat(o.rank))),Nz(5===n.rank,(()=>"Error in conv3dDerInput: filter must be rank 5, but got "+"rank ".concat(n.rank))),Nz(c===n.shape[3],(()=>"Error in conv3dDerInput: depth of input (".concat(c,") must ")+"match input depth for filter ".concat(n.shape[3],"."))),Nz(l===n.shape[4],(()=>"Error in conv3dDerInput: depth of output (".concat(l,") must ")+"match output depth for filter ".concat(n.shape[4],".")));const u={dy:o,filter:n},h={pad:r,strides:a,inputShape:s},d=GU.runKernel($P,u,h);return i?tq(d,[d.shape[1],d.shape[2],d.shape[3],d.shape[4]]):d}});const Rq=nG({conv3dTranspose_:function(e,t,n,a,r){const s=$U(e,"x","conv3dTranspose"),o=$U(t,"filter","conv3dTranspose");return Cq(n,s,o,a,r)}});const Aq=nG({cos_:function(e){const t={x:$U(e,"x","cos","float32")};return GU.runKernel(eB,t)}});const _q=nG({cosh_:function(e){const t={x:$U(e,"x","cosh","float32")};return GU.runKernel(tB,t)}});const Dq=nG({cumprod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:$U(e,"x","cumprod")},s={axis:t,exclusive:n,reverse:a};return GU.runKernel(nB,r,s)}});const Fq=nG({cumsum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r={x:$U(e,"x","cumsum")},s={axis:t,exclusive:n,reverse:a};return GU.runKernel(aB,r,s)}});const Oq=nG({denseBincount_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=$U(e,"x","denseBincount"),s=$U(t,"weights","denseBincount");Nz("int32"===r.dtype,(()=>"Error in denseBincount: input "+"dtype must be int32, but got ".concat(r.dtype))),Nz(r.rank<=2,(()=>"Error in denseBincount: input must be at most rank 2, but got "+"rank ".concat(r.rank,"."))),Nz(n>=0,(()=>"size must be non-negative, but got ".concat(n,"."))),Nz(s.size===r.size||0===s.size,(()=>"Error in denseBincount: weights must have the same shape as x or "+"0-length, but got x shape: ".concat(r.shape,", weights shape: ")+"".concat(s.shape,".")));const o={x:r,weights:s},i={size:n,binaryOutput:a};return GU.runKernel(sB,o,i)}});const Mq=nG({depthToSpace_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"NHWC";const a=$U(e,"x","depthToSpace","float32"),r="NHWC"===n?a.shape[1]:a.shape[2],s="NHWC"===n?a.shape[2]:a.shape[3],o="NHWC"===n?a.shape[3]:a.shape[1];Nz(t>1,(()=>"blockSize should be > 1 for depthToSpace, but was: ".concat(t))),Nz(r*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(r," and ").concat(t,"  for depthToSpace with input shape\n    ").concat(a.shape))),Nz(s*t>=0,(()=>"Negative dimension size caused by overflow when multiplying\n    ".concat(s," and ").concat(t," for depthToSpace with input shape\n        ").concat(a.shape))),Nz(o%(t*t)===0,(()=>"Dimension size must be evenly divisible by ".concat(t*t," but is ").concat(o," for depthToSpace with input shape ").concat(a.shape)));const i={x:a},c={blockSize:t,dataFormat:n};return GU.runKernel(oB,i,c)}});const Lq=nG({depthwiseConv2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"NHWC",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0;const i=$U(e,"x","depthwiseConv2d","float32"),c=$U(t,"filter","depthwiseConv2d","float32");let l=i,u=!1;3===i.rank&&(u=!0,l=tq(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Nz(4===l.rank,(()=>"Error in depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(l.rank,"."))),Nz(4===c.rank,(()=>"Error in depthwiseConv2d: filter must be rank 4, but got rank "+"".concat(c.rank,".")));const h="NHWC"===r?l.shape[3]:l.shape[1];Nz(h===c.shape[2],(()=>"Error in depthwiseConv2d: number of input channels "+"(".concat(h,") must match the inChannels dimension in ")+"filter ".concat(c.shape[2],"."))),eq("depthwiseConv2d",a,o);const d={x:l,filter:c},p={strides:n,pad:a,dataFormat:r,dilations:s,dimRoundingMode:o},f=GU.runKernel(iB,d,p);return u?tq(f,[f.shape[1],f.shape[2],f.shape[3]]):f}});const zq=nG({diag_:function(e){const t={x:$U(e,"x","diag")};return GU.runKernel(uB,t)}});const Pq=nG({dilation2d_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:[1,1],s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC";const o=$U(e,"x","dilation2d"),i=$U(t,"filter","dilation2d");Nz(3===o.rank||4===o.rank,(()=>"Error in dilation2d: input must be rank 3 or 4, but got rank "+"".concat(o.rank,"."))),Nz(3===i.rank,(()=>"Error in dilation2d: filter must be rank 3, but got rank "+"".concat(i.rank,"."))),Nz("NHWC"===s,(()=>"Error in dilation2d: Only NHWC is currently supported, "+"but got dataFormat of ".concat(s)));let c=o,l=!1;3===o.rank&&(c=tq(o,[1,o.shape[0],o.shape[1],o.shape[2]]),l=!0);const u={x:c,filter:i},h={strides:n,pad:a,dilations:r},d=GU.runKernel(hB,u,h);return l?tq(d,[d.shape[1],d.shape[2],d.shape[3]]):d}});const Bq=nG({equal_:function(e,t){let n=$U(e,"a","equal","string_or_numeric"),a=$U(t,"b","equal","string_or_numeric");[n,a]=OU(n,a),sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(vB,r)}});const Wq=nG({where_:function(e,t,n){const a=$U(t,"a","where"),r=$U(n,"b","where"),s=$U(e,"condition","where","bool"),o=sj(sj(s.shape,a.shape),r.shape),i={condition:gq(s,o),t:gq(a,o),e:gq(r,o)};return GU.runKernel(GW,i)}});const Vq=nG({divNoNan_:function(e,t){let n=$U(e,"a","div"),a=$U(t,"b","div");[n,a]=OU(n,a);const r=nK(n,a),s=oK(r),o=Bq(a,s);return Wq(o,s,r)}});const Uq=nG({dot_:function(e,t){const n=$U(e,"t1","dot"),a=$U(t,"t2","dot");Nz((1===n.rank||2===n.rank)&&(1===a.rank||2===a.rank),(()=>"Error in dot: inputs must all be rank 1 or 2, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=1===n.rank?n.size:n.shape[1],s=1===a.rank?a.size:a.shape[0];if(Nz(r===s,(()=>"Error in dot: inner dimensions of inputs must match, but got "+"".concat(r," and ").concat(s,"."))),1===n.rank&&1===a.rank){const e=tq(n,[1,-1]),t=tq(a,[-1,1]),r=RH(e,t);return tq(r,[])}if(1===n.rank&&2===a.rank){const e=tq(n,[1,-1]),t=tq(a,[a.shape[0],a.shape[1]]),r=RH(e,t);return tq(r,[r.size])}if(2===n.rank&&1===a.rank){const e=tq(a,[-1,1]),t=RH(n,e);return tq(t,[t.size])}{const e=tq(a,[a.shape[0],a.shape[1]]);return RH(n,e)}}});const Gq=nG({einsum_:function(e){for(var t=arguments.length,n=new Array(t>1?t-1:0),a=1;a<t;a++)n[a-1]=arguments[a];const r=n.map(((e,t)=>$U(e,"tensors".concat(t),"einsum"))),s={equation:e};return GU.runKernel(mB,r,s)}});const Hq=nG({elu_:function(e){const t={x:$U(e,"x","elu","float32")};return GU.runKernel(gB,t)}});const jq=nG({erf_:function(e){let t=$U(e,"x","erf");Nz("int32"===t.dtype||"float32"===t.dtype,(()=>"Input dtype must be `int32` or `float32`.")),"int32"===t.dtype&&(t=oH(t,"float32"));const n={x:t};return GU.runKernel(bB,n)}});function Kq(e,t){for(let n=0;n<e.length;++n)if(e[e.length-n-1]!==t-1-n)return!1;return!0}function qq(e,t,n){const a=e.length+t.length,r=[];let s=0,o=0;for(let i=0;i<a;i++)-1===n.indexOf(i)?r.push(e[s++]):r.push(t[o++]);return r}function Xq(e,t){const n=[],a=e.length;for(let r=0;r<a;r++)-1===t.indexOf(r)&&n.push(e[r]);return[n,t.map((t=>e[t]))]}function Yq(e,t){return qq(e,t.map((e=>1)),t)}function Qq(e,t,n){Nz(Kq(t,n),(()=>"".concat(e," supports only inner-most axes for now. ")+"Got axes ".concat(t," and rank-").concat(n," input.")))}function Jq(e,t){if(Kq(e,t))return null;const n=[];for(let a=0;a<t;++a)-1===e.indexOf(a)&&n.push(a);return e.forEach((e=>n.push(e))),n}function Zq(e){return e.map(((e,t)=>[t,e])).sort(((e,t)=>e[1]-t[1])).map((e=>e[0]))}function $q(e,t){const n=[];for(let a=t-e;a<t;++a)n.push(a);return n}const eX=nG({max_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:$U(e,"x","max")},r={reductionIndices:t,keepDims:n};return GU.runKernel($B,a,r)}});const tX=nG({min_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:$U(e,"x","min")},r={axis:t,keepDims:n};return GU.runKernel(iW,a,r)}});const nX=nG({sum_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=$U(e,"x","sum");"bool"===a.dtype&&(a=oH(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return GU.runKernel(ZW,r,s)}});function aX(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;if(0===e.rank)return kK(e);if(1!==e.rank&&null===n)return aX(tq(e,[-1]),t,n);if(1===e.rank||"number"===typeof n||Array.isArray(n)&&1===n.length){if(1===t)return nX(kK(e),n);if(t===1/0)return eX(kK(e),n);if(t===-1/0)return tX(kK(e),n);if("euclidean"===t||2===t)return rK(nX(vK(kK(e),fK(2,"int32")),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}if(Array.isArray(n)&&2===n.length){if(1===t)return eX(nX(kK(e),n[0]),n[1]-1);if(t===1/0)return eX(nX(kK(e),n[1]),n[0]);if(t===-1/0)return tX(nX(kK(e),n[1]),n[0]);if("fro"===t||"euclidean"===t)return rK(nX(sK(e),n));throw new Error("Error in norm: invalid ord value: ".concat(t))}throw new Error("Error in norm: invalid axis: ".concat(n))}const rX=nG({norm_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"euclidean",n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null,a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=aX(e=$U(e,"x","norm"),t,n);let s=r.shape;if(a){const t=Bz(n,e.shape);s=Yq(r.shape,t)}return tq(r,s)}});const sX=nG({euclideanNorm_:function(e){return rX(e,"euclidean",arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,arguments.length>2&&void 0!==arguments[2]&&arguments[2])}});const oX=nG({exp_:function(e){const t={x:$U(e,"x","exp")};return GU.runKernel(xB,t)}});const iX=nG({expandDims_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=$U(e,"x","expandDims","string_or_numeric");Nz(t<=n.rank,(()=>"Axis must be <= rank of the tensor"));const a={input:n},r={dim:t};return GU.runKernel(wB,a,r)}});const cX=nG({expm1_:function(e){const t={x:$U(e,"x","expm1")};return GU.runKernel(kB,t)}});const lX=nG({tile_:function(e,t){const n=$U(e,"x","tile","string_or_numeric");Nz(n.rank===t.length,(()=>"Error in transpose: rank of input ".concat(n.rank," ")+"must match length of reps ".concat(t,".")));const a={x:n},r={reps:t};return GU.runKernel(gV,a,r)}});const uX=nG({eye_:function(e,t,n){null==t&&(t=e);const a=sH([e,t],arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),r=e<=t?e:t;for(let o=0;o<r;++o)a.set(1,o,o);const s=tq(a.toTensor(),[e,t]);if(null==n)return s;if(1===n.length)return lX(iX(s,0),[n[0],1,1]);if(2===n.length)return lX(iX(iX(s,0),0),[n[0],n[1],1,1]);if(3===n.length)return lX(iX(iX(iX(s,0),0),0),[n[0],n[1],n[2],1,1]);throw new Error("eye() currently supports only 1D and 2D "+"batchShapes, but received ".concat(n.length,"D."))}});const hX=nG({floor_:function(e){const t={x:$U(e,"x","floor","float32")};return GU.runKernel(TB,t)}});const dX=nG({gather_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r={x:$U(e,"x","gather"),indices:$U(t,"indices","gather","int32")},s={axis:n,batchDims:a};return GU.runKernel(RB,r,s)}});const pX=nG({greater_:function(e,t){let n=$U(e,"a","greater","string_or_numeric"),a=$U(t,"b","greater","string_or_numeric");[n,a]=OU(n,a),sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(_B,r)}});const fX=nG({greaterEqual_:function(e,t){let n=$U(e,"a","greaterEqual","string_or_numeric"),a=$U(t,"b","greaterEqual","string_or_numeric");[n,a]=OU(n,a),sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(DB,r)}});const mX=nG({isFinite_:function(e){const t={x:$U(e,"x","isFinite")};return GU.runKernel(LB,t)}});const gX=nG({isInf_:function(e){const t={x:$U(e,"x","isInf")};return GU.runKernel(zB,t)}});const yX=nG({isNaN_:function(e){const t={x:$U(e,"x","isNaN")};return GU.runKernel(PB,t)}});const bX=nG({leakyRelu_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:.2;const n={x:$U(e,"x","leakyRelu")},a={alpha:t};return GU.runKernel(BB,n,a)}});const vX=nG({less_:function(e,t){let n=$U(e,"a","less","string_or_numeric"),a=$U(t,"b","less","string_or_numeric");[n,a]=OU(n,a),sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(WB,r)}});const xX=nG({lessEqual_:function(e,t){let n=$U(e,"a","lessEqual","string_or_numeric"),a=$U(t,"b","lessEqual","string_or_numeric");[n,a]=OU(n,a),sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(VB,r)}});function wX(e,t,n){if(n<=0)throw new Error("The number of values should be positive.");const a={start:e,stop:t,num:n};return GU.runKernel(UB,{},a)}const kX=nG({localResponseNormalization_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:.5;const s=$U(e,"x","localResponseNormalization");Nz(4===s.rank||3===s.rank,(()=>"Error in localResponseNormalization: x must be rank 3 or 4 but got\n               rank ".concat(s.rank,"."))),Nz(Dz(t),(()=>"Error in localResponseNormalization: depthRadius must be an "+"integer but got depthRadius ".concat(t,".")));let o=s,i=!1;3===s.rank&&(i=!0,o=tq(s,[1,s.shape[0],s.shape[1],s.shape[2]]));const c={x:o},l={depthRadius:t,bias:n,alpha:a,beta:r},u=GU.runKernel(JB,c,l);return i?tq(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const SX=nG({log_:function(e){const t={x:$U(e,"x","log","float32")};return GU.runKernel(GB,t)}});const IX=nG({log1p_:function(e){const t={x:$U(e,"x","log1p")};return GU.runKernel(HB,t)}});const NX=nG({softplus_:function(e){const t={x:$U(e,"x","softplus")};return GU.runKernel(QW,t)}});const TX=nG({logSigmoid_:function(e){const t=$U(e,"x","logSigmoid");return dK((e=>({value:$H(NX($H(e))),gradFunc:t=>aK(t,sq($H(e)))})))(t)}});const EX=nG({logSoftmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=$U(e,"logits","logSoftmax");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Log Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and axis was ").concat(t));const a=dK(((e,n)=>{const a=eX(e,t,!0),r=xK(e,a),s=xK(oH(r,"float32"),SX(nX(oX(r),t,!0)));n([s]);return{value:s,gradFunc:(e,n)=>{const[a]=n,r=oX(a);return xK(e,aK(nX(e,t,!0),r))}}}));return a(n)}});const CX=nG({logSumExp_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a=$U(e,"x","logSumExp"),r=Bz(t,a.shape),s=eX(a,r,!0),o=xK(a,s),i=oX(o),c=nX(i,r),l=SX(c),u=eK(tq(s,l.shape),l);if(n){const e=Yq(u.shape,r);return tq(u,e)}return u}});const RX=nG({logicalAnd_:function(e,t){const n=$U(e,"a","logicalAnd","bool"),a=$U(t,"b","logicalAnd","bool");sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(jB,r)}});const AX=nG({logicalNot_:function(e){const t={x:$U(e,"x","logicalNot","bool")};return GU.runKernel(KB,t)}});const _X=nG({logicalOr_:function(e,t){const n=$U(e,"a","logicalOr","bool"),a=$U(t,"b","logicalOr","bool");sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(qB,r)}});const DX=nG({logicalXor_:function(e,t){const n=$U(e,"a","logicalXor","bool"),a=$U(t,"b","logicalXor","bool");return sj(n.shape,a.shape),RX(_X(e,t),AX(RX(e,t)))}}),FX=2147483648;const OX=nG({searchSorted_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"left";const a=$U(e,"sortedSequence","searchSorted"),r=$U(t,"values","searchSorted"),s=a.shape[a.shape.length-1],o=r.shape[r.shape.length-1],i=tq(a,[-1,s]),c=tq(r,[-1,o]);if(i.rank<2)throw new Error("Sorted input argument must be at least 2-dimensional");if(i.shape[0]!==c.shape[0])throw new Error("Leading dimension of 'sortedSequence' and 'values' must match.");if(Rz(c.shape)>=FX)throw new Error("values tensor size must less than ".concat(FX));if(i.shape[1]>=FX)throw new Error("trailing dim_size must less than ".concat(FX," for int32 output type, was ").concat(i.shape[1]));const l={sortedSequence:i,values:c},u={side:n};return GU.runKernel(UW,l,u)}});function MX(e,t){return OX(e,t,"left")}const LX=nG({maxPool_:function(e,t,n,a,r){const s=$U(e,"x","maxPool");let o=s,i=!1;3===s.rank&&(i=!0,o=tq(s,[1,s.shape[0],s.shape[1],s.shape[2]])),Nz(4===o.rank,(()=>"Error in maxPool: input must be rank 4 but got rank ".concat(o.rank,"."))),Nz(ZK(n,1),(()=>"Error in maxPool: Either strides or dilations must be 1. "+"Got strides ".concat(n," and dilations '").concat(1,"'"))),eq("maxPool",a,r);const c={x:o},l={filterSize:t,strides:n,pad:a,dimRoundingMode:r},u=GU.runKernel(tW,c,l);return i?tq(u,[u.shape[1],u.shape[2],u.shape[3]]):u}});const zX=nG({maxPool3d_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[1,1,1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NDHWC";const o=$U(e,"x","maxPool3d");let i=o,c=!1;4===o.rank&&(c=!0,i=tq(o,[1,o.shape[0],o.shape[1],o.shape[2],o.shape[3]])),Nz(5===i.rank,(()=>"Error in maxPool3d: x must be rank 5 but got rank ".concat(i.rank,"."))),Nz("NDHWC"===s,(()=>"Error in maxPool3d: Only NDHWC is currently supported, "+"but got dataFormat of ".concat(s))),eq("maxPool3d",a,r);const l={x:i},u={filterSize:t,strides:n,pad:a,dimRoundingMode:r,dataFormat:s},h=GU.runKernel(aW,l,u);return c?tq(h,[h.shape[1],h.shape[2],h.shape[3],h.shape[4]]):h}});const PX=nG({maxPoolWithArgmax_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]&&arguments[4];const s={x:$U(e,"x","maxPoolWithArgmax")},o={filterSize:t,strides:n,pad:a,includeBatchInIndex:r},i=GU.runKernel(sW,s,o);return{result:i[0],indexes:i[1]}}});const BX=nG({mean_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const a={x:$U(e,"x","mean")},r={axis:t,keepDims:n};return GU.runKernel(oW,a,r)}});function WX(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===t){const t=WX(e,"float32"),n=WX(e,"float32");return aG(t,n)}const n=sP(Rz(e),t);return GU.makeTensor(n,e,t)}function VX(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"float32";if("complex64"===t){const t=VX(e,"float32"),n=WX(e,"float32");return aG(t,n)}const n=rP(Rz(e),t);return GU.makeTensor(n,e,t)}function UX(e,t){let{indexing:n="xy"}=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};if("xy"!==n&&"ij"!==n)throw new TypeError("".concat(n," is not a valid third argument to meshgrid"));if(void 0===e)return[];let a=$U(e,"x","meshgrid",e instanceof IU?e.dtype:"float32");if(void 0===t)return[a];let r=$U(t,"y","meshgrid",t instanceof IU?t.dtype:"float32");const s=Rz(a.shape),o=Rz(r.shape);return"xy"===n?(a=tq(a,[1,-1]),r=tq(r,[-1,1]),[RH(VX([o,1],a.dtype),a),RH(r,VX([1,s],r.dtype))]):(a=tq(a,[-1,1]),r=tq(r,[1,-1]),[RH(a,VX([1,o],a.dtype)),RH(VX([s,1],r.dtype),r)])}const GX=nG({minimum_:function(e,t){let n=$U(e,"a","minimum"),a=$U(t,"b","minimum");[n,a]=OU(n,a),"bool"===n.dtype&&(n=oH(n,"int32"),a=oH(a,"int32")),sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(cW,r)}});const HX=nG({mirrorPad_:function(e,t,n){Nz("reflect"===n||"symmetric"===n,(()=>"Invalid mode. Mode must be either reflect or symmetric. "+"Got ".concat(n,".")));const a=$U(e,"x","mirrorPad");if(0===a.rank)throw new Error("mirrorPad(scalar) is not defined. Pass non-scalar to mirrorPad");Nz(t.length===a.rank,(()=>"Padding doesn't match input. Must be ".concat(a.rank,". ")+"Got ".concat(t.length,".")));const r="reflect"===n?1:0;for(let i=0;i<a.rank;i++)Nz(2===t[i].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),Nz(t[i][0]>=0&&t[i][0]<=a.shape[i]-r&&t[i][1]>=0&&t[i][1]<=a.shape[i]-r,(()=>"Padding in dimension ".concat(i," cannot be greater than or equal ")+"to ".concat(a.shape[i]-r," or less than 0 for input of ")+"shape ".concat(a.shape)));const s={paddings:t,mode:n},o={x:a};return GU.runKernel(lW,o,s)}});const jX=nG({mod_:function(e,t){let n=$U(e,"a","mod"),a=$U(t,"b","mod");[n,a]=OU(n,a);const r={a:n,b:a};return GU.runKernel(uW,r)}});const KX=nG({moments_:function(e){let t=arguments.length>2&&void 0!==arguments[2]&&arguments[2];const n=Bz(arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,(e=$U(e,"x","moments")).shape),a=BX(e,n,t);let r=a.shape;t||(r=Yq(a.shape,n));const s=sK(xK(oH(e,"float32"),tq(a,r)));return{mean:a,variance:BX(s,n,t)}}});const qX=nG({multiRNNCell_:function(e,t,n,a){const r=$U(t,"data","multiRNNCell"),s=eG(n,"c","multiRNNCell"),o=eG(a,"h","multiRNNCell");let i=r;const c=[];for(let h=0;h<e.length;h++){const t=e[h](i,s[h],o[h]);c.push(t[0]),c.push(t[1]),i=t[1]}const l=[],u=[];for(let h=0;h<c.length;h+=2)l.push(c[h]),u.push(c[h+1]);return[l,u]}});const XX=nG({multinomial_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=$U(e,"logits","multinomial"),s=r.size,o=r.rank;if(s<2)throw new Error("Error in multinomial: you need at least 2 outcomes, but got "+"".concat(s,"."));if(o>2)throw new Error("Rank of probabilities must be 1 or 2, but is ".concat(o));n=n||Math.random();const i={logits:1===o?tq(r,[1,-1]):r},c={numSamples:t,seed:n,normalized:a},l=GU.runKernel(hW,i,c);return 1===o?tq(l,[l.size]):l}});const YX=nG({notEqual_:function(e,t){let n=$U(e,"a","notEqual","string_or_numeric"),a=$U(t,"b","notEqual","string_or_numeric");[n,a]=OU(n,a),sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(fW,r)}});const QX=nG({onesLike_:function(e){const t={x:$U(e,"x","onesLike")};return GU.runKernel(bW,t)}});const JX=nG({outerProduct_:function(e,t){const n=$U(e,"v1","outerProduct"),a=$U(t,"v2","outerProduct");Nz(1===n.rank&&1===a.rank,(()=>"Error in outerProduct: inputs must be rank 1, but got ranks "+"".concat(n.rank," and ").concat(a.rank,".")));const r=tq(n,[-1,1]),s=tq(a,[1,-1]);return RH(r,s)}});const ZX=nG({pad_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a=$U(e,"x","pad");if(0===a.rank)throw new Error("pad(scalar) is not defined. Pass non-scalar to pad");const r={paddings:t,constantValue:n},s={x:a};return GU.runKernel(wW,s,r)}});const $X=nG({pad1d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Nz(2===t.length,(()=>"Invalid number of paddings. Must be length of 2.")),ZX(e,[t],n)}});const eY=nG({pad2d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Nz(2===t.length&&2===t[0].length&&2===t[1].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),ZX(e,t,n)}});const tY=nG({pad3d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Nz(3===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),ZX(e,t,n)}});const nY=nG({pad4d_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;return Nz(4===t.length&&2===t[0].length&&2===t[1].length&&2===t[2].length&&2===t[3].length,(()=>"Invalid number of paddings. Must be length of 2 each.")),ZX(e,t,n)}});const aY=nG({spaceToBatchND_:function(e,t,n){const a=$U(e,"x","spaceToBatchND");Nz(a.rank>=1+t.length,(()=>"input rank ".concat(a.rank," should be > than [blockShape] ").concat(t.length))),Nz(n.length===t.length,(()=>"paddings.shape[0] ".concat(n.length," must be equal to [blockShape] ").concat(t.length))),Nz(a.shape.reduce(((e,a,r)=>r>0&&r<=t.length?e&&(a+n[r-1][0]+n[r-1][1])%t[r-1]===0:e),!0),(()=>"input spatial dimensions ".concat(a.shape.slice(1)," with paddings ").concat(n.toString()," must be divisible by blockShapes ").concat(t.toString())));const r={x:a},s={blockShape:t,paddings:n};return GU.runKernel($W,r,s)}});const rY=nG({pool_:function(e,t,n,a,r,s,o){null==r&&(r=[1,1]),null==s&&(s=1),0===a&&(a="valid");const i=$U(e,"x","maxPool");let c=i,l=!1;3===i.rank&&(l=!0,c=tq(i,[1,i.shape[0],i.shape[1],i.shape[2]])),Nz(ZK(s,r),(()=>"Error in pool: Either strides or dilations must be 1. "+"Got strides ".concat(s," and dilations '").concat(r,"'")));const u=UK(c.shape,t,s,r,a),h=[u.dilationHeight,u.dilationWidth];let d;d="same"===a?function(e,t){const n=e.map(((e,n)=>e+(e-1)*(t[n]-1))),a=n.map((e=>e-1)),r=a.map((e=>Math.floor(e/2))),s=a.map(((e,t)=>e-r[t]));return a.map(((e,t)=>[r[t],s[t]]))}([u.filterHeight,u.filterWidth],h):[[0,0],[0,0]];const p=1===h[0]&&1===h[1],[f,m]=function(e,t,n){const a=n.map((e=>e[0])),r=n.map((e=>e[1])),s=e.concat(a,r),o=t.map(((e,t)=>(e-s[t]%e)%e)),i=r.map(((e,t)=>e+o[t])),c=t.map(((e,t)=>[a[t],i[t]])),l=t.map(((e,t)=>[0,o[t]]));return[c,l]}([u.inHeight,u.inWidth],h,d),g=p?a:"valid",y=p?c:aY(c,h,f),b=("avg"===n?()=>nq(y,t,s,g,o):()=>LX(y,t,s,g,o))(),v=p?b:lq(b,h,m);return l?tq(v,[v.shape[1],v.shape[2],v.shape[3]]):v}});const sY=nG({prelu_:function(e,t){const n={x:$U(e,"x","prelu"),alpha:$U(t,"alpha","prelu")};return GU.runKernel(IW,n)}});const oY=nG({prod_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=$U(e,"x","prod");"bool"===a.dtype&&(a=oH(a,"int32"));const r={x:a},s={axis:t,keepDims:n};return GU.runKernel(NW,r,s)}});const iY=nG({raggedGather_:function(e,t,n,a){const r={paramsNestedSplits:e.map(((e,t)=>$U(e,"tensors".concat(t),"raggedGather","int32"))),paramsDenseValues:$U(t,"paramsDenseValues","raggedGather"),indices:$U(n,"indices","raggedGather","int32")},s={outputRaggedRank:a},o=GU.runKernel(TW,r,s);return{outputNestedSplits:o.slice(0,o.length-1),outputDenseValues:o[o.length-1]}}});const cY=nG({raggedTensorToTensor_:function(e,t,n,a,r){const s=$U(e,"shape","raggedTensorToTensor","int32"),o=$U(t,"values","raggedTensorToTensor"),i={shape:s,values:o,defaultValue:$U(n,"defaultValue","raggedTensorToTensor",o.dtype),rowPartitionTensors:a.map(((e,t)=>$U(e,"tensors".concat(t),"raggedTensorToTensor","int32")))},c={rowPartitionTypes:r};return GU.runKernel(EW,i,c)}});const lY=nG({rand_:function(e,t,n){const a=Rz(e);let r=null;if(null==n||"float32"===n)r=new Float32Array(a);else if("int32"===n)r=new Int32Array(a);else{if("bool"!==n)throw new Error("Unknown data type ".concat(n));r=new Uint8Array(a)}for(let s=0;s<a;s++)r[s]=t();return GU.makeTensor(r,e,n)}});class uY{constructor(e,t,n,a,r){this.mean=e,this.stdDev=t,this.dtype=n,this.nextVal=NaN,this.truncated=a,this.truncated&&(this.upper=this.mean+2*this.stdDev,this.lower=this.mean-2*this.stdDev);const s=r||Math.random();this.random=Zc.alea(s.toString())}nextValue(){if(!isNaN(this.nextVal)){const e=this.nextVal;return this.nextVal=NaN,e}let e,t,n=!1;for(;!n;){let a,r,s;do{a=2*this.random()-1,r=2*this.random()-1,s=a*a+r*r}while(s>=1||0===s);const o=Math.sqrt(-2*Math.log(s)/s);e=this.mean+this.stdDev*a*o,t=this.mean+this.stdDev*r*o,this.truncated&&!this.isValidTruncated(e)||(n=!0)}return this.truncated&&!this.isValidTruncated(t)||(this.nextVal=this.convertValue(t)),this.convertValue(e)}convertValue(e){return null==this.dtype||"float32"===this.dtype?e:Math.round(e)}isValidTruncated(e){return e<=this.upper&&e>=this.lower}}class hY{constructor(e,t,n,a){this.alpha=e,this.beta=1/t,this.dtype=n;const r=a||Math.random();this.randu=Zc.alea(r.toString()),this.randn=new uY(0,1,n,!1,this.randu()),this.d=e<1?e+2/3:e-1/3,this.c=1/Math.sqrt(9*this.d)}nextValue(){let e,t,n,a,r,s;for(;;){do{a=this.randn.nextValue(),s=1+this.c*a}while(s<=0);if(s*=s*s,e=a*a,t=1-.331*e*e,n=.5*e+this.d*(1-s+Math.log(s)),r=this.randu(),r<t||Math.log(r)<n)break}return s=1/this.beta*this.d*s,this.alpha<1&&(s*=Math.pow(this.randu(),1/this.alpha)),this.convertValue(s)}convertValue(e){return"float32"===this.dtype?e:Math.round(e)}}class dY{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;if(this.canReturnFloat=()=>null==this.dtype||"float32"===this.dtype,this.min=e,this.range=t-e,this.dtype=n,null==a&&(a=Math.random()),"number"===typeof a&&(a=a.toString()),!this.canReturnFloat()&&this.range<=1)throw new Error("The difference between ".concat(e," - ").concat(t," <= 1 and dtype is not float"));this.random=Zc.alea(a)}convertValue(e){return this.canReturnFloat()?e:Math.round(e)}nextValue(){return this.convertValue(this.min+this.range*this.random())}}const pY=nG({randomGamma_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32",r=arguments.length>4?arguments[4]:void 0;if(null==n&&(n=1),null==a&&(a="float32"),"float32"!==a&&"int32"!==a)throw new Error("Unsupported data type ".concat(a));const s=new hY(t,n,a,r),o=sH(e,a);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const fY=nG({randomNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(null!=a&&"bool"===a)throw new Error("Unsupported data type ".concat(a));const s=new uY(t,n,a,!1,r),o=sH(e,a);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const mY=nG({randomStandardNormal_:function(e,t,n){if(null!=t&&"bool"===t)throw new Error("Unsupported data type ".concat(t));return fY(e,0,1,t,n)}});const gY=nG({randomUniform_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>4?arguments[4]:void 0;const r=sH(e,arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32"),s=new dY(t,n,null,a);for(let o=0;o<r.values.length;o++)r.values[o]=s.nextValue();return r.toTensor()}});function yY(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"float32";if(0===n)throw new Error("Cannot have a step of zero");const r={start:e,stop:t,step:n,dtype:a};return GU.runKernel(CW,{},r)}const bY=nG({reciprocal_:function(e){const t={x:$U(e,"x","reciprocal")};return GU.runKernel(AW,t)}});const vY=nG({relu_:function(e){const t={x:$U(e,"x","relu")};return GU.runKernel(_W,t)}});const xY=nG({relu6_:function(e){const t={x:$U(e,"x","relu6")};return GU.runKernel(zW,t)}});const wY=nG({reverse_:function(e,t){const n={x:$U(e,"x","reverse")},a={dims:t};return GU.runKernel(PW,n,a)}});const kY=nG({reverse1d_:function(e){const t=$U(e,"x","reverse");return Nz(1===t.rank,(()=>"Error in reverse1D: x must be rank 1 but got rank ".concat(t.rank,"."))),wY(t,0)}});const SY=nG({reverse2d_:function(e,t){const n=$U(e,"x","reverse");return Nz(2===n.rank,(()=>"Error in reverse2D: x must be rank 2 but got rank ".concat(n.rank,"."))),wY(n,t)}});const IY=nG({reverse3d_:function(e,t){const n=$U(e,"x","reverse");return Nz(3===n.rank,(()=>"Error in reverse3D: x must be rank 3 but got rank ".concat(n.rank,"."))),wY(n,t)}});const NY=nG({reverse4d_:function(e,t){const n=$U(e,"x","reverse");return Nz(4===n.rank,(()=>"Error in reverse4D: x must be rank 4 but got rank ".concat(n.rank,"."))),wY(n,t)}});const TY=nG({round_:function(e){const t={x:$U(e,"x","round")};return GU.runKernel(BW,t)}});const EY=nG({rsqrt_:function(e){const t={x:$U(e,"x","rsqrt","float32")};return GU.runKernel(WW,t)}});const CY=nG({selu_:function(e){const t={x:$U(e,"x","selu")};return GU.runKernel(HW,t)}});const RY=nG({separableConv2d_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:"NHWC";const i=$U(e,"x","separableConv2d"),c=$U(t,"depthwiseFilter","separableConv2d"),l=$U(n,"pointwiseFilter","separableConv2d");let u=i,h=!1;if(3===i.rank&&(h=!0,u=tq(i,[1,i.shape[0],i.shape[1],i.shape[2]])),"NCHW"===o)throw new Error("separableConv2d currently does not support dataFormat NCHW; only NHWC is supported");Nz(4===u.rank,(()=>"Error in separableConv2d: input must be rank 4, but got "+"rank ".concat(u.rank,"."))),Nz(4===c.rank,(()=>"Error in separableConv2d: depthwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),Nz(4===l.rank,(()=>"Error in separableConv2d: pointwise filter must be rank 4, but "+"got rank ".concat(c.rank,"."))),Nz(1===l.shape[0],(()=>"Error in separableConv2d: the first dimension of pointwise filter "+" must be 1, but got ".concat(l.shape[0],"."))),Nz(1===l.shape[1],(()=>"Error in separableConv2d: the second dimension of pointwise "+"filter must be 1, but got ".concat(l.shape[1],".")));const d=c.shape[2],p=c.shape[3];Nz(l.shape[2]===d*p,(()=>"Error in separableConv2d: the third dimension of pointwise filter "+"must be ".concat(d*p,", ")+"but got ".concat(l.shape[2],".")));const f=Lq(u,c,a,r,o,s),m=Sq(f,l,1,"valid",o);return h?tq(m,[m.shape[1],m.shape[2],m.shape[3]]):m}});const AY=async function(e,t){const n=$U(e,"x","setdiff1d"),a=$U(t,"y","setdiff1d");Nz(n.dtype===a.dtype,(()=>"x and y should have the same dtype, but got x (".concat(n.dtype,") and y (").concat(a.dtype,")."))),Nz(1===n.rank,(()=>"x should be 1D tensor, but got x (".concat(n.shape,")."))),Nz(1===a.rank,(()=>"y should be 1D tensor, but got y (".concat(a.shape,").")));const r=await n.data(),s=await a.data(),o=new Set(s);let i=0;for(let u=0;u<r.length;u++)o.has(r[u])||i++;const c=new xU([i],n.dtype),l=new xU([i],"int32");for(let u=0,h=0;u<r.length;u++)o.has(r[u])||(c.values[h]=r[u],l.values[h]=u,h++);return[c.toTensor(),l.toTensor()]};const _Y=nG({sign_:function(e){const t={x:$U(e,"x","sign")};return GU.runKernel(XW,t)}});const DY=nG({sin_:function(e){const t={x:$U(e,"x","sin","float32")};return GU.runKernel(KW,t)}});const FY=nG({sinh_:function(e){const t={x:$U(e,"x","sinh")};return GU.runKernel(qW,t)}});const OY=nG({slice1d_:function(e,t,n){const a=$U(e,"x","slice1d");return Nz(1===a.rank,(()=>"slice1d expects a rank-1 tensor, but got a rank-".concat(a.rank," tensor"))),oq(a,[t],[n])}});const MY=nG({slice2d_:function(e,t,n){const a=$U(e,"x","slice2d");return Nz(2===a.rank,(()=>"slice2d expects a rank-2 tensor, but got a rank-".concat(a.rank," tensor"))),oq(a,t,n)}});const LY=nG({slice3d_:function(e,t,n){const a=$U(e,"x","slice3d");return Nz(3===a.rank,(()=>"slice3d expects a rank-3 tensor, but got a rank-".concat(a.rank," tensor"))),oq(a,t,n)}});const zY=nG({slice4d_:function(e,t,n){const a=$U(e,"x","slice4d");return Nz(4===a.rank,(()=>"slice4d expects a rank-4 tensor, but got a rank-".concat(a.rank," tensor"))),oq(a,t,n)}});const PY=nG({softmax_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:-1;const n=$U(e,"logits","softmax","float32");if(-1===t&&(t=n.rank-1),t!==n.rank-1)throw Error("Softmax along a non-last dimension is not yet supported. "+"Logits was rank ".concat(n.rank," and dim was ").concat(t));const a={logits:n},r={dim:t};return GU.runKernel(tV,a,r)}});const BY=nG({fft_:function(e){Nz("complex64"===e.dtype,(()=>"The dtype for tf.spectral.fft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return GU.runKernel(SB,t)}});const WY=nG({ifft_:function(e){Nz("complex64"===e.dtype,(()=>"The dtype for tf.spectral.ifft() must be complex64 "+"but got ".concat(e.dtype,".")));const t={input:e};return GU.runKernel(OB,t)}});const VY=nG({irfft_:function(e){const t=e.shape[e.shape.length-1],n=e.size/t;let a;if(t<=2){const r=tq(e,[n,t]);a=WY(r)}else{const r=[n,2*(t-1)],s=tq(ej(e),[n,t]),o=tq(ZH(e),[n,t]),i=wY(oq(s,[0,1],[n,t-2]),1),c=aK(wY(oq(o,[0,1],[n,t-2]),1),fK(-1)),l=rq([s,i],1),u=rq([o,c],1),h=tq(aG(l,u),[r[0],r[1]]);a=WY(h)}if(a=ej(a),3===e.rank&&0!==e.shape[0]){const t=a,n=e.shape[0];a=tq(a,[n,a.shape[0]/n,a.shape[1]]),t.dispose()}return a}});const UY=nG({split_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const a={x:$U(e,"x","split")},r={numOrSizeSplits:t,axis:n};return GU.runKernel(eV,a,r)}});const GY=nG({rfft_:function(e,t){Nz("float32"===e.dtype,(()=>"The dtype for rfft() must be real value but got ".concat(e.dtype)));let n=e.shape[e.shape.length-1];const a=e.size/n;let r;if(null!=t&&t<n){const a=e.shape.map((e=>0)),s=e.shape.map((e=>e));s[e.shape.length-1]=t,r=oq(e,a,s),n=t}else if(null!=t&&t>n){const a=e.shape.map((e=>e));a[e.shape.length-1]=t-n,r=rq([e,WX(a)],e.shape.length-1),n=t}else r=e;const s=oK(r),o=tq(aG(r,s),[a,n]),i=BY(o),c=Math.floor(n/2)+1,l=ej(i),u=ZH(i),h=UY(l,[c,n-c],l.shape.length-1),d=UY(u,[c,n-c],u.shape.length-1),p=r.shape.slice();return p[r.shape.length-1]=c,tq(aG(h[0],d[0]),p)}});const HY=nG({squaredDifference_:function(e,t){let n=$U(e,"a","squaredDifference"),a=$U(t,"b","squaredDifference");[n,a]=OU(n,a),sj(n.shape,a.shape);const r={a:n,b:a};return GU.runKernel(iV,r,{})}});const jY=nG({squeeze_:function(e,t){const n=$U(e,"x","squeeze","string_or_numeric");return tq(n,Wz(n.shape,t).newShape)}});const KY=nG({stack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=eG(e,"tensors","stack","string_or_numeric");Nz(n.length>=1,(()=>"Pass at least one tensor to tf.stack")),n.length>0&&Nz(t<=n[0].rank,(()=>"Axis must be <= rank of the tensor"));const a=n,r={axis:t};return GU.runKernel(xW,a,r)}});const qY=nG({step_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n={x:$U(e,"x","step")},a={alpha:t};return GU.runKernel(NV,n,a)}});const XY=nG({stridedSlice_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:0,i=arguments.length>7&&void 0!==arguments[7]?arguments[7]:0,c=arguments.length>8&&void 0!==arguments[8]?arguments[8]:0;const l={x:$U(e,"x","stridedSlice","string_or_numeric")},u={begin:t,end:n,strides:a,beginMask:r,endMask:s,ellipsisMask:o,newAxisMask:i,shrinkAxisMask:c};return GU.runKernel(lV,l,u)}});const YY=nG({tan_:function(e){const t={x:$U(e,"x","tan","float32")};return GU.runKernel(fV,t)}});function QY(e,t){Ez(e);const n=QU(e,t);if(1!==n.length)throw new Error("tensor1d() requires values to be a flat/TypedArray");return rG(e,null,n,t)}function JY(e,t,n){if(Ez(e),null!=t&&2!==t.length)throw new Error("tensor2d() requires shape to have two numbers");const a=QU(e,n);if(2!==a.length&&1!==a.length)throw new Error("tensor2d() requires values to be number[][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor2d() requires shape to be provided when `values` are a flat/TypedArray");return rG(e,t,a,n)}function ZY(e,t,n){if(Ez(e),null!=t&&4!==t.length)throw new Error("tensor4d() requires shape to have four numbers");const a=QU(e,n);if(4!==a.length&&1!==a.length)throw new Error("tensor4d() requires values to be number[][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor4d() requires shape to be provided when `values` are a flat array");return rG(e,t,a,n)}function $Y(e,t,n){if(Ez(e),null!=t&&5!==t.length)throw new Error("tensor5d() requires shape to have five numbers");const a=QU(e,n);if(5!==a.length&&1!==a.length)throw new Error("tensor5d() requires values to be number[][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor5d() requires shape to be provided when `values` are a flat array");return rG(e,t,a,n)}function eQ(e,t,n){if(Ez(e),null!=t&&6!==t.length)throw new Error("tensor6d() requires shape to have six numbers");const a=QU(e,n);if(6!==a.length&&1!==a.length)throw new Error("tensor6d() requires values to be number[][][][][][] or flat/TypedArray");if(1===a.length&&null==t)throw new Error("tensor6d() requires shape to be provided when `values` are a flat array");return rG(e,t=t||a,a,n)}const tQ=nG({topk_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:1,n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=$U(e,"x","topk");if(0===a.rank)throw new Error("topk() expects the input to be of rank 1 or higher");const r=a.shape[a.shape.length-1];if(t<0)throw new Error("'k' passed to topk() must be >= 0 but got ".concat(t));if(t>r)throw new Error("'k' passed to topk() must be <= the last dimension (".concat(r,") ")+"but got ".concat(t));const s={x:a},o={k:t,sorted:n},[i,c]=GU.runKernel(yV,s,o);return{values:i,indices:c}}});const nQ=nG({truncatedNormal_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1,a=arguments.length>3?arguments[3]:void 0,r=arguments.length>4?arguments[4]:void 0;if(null!=a&&"bool"===a)throw new Error("Unsupported data type $ { dtype }");const s=new uY(t,n,a,!0,r),o=sH(e,a);for(let i=0;i<o.values.length;i++)o.values[i]=s.nextValue();return o.toTensor()}});const aQ=nG({unique_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=$U(e,"x","unique","string_or_numeric");Nz(n.rank>0,(()=>"The input tensor must be at least 1D"));const a={x:n},r={axis:t},[s,o]=GU.runKernel(xV,a,r);return{values:s,indices:o}}});const rQ=nG({unsortedSegmentSum_:function(e,t,n){const a=$U(e,"x","unsortedSegmentSum"),r=$U(t,"segmentIds","unsortedSegmentSum","int32");Nz(Dz(n),(()=>"numSegments must be of dtype int"));const s={x:a,segmentIds:r},o={numSegments:n};return GU.runKernel(kV,s,o)}});const sQ=nG({unstack_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:0;const n=$U(e,"x","unstack","string_or_numeric");Nz(t>=-n.shape.length&&t<n.shape.length,(()=>"Axis = ".concat(t," is not in [-").concat(n.shape.length,", ").concat(n.shape.length,")")));const a={value:n},r={axis:t};return GU.runKernel(wV,a,r)}});function oQ(e,t){return OX(e,t,"right")}function iQ(e){let t=!(arguments.length>1&&void 0!==arguments[1])||arguments[1],n=arguments.length>2?arguments[2]:void 0,a=arguments.length>3?arguments[3]:void 0;return GU.makeVariable(e,t,n,a)}function cQ(e,t){const n=[];for(let s=0;s<t.length;s++)t[s]&&n.push(s);const a=sH(e,"int32"),r=sH([n.length,e.length],"int32");for(let s=0;s<n.length;s++){const t=a.indexToLoc(n[s]),o=s*e.length;r.values.set(t,o)}return r.toTensor()}const lQ=async function(e){const t=$U(e,"condition","whereAsync","bool"),n=await t.data(),a=cQ(t.shape,n);return e!==t&&t.dispose(),a};const uQ=async function(e,t,n){const a=$U(e,"tensor","boolMask"),r=$U(t,"mask","boolMask","bool"),s=null==n?0:n,o=r.rank,i=a.shape;Nz(o>0,(()=>"mask cannot be scalar")),Tz(i.slice(s,s+o),r.shape,"mask's shape must match the first K dimensions of tensor's shape,");let c=1;for(let m=s;m<s+o;m++)c*=i[m];const l=i.slice(0,s).concat([c],i.slice(s+o)),u=tq(a,l),h=tq(r,[-1]),d=await lQ(h),p=jY(d,[1]),f=dX(u,p,s);return e!==a&&a.dispose(),t!==r&&r.dispose(),p.dispose(),u.dispose(),h.dispose(),d.dispose(),f};const hQ=nG({movingAverage_:function(e,t,n,a){let r=!(arguments.length>4&&void 0!==arguments[4])||arguments[4];const s=$U(e,"v","movingAverage"),o=$U(t,"x","movingAverage"),i=$U(n,"decay","movingAverage");MU(s,o),Nz(_z(s.shape,o.shape),(()=>"Shape mismatch in v and x"));const c=fK(1),l=xK(c,i);let u=aK(xK(o,s),l);if(r){Nz(null!=a,(()=>"When using zeroDebias: true, step is required."));const e=$U(a,"step","movingAverage");u=nK(u,xK(c,vK(i,e)))}return eK(s,u)}});const dQ=nG({scatterND_:function(e,t,n){const a=$U(e,"indices","scatterND","int32"),r=$U(t,"updates","scatterND");mj(r,a,n);const s={indices:a,updates:r},o={shape:n};return GU.runKernel(VW,s,o)}});const pQ=nG({sparseToDense_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;const r=$U(e,"sparseIndices","sparseToDense","int32"),s=$U(t,"sparseValues","sparseToDense","string_or_numeric"),o=$U(a,"defaultValue","sparseToDense",s.dtype);!function(e,t,n,a){if("int32"!==e.dtype)throw new Error("tf.sparseToDense() expects the indices to be int32 type,"+" but the dtype was ".concat(e.dtype,"."));if(e.rank>2)throw new Error("sparseIndices should be a scalar, vector, or matrix,"+" but got shape ".concat(e.shape,"."));const r=e.rank>0?e.shape[0]:1,s=e.rank>1?e.shape[1]:1;if(n.length!==s)throw new Error("outputShape has incorrect number of elements:,"+" ".concat(n.length,", should be: ").concat(s,"."));const o=t.size;if(0!==t.rank&&(1!==t.rank||o!==r))throw new Error("sparseValues has incorrect shape "+"".concat(t.shape,", should be [] or [").concat(r,"]"));if(t.dtype!==a.dtype)throw new Error("sparseValues.dtype must match defaultValues.dtype")}(r,s,n,o);const i={sparseIndices:r,sparseValues:s,defaultValue:o},c={outputShape:n};return GU.runKernel(oV,i,c)}});const fQ=nG({gatherND_:function(e,t){const n=$U(t,"indices","gatherND","int32"),a={params:$U(e,"x","gatherND","string_or_numeric"),indices:n};return GU.runKernel(AB,a)}});const mQ=nG({dropout_:function(e,t,n,a){const r=$U(e,"x","dropout");if(Nz("float32"===r.dtype,(()=>"x has to be a floating point tensor since it's going to be "+"scaled, but got a ".concat(r.dtype," tensor instead."))),Nz(t>=0&&t<1,(()=>"rate must be a float in the range [0, 1), but got ".concat(t,"."))),0===t)return e instanceof IU?r.clone():r;const s=function(e,t){if(null==t)return e.shape.slice();if(_z(e.shape,t))return t;if(e.shape.length===t.length){const n=[];for(let a=0;a<e.shape.length;a++)null==t[a]&&null!=e.shape[a]?n.push(e.shape[a]):n.push(t[a]);return n}return t}(r,n),o=1-t,i=nK(hX(eK(gY(s,0,1,"float32",a),o)),o);return aK(r,i)}});function gQ(e){return Math.floor(Math.pow(2,Math.ceil(Math.log(e)/Math.log(2))))}function yQ(e,t,n){const a=1-e%2,r=new Float32Array(e);for(let s=0;s<e;++s){const o=2*Math.PI*s/(e+a-1);r[s]=t-n*Math.cos(o)}return QY(r,"float32")}const bQ=async function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:1;const a=$U(e,"predictions","inTopK"),r=$U(t,"targets","inTopK");Nz(a.rank>1,(()=>"inTopK() expects the predictions to be of rank 2 or higher, "+"but got ".concat(a.rank))),Nz(a.rank-1===r.rank,(()=>"predictions rank should be 1 larger than targets rank, but got predictions rank "+"".concat(a.rank," and targets rank ").concat(r.rank))),Tz(a.shape.slice(0,a.shape.length-1),r.shape,"predictions's shape should be align with the targets' shape, except the last dimension.");const s=a.shape[a.shape.length-1];Nz(n>0&&n<=s,(()=>"'k' passed to inTopK() must be > 0 && <= the predictions last "+"dimension (".concat(s,"), but got ").concat(n)));const o=await a.data(),i=await r.data(),[c,l]=[o.length/s,s],u=Vz("bool",c);for(let h=0;h<c;h++){const e=h*l,t=o.subarray(e,e+l),a=[];for(let n=0;n<t.length;n++)a.push({value:t[n],index:n});a.sort(((e,t)=>t.value-e.value)),u[h]=0;for(let r=0;r<n;r++)if(a[r].index===i[h]){u[h]=1;break}}return e!==a&&a.dispose(),t!==r&&r.dispose(),sG(u,r.shape,"bool")};const vQ=nG({conv2DBackpropFilter_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:"NHWC",o=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=tq(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=tq(t,[1,t.shape[0],t.shape[1],t.shape[2]])),Nz(4===i.rank,(()=>"Error in conv2dDerFilter: input must be rank 4, but got shape "+"".concat(i.shape,"."))),Nz(4===c.rank,(()=>"Error in conv2dDerFilter: dy must be rank 4, but got shape "+"".concat(c.shape,"."))),Nz(4===n.length,(()=>"Error in conv2dDerFilter: filterShape must be length 4, but got "+"".concat(n,".")));const l="NHWC"===s?i.shape[3]:i.shape[1],u="NHWC"===s?c.shape[3]:c.shape[1];Nz(l===n[2],(()=>"Error in conv2dDerFilter: depth of input ".concat(l,") must ")+"match input depth in filter (".concat(n[2],"."))),Nz(u===n[3],(()=>"Error in conv2dDerFilter: depth of dy (".concat(u,") must ")+"match output depth for filter (".concat(n[3],")."))),eq("conv2dDerFilter",r,o);const h={x:i,dy:c},d={strides:a,pad:r,dataFormat:s,dimRoundingMode:o,filterShape:n};return GU.runKernel(YP,h,d)}});function xQ(e,t,n){if(null==n||"linear"===n)return e;if("relu"===n)return aK(e,qY(t));throw new Error("Cannot compute gradient for fused activation ".concat(n,"."))}function wQ(e,t){let n=t;const a=rj(e.shape,t.shape);return a.length>0&&(n=nX(n,a)),tq(n,e.shape)}function kQ(e,t,n,a){if("linear"===t)return e;if("relu"===t)return vY(e);if("elu"===t)return Hq(e);if("relu6"===t)return xY(e);if("prelu"===t)return sY(e,n);if("leakyrelu"===t)return bX(e,a);if("sigmoid"===t)return sq(e);throw new Error("Unknown fused activation ".concat(t,"."))}const SQ=(e,t)=>!(e>0)||"linear"===t;const IQ=nG({fusedConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}=e;if(l=l||"linear",!1===SQ(GU.state.gradientDepth,l)){Nz("NHWC"===s,(()=>"Error in fused conv2d: got dataFormat of ".concat(s," but ")+"only NHWC is currently supported for the case of gradient depth is 0 and the activation is not linear."));let e=Sq(t,n,a,r,s,o,i);return null!=c&&(e=eK(e,c)),kQ(e,l,u,h)}const d=$U(t,"x","conv2d","float32"),p=$U(n,"filter","conv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=tq(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Nz(4===f.rank,(()=>"Error in fused conv2d: input must be rank 4, but got rank "+"".concat(f.rank,"."))),Nz(4===p.rank,(()=>"Error in fused conv2d: filter must be rank 4, but got rank "+"".concat(p.rank,"."))),eq("fused conv2d",r,i);const g="NHWC"===s?f.shape[3]:f.shape[1];Nz(p.shape[2]===g,(()=>"Error in conv2d: depth of input (".concat(g,") must match ")+"input depth for filter ".concat(p.shape[2],"."))),Nz(ZK(a,o),(()=>"Error in conv2D: Either strides or dilations must be 1. "+"Got strides ".concat(a," and dilations '").concat(o,"'")));const y=HK(f.shape,p.shape,a,o,r,i);let b,v;if(null!=c&&(b=$U(c,"bias","fused conv2d"),[b]=OU(b,d),"NHWC"===s?sj(y.outShape,b.shape):(Nz(b.shape.length<=1,(()=>"Error in fused conv2d: only supports scalar or 1-D Tensor bias for NCHW format but got the bias of "+"rank-".concat(b.shape.length,"."))),Nz(0===b.shape.length||b.shape[0]===y.outChannels||1===b.shape[0],(()=>"Error in fused conv2d: bias shape (".concat(b.shape,") is not ")+"compatible with the number of output channels "+"(".concat(y.outChannels,")"))))),null!=u){const e=u.shape;if(Nz(e.length<=1||3===e.length,(()=>"Error in fused conv2d: only supports scalar, 1-D Tensor or 3-D Tensor PReLU activation weights but got a tensor of "+"rank-".concat(e.length,"."))),1===e.length)Nz(1===e[0]||e[0]===y.outChannels,(()=>"Error in fused conv2d: PReLU activation weights "+"(".concat(e,") is not compatible with the number of output ")+"channels (".concat(y.outChannels,").")));else if(3===e.length)try{sj(e,y.outShape)}catch(S){const t="Error in fused conv2d: PReLU activation weights (".concat(e,") ")+"is not compatible with the output shape of the conv2d "+"(".concat(y.outShape,").");throw Error(t)}v=$U(u,"prelu weights","fused conv2d")}const x=(e,t)=>{Nz("NHWC"===s,(()=>"Error in gradient of fused conv2D: got dataFormat of ".concat(s," but only NHWC is currently supported.")));const[n,i,c,u]=t,h=xQ(e,c,l);Nz(JK(o),(()=>"Error in gradient of fused conv2D: dilation rates greater than 1 "+"are not yet supported in gradients. Got dilations '".concat(o,"'")));const d=[Nq(i.shape,h,n,a,r),vQ(i,h,n.shape,a,r)];if(null!=u){const e=wQ(u,h);d.push(e)}return d},w={x:f,filter:p,bias:b,preluActivationWeights:v},k={strides:a,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:h};if(null==c){const e=dK(((e,t,n)=>{let a=GU.runKernel(RV,w,k);return n([t,e,a]),m&&(a=tq(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:x}}));return e(f,p)}{const e=dK(((e,t,n,a)=>{let r=GU.runKernel(RV,w,k);return a([t,e,r,n]),m&&(r=tq(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:x}}));return e(f,p,b)}}});const NQ=nG({depthwiseConv2dNativeBackpropFilter_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=e;3===e.rank&&(i=tq(e,[1,e.shape[0],e.shape[1],e.shape[2]]));let c=t;3===c.rank&&(c=tq(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={x:i,dy:c},u={strides:a,pad:r,dimRoundingMode:o,dilations:s,filterShape:n};return GU.runKernel(cB,l,u)}});const TQ=nG({depthwiseConv2dNativeBackpropInput_:function(e,t,n,a,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:[1,1],o=arguments.length>6?arguments[6]:void 0,i=t,c=!1;3===t.rank&&(c=!0,i=tq(t,[1,t.shape[0],t.shape[1],t.shape[2]]));const l={dy:i,filter:n},u={strides:a,pad:r,dimRoundingMode:o,dilations:s,inputShape:e},h=GU.runKernel(lB,l,u);return c?tq(h,[h.shape[1],h.shape[2],h.shape[3]]):h}});const EQ=nG({fusedDepthwiseConv2d_:function(e){let{x:t,filter:n,strides:a,pad:r,dataFormat:s="NHWC",dilations:o=[1,1],dimRoundingMode:i,bias:c,activation:l="linear",preluActivationWeights:u,leakyreluAlpha:h}=e;if(!1===SQ(GU.state.gradientDepth,l)){let e=Lq(t,n,a,r,s,o,i);return null!=c&&(e=eK(e,c)),kQ(e,l,u,h)}const d=$U(t,"x","depthwiseConv2d","float32"),p=$U(n,"filter","depthwiseConv2d","float32");let f=d,m=!1;3===d.rank&&(m=!0,f=tq(d,[1,d.shape[0],d.shape[1],d.shape[2]])),Nz(4===f.rank,(()=>"Error in fused depthwiseConv2d: input must be rank 4, but got "+"rank ".concat(f.rank,"."))),Nz(4===p.rank,(()=>"Error in fused depthwiseConv2d: filter must be rank 4, "+"but got rank ".concat(p.rank,"."))),Nz(f.shape[3]===p.shape[2],(()=>"Error in fused depthwiseConv2d: number of input channels "+"(".concat(f.shape[3],") must match the inChannels dimension in ")+"filter ".concat(p.shape[2],"."))),null==o&&(o=[1,1]),Nz(ZK(a,o),(()=>"Error in fused depthwiseConv2d: Either strides or dilations must "+"be 1. Got strides ".concat(a," and dilations '").concat(o,"'"))),eq("fused depthwiseConv2d",r,i);const g=HK(f.shape,p.shape,a,o,r,i,!0);let y,b;null!=c&&(y=$U(c,"bias","fused conv2d"),[y]=OU(y,d),sj(g.outShape,y.shape)),null!=u&&(b=$U(u,"prelu weights","fused depthwiseConv2d"));const v=(e,t)=>{Nz(JK(o),(()=>"Error in gradient of fused depthwiseConv2d: dilation rates greater than 1 are not yet supported. Got dilations "+"'".concat(o,"'")));const[n,s,c,u]=t,h=xQ(e,c,l),d=TQ(s.shape,h,n,a,r,o,i),p=NQ(s,h,n.shape,a,r,o,i);if(null!=u){return[d,p,wQ(y,h)]}return[d,p]},x={x:f,filter:p,bias:y,preluActivationWeights:b},w={strides:a,pad:r,dataFormat:s,dilations:o,dimRoundingMode:i,activation:l,leakyreluAlpha:h};if(null==c){const e=dK(((e,t,n)=>{let a=GU.runKernel(AV,x,w);return n([t,e,a]),m&&(a=tq(a,[a.shape[1],a.shape[2],a.shape[3]])),{value:a,gradFunc:v}}));return e(f,p)}{const e=dK(((e,t,n,a)=>{let r=GU.runKernel(AV,x,w);return a([t,e,r,n]),m&&(r=tq(r,[r.shape[1],r.shape[2],r.shape[3]])),{value:r,gradFunc:v}}));return e(f,p,y)}}});const CQ=nG({fusedMatMul_:function(e){let{a:t,b:n,transposeA:a=!1,transposeB:r=!1,bias:s,activation:o="linear",preluActivationWeights:i,leakyreluAlpha:c=.2}=e;if(!1===SQ(GU.state.gradientDepth,o)){let e=RH(t,n,a,r);return null!=s&&(e=eK(e,s)),kQ(e,o,i,c)}let l=$U(t,"a","fused matMul"),u=$U(n,"b","fused matMul");[l,u]=OU(l,u);const h=a?l.shape[l.rank-2]:l.shape[l.rank-1],d=r?u.shape[u.rank-1]:u.shape[u.rank-2],p=a?l.shape[l.rank-1]:l.shape[l.rank-2],f=r?u.shape[u.rank-2]:u.shape[u.rank-1],m=l.shape.slice(0,-2),g=u.shape.slice(0,-2),y=Rz(m),b=Rz(g);Nz(h===d,(()=>"Error in fused matMul: inner shapes (".concat(h,") and (")+"".concat(d,") of Tensors with shapes ").concat(l.shape," and ")+"".concat(u.shape," and transposeA=").concat(a)+" and transposeB=".concat(r," must match.")));const v=sj(l.shape.slice(0,-2),u.shape.slice(0,-2)).concat([p,f]),x=tq(l,a?[y,h,p]:[y,p,h]),w=tq(u,r?[b,f,d]:[b,d,f]);let k,S;null!=s&&(k=$U(s,"bias","fused matMul"),[k]=OU(k,l),sj(v,k.shape)),null!=i&&(S=$U(i,"prelu weights","fused matMul"));const I=(e,t)=>{const[n,i,c,l]=t,u=xQ(tq(e,c.shape),c,o);let h,d;if(a||r?!a&&r?(h=RH(u,i,!1,!1),d=RH(u,n,!0,!1)):a&&!r?(h=RH(i,u,!1,!0),d=RH(n,u,!1,!1)):(h=RH(i,u,!0,!0),d=RH(u,n,!0,!0)):(h=RH(u,i,!1,!0),d=RH(n,u,!0,!1)),null!=s){return[h,d,wQ(l,u)]}return[h,d]},N={a:x,b:w,bias:k,preluActivationWeights:S},T={transposeA:a,transposeB:r,activation:o,leakyreluAlpha:c};if(null==s){const e=dK(((e,t,n)=>{const a=GU.runKernel(CV,N,T);return n([e,t,a]),{value:tq(a,v),gradFunc:I}}));return e(x,w)}{const e=dK(((e,t,n,a)=>{const r=GU.runKernel(CV,N,T);return a([e,t,r,n]),{value:tq(r,v),gradFunc:I}}));return e(x,w,k)}}});const RQ=nG({hammingWindow_:function(e){return yQ(e,.54,.46)}});const AQ=nG({hannWindow_:function(e){return yQ(e,.5,.5)}});const _Q=nG({frame_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3],r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=0;const o=[];for(;s+t<=e.size;)o.push(oq(e,s,t)),s+=n;if(a)for(;s<e.size;){const a=s+t-e.size,i=rq([oq(e,s,t-a),yK([a],r)]);o.push(i),s+=n}return 0===o.length?JY([],[0,t]):tq(rq(o),[o.length,t])}});const DQ=nG({stft_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:AQ;null==a&&(a=gQ(t));const s=_Q(e,t,n),o=aK(s,r(t));return GY(o,a)}});const FQ=nG({cropAndResize_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"bilinear",s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=$U(e,"image","cropAndResize"),i=$U(t,"boxes","cropAndResize","float32"),c=$U(n,"boxInd","cropAndResize","int32"),l=i.shape[0];Nz(4===o.rank,(()=>"Error in cropAndResize: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),Nz(2===i.rank&&4===i.shape[1],(()=>"Error in cropAndResize: boxes must be have size [".concat(l,",4] ")+"but had shape ".concat(i.shape,"."))),Nz(1===c.rank&&c.shape[0]===l,(()=>"Error in cropAndResize: boxInd must be have size [".concat(l,"] ")+"but had shape ".concat(i.shape,"."))),Nz(2===a.length,(()=>"Error in cropAndResize: cropSize must be of length 2, but got "+"length ".concat(a.length,"."))),Nz(a[0]>=1&&a[1]>=1,(()=>"cropSize must be atleast [1,1], but was ".concat(a))),Nz("bilinear"===r||"nearest"===r,(()=>"method must be bilinear or nearest, but was ".concat(r)));const u={image:o,boxes:i,boxInd:c},h={method:r,extrapolationValue:s,cropSize:a};return GU.runKernel(rB,u,h)}});const OQ=nG({flipLeftRight_:function(e){const t=$U(e,"image","flipLeftRight","float32");Nz(4===t.rank,(()=>"Error in flipLeftRight: image must be rank 4,"+"but got rank ".concat(t.rank,".")));const n={image:t};return GU.runKernel(NB,n,{})}});const MQ=nG({grayscaleToRGB_:function(e){const t=$U(e,"image","grayscaleToRGB"),n=t.rank-1,a=t.shape[n];Nz(t.rank>=2,(()=>"Error in grayscaleToRGB: images must be at least rank 2, "+"but got rank ".concat(t.rank,"."))),Nz(1===a,(()=>"Error in grayscaleToRGB: last dimension of a grayscale image "+"should be size 1, but got size ".concat(a,".")));const r=new Array(t.rank);return r.fill(1,0,n),r[n]=3,lX(t,r)}});const LQ=nG({rotateWithOffset_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=$U(e,"image","rotateWithOffset","float32");Nz(4===r.rank,(()=>"Error in rotateWithOffset: image must be rank 4,"+"but got rank ".concat(r.rank,".")));const s={image:r},o={radians:t,fillValue:n,center:a};return GU.runKernel(EV,s,o)}});function zQ(e,t,n,a,r,s){null==a&&(a=.5),null==r&&(r=Number.NEGATIVE_INFINITY),null==s&&(s=0);const o=e.shape[0];return n=Math.min(n,o),Nz(0<=a&&a<=1,(()=>"iouThreshold must be in [0, 1], but was '".concat(a,"'"))),Nz(2===e.rank,(()=>"boxes must be a 2D tensor, but was of rank '".concat(e.rank,"'"))),Nz(4===e.shape[1],(()=>"boxes must have 4 columns, but 2nd dimension was ".concat(e.shape[1]))),Nz(1===t.rank,(()=>"scores must be a 1D tensor")),Nz(t.shape[0]===o,(()=>"scores has incompatible shape with boxes. Expected ".concat(o,", ")+"but was ".concat(t.shape[0]))),Nz(0<=s&&s<=1,(()=>"softNmsSigma must be in [0, 1], but was '".concat(s,"'"))),{maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s}}const PQ=nG({nonMaxSuppression_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=$U(e,"boxes","nonMaxSuppression","float32"),o=$U(t,"scores","nonMaxSuppression","float32"),i=zQ(s,o,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c={maxOutputSize:n,iouThreshold:a,scoreThreshold:r};return GU.runKernel(mW,{boxes:s,scores:o},c)}});function BQ(e,t,n){const a=function(e,t,n){return function(e,t,n){let a=0,r=e.length,s=0,o=!1;for(;a<r;){s=a+(r-a>>>1);const i=n(t,e[s]);i>0?a=s+1:(r=s,o=!i)}return o?a:-a-1}(e,t,n||WQ)}(e,t,n),r=a<0?-(a+1):a;e.splice(r,0,t)}function WQ(e,t){return e>t?1:e<t?-1:0}function VQ(e,t,n,a,r){return HQ(e,t,n,a,r,0)}function UQ(e,t,n,a,r,s){return HQ(e,t,n,a,r,0,!1,s,!0)}function GQ(e,t,n,a,r,s){return HQ(e,t,n,a,r,s,!0)}function HQ(e,t,n,a,r,s){let o=arguments.length>6&&void 0!==arguments[6]&&arguments[6],i=arguments.length>7&&void 0!==arguments[7]&&arguments[7],c=arguments.length>8&&void 0!==arguments[8]&&arguments[8];const l=[];for(let g=0;g<t.length;g++)t[g]>r&&l.push({score:t[g],boxIndex:g,suppressBeginIndex:0});l.sort(qQ);const u=s>0?-.5/s:0,h=[],d=[];for(;h.length<n&&l.length>0;){const t=l.pop(),{score:n,boxIndex:s,suppressBeginIndex:o}=t;if(n<r)break;let i=!1;for(let c=h.length-1;c>=o;--c){const n=jQ(e,s,h[c]);if(n>=a){i=!0;break}if(t.score=t.score*KQ(a,u,n),t.score<=r)break}t.suppressBeginIndex=h.length,i||(t.score===n?(h.push(s),d.push(t.score)):t.score>r&&BQ(l,t,qQ))}const p=h.length,f=n-p;i&&f>0&&(h.push(...new Array(f).fill(0)),d.push(...new Array(f).fill(0)));const m={selectedIndices:h};return o&&(m.selectedScores=d),c&&(m.validOutputs=p),m}function jQ(e,t,n){const a=e.subarray(4*t,4*t+4),r=e.subarray(4*n,4*n+4),s=Math.min(a[0],a[2]),o=Math.min(a[1],a[3]),i=Math.max(a[0],a[2]),c=Math.max(a[1],a[3]),l=Math.min(r[0],r[2]),u=Math.min(r[1],r[3]),h=Math.max(r[0],r[2]),d=Math.max(r[1],r[3]),p=(i-s)*(c-o),f=(h-l)*(d-u);if(p<=0||f<=0)return 0;const m=Math.max(s,l),g=Math.max(o,u),y=Math.min(i,h),b=Math.min(c,d),v=Math.max(y-m,0)*Math.max(b-g,0);return v/(p+f-v)}function KQ(e,t,n){const a=Math.exp(t*n*n);return n<=e?a:0}function qQ(e,t){return e.score-t.score||e.score===t.score&&t.boxIndex-e.boxIndex}const XQ=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY;const s=$U(e,"boxes","nonMaxSuppressionAsync"),o=$U(t,"scores","nonMaxSuppressionAsync"),i=zQ(s,o,n,a,r);n=i.maxOutputSize,a=i.iouThreshold,r=i.scoreThreshold;const c=await Promise.all([s.data(),o.data()]),l=c[0],u=c[1],{selectedIndices:h}=VQ(l,u,n,a,r);return s!==e&&s.dispose(),o!==t&&o.dispose(),QY(h,"int32")};const YQ=nG({nonMaxSuppressionWithScore_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=$U(e,"boxes","nonMaxSuppression"),i=$U(t,"scores","nonMaxSuppression"),c=zQ(o,i,n,a,r,s);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,s=c.softNmsSigma;const l={boxes:o,scores:i},u={maxOutputSize:n,iouThreshold:a,scoreThreshold:r,softNmsSigma:s},h=GU.runKernel(yW,l,u);return{selectedIndices:h[0],selectedScores:h[1]}}});const QQ=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0;const o=$U(e,"boxes","nonMaxSuppressionAsync"),i=$U(t,"scores","nonMaxSuppressionAsync"),c=zQ(o,i,n,a,r,s);n=c.maxOutputSize,a=c.iouThreshold,r=c.scoreThreshold,s=c.softNmsSigma;const l=await Promise.all([o.data(),i.data()]),u=l[0],h=l[1],{selectedIndices:d,selectedScores:p}=GQ(u,h,n,a,r,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:QY(d,"int32"),selectedScores:QY(p)}};const JQ=nG({nonMaxSuppressionPadded_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=$U(e,"boxes","nonMaxSuppression"),i=$U(t,"scores","nonMaxSuppression"),c=zQ(o,i,n,a,r,null),l={boxes:o,scores:i},u={maxOutputSize:c.maxOutputSize,iouThreshold:c.iouThreshold,scoreThreshold:c.scoreThreshold,padToMaxOutputSize:s},h=GU.runKernel(gW,l,u);return{selectedIndices:h[0],validOutputs:h[1]}}});const ZQ=async function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:Number.NEGATIVE_INFINITY,s=arguments.length>5&&void 0!==arguments[5]&&arguments[5];const o=$U(e,"boxes","nonMaxSuppressionAsync"),i=$U(t,"scores","nonMaxSuppressionAsync"),c=zQ(o,i,n,a,r,null),l=c.maxOutputSize,u=c.iouThreshold,h=c.scoreThreshold,[d,p]=await Promise.all([o.data(),i.data()]),{selectedIndices:f,validOutputs:m}=UQ(d,p,l,u,h,s);return o!==e&&o.dispose(),i!==t&&i.dispose(),{selectedIndices:QY(f,"int32"),validOutputs:fK(m,"int32")}};const $Q=nG({resizeBilinear_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=$U(e,"images","resizeBilinear");Nz(3===r.rank||4===r.rank,(()=>"Error in resizeBilinear: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),Nz(2===t.length,(()=>"Error in resizeBilinear: new shape must 2D, but got shape "+"".concat(t,"."))),Nz(!1===a||!1===n,(()=>"Error in resizeBilinear: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=tq(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:s},c={alignCorners:n,halfPixelCenters:a,size:t},l=GU.runKernel(MW,i,c);return o?tq(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const eJ=nG({resizeNearestNeighbor_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=$U(e,"images","resizeNearestNeighbor");Nz(3===r.rank||4===r.rank,(()=>"Error in resizeNearestNeighbor: x must be rank 3 or 4, but got "+"rank ".concat(r.rank,"."))),Nz(2===t.length,(()=>"Error in resizeNearestNeighbor: new shape must 2D, but got shape "+"".concat(t,"."))),Nz("float32"===r.dtype||"int32"===r.dtype,(()=>"`images` must have `int32` or `float32` as dtype")),Nz(!1===a||!1===n,(()=>"Error in resizeNearestNeighbor: If halfPixelCenters is true, alignCorners must be false."));let s=r,o=!1;3===r.rank&&(o=!0,s=tq(r,[1,r.shape[0],r.shape[1],r.shape[2]]));const[]=t,i={images:s},c={alignCorners:n,halfPixelCenters:a,size:t},l=GU.runKernel(FW,i,c);return o?tq(l,[l.shape[1],l.shape[2],l.shape[3]]):l}});const tJ=nG({threshold_:function(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"binary",n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:.5;const r=$U(e,"image","threshold"),s=r.shape[0]*r.shape[1];let o,i,c,l,u=aK(QY([a]),255);if(Nz(3===r.rank,(()=>"Error in threshold: image must be rank 3,"+"but got rank ".concat(r.rank,"."))),Nz(3===r.shape[2]||1===r.shape[2],(()=>"Error in threshold: image color channel must be equal to 3 or 1"+"but got ".concat(r.shape[2],"."))),Nz("int32"===r.dtype||"float32"===r.dtype,(()=>"Error in dtype: image dtype must be int32 or float32,"+"but got dtype ".concat(r.dtype,"."))),Nz("otsu"===t||"binary"===t,(()=>"Method must be binary or otsu, but was ".concat(t))),3===r.shape[2]){[o,i,c]=UY(r,[1,1,1],-1);const e=aK(o,.2989),t=aK(i,.587),n=aK(c,.114);l=eK(eK(e,t),n)}else l=e;if("otsu"===t){u=function(e,t){let n,a,r,s,o,i,c=QY([-1]),l=QY([0]),u=QY([0]);for(let h=0;h<e.size-1;h++){n=oq(e,0,h+1),a=oq(e,h+1),o=nK(nX(n),t),i=nK(nX(a),t);const d=nX(aK(n,yY(0,n.size)));r=nK(d,nX(n));const p=yK(a.shape,n.size),f=eK(yY(0,a.size),p),m=aK(a,f);s=nK(nX(m),nX(a));const g=xK(r,s),y=xK(r,s),b=aK(o,i);u=aK(aK(b,g),y);const v=pX(u,l);l=Wq(v,u,l),c=Wq(v,QY([h]),c)}return c}(fq(oH(TY(l),"int32"),sG([]),256),s)}const h=n?xX(l,u):pX(l,u);return oH(aK(h,255),"int32")}});const nJ=nG({transform_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"nearest",a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"constant",r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:0,s=arguments.length>5?arguments[5]:void 0;const o=$U(e,"image","transform","float32"),i=$U(t,"transforms","transform","float32");Nz(4===o.rank,(()=>"Error in transform: image must be rank 4,"+"but got rank ".concat(o.rank,"."))),Nz(2===i.rank&&(i.shape[0]===o.shape[0]||1===i.shape[0])&&8===i.shape[1],(()=>"Error in transform: Input transform should be batch x 8 or 1 x 8")),Nz(null==s||2===s.length,(()=>"Error in transform: outputShape must be [height, width] or null, "+"but got ".concat(s,".")));const c={image:o,transforms:i},l={interpolation:n,fillMode:a,fillValue:r,outputShape:s};return GU.runKernel(bV,c,l)}});const aJ=nG({bandPart_:function(e,t,n){Nz(t%1===0,(()=>"bandPart(): numLower must be an integer, got ".concat(t,"."))),Nz(n%1===0,(()=>"bandPart(): numUpper must be an integer, got ".concat(n,".")));const a=$U(e,"a","bandPart");Nz(a.rank>=2,(()=>"bandPart(): Rank must be at least 2, got ".concat(a.rank,".")));const r=a.shape,[s,o]=a.shape.slice(-2);if(!(t<=s))throw new Error("bandPart(): numLower (".concat(t,")")+" must not be greater than the number of rows (".concat(s,")."));if(!(n<=o))throw new Error("bandPart(): numUpper (".concat(n,")")+" must not be greater than the number of columns (".concat(o,")."));t<0&&(t=s),n<0&&(n=o);const i=tq(yY(0,s,1,"int32"),[-1,1]),c=yY(0,o,1,"int32"),l=xK(i,c),u=RX(xX(l,fK(+t,"int32")),fX(l,fK(-n,"int32"))),h=WX([s,o],a.dtype);return tq(KY(sQ(tq(a,[-1,s,o])).map((e=>Wq(u,e,h)))),r)}});const rJ=nG({gramSchmidt_:function(e){let t;if(Array.isArray(e)){t=!1,Nz(null!=e&&e.length>0,(()=>"Gram-Schmidt process: input must not be null, undefined, or empty"));const n=e[0].shape[0];for(let t=1;t<e.length;++t)Nz(e[t].shape[0]===n,(()=>"Gram-Schmidt: Non-unique lengths found in the input vectors: "+"(".concat(e[t].shape[0]," vs. ").concat(n,")")))}else t=!0,e=UY(e,e.shape[0],0).map((e=>jY(e,[0])));Nz(e.length<=e[0].shape[0],(()=>"Gram-Schmidt: Number of vectors (".concat(e.length,") exceeds ")+"number of dimensions (".concat(e[0].shape[0],").")));const n=[],a=e;for(let r=0;r<e.length;++r)n.push(GU.tidy((()=>{let e=a[r];if(r>0)for(let t=0;t<r;++t){const a=aK(nX(aK(n[t],e)),n[t]);e=xK(e,a)}return nK(e,rX(e,"euclidean"))})));return t?KY(n,0):n}});function sJ(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return GU.tidy((()=>{Nz(2===e.shape.length,(()=>"qr2d() requires a 2D Tensor, but got a ".concat(e.shape.length,"D Tensor.")));const n=e.shape[0],a=e.shape[1];let r=uX(n),s=iH(e);const o=JY([[1]],[1,1]);let i=iH(o);const c=n>=a?a:n;for(let e=0;e<c;++e){const t=s,c=i,l=r;[i,s,r]=GU.tidy((()=>{const t=oq(s,[e,e],[n-e,1]),c=rX(t),l=oq(s,[e,e],[1,1]),u=Wq(pX(l,0),JY([[-1]]),JY([[1]])),h=xK(l,aK(u,c)),d=nK(t,h);i=1===d.shape[0]?iH(o):rq([o,oq(d,[1,0],[d.shape[0]-1,d.shape[1]])],0);const p=$H(nK(RH(u,h),c)),f=oq(s,[e,0],[n-e,a]),m=aK(p,i),g=tj(i);if(0===e)s=xK(f,RH(m,RH(g,f)));else{const t=xK(f,RH(m,RH(g,f)));s=rq([oq(s,[0,0],[e,a]),t],0)}const y=tj(m),b=oq(r,[0,e],[n,r.shape[1]-e]);if(0===e)r=xK(b,RH(RH(b,i),y));else{const t=xK(b,RH(RH(b,i),y));r=rq([oq(r,[0,0],[n,e]),t],1)}return[i,s,r]})),WH([t,c,l])}return!t&&n>a&&(r=oq(r,[0,0],[n,a]),s=oq(s,[0,0],[a,a])),[r,s]}))}const oJ=nG({qr_:function(e){let t=arguments.length>1&&void 0!==arguments[1]&&arguments[1];if(Nz(e.rank>=2,(()=>"qr() requires input tensor to have a rank >= 2, but got rank ".concat(e.rank))),2===e.rank)return sJ(e,t);{const n=e.shape.slice(0,e.shape.length-2).reduce(((e,t)=>e*t)),a=sQ(tq(e,[n,e.shape[e.shape.length-2],e.shape[e.shape.length-1]]),0),r=[],s=[];a.forEach((e=>{const[n,a]=sJ(e,t);r.push(n),s.push(a)}));return[tq(KY(r,0),e.shape),tq(KY(s,0),e.shape)]}}});var iJ;!function(e){e[e.NONE=0]="NONE",e[e.MEAN=1]="MEAN",e[e.SUM=2]="SUM",e[e.SUM_BY_NONZERO_WEIGHTS=3]="SUM_BY_NONZERO_WEIGHTS"}(iJ||(iJ={}));const cJ=nG({computeWeightedLoss_:function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:iJ.SUM_BY_NONZERO_WEIGHTS;const a=$U(e,"losses","computeWeightedLoss");let r=null;null!=t&&(r=$U(t,"weights","computeWeightedLoss"));const s=null==r?a:aK(a,r);if(n===iJ.NONE)return s;if(n===iJ.SUM)return nX(s);if(n===iJ.MEAN){if(null==r)return BX(s);{const e=a.size/r.size,t=nK(nX(s),nX(r));return e>1?nK(t,fK(e)):t}}if(n===iJ.SUM_BY_NONZERO_WEIGHTS){if(null==r)return nK(nX(s),fK(a.size));{const e=aK(r,VX(a.shape)),t=oH(nX(YX(e,fK(0))),"float32");return nK(nX(s),t)}}throw Error("Unknown reduction: ".concat(n))}});const lJ=nG({absoluteDifference_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:iJ.SUM_BY_NONZERO_WEIGHTS;const r=$U(e,"labels","absoluteDifference"),s=$U(t,"predictions","absoluteDifference");let o=null;null!=n&&(o=$U(n,"weights","absoluteDifference")),Tz(r.shape,s.shape,"Error in absoluteDifference: ");const i=kK(xK(r,s));return cJ(i,o,a)}});const uJ=nG({cosineDistance_:function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:iJ.SUM_BY_NONZERO_WEIGHTS;const s=$U(e,"labels","cosineDistance"),o=$U(t,"predictions","cosineDistance");let i=null;null!=a&&(i=$U(a,"weights","cosineDistance")),Tz(s.shape,o.shape,"Error in cosineDistance: ");const c=fK(1),l=xK(c,nX(aK(s,o),n,!0));return cJ(l,i,r)}});const hJ=nG({hingeLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:iJ.SUM_BY_NONZERO_WEIGHTS,r=$U(e,"labels","hingeLoss");const s=$U(t,"predictions","hingeLoss");let o=null;null!=n&&(o=$U(n,"weights","hingeLoss")),Tz(r.shape,s.shape,"Error in hingeLoss: ");const i=fK(1);r=xK(aK(fK(2),r),i);const c=vY(xK(i,aK(r,s)));return cJ(c,o,a)}});const dJ=nG({huberLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:iJ.SUM_BY_NONZERO_WEIGHTS;const s=$U(e,"labels","huberLoss"),o=$U(t,"predictions","huberLoss");let i=null;null!=n&&(i=$U(n,"weights","huberLoss")),Tz(s.shape,o.shape,"Error in huberLoss: ");const c=fK(a),l=kK(xK(o,s)),u=GX(l,c),h=xK(l,u),d=eK(aK(fK(.5),sK(u)),aK(c,h));return cJ(d,i,r)}});const pJ=nG({logLoss_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:1e-7,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:iJ.SUM_BY_NONZERO_WEIGHTS;const s=$U(e,"labels","logLoss"),o=$U(t,"predictions","logLoss");let i=null;null!=n&&(i=$U(n,"weights","logLoss")),Tz(s.shape,o.shape,"Error in logLoss: ");const c=fK(1),l=fK(a),u=$H(aK(s,SX(eK(o,l)))),h=aK(xK(c,s),SX(eK(xK(c,o),l))),d=xK(u,h);return cJ(d,i,r)}});const fJ=nG({meanSquaredError_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:iJ.SUM_BY_NONZERO_WEIGHTS;const r=$U(e,"labels","meanSquaredError"),s=$U(t,"predictions","meanSquaredError");let o=null;null!=n&&(o=$U(n,"weights","meanSquaredError")),Tz(r.shape,s.shape,"Error in meanSquaredError: ");const i=HY(r,s);return cJ(i,o,a)}});const mJ=nG({sigmoidCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:iJ.SUM_BY_NONZERO_WEIGHTS,s=$U(e,"multiClassLabels","sigmoidCrossEntropy");const o=$U(t,"logits","sigmoidCrossEntropy");let i=null;if(null!=n&&(i=$U(n,"weights","sigmoidCrossEntropy")),Tz(s.shape,o.shape,"Error in sigmoidCrossEntropy: "),a>0){const e=fK(a),t=fK(1),n=fK(.5);s=eK(aK(s,xK(t,e)),aK(n,e))}const c=function(e,t){const n=$U(e,"labels","sigmoidCrossEntropyWithLogits"),a=$U(t,"logits","sigmoidCrossEntropyWithLogits");Tz(n.shape,a.shape,"Error in sigmoidCrossEntropyWithLogits: ");const r=vY(a),s=aK(a,n),o=IX(oX($H(kK(a))));return eK(xK(r,s),o)}(s,o);return cJ(c,i,r)}});const gJ=nG({softmaxCrossEntropy_:function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0,r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:iJ.SUM_BY_NONZERO_WEIGHTS,s=$U(e,"onehotLabels","softmaxCrossEntropy");const o=$U(t,"logits","softmaxCrossEntropy");let i=null;if(null!=n&&(i=$U(n,"weights","softmaxCrossEntropy")),Tz(s.shape,o.shape,"Error in softmaxCrossEntropy: "),a>0){const e=fK(a),t=fK(1),n=fK(s.shape[1]);s=eK(aK(s,xK(t,e)),nK(e,n))}const c=function(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(-1===n&&(n=t.rank-1),n!==t.rank-1)throw Error("Softmax cross entropy along a non-last dimension is not yet "+"supported. Labels / logits was rank ".concat(t.rank," ")+"and dim was ".concat(n));const a=dK(((e,t,a)=>{const r=CX(t,[n],!0),s=xK(oH(t,"float32"),r);a([e,s]);const o=$H(aK(s,e));return{value:nX(o,[n]),gradFunc:(e,t)=>{const[a,r]=t,s=Yq(e.shape,[n]);return[aK(tq(e,s),xK(oH(a,"float32"),oX(r))),aK(tq(e,s),xK(oX(r),oH(a,"float32")))]}}}));return a(e,t)}(s,o);return cJ(c,i,r)}});const yJ=nG({sparseFillEmptyRows_:function(e,t,n,a){const r=$U(e,"indices","sparseFillEmptyRows","int32"),s=$U(t,"values","sparseFillEmptyRows"),o=$U(n,"denseShape","sparseFillEmptyRows","int32"),i=$U(a,"defaultValue","sparseFillEmptyRows",s.dtype);if(2!==r.rank)throw new Error("Indices should be Tensor2D but received shape\n        ".concat(r.shape));if(1!==s.rank)throw new Error("Values should be Tensor1D but received shape ".concat(s.shape));if(1!==o.rank)throw new Error("Dense shape should be Tensor1D but received shape ".concat(o.shape));if(0!==i.rank)throw new Error("Default value should be a scalar but received shape ".concat(i.shape));const c={indices:r,values:s,denseShape:o,defaultValue:i},l=GU.runKernel(nV,c);return{outputIndices:l[0],outputValues:l[1],emptyRowIndicator:l[2],reverseIndexMap:l[3]}}});const bJ=nG({sparseReshape_:function(e,t,n){const a=$U(e,"inputIndices","sparseReshape","int32"),r=$U(t,"inputShape","sparseReshape","int32"),s=$U(n,"newShape","sparseReshape","int32");if(2!==a.rank)throw new Error("Input indices should be Tensor2D but received shape\n        ".concat(a.shape));if(1!==r.rank)throw new Error("Input shape should be Tensor1D but received shape ".concat(r.shape));if(1!==s.rank)throw new Error("New shape should be Tensor1D but received shape ".concat(s.shape));const o={inputIndices:a,inputShape:r,newShape:s},i=GU.runKernel(aV,o);return{outputIndices:i[0],outputShape:i[1]}}});const vJ=nG({sparseSegmentMean_:function(e,t,n){const a=$U(e,"data","sparseSegmentMean"),r=$U(t,"indices","sparseSegmentMean","int32"),s=$U(n,"segmentIds","sparseSegmentMean","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n          ".concat(r.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n          ".concat(s.shape));const o={data:a,indices:r,segmentIds:s};return GU.runKernel(rV,o)}});const xJ=nG({sparseSegmentSum_:function(e,t,n){const a=$U(e,"data","sparseSegmentSum"),r=$U(t,"indices","sparseSegmentSum","int32"),s=$U(n,"segmentIds","sparseSegmentSum","int32");if(a.rank<1)throw new Error("Data should be at least 1 dimensional but received scalar");if(1!==r.rank)throw new Error("Indices should be Tensor1D but received shape\n         ".concat(r.shape));if(1!==s.rank)throw new Error("Segment ids should be Tensor1D but received shape\n         ".concat(s.shape));const o={data:a,indices:r,segmentIds:s};return GU.runKernel(sV,o)}});const wJ=nG({stringNGrams_:function(e,t,n,a,r,s,o,i){const c=$U(e,"data","stringNGrams","string");if("string"!==c.dtype)throw new Error("Data must be of datatype string");if(1!==c.shape.length)throw new Error("Data must be a vector, saw: ".concat(c.shape));const l=$U(t,"dataSplits","stringNGrams");if("int32"!==l.dtype)throw new Error("Data splits must be of datatype int32");const u={separator:n,nGramWidths:a,leftPad:r,rightPad:s,padWidth:o,preserveShortSequences:i},h={data:c,dataSplits:l},d=GU.runKernel(uV,h,u);return{nGrams:d[0],nGramsSplits:d[1]}}});const kJ=nG({stringSplit_:function(e,t){let n=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const a=$U(e,"input","stringSplit","string"),r=$U(t,"delimiter","stringSplit","string");if(1!==a.rank)throw new Error("Input should be Tensor1D but received shape ".concat(a.shape));if(0!==r.rank)throw new Error("Delimiter should be a scalar but received shape ".concat(r.shape));const s={skipEmpty:n},o={input:a,delimiter:r},i=GU.runKernel(hV,o,s);return{indices:i[0],values:i[1],shape:i[2]}}});const SJ=nG({stringToHashBucketFast_:function(e,t){const n=$U(e,"input","stringToHashBucketFast","string"),a={numBuckets:t};if(t<=0)throw new Error("Number of buckets must be at least 1");const r={input:n};return GU.runKernel(dV,r,a)}}),IJ={fft:BY,ifft:WY,rfft:GY,irfft:VY},NJ={hammingWindow:RQ,hannWindow:AQ,frame:_Q,stft:DQ},TJ={flipLeftRight:OQ,grayscaleToRGB:MQ,resizeNearestNeighbor:eJ,resizeBilinear:$Q,rotateWithOffset:LQ,cropAndResize:FQ,nonMaxSuppression:PQ,nonMaxSuppressionAsync:XQ,nonMaxSuppressionWithScore:YQ,nonMaxSuppressionWithScoreAsync:QQ,nonMaxSuppressionPadded:JQ,nonMaxSuppressionPaddedAsync:ZQ,threshold:tJ,transform:nJ},EJ={bandPart:aJ,gramSchmidt:rJ,qr:oJ},CJ={absoluteDifference:lJ,computeWeightedLoss:cJ,cosineDistance:uJ,hingeLoss:hJ,huberLoss:dJ,logLoss:pJ,meanSquaredError:fJ,sigmoidCrossEntropy:mJ,softmaxCrossEntropy:gJ},RJ={sparseFillEmptyRows:yJ,sparseReshape:bJ,sparseSegmentMean:vJ,sparseSegmentSum:xJ},AJ={stringNGrams:wJ,stringSplit:kJ,stringToHashBucketFast:SJ},_J={sgd:CK.sgd,momentum:CK.momentum,adadelta:CK.adadelta,adagrad:CK.adagrad,rmsprop:CK.rmsprop,adamax:CK.adamax,adam:CK.adam},DJ="undefined"!==typeof requestAnimationFrame?requestAnimationFrame:"undefined"!==typeof setImmediate?setImmediate:e=>e();function FJ(){return new Promise((e=>DJ((()=>e()))))}function OJ(e,t){const n=e[0].length;e.forEach(((e,t)=>{Nz(e.length===n,(()=>"Error in concat".concat(n,"D: rank of tensors[").concat(t,"] must be the same ")+"as the rank of the rest (".concat(n,")")))})),Nz(t>=0&&t<n,(()=>"Error in concat".concat(n,"D: axis must be between 0 and ").concat(n-1,".")));const a=e[0];e.forEach(((e,r)=>{for(let s=0;s<n;s++)Nz(s===t||e[s]===a[s],(()=>"Error in concat".concat(n,"D: Shape of tensors[").concat(r,"] (").concat(e,") ")+"does not match the shape of the rest (".concat(a,") ")+"along the non-concatenated axis ".concat(r,".")))}))}function MJ(e,t){const n=e[0].slice();for(let a=1;a<e.length;a++)n[t]+=e[a][t];return n}var LJ;function zJ(e,t,n){let a=new Array;if(null==n&&null==t)return a;if(null==t)for(;a.length<e+n.length;)a.push(-1);else a=t.slice();if(null==n)return a;if(e+n.length!==a.length)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.rank = ").concat(e+n.length,", but shape.rank = ").concat(a.length));for(let r=1;r<n.length;++r){const s=n[r],o=a[a.length-n.length+r],i=a[o];if(s>=0)if(i>=0){if(i!==s)throw new Error("rt input.shape and shape=".concat(t," are incompatible: rt input.shape[").concat(r+e,"] = ").concat(s," but shape[").concat(r+e,"] = ").concat(i))}else a[o]=s}return a}function PJ(e){const t={FIRST_DIM_SIZE:LJ.FIRST_DIM_SIZE,VALUE_ROWIDS:LJ.VALUE_ROWIDS,ROW_LENGTHS:LJ.ROW_LENGTHS,ROW_SPLITS:LJ.ROW_SPLITS,ROW_LIMITS:LJ.ROW_LIMITS,ROW_STARTS:LJ.ROW_STARTS},n=[];for(const a of e){if(!(a in t))break;n.push(t[a])}return n}function BJ(e){return 0===e.length?0:e[0]===LJ.FIRST_DIM_SIZE?e.length-1:e.length}function WJ(e,t){if(null==e||null==t)return;const n=e.length,a=t.length;if(n>=a)throw new Error("defaultValue.shape=".concat(e," and ragged tensor flatValues.shape=").concat(t,", are incompatible: defaultValue.rank = ").concat(n," must be less than ragged tensor input flatValues.rank = ").concat(a,")"));for(let r=0;r<Math.min(n,a-1);++r){const n=e[r],a=t[r+1];if(n>=0&&a>=0&&1!==n&&n!==a)throw new Error("defaultValue.shape=".concat(e,", and ragged tensor input flatValues.shape=").concat(t," are incompatible: defaultValue.shape[").concat(r-e.length,"] = ").concat(n," but ragged tensor input.flatValues.shape[").concat(r-e.length,"] = ").concat(a))}}!function(e){e[e.FIRST_DIM_SIZE=0]="FIRST_DIM_SIZE",e[e.VALUE_ROWIDS=1]="VALUE_ROWIDS",e[e.ROW_LENGTHS=2]="ROW_LENGTHS",e[e.ROW_SPLITS=3]="ROW_SPLITS",e[e.ROW_LIMITS=4]="ROW_LIMITS",e[e.ROW_STARTS=5]="ROW_STARTS"}(LJ||(LJ={}));const VJ=30;function UJ(e){return e<=VJ?e:eP(e,Math.floor(Math.sqrt(e)))}function GJ(e,t,n){return[n*("number"===typeof e?e:e[0]),t*("number"===typeof e?e:e[1])]}function HJ(e,t,n){let a=[];if(!(arguments.length>3&&void 0!==arguments[3])||arguments[3])a=a.concat(t.slice(0)),a.push(e[0]/n),a=a.concat(e.slice(1));else{a=a.concat(e[0]);const n=t.length;for(let r=0;r<n;++r)a=a.concat([e[r+1]/t[r],t[r]]);a=a.concat(e.slice(n+1))}return a}function jJ(e,t){const n=[];if(!(arguments.length>2&&void 0!==arguments[2])||arguments[2]){n.push(t);for(let a=t+1;a<e;++a)a<=2*t?(n.push(a),n.push(a-(t+1))):n.push(a)}else{const a=[],r=[];for(let n=1;n<e;++n)n>=2*t+1||n%2===1?r.push(n):a.push(n);n.push(...a),n.push(0),n.push(...r)}return n}function KJ(e,t,n){let a=!(arguments.length>3&&void 0!==arguments[3])||arguments[3];const r=[];a?r.push(e[0]/n):r.push(e[0]*n);for(let s=1;s<e.length;++s)s<=t.length?a?r.push(t[s-1]*e[s]):r.push(e[s]/t[s-1]):r.push(e[s]);return r}function qJ(e,t){const n=[0];for(let a=0;a<t;++a)n.push(e[a][0]);return n}function XJ(e,t,n){const a=e.slice(0,1);for(let r=0;r<n;++r)a.push(e[r+1]-t[r][0]-t[r][1]);return a}const YJ=1.7580993408473768,QJ=1.0507009873554805,JJ=.3275911,ZJ=.254829592,$J=-.284496736,eZ=1.421413741,tZ=-1.453152027,nZ=1.061405429;function aZ(e,t){if(e.length!==t.length)throw new Error("Cannot merge real and imag arrays of different lengths. real:"+"".concat(e.length,", imag: ").concat(t.length,"."));const n=new Float32Array(2*e.length);for(let a=0;a<n.length;a+=2)n[a]=e[a/2],n[a+1]=t[a/2];return n}function rZ(e){const t=new Float32Array(e.length/2),n=new Float32Array(e.length/2);for(let a=0;a<e.length;a+=2)t[a/2]=e[a],n[a/2]=e[a+1];return{real:t,imag:n}}function sZ(e){const t=Math.ceil(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=0;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function oZ(e){const t=Math.floor(e.length/4),n=new Float32Array(t),a=new Float32Array(t);for(let r=2;r<e.length;r+=4)n[Math.floor(r/4)]=e[r],a[Math.floor(r/4)]=e[r+1];return{real:n,imag:a}}function iZ(e,t){return{real:e[2*t],imag:e[2*t+1]}}function cZ(e,t,n,a){e[2*a]=t,e[2*a+1]=n}function lZ(e,t){const n=new Float32Array(e/2),a=new Float32Array(e/2);for(let r=0;r<Math.ceil(e/2);r++){const s=(t?2:-2)*Math.PI*(r/e);n[r]=Math.cos(s),a[r]=Math.sin(s)}return{real:n,imag:a}}function uZ(e,t,n){const a=(n?2:-2)*Math.PI*(e/t);return{real:Math.cos(a),imag:Math.sin(a)}}const hZ="->",dZ=/->/g,pZ=",",fZ="...";function mZ(e,t){const n=((e=e.replace(/\s/g,"")).length-e.replace(dZ,"").length)/hZ.length;if(n<1)throw new Error("Equations without an arrow are not supported.");if(n>1)throw new Error('Equation must contain exactly one arrow ("'.concat(hZ,'").'));const[a,r]=e.split(hZ);Nz(-1===a.indexOf(fZ),(()=>'The ellipsis notation ("'.concat(fZ,'") is not supported yet.')));const s=a.split(pZ),o=s.length;if(t!==o)throw new Error("Expected ".concat(o," input tensors, received ").concat(t));if(o>2)throw new Error("Support for more than 2 input tensors is not implemented yet.");const i=[];for(let h=0;h<r.length;++h){const e=r[h];if(!s.some((t=>-1!==t.indexOf(e))))throw new Error("Output subscripts contain the label ".concat(e," ")+"not present in the input subscripts.");-1===i.indexOf(e)&&i.push(e)}for(let h=0;h<a.length;++h){const e=a[h];-1===i.indexOf(e)&&e!==pZ&&i.push(e)}const c=new Array(s.length);for(let h=0;h<o;++h){if(new Set(s[h].split("")).size!==s[h].length)throw new Error("Found duplicate axes in input component ".concat(s[h],". ")+"Support for duplicate axes in input is not implemented yet.");c[h]=[];for(let e=0;e<s[h].length;++e)c[h].push(i.indexOf(s[h][e]))}const l=i.length,u=[];for(let h=r.length;h<l;++h)u.push(h);return{allDims:i,summedDims:u,idDims:c}}function gZ(e,t){let n=new Array(e);n.fill(-1);for(let r=0;r<t.length;++r)n[t[r]]=r;const a=[];for(let r=0;r<e;++r)-1===n[r]&&a.push(r);return n=n.filter((e=>-1!==e)),{permutationIndices:n,expandDims:a}}function yZ(e,t,n){const a=new Array(e);for(let r=0;r<n.length;++r){const e=n[r].shape;for(let n=0;n<t[r].length;++n)void 0===a[t[r][n]]?a[t[r][n]]=e[n]:Nz(a[t[r][n]]===e[n],(()=>"Expected dimension ".concat(a[t[r][n]]," at axis ").concat(n," ")+"of input shaped ".concat(JSON.stringify(e),", ")+"but got dimension ".concat(e[n])))}}function bZ(e,t){const n=e,a=[];let r=0;0===e.length&&n.push(-1),r=e.length+1;for(let o=0;o<r;++o)a.push([]);const s=[];for(let o=0;o<n.length;++o){const e=xZ(t,n[o]);for(const t of e)-1===s.indexOf(t)&&(a[o].push(t),s.push(t))}return{path:n,steps:a}}function vZ(e){return e.every(((e,t)=>e===t))}function xZ(e,t){const n=[];for(let a=0;a<e.length;++a)0!==e[a].length&&-1===e[a].indexOf(t)&&-1!==t||n.push(a);return n}function wZ(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0,a=[];if("number"===typeof t)Nz(e.shape[n]%t===0,(()=>"Number of splits must evenly divide the axis.")),a=new Array(t).fill(e.shape[n]/t);else{const r=t.reduce(((e,t)=>(-1===t&&(e+=1),e)),0);Nz(r<=1,(()=>"There should be only one negative value in split array."));const s=t.indexOf(-1);if(-1!==s){const a=t.reduce(((e,t)=>t>0?e+t:e));t[s]=e.shape[n]-a}Nz(e.shape[n]===t.reduce(((e,t)=>e+t)),(()=>"The sum of sizes must match the size of the axis dimension.")),a=t}return a}function kZ(e){return"Received SparseTensor with denseShape[0] = 0 but\n  indices.shape[0] = ".concat(e)}function SZ(e,t){return"indices(".concat(e,", 0) is invalid: ").concat(t," < 0")}function IZ(e,t,n){return"indices(".concat(e,", 0) is invalid: ").concat(t," >= ").concat(n)}function NZ(e,t){return"only one output dimension may be -1, not both ".concat(e," and ").concat(t)}function TZ(e,t){return"size ".concat(e," must be non-negative, not ").concat(t)}function EZ(){return"reshape cannot infer the missing input size for an empty tensor unless all specified input sizes are non-zero"}function CZ(e,t){const n=Rz(e),a=Rz(t);return"Input to reshape is a SparseTensor with ".concat(n,"\n  dense values, but the requested shape requires a multiple of ").concat(a,". inputShape=").concat(e," outputShape= ").concat(t)}function RZ(e,t){const n=Rz(e),a=Rz(t);return"Input to reshape is a tensor with ".concat(n," dense values, but the requested shape has ").concat(a,". inputShape=").concat(e," outputShape=").concat(t)}function AZ(){return"segment ids must be >= 0"}function _Z(){return"segment ids are not increasing"}function DZ(e,t){return"Segment id ".concat(e," out of range [0, ").concat(t,"), possibly because segmentIds input is not sorted.")}function FZ(e,t,n){return"Bad: indices[".concat(e,"] == ").concat(t," out of range [0, ").concat(n,")")}function OZ(e,t){let n,a=!1;for(e<=VJ?(n=e,a=!0):n=eP(e,Math.floor(Math.sqrt(e)));!a;)n>t||n===e?a=!0:n=eP(e,n+1);return n}function MZ(e,t,n){const a=[],r=e.length;for(let s=0;s<r;s++)s!==t?a.push(e[s]):a.push(n);return a}function LZ(e,t,n,a){const r=t.shape.length,s=e.shape.length;if(0!==a&&(a<-r||a>r))throw new Error("Expect batchDims in the range of [-".concat(r,", ").concat(r,"], but got ").concat(a));if(a<0&&(a+=r),a>s)throw new Error("batchDims (".concat(a,") must be less than rank(x) (\n    ").concat(s,")."));if(n<a)throw new Error("batchDims (".concat(a,") must be less than or equal to axis (").concat(n,")."));for(let h=0;h<a;++h)if(e.shape[h]!==t.shape[h])throw new Error("x.shape[".concat(h,"]: ").concat(e.shape[h]," should be equal to indices.shape[").concat(h,"]: ").concat(t.shape[h],"."));const o=e.shape[n],i=[];let c=1,l=1,u=1;for(let h=0;h<a;++h)i.push(e.shape[h]),c*=e.shape[h];for(let h=a;h<n;h++)i.push(e.shape[h]),l*=e.shape[h];for(let h=a;h<r;h++)i.push(t.shape[h]);for(let h=n+1;h<s;h++)i.push(e.shape[h]),u*=e.shape[h];return{batchSize:c,sliceSize:u,outerSize:l,dimSize:o,outputShape:i}}function zZ(e){try{return e.map((e=>cU(e)))}catch(o1){throw new Error("Failed to decode encoded string bytes into utf-8, error: ".concat(o1))}}function PZ(e){return e.map((e=>iU(e)))}var BZ,WZ;fP().registerFlag("KEEP_INTERMEDIATE_TENSORS",(()=>!1),(e=>{e&&console.warn("Keep intermediate tensors is ON. This will print the values of all intermediate tensors during model inference. Not all models support this mode. For details, check e2e/benchmarks/ model_config.js. This significantly impacts performance.")})),function(e){e[e.DT_INVALID=0]="DT_INVALID",e[e.DT_FLOAT=1]="DT_FLOAT",e[e.DT_DOUBLE=2]="DT_DOUBLE",e[e.DT_INT32=3]="DT_INT32",e[e.DT_UINT8=4]="DT_UINT8",e[e.DT_INT16=5]="DT_INT16",e[e.DT_INT8=6]="DT_INT8",e[e.DT_STRING=7]="DT_STRING",e[e.DT_COMPLEX64=8]="DT_COMPLEX64",e[e.DT_INT64=9]="DT_INT64",e[e.DT_BOOL=10]="DT_BOOL",e[e.DT_QINT8=11]="DT_QINT8",e[e.DT_QUINT8=12]="DT_QUINT8",e[e.DT_QINT32=13]="DT_QINT32",e[e.DT_BFLOAT16=14]="DT_BFLOAT16",e[e.DT_QINT16=15]="DT_QINT16",e[e.DT_QUINT16=16]="DT_QUINT16",e[e.DT_UINT16=17]="DT_UINT16",e[e.DT_COMPLEX128=18]="DT_COMPLEX128",e[e.DT_HALF=19]="DT_HALF",e[e.DT_RESOURCE=20]="DT_RESOURCE",e[e.DT_VARIANT=21]="DT_VARIANT",e[e.DT_UINT32=22]="DT_UINT32",e[e.DT_UINT64=23]="DT_UINT64",e[e.DT_FLOAT_REF=101]="DT_FLOAT_REF",e[e.DT_DOUBLE_REF=102]="DT_DOUBLE_REF",e[e.DT_INT32_REF=103]="DT_INT32_REF",e[e.DT_UINT8_REF=104]="DT_UINT8_REF",e[e.DT_INT16_REF=105]="DT_INT16_REF",e[e.DT_INT8_REF=106]="DT_INT8_REF",e[e.DT_STRING_REF=107]="DT_STRING_REF",e[e.DT_COMPLEX64_REF=108]="DT_COMPLEX64_REF",e[e.DT_INT64_REF=109]="DT_INT64_REF",e[e.DT_BOOL_REF=110]="DT_BOOL_REF",e[e.DT_QINT8_REF=111]="DT_QINT8_REF",e[e.DT_QUINT8_REF=112]="DT_QUINT8_REF",e[e.DT_QINT32_REF=113]="DT_QINT32_REF",e[e.DT_BFLOAT16_REF=114]="DT_BFLOAT16_REF",e[e.DT_QINT16_REF=115]="DT_QINT16_REF",e[e.DT_QUINT16_REF=116]="DT_QUINT16_REF",e[e.DT_UINT16_REF=117]="DT_UINT16_REF",e[e.DT_COMPLEX128_REF=118]="DT_COMPLEX128_REF",e[e.DT_HALF_REF=119]="DT_HALF_REF",e[e.DT_RESOURCE_REF=120]="DT_RESOURCE_REF",e[e.DT_VARIANT_REF=121]="DT_VARIANT_REF",e[e.DT_UINT32_REF=122]="DT_UINT32_REF",e[e.DT_UINT64_REF=123]="DT_UINT64_REF"}(BZ||(BZ={})),function(e){let t;!function(e){e[e.LEGACY=0]="LEGACY",e[e.V1=1]="V1",e[e.V2=2]="V2"}(t=e.CheckpointFormatVersion||(e.CheckpointFormatVersion={}))}(WZ||(WZ={}));const VZ={};function UZ(e){return VZ[e]}function GZ(e,t,n,a,r){const s=t.inputParams[e];if(s&&void 0!==s.inputIndexStart){const e=s.inputIndexStart,o=0===s.inputIndexEnd?void 0:void 0===s.inputIndexEnd?e+1:s.inputIndexEnd;if("tensor"===s.type)return HZ(t.inputNames[s.inputIndexStart],n,a,r);if("tensors"===s.type){return t.inputNames.slice(e,o).map((e=>HZ(e,n,a,r)))}const i=HZ(t.inputNames.slice(e)[0],n,a,r),c=i.dataSync();return"number"===s.type?c[0]:aP(i.shape,c)}const o=t.attrParams[e];return o&&o.value}function HZ(e,t,n,a){const[r,s]=qZ(e);if(null!=a){const e=a.getHashTableHandleByName(r);if(null!=e)return e}const o=n.currentContextIds.find((e=>!!t[KZ(r,e)]));return void 0!==o?t[KZ(r,o)][s]:void 0}function jZ(e,t){const[n,a,r]=qZ(e);return[KZ(n,t&&t.currentContextId),a,r]}function KZ(e,t){return t?"".concat(e,"-").concat(t):e}function qZ(e){const t=e.split(":");if(1===t.length)return[e,0,void 0];const n=t[0],a=3===t.length?t[1]:void 0;return[n,Number(t[t.length-1]),a]}function XZ(e,t,n){let a=GZ("pad",e,t,n);if("explicit"===a){a=GZ("explicitPaddings",e,t,n);const r=[[0,0],[0,0],[0,0],[0,0]];for(let e=0;e<4;e++)r[e][0]=a[2*e],r[e][1]=a[2*e+1];return r}return a}function YZ(e){return e.kept?e:iH(e)}const QZ=[{tfOpName:"Add",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddV2",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AddN",category:"arithmetic",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"BiasAdd",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"Sub",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"RealDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Div",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"DivNoNan",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorDiv",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mul",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Maximum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Minimum",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Pow",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SquaredDifference",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Mod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"FloorMod",category:"arithmetic",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],JZ=[{tfOpName:"Abs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atan2",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Ceil",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ClipByValue",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"clipValueMin",type:"number"},{start:2,name:"clipValueMax",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Complex",category:"basic_math",inputs:[{start:0,name:"real",type:"tensor"},{start:1,name:"imag",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ComplexAbs",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cos",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Cosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Elu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Exp",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Floor",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Imag",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Neg",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Real",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"Tout",name:"outputType",type:"dtype",notSupported:!0}]},{tfOpName:"Prelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"alpha",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Relu6",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Selu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sigmoid",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sin",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Rsqrt",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Square",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Tanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Sign",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Round",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Expm1",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Log1p",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Reciprocal",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Softplus",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Asinh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Acosh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Atanh",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Erf",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Prod",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axes",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LeakyRelu",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"alpha",name:"alpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"IsNan",category:"basic_math",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],ZZ=[{tfOpName:"EmptyTensorList",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"maxNumElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"LoopCond",category:"control",inputs:[{start:0,name:"pred",type:"tensor"}]},{tfOpName:"Switch",category:"control",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"pred",type:"tensor"}]},{tfOpName:"Merge",category:"control",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}]},{tfOpName:"Enter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"frame_name",name:"frameName",type:"string"},{tfName:"is_constant",name:"isConstant",type:"bool"}]},{tfOpName:"Exit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NextIteration",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayV3",category:"control",inputs:[{start:0,name:"size",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"dynamic_size",name:"dynamicSize",type:"bool"},{tfName:"clear_after_read",name:"clearAfterRead",type:"bool"},{tfName:"identical_element_shapes",name:"identicalElementShapes",type:"bool"},{tfName:"tensor_array_name",name:"name",type:"string"}]},{tfOpName:"TensorArrayWriteV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayReadV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"TensorArrayGatherV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape",name:"elementShape",type:"shape"}]},{tfOpName:"TensorArrayScatterV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"tensor",type:"tensor"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArrayConcatV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"element_shape_except0",name:"elementShapeExcept0",type:"shape",notSupported:!0}]},{tfOpName:"TensorArraySplitV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"tensor",type:"tensor"},{start:2,name:"lengths",type:"number[]"},{start:3,name:"flowIn",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"TensorArraySizeV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"},{start:1,name:"flowIn",type:"number"}]},{tfOpName:"TensorArrayCloseV3",category:"control",inputs:[{start:0,name:"tensorArrayId",type:"tensor"}]},{tfOpName:"StatelessIf",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"If",category:"control",inputs:[{start:0,name:"cond",type:"tensor"},{start:1,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"then_branch",name:"thenBranch",type:"func"},{tfName:"else_branch",name:"elseBranch",type:"func"}]},{tfOpName:"StatelessWhile",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"While",category:"control",inputs:[{start:0,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"cond",name:"cond",type:"func"},{tfName:"body",name:"body",type:"func"}]},{tfOpName:"TensorListScatter",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListScatterV2",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"},{start:3,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGather",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"indices",type:"number[]"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListGetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListSetItem",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"index",type:"number"},{start:2,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListReserve",category:"control",inputs:[{start:0,name:"elementShape",type:"shape"},{start:1,name:"numElements",type:"number"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListFromTensor",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListStack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"},{tfName:"num_elements",name:"numElements",type:"dtype"}]},{tfOpName:"TensorListSplit",category:"control",inputs:[{start:0,name:"tensor",type:"tensor"},{start:1,name:"elementShape",type:"shape"},{start:2,name:"lengths",type:"number[]"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcat",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListConcatV2",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}],attrs:[{tfName:"element_shape",name:"elementShape",type:"shape"},{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPopBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"elementShape",type:"shape"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListPushBack",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"tensor",type:"tensor"}],attrs:[{tfName:"element_dtype",name:"elementDType",type:"dtype"}]},{tfOpName:"TensorListLength",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"}]},{tfOpName:"TensorListResize",category:"control",inputs:[{start:0,name:"tensorListId",type:"tensor"},{start:1,name:"size",type:"number"}]}],$Z=[{tfOpName:"AvgPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[],notSupported:!0},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPoolWithArgmax",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"include_batch_in_index",name:"includeBatchInIndex",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"AvgPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MaxPool3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"ksize",name:"kernelSize",type:"number[]"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Conv1D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"stride",name:"stride",type:"number"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NWC"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"dilation",name:"dilation",type:"number",defaultValue:1}]},{tfOpName:"Conv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"useCudnnOnGpu",name:"useCudnnOnGpu",type:"bool"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"_FusedConv2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"use_cudnn_on_gpu",name:"useCudnnOnGpu",type:"bool",defaultValue:!0},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2}]},{tfOpName:"Conv2DBackpropInput",category:"convolution",inputs:[{start:2,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:0,name:"outputShape",type:"number[]"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]",notSupported:!0}]},{tfOpName:"DepthwiseConv2d",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"DepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"FusedDepthwiseConv2dNative",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]",defaultValue:[1,1,1,1]},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"explicit_paddings",name:"explicitPaddings",type:"number[]",defaultValue:[]}]},{tfOpName:"Conv3D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"padding",name:"pad",type:"string"},{tfName:"data_format",name:"dataFormat",type:"string",defaultValue:"NHWC"},{tfName:"dilations",name:"dilations",type:"number[]"}]},{tfOpName:"Dilation2D",category:"convolution",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"filter",type:"tensor"}],attrs:[{tfName:"strides",name:"strides",type:"number[]"},{tfName:"rates",name:"dilations",type:"number[]"},{tfName:"padding",name:"pad",type:"string"}]}],e$=[{tfOpName:"Fill",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"},{start:1,name:"value",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"LinSpace",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"num",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"OneHot",category:"creation",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"depth",type:"number"},{start:2,name:"onValue",type:"number",defaultValue:1},{start:3,name:"offValue",type:"number",defaultValue:0}],attrs:[{tfName:"axis",name:"axis",type:"number",notSupported:!0},{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Ones",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"OnesLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"RandomStandardNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"RandomUniform",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"minval",name:"minval",type:"number",defaultValue:0},{tfName:"maxval",name:"maxval",type:"number",defaultValue:1},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"seed",name:"seed",type:"number",defaultValue:0},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Range",category:"creation",inputs:[{start:0,name:"start",type:"number"},{start:1,name:"stop",type:"number"},{start:2,name:"step",type:"number",defaultValue:0}],attrs:[{tfName:"Tidx",name:"dtype",type:"dtype"}]},{tfOpName:"TruncatedNormal",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"means",name:"mean",type:"number",defaultValue:0},{tfName:"stddev",name:"stdDev",type:"number",defaultValue:1},{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number",defaultValue:0,notSupported:!0},{tfName:"dtype",name:"dtype",type:"dtype"},{tfName:"T",name:"T",type:"number",notSupported:!0}]},{tfOpName:"Zeros",category:"creation",inputs:[{start:0,name:"shape",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"ZerosLike",category:"creation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype"}]},{tfOpName:"Multinomial",category:"creation",inputs:[{start:0,name:"logits",type:"tensor"},{start:1,name:"numSamples",type:"number"}],attrs:[{tfName:"seed",name:"seed",type:"number"},{tfName:"seed2",name:"seed2",type:"number"},{tfName:"T",name:"dtype",type:"dtype"},{tfName:"output_dtype",name:"output_dtype",type:"dtype"}]}],t$=[{tfOpName:"NonMaxSuppressionV2",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV3",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}]},{tfOpName:"NonMaxSuppressionV4",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0},{tfName:"T_threshold",name:"threshold",type:"dtype",notSupported:!0},{tfName:"pad_to_max_output_size",name:"padToMaxOutputSize",type:"bool"}]},{tfOpName:"NonMaxSuppressionV5",category:"dynamic",inputs:[{start:0,name:"boxes",type:"tensor"},{start:1,name:"scores",type:"tensor"},{start:2,name:"maxOutputSize",type:"number"},{start:3,name:"iouThreshold",type:"number"},{start:4,name:"scoreThreshold",type:"number"},{start:5,name:"softNmsSigma",type:"number"}]},{tfOpName:"Where",category:"dynamic",inputs:[{start:0,name:"condition",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ListDiff",category:"dynamic",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"y",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],n$=[{tfOpName:"LowerBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"TopKV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"k",type:"number"}],attrs:[{tfName:"sorted",name:"sorted",type:"bool"}]},{tfOpName:"UpperBound",category:"evaluation",inputs:[{start:0,name:"sortedSequence",type:"tensor"},{start:1,name:"values",type:"tensor"}]},{tfOpName:"Unique",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"UniqueV2",category:"evaluation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]}],a$=[{tfOpName:"PlaceholderWithDefault",category:"graph",inputs:[{start:0,name:"default",type:"tensor"}],attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Placeholder",category:"graph",attrs:[{tfName:"shape",name:"shape",type:"shape"},{tfName:"dtype",name:"dtype",type:"dtype"}]},{tfOpName:"Const",category:"graph"},{tfOpName:"Identity",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IdentityN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Snapshot",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Rank",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Size",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"Shape",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"ShapeN",category:"graph",inputs:[{start:0,end:0,name:"x",type:"tensors"}]},{tfOpName:"Print",category:"graph",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"data",type:"tensors"}],attrs:[{tfName:"message",name:"message",type:"string"},{tfName:"first_n",name:"firstN",type:"number",notSupported:!0},{tfName:"summarize",name:"summarize",type:"number",defaultValue:3}]},{tfOpName:"NoOp",category:"graph",inputs:[]},{tfOpName:"StopGradient",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"FakeQuantWithMinMaxVars",category:"graph",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"min",name:"min",type:"number"},{tfName:"max",name:"max",type:"number"}]}],r$=[{tfOpName:"HashTable",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"HashTableV2",category:"hash_table",inputs:[],attrs:[{tfName:"shared_name",name:"sharedName",type:"string"},{tfName:"use_node_name_sharing",name:"useNodeNameSharing",type:"bool"},{tfName:"key_dtype",name:"keyDType",type:"dtype"},{tfName:"value_dtype",name:"valueDType",type:"dtype"}]},{tfOpName:"LookupTableImport",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableImportV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"values",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFind",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableFindV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"},{start:1,name:"keys",type:"tensor"},{start:2,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"Tin",name:"tIn",type:"dtype",notSupported:!0},{tfName:"Tout",name:"tOut",type:"dtype",notSupported:!0}]},{tfOpName:"LookupTableSize",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]},{tfOpName:"LookupTableSizeV2",category:"hash_table",inputs:[{start:0,name:"tableHandle",type:"tensor"}]}],s$=[{tfOpName:"ResizeBilinear",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"ResizeNearestNeighbor",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"size",type:"number[]"}],attrs:[{tfName:"align_corners",name:"alignCorners",type:"bool"},{tfName:"half_pixel_centers",name:"halfPixelCenters",type:"bool"},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"CropAndResize",category:"image",inputs:[{start:0,name:"image",type:"tensor"},{start:1,name:"boxes",type:"tensor"},{start:2,name:"boxInd",type:"tensor"},{start:3,name:"cropSize",type:"number[]"}],attrs:[{tfName:"method",name:"method",type:"string"},{tfName:"extrapolation_value",name:"extrapolationValue",type:"number"}]},{tfOpName:"ImageProjectiveTransformV3",category:"image",inputs:[{start:0,name:"images",type:"tensor"},{start:1,name:"transforms",type:"tensor"},{start:2,name:"outputShape",type:"number[]"},{start:3,name:"fillValue",type:"number"}],attrs:[{tfName:"interpolation",name:"interpolation",type:"string"},{tfName:"fill_mode",name:"fillMode",type:"string"}]}],o$=[{tfOpName:"Equal",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"NotEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Greater",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"GreaterEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Less",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LessEqual",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalAnd",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalNot",category:"logical",inputs:[{start:0,name:"a",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"LogicalOr",category:"logical",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Select",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SelectV2",category:"logical",inputs:[{start:0,name:"condition",type:"tensor"},{start:1,name:"a",type:"tensor"},{start:2,name:"b",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]}],i$=[{tfOpName:"_FusedMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"},{start:2,end:0,name:"args",type:"tensors"}],attrs:[{tfName:"num_args",name:"numArgs",type:"number"},{tfName:"fused_ops",name:"fusedOps",type:"string[]",defaultValue:[]},{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:1e-4},{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"leakyrelu_alpha",name:"leakyreluAlpha",type:"number",defaultValue:.2},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"MatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"transpose_a",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"transpose_b",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMul",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"BatchMatMulV2",category:"matrices",inputs:[{start:0,name:"a",type:"tensor"},{start:1,name:"b",type:"tensor"}],attrs:[{tfName:"adj_x",name:"transposeA",type:"bool",defaultValue:!1},{tfName:"adj_y",name:"transposeB",type:"bool",defaultValue:!1},{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Transpose",category:"matrices",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"perm",type:"number[]"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"Einsum",category:"matrices",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"equation",name:"equation",type:"string"},{tfName:"N",name:"n",type:"number",defaultValue:2},{tfName:"T",name:"dtype",type:"dtype"}]}],c$=[{tfOpName:"EuclideanNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool",defaultValue:!1}]},{tfOpName:"FusedBatchNorm",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV2",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"FusedBatchNormV3",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"scale",type:"tensor"},{start:2,name:"offset",type:"tensor"},{start:3,name:"mean",type:"tensor"},{start:4,name:"variance",type:"tensor"}],attrs:[{tfName:"epsilon",name:"epsilon",type:"number",defaultValue:.001},{tfName:"data_format",name:"dataFormat",type:"string",notSupported:!0}]},{tfOpName:"LRN",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"depth_radius",name:"radius",type:"number",defaultValue:5},{tfName:"bias",name:"bias",type:"number",defaultValue:1},{tfName:"alpha",name:"alpha",type:"number",defaultValue:1},{tfName:"beta",name:"beta",type:"number",defaultValue:.5}]},{tfOpName:"Softmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"LogSoftmax",category:"normalization",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"SparseToDense",category:"normalization",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!0,notSupported:!0}]}],l$=[{tfOpName:"Bincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}]},{tfOpName:"DenseBincount",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"size",type:"number"},{start:2,name:"weights",type:"tensor"}],attrs:[{tfName:"binary_output",name:"binaryOutput",type:"bool"}]},{tfOpName:"Max",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Mean",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Min",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Sum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"All",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Any",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"ArgMax",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"ArgMin",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"Prod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}],attrs:[{tfName:"keep_dims",name:"keepDims",type:"bool"}]},{tfOpName:"Cumprod",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]},{tfOpName:"Cumsum",category:"reduction",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}],attrs:[{tfName:"exclusive",name:"exclusive",type:"bool"},{tfName:"reverse",name:"reverse",type:"bool"}]}],u$=[{tfOpName:"ConcatV2",category:"slice_join",inputs:[{start:0,end:-1,name:"tensors",type:"tensors"},{start:-1,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"Concat",category:"slice_join",inputs:[{start:1,end:0,name:"tensors",type:"tensors"},{start:0,name:"axis",type:"number"}],attrs:[{tfName:"N",name:"n",type:"number",defaultValue:2}]},{tfOpName:"GatherV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"axis",type:"number",defaultValue:0}],attrs:[{tfName:"batch_dims",name:"batchDims",type:"number",defaultValue:0}]},{tfOpName:"Gather",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",notSupported:!0}]},{tfOpName:"Reverse",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"dims",type:"bool[]"}]},{tfOpName:"ReverseV2",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number[]"}]},{tfOpName:"Slice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"size",type:"number[]"}]},{tfOpName:"StridedSlice",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"begin",type:"number[]"},{start:2,name:"end",type:"number[]"},{start:3,name:"strides",type:"number[]"}],attrs:[{tfName:"begin_mask",name:"beginMask",type:"number",defaultValue:0},{tfName:"end_mask",name:"endMask",type:"number",defaultValue:0},{tfName:"new_axis_mask",name:"newAxisMask",type:"number",defaultValue:0},{tfName:"ellipsis_mask",name:"ellipsisMask",type:"number",defaultValue:0},{tfName:"shrink_axis_mask",name:"shrinkAxisMask",type:"number",defaultValue:0}]},{tfOpName:"Pack",category:"slice_join",inputs:[{start:0,end:0,name:"tensors",type:"tensors"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0}]},{tfOpName:"Unpack",category:"slice_join",inputs:[{start:0,name:"tensor",type:"tensor"}],attrs:[{tfName:"axis",name:"axis",type:"number",defaultValue:0},{tfName:"num",name:"num",type:"number",defaultValue:0,notSupported:!0}]},{tfOpName:"Tile",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"reps",type:"number[]"}]},{tfOpName:"Split",category:"slice_join",inputs:[{start:0,name:"axis",type:"number",defaultValue:0},{start:1,name:"x",type:"tensor"}],attrs:[{tfName:"num_split",name:"numOrSizeSplits",type:"number",defaultValue:1}]},{tfOpName:"SplitV",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"numOrSizeSplits",type:"number[]"},{start:2,name:"axis",type:"number",defaultValue:0}]},{tfOpName:"ScatterNd",category:"slice_join",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"shape",type:"number[]"}]},{tfOpName:"GatherNd",category:"slice_join",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"indices",type:"tensor"}]},{tfOpName:"SparseToDense",category:"slice_join",inputs:[{start:0,name:"sparseIndices",type:"tensor"},{start:1,name:"outputShape",type:"number[]"},{start:2,name:"sparseValues",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}],attrs:[{tfName:"validate_indices",name:"validateIndices",type:"bool",defaultValue:!1,notSupported:!0}]}],h$=[{tfOpName:"SparseFillEmptyRows",category:"sparse",inputs:[{start:0,name:"indices",type:"tensor"},{start:1,name:"values",type:"tensor"},{start:2,name:"denseShape",type:"tensor"},{start:3,name:"defaultValue",type:"tensor"}]},{tfOpName:"SparseReshape",category:"sparse",inputs:[{start:0,name:"inputIndices",type:"tensor"},{start:1,name:"inputShape",type:"tensor"},{start:2,name:"newShape",type:"tensor"}],attrs:[{tfName:"T",name:"dtype",type:"dtype",notSupported:!0}]},{tfOpName:"SparseSegmentMean",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]},{tfOpName:"SparseSegmentSum",category:"sparse",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"indices",type:"tensor"},{start:2,name:"segmentIds",type:"tensor"}]}],d$=[{tfOpName:"FFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"IFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"}]},{tfOpName:"RFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]},{tfOpName:"IRFFT",category:"spectral",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"fft_length",type:"number",notSupported:!0}]}],p$=[{tfOpName:"StringNGrams",category:"string",inputs:[{start:0,name:"data",type:"tensor"},{start:1,name:"dataSplits",type:"tensor"}],attrs:[{tfName:"separator",name:"separator",type:"string"},{tfName:"ngram_widths",name:"nGramWidths",type:"number[]"},{tfName:"left_pad",name:"leftPad",type:"string"},{tfName:"right_pad",name:"rightPad",type:"string"},{tfName:"pad_width",name:"padWidth",type:"number"},{tfName:"preserve_short_sequences",name:"preserveShortSequences",type:"bool"}],outputs:["ngrams","ngrams_splits"]},{tfOpName:"StringSplit",category:"string",inputs:[{start:0,name:"input",type:"tensor"},{start:1,name:"delimiter",type:"tensor"}],attrs:[{tfName:"skip_empty",name:"skipEmpty",type:"bool"}],outputs:["indices","values","shape"]},{tfOpName:"StringToHashBucketFast",category:"string",inputs:[{start:0,name:"input",type:"tensor"}],attrs:[{tfName:"num_buckets",name:"numBuckets",type:"number"}]}],f$=[{tfOpName:"Cast",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"SrcT",name:"sdtype",type:"dtype",notSupported:!0},{tfName:"DstT",name:"dtype",type:"dtype"}]},{tfOpName:"ExpandDims",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"axis",type:"number"}]},{tfOpName:"MirrorPad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"mode",name:"mode",type:"string"}]},{tfOpName:"Pad",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"}],attrs:[{tfName:"constant_value",name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"PadV2",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"padding",type:"number[]"},{start:2,name:"constantValue",type:"number",defaultValue:0}]},{tfOpName:"Reshape",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}]},{tfOpName:"Squeeze",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"axis",tfDeprecatedName:"squeeze_dims",name:"axis",type:"number[]"}]},{tfOpName:"SpaceToBatchND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"paddings",type:"number[]"}]},{tfOpName:"BatchToSpaceND",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"blockShape",type:"number[]"},{start:2,name:"crops",type:"number[]"}]},{tfOpName:"DepthToSpace",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"}],attrs:[{tfName:"block_size",name:"blockSize",type:"number"},{tfName:"data_format",name:"dataFormat",type:"string"}]},{tfOpName:"BroadcastTo",category:"transformation",inputs:[{start:0,name:"x",type:"tensor"},{start:1,name:"shape",type:"number[]"}],attrs:[]},{tfOpName:"BroadcastArgs",category:"transformation",inputs:[{start:0,name:"s0",type:"tensor"},{start:1,name:"s1",type:"tensor"}],attrs:[]}];class m${static get Instance(){return this._instance||(this._instance=new this)}constructor(){const e=[].concat(...[k,S,I,N,T,E,C,R,A,_,D,F,O,M,L,z,P,B,W].map((e=>e.json)));this.opMappers=e.reduce(((e,t)=>(e[t.tfOpName]=t,e)),{})}transformGraph(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=e.node,a=[],r=[],s=[],o=n.reduce(((e,t)=>(e[t.name]=this.mapNode(t),t.op.startsWith("Placeholder")?a.push(e[t.name]):"Const"===t.op?r.push(e[t.name]):null!=t.input&&0!==t.input.length||s.push(e[t.name]),e)),{});let i=[];const c=[];let l={},u={};null!=t&&(l=this.mapSignatureEntries(t.inputs),u=this.mapSignatureEntries(t.outputs));const h=Object.keys(o);h.forEach((e=>{const t=o[e];t.inputNames.forEach(((e,n)=>{const[a,,r]=jZ(e),s=o[a];if(null!=s.outputs){const e=s.outputs.indexOf(r);if(-1!==e){const r="".concat(a,":").concat(e);t.inputNames[n]=r}}t.inputs.push(s),s.children.push(t)}))})),0===Object.keys(u).length?h.forEach((e=>{const t=o[e];0===t.children.length&&c.push(t)})):Object.keys(u).forEach((e=>{const[t]=jZ(e),n=o[t];null!=n&&(n.signatureKey=u[e],c.push(n))})),Object.keys(l).length>0?Object.keys(l).forEach((e=>{const[t]=jZ(e),n=o[t];n&&(n.signatureKey=l[e],i.push(n))})):i=a;let d={};null!=e.library&&null!=e.library.function&&(d=e.library.function.reduce(((e,t)=>(e[t.signature.name]=this.mapFunction(t),e)),{}));const p={nodes:o,inputs:i,outputs:c,weights:r,placeholders:a,signature:t,functions:d};return s.length>0&&(p.initNodes=s),p}mapSignatureEntries(e){return Object.keys(e||{}).reduce(((t,n)=>(t[e[n].name]=n,t)),{})}mapNode(e){const t=UZ(e.op)||this.opMappers[e.op]||{};null==e.attr&&(e.attr={});const n={name:e.name,op:e.op,category:t.category,inputNames:(e.input||[]).map((e=>e.startsWith("^")?e.slice(1):e)),inputs:[],children:[],inputParams:{},attrParams:{},rawAttrs:e.attr,outputs:t.outputs};return null!=t.inputs&&(n.inputParams=t.inputs.reduce(((e,t)=>(e[t.name]={type:t.type,inputIndexStart:t.start,inputIndexEnd:t.end},e)),{})),null!=t.attrs&&(n.attrParams=t.attrs.reduce(((t,n)=>{const a=n.type;let r;switch(n.type){case"string":r=y$(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=y$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"string[]":r=E$(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=E$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number":r=v$(e.attr,n.tfName,n.defaultValue||0),void 0===r&&n.tfDeprecatedName&&(r=v$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"number[]":r=T$(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=T$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool":r=b$(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=b$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"bool[]":r=R$(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=R$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape":r=N$(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=N$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"shape[]":r=C$(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=C$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype":r=k$(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=k$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"dtype[]":r=S$(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=S$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"func":r=w$(e.attr,n.tfName,n.defaultValue),void 0===r&&n.tfDeprecatedName&&(r=w$(e.attr,n.tfDeprecatedName,n.defaultValue));break;case"tensor":case"tensors":break;default:throw new Error("Unsupported param type: ".concat(n.type," for op: ").concat(e.op))}return t[n.name]={value:r,type:a},t}),{})),n}mapFunction(e){const t=e.nodeDef,n=[];let a={};null!=t&&(a=t.reduce(((e,t)=>(e[t.name]=this.mapNode(t),"Const"===t.op&&n.push(e[t.name]),e)),{}));const r=[],s=[];e.signature.inputArg.forEach((e=>{const[t]=jZ(e.name),n={name:t,op:"Placeholder",inputs:[],inputNames:[],category:"graph",inputParams:{},attrParams:{dtype:{value:x$(e.type),type:"dtype"}},children:[]};n.signatureKey=e.name,r.push(n),a[t]=n}));Object.keys(a).forEach((e=>{const t=a[e];t.inputNames.forEach(((e,n)=>{const[r,,s]=jZ(e),o=a[r];if(null!=o.outputs){const e=o.outputs.indexOf(s);if(-1!==e){const a="".concat(r,":").concat(e);t.inputNames[n]=a}}t.inputs.push(o),o.children.push(t)}))}));const o=e.ret;e.signature.outputArg.forEach((e=>{const[t,n]=jZ(o[e.name]),r=a[t];null!=r&&(r.defaultOutput=n,s.push(r))}));const i=this.mapArgsToSignature(e);return{nodes:a,inputs:r,outputs:s,weights:n,placeholders:[],signature:i}}mapArgsToSignature(e){return{methodName:e.signature.name,inputs:e.signature.inputArg.reduce(((e,t)=>(e[t.name]=this.mapArgToTensorInfo(t),e)),{}),outputs:e.signature.outputArg.reduce(((t,n)=>(t[n.name]=this.mapArgToTensorInfo(n,e.ret),t)),{})}}mapArgToTensorInfo(e,t){let n=e.name;return null!=t&&(n=t[n]),{name:n,dtype:e.type}}}function g$(e,t){const n=Array.isArray(e)?String.fromCharCode.apply(null,e):function(e){const t=fP().global;if("undefined"!==typeof t.atob)return t.atob(e);if("undefined"!==typeof Buffer)return new Buffer(e,"base64").toString();throw new Error("Unable to decode base64 in this environment. Missing built-in atob() or Buffer()")}(e);return t?n:n.toLowerCase()}function y$(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e[t];return null!=r?g$(r.s,a):n}function b$(e,t,n){const a=e[t];return a?a.b:n}function v$(e,t,n){const a=e[t]||{},r=null!=a.i?a.i:null!=a.f?a.f:n;return"number"===typeof r?r:parseInt(r,10)}function x$(e){switch("string"===typeof e&&(e=BZ[e]),e){case BZ.DT_FLOAT:case BZ.DT_HALF:return"float32";case BZ.DT_INT32:case BZ.DT_INT64:case BZ.DT_INT8:case BZ.DT_UINT8:return"int32";case BZ.DT_BOOL:return"bool";case BZ.DT_DOUBLE:return"float32";case BZ.DT_STRING:return"string";default:return null}}function w$(e,t,n){const a=e[t];return a&&a.func?a.func.name:n}function k$(e,t,n){const a=e[t];return a&&a.type?x$(a.type):n}function S$(e,t,n){const a=e[t];return a&&a.list&&a.list.type?a.list.type.map((e=>x$(e))):n}function I$(e){if(!e.unknownRank)return null!=e.dim?e.dim.map((e=>"number"===typeof e.size?e.size:parseInt(e.size,10))):[]}function N$(e,t,n){const a=e[t];return a&&a.shape?I$(a.shape):n}function T$(e,t,n){const a=e[t];return a?((a.list.f&&a.list.f.length?a.list.f:a.list.i)||[]).map((e=>"number"===typeof e?e:parseInt(e,10))):n}function E$(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const r=e[t];return r&&r.list&&r.list.s?r.list.s.map((e=>g$(e,a))):n}function C$(e,t,n){const a=e[t];return a&&a.list&&a.list.shape?a.list.shape.map((e=>I$(e))):n}function R$(e,t,n){const a=e[t];return a&&a.list&&a.list.b?a.list.b:n}class A${constructor(e,t,n){this.node=e,this.tensorMap=t,this.context=n,this.inputs=[],this.attrs={},this.inputs=e.inputNames.map((e=>this.getInput(e))),null!=e.rawAttrs&&(this.attrs=Object.keys(e.rawAttrs).reduce(((e,t)=>(e[t]=this.getAttr(t),e)),{}))}getInput(e){return HZ(e,this.tensorMap,this.context)}getAttr(e,t){const n=this.node.rawAttrs[e];if(null!=n.tensor)return HZ(e,this.tensorMap,this.context);if(null!=n.i||null!=n.f)return v$(this.node.rawAttrs,e,t);if(null!=n.s)return y$(this.node.rawAttrs,e,t);if(null!=n.b)return b$(this.node.rawAttrs,e,t);if(null!=n.shape)return N$(this.node.rawAttrs,e,t);if(null!=n.type)return k$(this.node.rawAttrs,e,t);if(null!=n.list){if(null!=n.list.i||null!=n.list.f)return T$(this.node.rawAttrs,e,t);if(null!=n.list.s)return E$(this.node.rawAttrs,e,t);if(null!=n.list.shape)return C$(this.node.rawAttrs,e,t);if(null!=n.list.b)return R$(this.node.rawAttrs,e,t);if(null!=n.list.type)return S$(this.node.rawAttrs,e,t)}return t}}function _$(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"";if("number"!==typeof e&&"number"!==typeof t){Nz(e.length===t.length,(()=>n+" Shapes ".concat(e," and ").concat(t," must match")));for(let a=0;a<e.length;a++){const r=e[a],s=t[a];Nz(r<0||s<0||r===s,(()=>n+" Shapes ".concat(e," and ").concat(t," must match")))}}}function D$(e){return"number"!==typeof e&&!e.some((e=>e<0))}function F$(e,t,n){let a=O$(e,n);const r=!D$(a);if(r&&0===t.length)throw new Error("Tried to calculate elements of an empty list"+" with non-fully-defined elementShape: ".concat(a));if(r&&t.forEach((e=>{a=O$(e.shape,a)})),!D$(a))throw new Error("Non-fully-defined elementShape: ".concat(a));return a}function O$(e,t){if("number"===typeof e)return t;if("number"===typeof t)return e;if(e.length!==t.length)throw new Error("Incompatible ranks during merge: ".concat(e," vs. ").concat(t));const n=[];for(let a=0;a<e.length;++a){const r=e[a],s=t[a];if(r>=0&&s>=0&&r!==s)throw new Error("Incompatible shape during merge: ".concat(e," vs. ").concat(t));n[a]=r>=0?r:s}return n}class M${constructor(e,t,n,a,r,s,o){this.name=e,this.dtype=t,this.maxSize=n,this.elementShape=a,this.identicalElementShapes=r,this.dynamicSize=s,this.clearAfterRead=o,this.tensors=[],this.closed_=!1,this.idTensor=fK(0),VH(this.idTensor)}get id(){return this.idTensor.id}get closed(){return this.closed_}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.tensor.id)||t.tensor.dispose()})),this.tensors=[],this.closed_=!0,this.idTensor.dispose()}size(){return this.tensors.length}read(e){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||e>=this.size())throw new Error("Tried to read from index ".concat(e,", but array size is: ").concat(this.size()));const t=this.tensors[e];if(t.cleared)throw new Error("TensorArray ".concat(this.name,": Could not read index ").concat(e," twice because it was cleared after a previous read ")+"(perhaps try setting clear_after_read = false?).");return this.clearAfterRead&&(t.cleared=!0),t.read=!0,t.tensor}readMany(e){return e.map((e=>this.read(e)))}write(e,t){if(this.closed_)throw new Error("TensorArray ".concat(this.name," has already been closed."));if(e<0||!this.dynamicSize&&e>=this.maxSize)throw new Error("Tried to write to index ".concat(e,", but array is not resizeable and size is: ").concat(this.maxSize));const n=this.tensors[e]||{};if(t.dtype!==this.dtype)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,",\n          because the value dtype is ").concat(t.dtype,", but TensorArray dtype is ").concat(this.dtype,"."));if(0!==this.size()||null!=this.elementShape&&0!==this.elementShape.length||(this.elementShape=t.shape),_$(this.elementShape,t.shape,"TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,".")),n.read)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been read."));if(n.written)throw new Error("TensorArray ".concat(this.name,": Could not write to TensorArray index ").concat(e,", because it has already been written."));n.tensor=t,VH(t),n.written=!0,this.tensors[e]=n}writeMany(e,t){if(e.length!==t.length)throw new Error("TensorArray ".concat(this.name,": could not write multiple tensors,")+"because the index size: ".concat(e.length," is not the same as tensors size: ").concat(t.length,"."));e.forEach(((e,n)=>this.write(e,t[n])))}gather(e,t){if(t&&t!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but gather requested dtype ").concat(t));if(e)e=e.slice(0,this.size());else{e=[];for(let t=0;t<this.size();t++)e.push(t)}if(0===e.length)return sG([],[0].concat(this.elementShape));const n=this.readMany(e);return _$(this.elementShape,n[0].shape,"TensorArray shape mismatch: "),KY(n,0)}concat(e){if(e&&e!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but concat requested dtype ").concat(e));if(0===this.size())return sG([],[0].concat(this.elementShape));const t=[];for(let a=0;a<this.size();a++)t.push(a);const n=this.readMany(t);return _$(this.elementShape,n[0].shape,"TensorArray shape mismatch: tensor array shape (".concat(this.elementShape,") vs first tensor shape (").concat(n[0].shape,")")),rq(n,0)}scatter(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));if(e.length!==t.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(e.length," vs. ").concat(t.shape[0]));const n=Math.max(...e);if(!this.dynamicSize&&n>=this.maxSize)throw new Error("Max index must be < array size (".concat(n,"  vs. ").concat(this.maxSize,")"));this.writeMany(e,sQ(t,0))}split(e,t){if(t.dtype!==this.dtype)throw new Error("TensorArray dtype is ".concat(this.dtype," but tensor has dtype ").concat(t.dtype));let n=0;const a=e.map((e=>(n+=e,n)));if(n!==t.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(n,", and tensor's shape is: ").concat(t.shape));if(!this.dynamicSize&&e.length!==this.maxSize)throw new Error("TensorArray's size is not equal to the size of lengths (".concat(this.maxSize," vs. ").concat(e.length,"), ")+"and the TensorArray is not marked as dynamically resizeable");const r=0===n?0:t.size/n,s=[];BH((()=>{t=tq(t,[1,n,r]);for(let n=0;n<e.length;++n){const o=[0,0===n?0:a[n-1],0],i=[1,e[n],r];s[n]=tq(oq(t,o,i),this.elementShape)}return s}));const o=[];for(let i=0;i<e.length;i++)o[i]=i;this.writeMany(o,s)}}class L${constructor(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:-1;this.tensors=e,this.elementShape=t,this.elementDtype=n,null!=e&&e.forEach((e=>{if(n!==e.dtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(e.dtype));_$(t,e.shape,"TensorList shape mismatch: "),VH(e)})),this.idTensor=fK(0),this.maxNumElements=a,VH(this.idTensor)}get id(){return this.idTensor.id}copy(){return new L$([...this.tensors],this.elementShape,this.elementDtype)}clearAndClose(e){this.tensors.forEach((t=>{null!=e&&e.has(t.id)||t.dispose()})),this.tensors.length=0,this.idTensor.dispose()}size(){return this.tensors.length}stack(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:-1;if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(-1!==n&&this.tensors.length!==n)throw new Error("Operation expected a list with ".concat(n," elements but got a list with ").concat(this.tensors.length," elements."));_$(e,this.elementShape,"TensorList shape mismatch: ");const a=F$(this.elementShape,this.tensors,e);return BH((()=>{const e=this.tensors.map((e=>tq(e,a)));return KY(e,0)}))}popBack(e,t){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));if(0===this.size())throw new Error("Trying to pop from an empty list.");const n=F$(this.elementShape,this.tensors,e),a=this.tensors.pop();return a.kept=!1,_$(a.shape,e,"TensorList shape mismatch: "),tq(a,n)}pushBack(e){if(e.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(this.elementDtype));if(_$(e.shape,this.elementShape,"TensorList shape mismatch: "),this.maxNumElements===this.size())throw new Error("Trying to push element into a full list.");VH(e),this.tensors.push(e)}resize(e){if(e<0)throw new Error("TensorListResize expects size to be non-negative. Got: ".concat(e));if(-1!==this.maxNumElements&&e>this.maxNumElements)throw new Error("TensorListResize input size ".concat(e," is greater maxNumElement ").concat(this.maxNumElements,"."));const t=new L$([],this.elementShape,this.elementDtype,this.maxNumElements);t.tensors.length=e;for(let n=0;n<Math.min(this.tensors.length,e);++n)t.tensors[n]=this.tensors[n];return t}getItem(e,t,n){if(n!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(n,", but list elements ").concat(this.elementDtype));if(e<0||e>this.tensors.length)throw new Error("Trying to access element ".concat(e," in a list with ").concat(this.tensors.length," elements."));if(null==this.tensors[e])throw new Error("element at index ".concat(e," is null."));_$(this.tensors[e].shape,t,"TensorList shape mismatch: ");const a=F$(this.elementShape,this.tensors,t);return tq(this.tensors[e],a)}setItem(e,t){if(t.dtype!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t.dtype,", but list elements ").concat(this.elementDtype));if(e<0||-1!==this.maxNumElements&&e>=this.maxNumElements)throw new Error("Trying to set element ".concat(e," in a list with max ").concat(this.maxNumElements," elements."));_$(this.elementShape,t.shape,"TensorList shape mismatch: "),VH(t),null!=this.tensors[e]&&(this.tensors[e].kept=!1),this.tensors[e]=t}gather(e,t,n){if(t!==this.elementDtype)throw new Error("Invalid data types; op elements ".concat(t,", but list elements ").concat(this.elementDtype));_$(this.elementShape,n,"TensorList shape mismatch: "),e=e.slice(0,this.size());const a=F$(this.elementShape,this.tensors,n);return 0===e.length?sG([],[0].concat(a)):BH((()=>{const t=e.map((e=>tq(this.tensors[e],a)));return KY(t,0)}))}concat(e,t){if(e&&e!==this.elementDtype)throw new Error("TensorList dtype is ".concat(this.elementDtype," but concat requested dtype ").concat(e));_$(this.elementShape,t,"TensorList shape mismatch: ");const n=F$(this.elementShape,this.tensors,t);return 0===this.size()?sG([],[0].concat(n)):BH((()=>{const e=this.tensors.map((e=>tq(e,n)));return rq(e,0)}))}}const z$=async(e,t,n)=>{switch(e.op){case"If":case"StatelessIf":{const a=GZ("thenBranch",e,t,n),r=GZ("elseBranch",e,t,n),s=GZ("cond",e,t,n),o=GZ("args",e,t,n);return(await s.data())[0]?n.functionMap[a].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap):n.functionMap[r].executeFunctionAsync(o,n.tensorArrayMap,n.tensorListMap)}case"While":case"StatelessWhile":{const a=GZ("body",e,t,n),r=GZ("cond",e,t,n),s=GZ("args",e,t,n),o=await n.functionMap[r].executeFunctionAsync(s,n.tensorArrayMap,n.tensorListMap),i=s.map((e=>e.id));let c=await o[0].data();o.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||e.dispose()}));let l=s;for(;c[0];){const e=l;l=await n.functionMap[a].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);const t=l.map((e=>e.id));e.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}));const s=await n.functionMap[r].executeFunctionAsync(l,n.tensorArrayMap,n.tensorListMap);c=await s[0].data(),s.forEach((e=>{e.kept||-1!==i.indexOf(e.id)||-1!==t.indexOf(e.id)||e.dispose()}))}return l}case"LoopCond":return[YZ(GZ("pred",e,t,n))];case"Switch":{const a=GZ("pred",e,t,n);let r=GZ("data",e,t,n);return r.kept||(r=YZ(r)),(await a.data())[0]?[void 0,r]:[r,void 0]}case"Merge":{const a=e.inputNames.find((e=>void 0!==HZ(e,t,n)));if(a){return[YZ(HZ(a,t,n))]}return}case"Enter":{const a=GZ("frameName",e,t,n),r=GZ("tensor",e,t,n);return n.enterFrame(a),[YZ(r)]}case"Exit":{const a=GZ("tensor",e,t,n);return n.exitFrame(),[YZ(a)]}case"NextIteration":{const a=GZ("tensor",e,t,n);return n.nextIteration(),[YZ(a)]}case"TensorArrayV3":{const a=GZ("size",e,t,n),r=GZ("dtype",e,t,n),s=GZ("elementShape",e,t,n),o=GZ("dynamicSize",e,t,n),i=GZ("clearAfterRead",e,t,n),c=GZ("identicalElementShapes",e,t,n),l=GZ("name",e,t,n),u=new M$(l,r,a,s,c,o,i);return n.addTensorArray(u),[u.idTensor,fK(1)]}case"TensorArrayWriteV3":{const a=GZ("tensorArrayId",e,t,n),r=GZ("index",e,t,n),s=GZ("tensor",e,t,n),o=n.getTensorArray(a.id);return o.write(r,s),[o.idTensor]}case"TensorArrayReadV3":{const a=GZ("tensorArrayId",e,t,n),r=GZ("index",e,t,n);return[n.getTensorArray(a.id).read(r)]}case"TensorArrayGatherV3":{const a=GZ("tensorArrayId",e,t,n),r=GZ("indices",e,t,n),s=GZ("dtype",e,t,n);return[n.getTensorArray(a.id).gather(r,s)]}case"TensorArrayScatterV3":{const a=GZ("tensorArrayId",e,t,n),r=GZ("indices",e,t,n),s=GZ("tensor",e,t,n),o=n.getTensorArray(a.id);return o.scatter(r,s),[o.idTensor]}case"TensorArrayConcatV3":{const a=GZ("tensorArrayId",e,t,n),r=n.getTensorArray(a.id),s=GZ("dtype",e,t,n);return[r.concat(s)]}case"TensorArraySplitV3":{const a=GZ("tensorArrayId",e,t,n),r=GZ("tensor",e,t,n),s=GZ("lengths",e,t,n),o=n.getTensorArray(a.id);return o.split(s,r),[o.idTensor]}case"TensorArraySizeV3":{const a=GZ("tensorArrayId",e,t,n);return[fK(n.getTensorArray(a.id).size(),"int32")]}case"TensorArrayCloseV3":{const a=GZ("tensorArrayId",e,t,n),r=n.getTensorArray(a.id);return r.clearAndClose(),[r.idTensor]}case"TensorListSetItem":{const a=GZ("tensorListId",e,t,n),r=GZ("index",e,t,n),s=GZ("tensor",e,t,n),o=n.getTensorList(a.id);return o.setItem(r,s),[o.idTensor]}case"TensorListGetItem":{const a=GZ("tensorListId",e,t,n),r=GZ("index",e,t,n),s=GZ("elementShape",e,t,n),o=GZ("elementDType",e,t,n);return[n.getTensorList(a.id).getItem(r,s,o)]}case"TensorListScatterV2":case"TensorListScatter":{const a=GZ("indices",e,t,n),r=function(e,t,n,a){if(t.length!==e.shape[0])throw new Error("Expected len(indices) == tensor.shape[0], but saw: ".concat(t.length," vs. ").concat(e.shape[0]));const r=Math.max(...t);if(null!=a&&-1!==a&&r>=a)throw new Error("Max index must be < array size (".concat(r,"  vs. ").concat(a,")"));const s=new L$([],n,e.dtype,a),o=sQ(e,0);return t.forEach(((e,t)=>{s.setItem(e,o[t])})),s}(GZ("tensor",e,t,n),a,GZ("elementShape",e,t,n),GZ("numElements",e,t,n));return n.addTensorList(r),[r.idTensor]}case"TensorListReserve":case"EmptyTensorList":{const a=GZ("elementShape",e,t,n),r=GZ("elementDType",e,t,n);let s;s="TensorListReserve"===e.op?"numElements":"maxNumElements";const o=GZ(s,e,t,n),i=function(e,t,n,a){return new L$([],e,t,a)}(a,r,0,"TensorListReserve"===e.op?-1:o);return n.addTensorList(i),[i.idTensor]}case"TensorListGather":{const a=GZ("tensorListId",e,t,n),r=GZ("indices",e,t,n),s=GZ("elementShape",e,t,n),o=GZ("elementDType",e,t,n);return[n.getTensorList(a.id).gather(r,o,s)]}case"TensorListStack":{const a=GZ("tensorListId",e,t,n),r=GZ("elementShape",e,t,n),s=GZ("elementDType",e,t,n),o=GZ("numElements",e,t,n);return[n.getTensorList(a.id).stack(r,s,o)]}case"TensorListFromTensor":{const a=function(e,t,n){const a=e.dtype;if(e.shape.length<1)throw new Error("Tensor must be at least a vector, but saw shape: ".concat(e.shape));if(e.dtype!==n)throw new Error("Invalid data types; op elements ".concat(e.dtype,", but list elements ").concat(n));_$(e.shape.slice(1),t,"TensorList shape mismatch: ");const r=sQ(e);return new L$(r,t,a)}(GZ("tensor",e,t,n),GZ("elementShape",e,t,n),GZ("elementDType",e,t,n));return n.addTensorList(a),[a.idTensor]}case"TensorListConcat":case"TensorListConcatV2":{const a=GZ("tensorListId",e,t,n),r=n.getTensorList(a.id),s=GZ("dtype",e,t,n),o=GZ("elementShape",e,t,n);return[r.concat(s,o)]}case"TensorListPushBack":{const a=GZ("tensorListId",e,t,n),r=GZ("tensor",e,t,n),s=n.getTensorList(a.id);return s.pushBack(r),[s.idTensor]}case"TensorListPopBack":{const a=GZ("tensorListId",e,t,n),r=GZ("elementShape",e,t,n),s=GZ("elementDType",e,t,n);return[n.getTensorList(a.id).popBack(r,s)]}case"TensorListSplit":{const a=GZ("tensor",e,t,n),r=GZ("elementShape",e,t,n),s=function(e,t,n){let a=0;const r=t.map((e=>(a+=e,a)));if(a!==e.shape[0])throw new Error("Expected sum of lengths to be equal to\n          tensor.shape[0], but sum of lengths is\n        ".concat(a,", and tensor's shape is: ").concat(e.shape));const s=O$(e.shape.slice(1),n),o=0===a?0:e.size/a,i=BH((()=>{const n=[];e=tq(e,[1,a,o]);for(let a=0;a<t.length;++a){const i=[0,0===a?0:r[a-1],0],c=[1,t[a],o];n[a]=tq(oq(e,i,c),s)}return e.dispose(),n})),c=new L$([],n,e.dtype,t.length);for(let l=0;l<i.length;l++)c.setItem(l,i[l]);return c}(a,GZ("lengths",e,t,n),r);return n.addTensorList(s),[s.idTensor]}case"TensorListLength":{const a=GZ("tensorListId",e,t,n);return[fK(n.getTensorList(a.id).size(),"int32")]}case"TensorListResize":{const a=GZ("tensorListId",e,t,n),r=GZ("size",e,t,n),s=n.getTensorList(a.id).resize(r);return n.addTensorList(s),[s.idTensor]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}};function P$(e,t,n){const[a,r]=GZ("fusedOps",e,t,n),s="biasadd"===a,o=!s,i="prelu"===r,c="fusedbatchnorm"===a,l=GZ("numArgs",e,t,n);if(s){if(i&&2!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&s&&1!==l)throw new Error("FusedConv2d and DepthwiseConv2d with BiasAdd must have one extra argument: bias.")}if(c)throw new Error("FusedConv2d and DepthwiseConv2d with FusedBatchNorm is not supported");const u=GZ("strides",e,t,n),h=XZ(e,t,n),d=GZ("dataFormat",e,t,n).toUpperCase(),p=GZ("dilations",e,t,n);let[f,m]=GZ("args",e,t,n);o&&(m=f,f=void 0);return{stride:u,pad:h,dataFormat:d,dilations:p,biasArg:f,preluArg:m,activationFunc:r,leakyreluAlpha:GZ("leakyreluAlpha",e,t,n)}}function B$(e,t,n){return{boxes:GZ("boxes",e,t,n),scores:GZ("scores",e,t,n),maxOutputSize:GZ("maxOutputSize",e,t,n),iouThreshold:GZ("iouThreshold",e,t,n),scoreThreshold:GZ("scoreThreshold",e,t,n),softNmsSigma:GZ("softNmsSigma",e,t,n)}}class W${constructor(e,t){this.keyDType=e,this.valueDType=t,this.handle=fK(0),this.tensorMap=new Map,VH(this.handle)}get id(){return this.handle.id}clearAndClose(){this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),this.handle.dispose()}size(){return this.tensorMap.size}tensorSize(){return fK(this.size(),"int32")}async import(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return this.tensorMap.forEach((e=>e.dispose())),this.tensorMap.clear(),BH((()=>{const e=sQ(t),a=n.length,r=e.length;Nz(a===r,(()=>"The number of elements doesn't match, keys has "+"".concat(a," elements, the values has ").concat(r," ")+"elements."));for(let t=0;t<a;t++){const a=n[t],r=e[t];VH(r),this.tensorMap.set(a,r)}return this.handle}))}async find(e,t){this.checkKeyAndValueTensor(e,t);const n=await e.data();return BH((()=>{const e=[];for(let a=0;a<n.length;a++){const r=n[a],s=this.findWithDefault(r,t);e.push(s)}return KY(e)}))}findWithDefault(e,t){const n=this.tensorMap.get(e);return null!=n?n:t}checkKeyAndValueTensor(e,t){if(e.dtype!==this.keyDType)throw new Error("Expect key dtype ".concat(this.keyDType,", but got ")+"".concat(e.dtype));if(t.dtype!==this.valueDType)throw new Error("Expect value dtype ".concat(this.valueDType,", but got ")+"".concat(t.dtype))}}function V$(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:BH;const s=((e,t,n)=>{switch(e.category){case"arithmetic":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"BiasAdd":case"AddV2":case"Add":return[a.add(GZ("a",e,t,n),GZ("b",e,t,n))];case"AddN":return[a.addN(GZ("tensors",e,t,n))];case"FloorMod":case"Mod":return[a.mod(GZ("a",e,t,n),GZ("b",e,t,n))];case"Mul":return[a.mul(GZ("a",e,t,n),GZ("b",e,t,n))];case"RealDiv":case"Div":return[a.div(GZ("a",e,t,n),GZ("b",e,t,n))];case"DivNoNan":return[a.divNoNan(GZ("a",e,t,n),GZ("b",e,t,n))];case"FloorDiv":return[a.floorDiv(GZ("a",e,t,n),GZ("b",e,t,n))];case"Sub":return[a.sub(GZ("a",e,t,n),GZ("b",e,t,n))];case"Minimum":return[a.minimum(GZ("a",e,t,n),GZ("b",e,t,n))];case"Maximum":return[a.maximum(GZ("a",e,t,n),GZ("b",e,t,n))];case"Pow":return[a.pow(GZ("a",e,t,n),GZ("b",e,t,n))];case"SquaredDifference":return[a.squaredDifference(GZ("a",e,t,n),GZ("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"basic_math":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"Abs":case"ComplexAbs":return[a.abs(GZ("x",e,t,n))];case"Acos":return[a.acos(GZ("x",e,t,n))];case"Acosh":return[a.acosh(GZ("x",e,t,n))];case"Asin":return[a.asin(GZ("x",e,t,n))];case"Asinh":return[a.asinh(GZ("x",e,t,n))];case"Atan":return[a.atan(GZ("x",e,t,n))];case"Atan2":return[a.atan2(GZ("x",e,t,n),GZ("y",e,t,n))];case"Atanh":return[a.atanh(GZ("x",e,t,n))];case"Ceil":return[a.ceil(GZ("x",e,t,n))];case"Complex":return[a.complex(GZ("real",e,t,n),GZ("imag",e,t,n))];case"Cos":return[a.cos(GZ("x",e,t,n))];case"Cosh":return[a.cosh(GZ("x",e,t,n))];case"Elu":return[a.elu(GZ("x",e,t,n))];case"Erf":return[a.erf(GZ("x",e,t,n))];case"Exp":return[a.exp(GZ("x",e,t,n))];case"Expm1":return[a.expm1(GZ("x",e,t,n))];case"Floor":return[a.floor(GZ("x",e,t,n))];case"Log":return[a.log(GZ("x",e,t,n))];case"Log1p":return[a.log1p(GZ("x",e,t,n))];case"Imag":return[a.imag(GZ("x",e,t,n))];case"Neg":return[a.neg(GZ("x",e,t,n))];case"Reciprocal":return[a.reciprocal(GZ("x",e,t,n))];case"Real":return[a.real(GZ("x",e,t,n))];case"Relu":return[a.relu(GZ("x",e,t,n))];case"Round":return[a.round(GZ("x",e,t,n))];case"Selu":return[a.selu(GZ("x",e,t,n))];case"Sigmoid":return[a.sigmoid(GZ("x",e,t,n))];case"Sin":return[a.sin(GZ("x",e,t,n))];case"Sign":return[a.sign(GZ("x",e,t,n))];case"Sinh":return[a.sinh(GZ("x",e,t,n))];case"Softplus":return[a.softplus(GZ("x",e,t,n))];case"Sqrt":return[a.sqrt(GZ("x",e,t,n))];case"Square":return[a.square(GZ("x",e,t,n))];case"Tanh":return[a.tanh(GZ("x",e,t,n))];case"Tan":return[a.tan(GZ("x",e,t,n))];case"ClipByValue":return[a.clipByValue(GZ("x",e,t,n),GZ("clipValueMin",e,t,n),GZ("clipValueMax",e,t,n))];case"Relu6":return[a.relu6(GZ("x",e,t,n))];case"Rsqrt":return[a.rsqrt(HZ(e.inputNames[0],t,n))];case"Prod":return[a.prod(GZ("x",e,t,n),GZ("axes",e,t,n))];case"LeakyRelu":return[a.leakyRelu(GZ("x",e,t,n),GZ("alpha",e,t,n))];case"Prelu":return[a.prelu(GZ("x",e,t,n),GZ("alpha",e,t,n))];case"IsNan":return[a.isNaN(HZ(e.inputNames[0],t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"control":return z$(e,t,n);case"convolution":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"Conv1D":{const r=GZ("stride",e,t,n),s=GZ("pad",e,t,n),o=GZ("dataFormat",e,t,n).toUpperCase(),i=GZ("dilation",e,t,n);return[a.conv1d(GZ("x",e,t,n),GZ("filter",e,t,n),r,s,o,i)]}case"Conv2D":{const r=GZ("strides",e,t,n),s=XZ(e,t,n),o=GZ("dataFormat",e,t,n).toUpperCase(),i=GZ("dilations",e,t,n);return[a.conv2d(GZ("x",e,t,n),GZ("filter",e,t,n),[r[1],r[2]],s,o,[i[1],i[2]])]}case"_FusedConv2D":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:h}=P$(e,t,n);return[a.fused.conv2d({x:GZ("x",e,t,n),filter:GZ("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:h})]}case"FusedDepthwiseConv2dNative":{const{stride:r,pad:s,dataFormat:o,dilations:i,biasArg:c,preluArg:l,activationFunc:u,leakyreluAlpha:h}=P$(e,t,n);return[a.fused.depthwiseConv2d({x:GZ("x",e,t,n),filter:GZ("filter",e,t,n),strides:[r[1],r[2]],pad:s,dataFormat:o,dilations:[i[1],i[2]],bias:c,activation:u,preluActivationWeights:l,leakyreluAlpha:h})]}case"Conv2DBackpropInput":case"Conv2dTranspose":{const r=GZ("outputShape",e,t,n),s=GZ("strides",e,t,n),o=XZ(e,t,n);return[a.conv2dTranspose(GZ("x",e,t,n),GZ("filter",e,t,n),r,[s[1],s[2]],o)]}case"DepthwiseConv2dNative":case"DepthwiseConv2d":{const r=GZ("strides",e,t,n),s=XZ(e,t,n),o=GZ("dilations",e,t,n),i=GZ("dataFormat",e,t,n).toUpperCase();return[a.depthwiseConv2d(GZ("input",e,t,n),GZ("filter",e,t,n),[r[1],r[2]],s,i,[o[1],o[2]])]}case"Conv3D":{const r=GZ("strides",e,t,n),s=GZ("pad",e,t,n),o=GZ("dataFormat",e,t,n).toUpperCase(),i=GZ("dilations",e,t,n);return[a.conv3d(GZ("x",e,t,n),GZ("filter",e,t,n),[r[1],r[2],r[3]],s,o,[i[1],i[2],i[3]])]}case"AvgPool":{const r=GZ("strides",e,t,n),s=GZ("pad",e,t,n),o=GZ("kernelSize",e,t,n);return[a.avgPool(GZ("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPool":{const r=GZ("strides",e,t,n),s=GZ("pad",e,t,n),o=GZ("kernelSize",e,t,n);return[a.maxPool(GZ("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s)]}case"MaxPoolWithArgmax":{const r=GZ("strides",e,t,n),s=GZ("pad",e,t,n),o=GZ("kernelSize",e,t,n),i=GZ("includeBatchInIndex",e,t,n),{result:c,indexes:l}=a.maxPoolWithArgmax(GZ("x",e,t,n),[o[1],o[2]],[r[1],r[2]],s,i);return[c,l]}case"AvgPool3D":{const r=GZ("strides",e,t,n),s=GZ("pad",e,t,n),o=GZ("kernelSize",e,t,n);return[a.avgPool3d(GZ("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"MaxPool3D":{const r=GZ("strides",e,t,n),s=GZ("pad",e,t,n),o=GZ("kernelSize",e,t,n);return[a.maxPool3d(GZ("x",e,t,n),[o[1],o[2],o[3]],[r[1],r[2],r[3]],s)]}case"Dilation2D":{const r=GZ("strides",e,t,n),s=GZ("pad",e,t,n),o=GZ("dilations",e,t,n),i=r[1],c=r[2],l=o[1],u=o[2];return[a.dilation2d(GZ("x",e,t,n),GZ("filter",e,t,n),[i,c],s,[l,u],"NHWC")]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"creation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"Fill":{const r=GZ("shape",e,t,n),s=GZ("dtype",e,t,n),o=GZ("value",e,t,n);return[a.fill(r,o,s)]}case"LinSpace":{const r=GZ("start",e,t,n),s=GZ("stop",e,t,n),o=GZ("num",e,t,n);return[a.linspace(r,s,o)]}case"Multinomial":{const r=GZ("logits",e,t,n),s=GZ("numSamples",e,t,n),o=GZ("seed",e,t,n);return[a.multinomial(r,s,o)]}case"OneHot":{const r=GZ("indices",e,t,n),s=GZ("depth",e,t,n),o=GZ("onValue",e,t,n),i=GZ("offValue",e,t,n),c=GZ("dtype",e,t,n);return[a.oneHot(r,s,o,i,c)]}case"Ones":return[a.ones(GZ("shape",e,t,n),GZ("dtype",e,t,n))];case"OnesLike":return[a.onesLike(GZ("x",e,t,n))];case"RandomStandardNormal":return[a.randomStandardNormal(GZ("shape",e,t,n),GZ("dtype",e,t,n),GZ("seed",e,t,n))];case"RandomUniform":return[a.randomUniform(GZ("shape",e,t,n),GZ("minval",e,t,n),GZ("maxval",e,t,n),GZ("dtype",e,t,n))];case"Range":{const r=GZ("start",e,t,n),s=GZ("stop",e,t,n),o=GZ("step",e,t,n);return[a.range(r,s,o,GZ("dtype",e,t,n))]}case"TruncatedNormal":{const r=GZ("shape",e,t,n),s=GZ("mean",e,t,n),o=GZ("stdDev",e,t,n),i=GZ("seed",e,t,n);return[a.truncatedNormal(r,s,o,GZ("dtype",e,t,n),i)]}case"Zeros":return[a.zeros(GZ("shape",e,t,n),GZ("dtype",e,t,n))];case"ZerosLike":return[a.zerosLike(GZ("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"dynamic":return async function(e,t,n,a){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:V;switch(e.op){case"NonMaxSuppressionV5":{const{boxes:a,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:c,softNmsSigma:l}=B$(e,t,n),u=await r.image.nonMaxSuppressionWithScoreAsync(a,s,o,i,c,l);return[u.selectedIndices,u.selectedScores]}case"NonMaxSuppressionV4":{const{boxes:a,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=B$(e,t,n),l=GZ("padToMaxOutputSize",e,t,n),u=await r.image.nonMaxSuppressionPaddedAsync(a,s,o,i,c,l);return[u.selectedIndices,u.validOutputs]}case"NonMaxSuppressionV3":case"NonMaxSuppressionV2":{const{boxes:a,scores:s,maxOutputSize:o,iouThreshold:i,scoreThreshold:c}=B$(e,t,n);return[await r.image.nonMaxSuppressionAsync(a,s,o,i,c)]}case"Where":{const a=r.cast(GZ("condition",e,t,n),"bool"),s=[await r.whereAsync(a)];return a.dispose(),s}case"ListDiff":return r.setdiff1dAsync(GZ("x",e,t,n),GZ("y",e,t,n));default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n);case"evaluation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"LowerBound":{const r=GZ("sortedSequence",e,t,n),s=GZ("values",e,t,n);return[a.lowerBound(r,s)]}case"TopKV2":{const r=GZ("x",e,t,n),s=GZ("k",e,t,n),o=GZ("sorted",e,t,n),i=a.topk(r,s,o);return[i.values,i.indices]}case"UpperBound":{const r=GZ("sortedSequence",e,t,n),s=GZ("values",e,t,n);return[a.upperBound(r,s)]}case"Unique":{const r=GZ("x",e,t,n),s=a.unique(r);return[s.values,s.indices]}case"UniqueV2":{const r=GZ("x",e,t,n),s=GZ("axis",e,t,n),o=a.unique(r,s);return[o.values,o.indices]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"image":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"ResizeBilinear":{const r=GZ("images",e,t,n),s=GZ("size",e,t,n),o=GZ("alignCorners",e,t,n),i=GZ("halfPixelCenters",e,t,n);return[a.image.resizeBilinear(r,[s[0],s[1]],o,i)]}case"ResizeNearestNeighbor":{const r=GZ("images",e,t,n),s=GZ("size",e,t,n),o=GZ("alignCorners",e,t,n),i=GZ("halfPixelCenters",e,t,n);return[a.image.resizeNearestNeighbor(r,[s[0],s[1]],o,i)]}case"CropAndResize":{const r=GZ("image",e,t,n),s=GZ("boxes",e,t,n),o=GZ("boxInd",e,t,n),i=GZ("cropSize",e,t,n),c=GZ("method",e,t,n),l=GZ("extrapolationValue",e,t,n);return[a.image.cropAndResize(r,s,o,i,c,l)]}case"ImageProjectiveTransformV3":{const r=GZ("images",e,t,n),s=GZ("transforms",e,t,n),o=GZ("outputShape",e,t,n),i=GZ("fillValue",e,t,n),c=GZ("interpolation",e,t,n),l=GZ("fillMode",e,t,n);return[a.image.transform(r,s,c.toLowerCase(),l.toLowerCase(),i,o)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"graph":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"Const":return t[e.name];case"PlaceholderWithDefault":const r=GZ("default",e,t,n);return[HZ(e.name,t,n)||r];case"Placeholder":return[HZ(e.name,t,n)];case"Identity":case"StopGradient":case"FakeQuantWithMinMaxVars":case"Snapshot":return[YZ(GZ("x",e,t,n))];case"IdentityN":return GZ("x",e,t,n).map((e=>YZ(e)));case"Shape":return[a.tensor1d(GZ("x",e,t,n).shape,"int32")];case"ShapeN":return GZ("x",e,t,n).map((e=>a.tensor1d(e.shape)));case"Size":return[a.scalar(GZ("x",e,t,n).size,"int32")];case"Rank":return[a.scalar(GZ("x",e,t,n).rank,"int32")];case"NoOp":return[a.scalar(1)];case"Print":const s=GZ("x",e,t,n),o=GZ("data",e,t,n),i=GZ("message",e,t,n),c=GZ("summarize",e,t,n);console.warn("The graph has a tf.print() operation,usually used for debugging, which slows down performance."),console.log(i);for(let e=0;e<o.length;e++)console.log(Array.prototype.slice.call(o[e].dataSync()).slice(0,c));return[s];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"logical":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"Equal":return[a.equal(GZ("a",e,t,n),GZ("b",e,t,n))];case"NotEqual":return[a.notEqual(GZ("a",e,t,n),GZ("b",e,t,n))];case"Greater":return[a.greater(GZ("a",e,t,n),GZ("b",e,t,n))];case"GreaterEqual":return[a.greaterEqual(GZ("a",e,t,n),GZ("b",e,t,n))];case"Less":return[a.less(GZ("a",e,t,n),GZ("b",e,t,n))];case"LessEqual":return[a.lessEqual(GZ("a",e,t,n),GZ("b",e,t,n))];case"LogicalAnd":return[a.logicalAnd(GZ("a",e,t,n),GZ("b",e,t,n))];case"LogicalNot":return[a.logicalNot(GZ("a",e,t,n))];case"LogicalOr":return[a.logicalOr(GZ("a",e,t,n),GZ("b",e,t,n))];case"Select":case"SelectV2":return[a.where(GZ("condition",e,t,n),GZ("a",e,t,n),GZ("b",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"matrices":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"BatchMatMul":case"BatchMatMulV2":case"MatMul":return[a.matMul(GZ("a",e,t,n),GZ("b",e,t,n),GZ("transposeA",e,t,n),GZ("transposeB",e,t,n))];case"Einsum":return[a.einsum(GZ("equation",e,t,n),...GZ("tensors",e,t,n))];case"Transpose":return[a.transpose(GZ("x",e,t,n),GZ("perm",e,t,n))];case"_FusedMatMul":const[r,s]=GZ("fusedOps",e,t,n),o="biasadd"===r,i="prelu"===s,c=GZ("numArgs",e,t,n),l=GZ("leakyreluAlpha",e,t,n);if(o){if(i&&2!==c)throw new Error("Fused MatMul with BiasAdd and Prelu must have two extra arguments: bias and alpha.");if(!i&&1!==c)throw new Error("Fused MatMul with BiasAdd must have one extra argument: bias.")}const[u,h]=GZ("args",e,t,n);return[a.fused.matMul({a:GZ("a",e,t,n),b:GZ("b",e,t,n),transposeA:GZ("transposeA",e,t,n),transposeB:GZ("transposeB",e,t,n),bias:u,activation:s,preluActivationWeights:h,leakyreluAlpha:l})];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"normalization":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"EuclideanNorm":return[a.euclideanNorm(GZ("x",e,t,n),GZ("axis",e,t,n),GZ("keepDims",e,t,n))];case"FusedBatchNorm":case"FusedBatchNormV2":case"FusedBatchNormV3":return[a.batchNorm(GZ("x",e,t,n),GZ("mean",e,t,n),GZ("variance",e,t,n),GZ("offset",e,t,n),GZ("scale",e,t,n),GZ("epsilon",e,t,n))];case"LRN":return[a.localResponseNormalization(GZ("x",e,t,n),GZ("radius",e,t,n),GZ("bias",e,t,n),GZ("alpha",e,t,n),GZ("beta",e,t,n))];case"Softmax":return[a.softmax(GZ("x",e,t,n))];case"LogSoftmax":return[a.logSoftmax(GZ("x",e,t,n))];case"SparseToDense":return[a.sparseToDense(GZ("sparseIndices",e,t,n),GZ("outputShape",e,t,n),GZ("sparseValues",e,t,n),GZ("defaultValue",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"reduction":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"Max":{const r=GZ("axis",e,t,n),s=GZ("keepDims",e,t,n);return[a.max(GZ("x",e,t,n),r,s)]}case"Mean":{const r=GZ("axis",e,t,n),s=GZ("keepDims",e,t,n);return[a.mean(GZ("x",e,t,n),r,s)]}case"Min":{const r=GZ("axis",e,t,n),s=GZ("keepDims",e,t,n);return[a.min(GZ("x",e,t,n),r,s)]}case"Sum":{const r=GZ("axis",e,t,n),s=GZ("keepDims",e,t,n);return[a.sum(GZ("x",e,t,n),r,s)]}case"All":{const r=GZ("axis",e,t,n),s=GZ("keepDims",e,t,n);return[a.all(GZ("x",e,t,n),r,s)]}case"Any":{const r=GZ("axis",e,t,n),s=GZ("keepDims",e,t,n);return[a.any(GZ("x",e,t,n),r,s)]}case"ArgMax":{const r=GZ("axis",e,t,n);return[a.argMax(GZ("x",e,t,n),r)]}case"ArgMin":{const r=GZ("axis",e,t,n);return[a.argMin(GZ("x",e,t,n),r)]}case"Prod":{const r=GZ("axis",e,t,n),s=GZ("keepDims",e,t,n);return[a.prod(GZ("x",e,t,n),r,s)]}case"Cumprod":{const r=GZ("axis",e,t,n),s=GZ("exclusive",e,t,n),o=GZ("reverse",e,t,n);return[a.cumprod(GZ("x",e,t,n),r,s,o)]}case"Cumsum":{const r=GZ("axis",e,t,n),s=GZ("exclusive",e,t,n),o=GZ("reverse",e,t,n);return[a.cumsum(GZ("x",e,t,n),r,s,o)]}case"Bincount":const r=GZ("x",e,t,n),s=GZ("weights",e,t,n),o=GZ("size",e,t,n);return[a.bincount(r,s,o)];case"DenseBincount":{const r=GZ("x",e,t,n),s=GZ("weights",e,t,n),o=GZ("size",e,t,n),i=GZ("binaryOutput",e,t,n);return[a.denseBincount(r,s,o,i)]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"slice_join":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"ConcatV2":case"Concat":{const r=GZ("n",e,t,n),s=GZ("axis",e,t,n);let o=GZ("tensors",e,t,n);return o=o.slice(0,r),[a.concat(o,s)]}case"Gather":{const r=GZ("x",e,t,n),s=GZ("indices",e,t,n);return[a.gather(r,a.cast(s,"int32"),0)]}case"GatherV2":{const r=GZ("axis",e,t,n),s=GZ("batchDims",e,t,n),o=GZ("x",e,t,n),i=GZ("indices",e,t,n);return[a.gather(o,a.cast(i,"int32"),r,s)]}case"Reverse":{const r=GZ("dims",e,t,n),s=[];for(let e=0;e<r.length;e++)r[e]&&s.push(e);const o=GZ("x",e,t,n);return[a.reverse(o,s)]}case"ReverseV2":{const r=GZ("axis",e,t,n),s=GZ("x",e,t,n);return[a.reverse(s,r)]}case"Slice":{const r=GZ("begin",e,t,n),s=GZ("size",e,t,n);return[a.slice(GZ("x",e,t,n),r,s)]}case"StridedSlice":{const r=GZ("begin",e,t,n),s=GZ("end",e,t,n),o=GZ("strides",e,t,n),i=GZ("beginMask",e,t,n),c=GZ("endMask",e,t,n),l=GZ("ellipsisMask",e,t,n),u=GZ("newAxisMask",e,t,n),h=GZ("shrinkAxisMask",e,t,n),d=GZ("x",e,t,n);return[a.stridedSlice(d,r,s,o,i,c,l,u,h)]}case"Pack":return BH((()=>{const r=GZ("axis",e,t,n),s=GZ("tensors",e,t,n),o=s[0].shape,i=a.squeeze(s[0]).shape,c=s.map((e=>{const t=_z(e.shape,o);if(!t&&!_z(a.squeeze(e).shape,i))throw new Error("the input tensors shape does not match");return t?e:a.reshape(e,o)}));return[a.stack(c,r)]}));case"Unpack":{const r=GZ("axis",e,t,n),s=GZ("tensor",e,t,n);return a.unstack(s,r)}case"Tile":{const r=GZ("reps",e,t,n);return[a.tile(GZ("x",e,t,n),r)]}case"Split":case"SplitV":{const r=GZ("axis",e,t,n),s=GZ("numOrSizeSplits",e,t,n),o=GZ("x",e,t,n);return a.split(o,s,r)}case"ScatterNd":{const r=GZ("indices",e,t,n),s=GZ("values",e,t,n),o=GZ("shape",e,t,n);return[a.scatterND(r,s,o)]}case"GatherNd":{const r=GZ("x",e,t,n),s=GZ("indices",e,t,n);return[a.gatherND(r,s)]}case"SparseToDense":{const r=GZ("sparseIndices",e,t,n),s=GZ("outputShape",e,t,n),o=GZ("sparseValues",e,t,n),i=GZ("defaultValue",e,t,n);return[a.sparseToDense(r,o,s,o.dtype===i.dtype?i:a.cast(i,o.dtype))]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"sparse":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"SparseFillEmptyRows":{const{outputIndices:r,outputValues:s,emptyRowIndicator:o,reverseIndexMap:i}=a.sparse.sparseFillEmptyRows(GZ("indices",e,t,n),GZ("values",e,t,n),GZ("denseShape",e,t,n),GZ("defaultValue",e,t,n));return[r,s,o,i]}case"SparseReshape":{const{outputIndices:r,outputShape:s}=a.sparse.sparseReshape(GZ("inputIndices",e,t,n),GZ("inputShape",e,t,n),GZ("newShape",e,t,n));return[r,s]}case"SparseSegmentMean":return[a.sparse.sparseSegmentMean(GZ("data",e,t,n),GZ("indices",e,t,n),GZ("segmentIds",e,t,n))];case"SparseSegmentSum":return[a.sparse.sparseSegmentSum(GZ("data",e,t,n),GZ("indices",e,t,n),GZ("segmentIds",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"spectral":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"FFT":return[a.fft(GZ("x",e,t,n))];case"IFFT":return[a.ifft(GZ("x",e,t,n))];case"RFFT":return[a.rfft(GZ("x",e,t,n))];case"IRFFT":return[a.irfft(GZ("x",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"string":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"StringNGrams":{const{nGrams:r,nGramsSplits:s}=a.string.stringNGrams(GZ("data",e,t,n),GZ("dataSplits",e,t,n),GZ("separator",e,t,n),GZ("nGramWidths",e,t,n),GZ("leftPad",e,t,n),GZ("rightPad",e,t,n),GZ("padWidth",e,t,n),GZ("preserveShortSequences",e,t,n));return[r,s]}case"StringSplit":{const{indices:r,values:s,shape:o}=a.string.stringSplit(GZ("input",e,t,n),GZ("delimiter",e,t,n),GZ("skipEmpty",e,t,n));return[r,s,o]}case"StringToHashBucketFast":return[a.string.stringToHashBucketFast(GZ("input",e,t,n),GZ("numBuckets",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"transformation":return r((()=>function(e,t,n){let a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:V;switch(e.op){case"Cast":return[a.cast(GZ("x",e,t,n),GZ("dtype",e,t,n))];case"ExpandDims":{const r=GZ("axis",e,t,n);return[a.expandDims(GZ("x",e,t,n),r)]}case"Squeeze":{const r=GZ("axis",e,t,n);return[a.squeeze(GZ("x",e,t,n),r)]}case"Reshape":return[a.reshape(GZ("x",e,t,n),GZ("shape",e,t,n))];case"MirrorPad":return[a.mirrorPad(GZ("x",e,t,n),GZ("padding",e,t,n),GZ("mode",e,t,n))];case"PadV2":case"Pad":return[a.pad(GZ("x",e,t,n),GZ("padding",e,t,n),GZ("constantValue",e,t,n))];case"SpaceToBatchND":{const r=GZ("blockShape",e,t,n),s=GZ("paddings",e,t,n);return[a.spaceToBatchND(GZ("x",e,t,n),r,s)]}case"BatchToSpaceND":{const r=GZ("blockShape",e,t,n),s=GZ("crops",e,t,n);return[a.batchToSpaceND(GZ("x",e,t,n),r,s)]}case"DepthToSpace":{const r=GZ("blockSize",e,t,n),s=GZ("dataFormat",e,t,n).toUpperCase();return[a.depthToSpace(GZ("x",e,t,n),r,s)]}case"BroadcastTo":return[a.broadcastTo(GZ("x",e,t,n),GZ("shape",e,t,n))];case"BroadcastArgs":return[a.broadcastArgs(GZ("s0",e,t,n),GZ("s1",e,t,n))];default:throw TypeError("Node type ".concat(e.op," is not implemented"))}}(e,t,n)));case"hash_table":return(async(e,t,n,a)=>{switch(e.op){case"HashTable":case"HashTableV2":{const r=GZ("keyDType",e,t,n),s=GZ("valueDType",e,t,n),o=new W$(r,s);return a.addHashTable(e.name,o),[o.handle]}case"LookupTableImport":case"LookupTableImportV2":{const r=GZ("tableHandle",e,t,n,a),s=GZ("keys",e,t,n),o=GZ("values",e,t,n),i=a.getHashTableById(r.id);return[await i.import(s,o)]}case"LookupTableFind":case"LookupTableFindV2":{const r=GZ("tableHandle",e,t,n,a),s=GZ("keys",e,t,n),o=GZ("defaultValue",e,t,n),i=a.getHashTableById(r.id);return[await i.find(s,o)]}case"LookupTableSize":case"LookupTableSizeV2":{const r=GZ("tableHandle",e,t,n,a);return[a.getHashTableById(r.id).tensorSize()]}default:throw TypeError("Node type ".concat(e.op," is not implemented"))}})(e,t,n,a);case"custom":const s=UZ(e.op);if(s&&s.customExecutor)return s.customExecutor(new A$(e,t,n));throw TypeError("Custom op ".concat(e.op," is not registered."));default:throw TypeError("Unknown op '".concat(e.op,"'. File an issue at ")+"https://github.com/tensorflow/tfjs/issues so we can add it, or register a custom execution with tf.registerOp()")}})(e,t,n);return uP(s)?s.then((e=>[].concat(e))):[].concat(s)}class U${constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{},a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};this.weightMap=e,this.tensorArrayMap=t,this.tensorListMap=n,this.functionMap=a,this.rootContext={id:0,frameName:"",iterationId:0},this.contexts=[this.rootContext],this.lastId=0,this.generateCurrentContextIds()}newFrame(e,t){return{id:e,frameName:t,iterationId:0}}set currentContext(e){this.contexts!==e&&(this.contexts=e,this.generateCurrentContextIds())}get currentContext(){return this.contexts}get currentContextId(){return this._currentContextIds[0]}get currentContextIds(){return this._currentContextIds}generateCurrentContextIds(){const e=[];for(let t=0;t<this.contexts.length-1;t++){const n=this.contexts.slice(0,this.contexts.length-t);e.push(this.contextIdforContexts(n))}e.push(""),this._currentContextIds=e}contextIdforContexts(e){return e?e.map((e=>0===e.id&&0===e.iterationId?"":"".concat(e.frameName,"-").concat(e.iterationId))).join("/"):""}enterFrame(e){this.contexts&&(this.lastId++,this.contexts=this.contexts.slice(),this.contexts.push(this.newFrame(this.lastId,e)),this._currentContextIds.unshift(this.contextIdforContexts(this.contexts)))}exitFrame(){if(!(this.contexts&&this.contexts.length>1))throw new Error("Cannot exit frame, the context is empty");this.contexts=this.contexts.slice(),this.contexts.splice(-1),this.currentContextIds.shift()}nextIteration(){if(!(this.contexts&&this.contexts.length>0))throw new Error("Cannot increase frame iteration, the context is empty");{this.contexts=this.contexts.slice(),this.lastId++;const e=Object.assign({},this.contexts[this.contexts.length-1]);e.iterationId+=1,e.id=this.lastId,this.contexts.splice(-1,1,e),this._currentContextIds.splice(0,1,this.contextIdforContexts(this.contexts))}}getWeight(e){return this.weightMap[e]}addTensorArray(e){this.tensorArrayMap[e.id]=e}getTensorArray(e){return this.tensorArrayMap[e]}addTensorList(e){this.tensorListMap[e.id]=e}getTensorList(e){return this.tensorListMap[e]}dispose(e){for(const t in this.tensorArrayMap)this.tensorArrayMap[t].clearAndClose(e);for(const t in this.tensorListMap)this.tensorListMap[t].clearAndClose(e)}}function G$(e,t,n,a){const r=new Set,s=[];let o=null,i=null;const c=new Set,l=Object.keys(e).map((e=>qZ(e)[0]));let u=[];null!=a&&(u=a.map((e=>qZ(e.name)[0])));const h=[...t];for(;h.length>0;){const e=h.pop();(q$(e)||X$(e)||Y$(e))&&null==o&&(o=e,i=o.children.map((e=>e.name)).filter((e=>r.has(e)))),r.add(e.name),null==n[e.name]&&(-1===l.indexOf(e.name)&&-1===u.indexOf(e.name)&&(0!==e.inputs.length?e.inputs.forEach((e=>{c.has(e.name)||(c.add(e.name),h.push(e))})):s.push(e.name)))}return{inputs:e,outputs:t,usedNodes:r,missingInputs:s,dynamicNode:o,syncInputs:i}}const H$=["Switch","Merge","Enter","Exit","NextIteration","StatelessIf","StatelessWhile","if","While"],j$=["NonMaxSuppressionV2","NonMaxSuppressionV3","NonMaxSuppressionV5","Where"],K$=["HashTable","HashTableV2","LookupTableImport","LookupTableImportV2","LookupTableFind","LookupTableFindV2","LookupTableSize","LookupTableSizeV2"];function q$(e){return H$.indexOf(e.op)>=0}function X$(e){return j$.indexOf(e.op)>=0}function Y$(e){return K$.indexOf(e.op)>=0}class Q${constructor(e,t){this.graph=e,this.parent=t,this.compiledMap=new Map,this._weightMap={},this.SEPERATOR=",",this._functions={},this._functionExecutorMap={},this.intermediateTensors={},this.keepTensorForDebug=!1,this._outputs=e.outputs,this._inputs=e.inputs,this._initNodes=e.initNodes,this._signature=e.signature,this._functions=e.functions,null!=e.functions&&Object.keys(e.functions).forEach((t=>{this._functionExecutorMap[t]=new Q$(e.functions[t],this)}))}get weightIds(){return this.parent?this.parent.weightIds:this._weightIds}get functionExecutorMap(){return this.parent?this.parent.functionExecutorMap:this._functionExecutorMap}get weightMap(){return this.parent?this.parent.weightMap:this._weightMap}set weightMap(e){const t=Object.keys(e).map((t=>e[t].map((e=>e.id))));this._weightIds=[].concat(...t),this._weightMap=e}set resourceManager(e){this._resourceManager=e}get inputs(){return this._inputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get outputs(){return this._outputs.map((e=>({name:e.name,shape:e.attrParams.shape?e.attrParams.shape.value:void 0,dtype:e.attrParams.dtype?e.attrParams.dtype.value:void 0})))}get inputNodes(){return this._inputs.map((e=>e.signatureKey||e.name))}get outputNodes(){return this._outputs.map((e=>{const t=e.signatureKey||e.name;return e.defaultOutput?"".concat(t,":").concat(e.defaultOutput):t}))}get functions(){return Object.keys(this._functions).reduce(((e,t)=>(e[t]=this._functions[t].signature,e)),{})}getCompilationKey(e,t){const n=e.map((e=>e.name)).sort(),a=t.map((e=>e.name)).sort();return n.join(this.SEPERATOR)+"--"+a.join(this.SEPERATOR)}compile(e,t){const n=G$(e,t,this.weightMap,this._initNodes),{missingInputs:a,dynamicNode:r,syncInputs:s}=n;if(null!=r)throw new Error("This execution contains the node '".concat(r.name,"', which has ")+"the dynamic op '".concat(r.op,"'. Please use ")+"model.executeAsync() instead. Alternatively, to avoid the "+"dynamic ops, specify the inputs [".concat(s,"]"));if(a.length>0){const n=t.map((e=>e.name)),r=Object.keys(e);throw new Error("Cannot compute the outputs [".concat(n,"] from the provided inputs ")+"[".concat(r,"]. Missing the following inputs: [").concat(a,"]"))}return function(e,t,n){const{usedNodes:a,inputs:r}=n,s=[],o=Object.keys(r).map((e=>qZ(e)[0])).map((t=>e.nodes[t])),i=e.initNodes;o.forEach((e=>{a.has(e.name)&&s.push(e)})),e.weights.forEach((e=>{a.has(e.name)&&s.push(e)})),null!=i&&i.forEach((e=>{a.has(e.name)&&s.push(e)}));const c=new Set,l=[];for(;s.length>0;){const e=s.pop();c.add(e.name),t[e.name]||l.push(e),e.children.forEach((e=>{!c.has(e.name)&&a.has(e.name)&&e.inputs.every((e=>c.has(e.name)))&&s.push(e)}))}return l}(this.graph,this.weightMap,n)}execute(e,t){e=this.mapInputs(e);const n=Object.keys(e).sort();this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t);const a=n.map((e=>this.graph.nodes[qZ(e)[0]])),r=t.map((e=>qZ(e)[0]));let s=r.map((e=>this.graph.nodes[e]));this.resetIntermediateTensors(),0===s.length&&(s=this._outputs);const o=this.getCompilationKey(a,s);let i=this.compiledMap.get(o);null==i&&(i=this.compile(e,s),this.compiledMap.set(o,i));const c={},l={};return BH((()=>{const n=new U$(this.weightMap,c,l,this.functionExecutorMap),a=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,r]=qZ(t),s=[];s[r]=e[t],a[n]=s}));const s=this.getFrozenTensorIds(a),o={};for(let e=0;e<i.length;e++){const t=i[e];if(!a[t.name]){const e=V$(t,a,n,this._resourceManager);if(uP(e))throw new Error("The execution of the op '".concat(t.op,"' returned a promise. ")+"Please use model.executeAsync() instead.");a[t.name]=e,this.checkTensorForDisposal(t.name,t,a,n,s,r,o)}}return null==this.parent&&n.dispose(s),t.map((e=>HZ(e,a,n)))}))}getFrozenTensorIds(e){const t=[].concat.apply([],Object.keys(e).map((t=>e[t])).map((e=>e.map((e=>e.id)))));return new Set(t)}checkTensorForDisposal(e,t,n,a,r,s,o){"control"!==t.category&&-1===s.indexOf(e)&&(n[e].forEach((e=>{null!=e&&(o[e.id]=(o[e.id]||0)+t.children.length)})),t.inputs.forEach((e=>{if("control"!==e.category){const s=function(e,t,n){return t[KZ(e,n.currentContextId)]}(e.name,n,a);null!=s&&s.forEach((e=>{if(e&&!e.kept&&!r.has(e.id)){const n=o[e.id];if(1===n){if(this.keepTensorForDebug){const[n,r]=jZ(t.name,a);this.intermediateTensors[n]||(this.intermediateTensors[n]=[]),this.intermediateTensors[n][r]=e}else e.dispose();delete o[e.id]}else null!=n&&o[e.id]--}}))}})))}async executeAsync(e,t){return this._executeAsync(e,t)}disposeIntermediateTensors(){this.intermediateTensors&&(Object.keys(this.intermediateTensors).forEach((e=>this.intermediateTensors[e].forEach((e=>e.dispose())))),this.disposeTensorsMap())}disposeTensorsMap(){this.tensorsMap&&Object.keys(this.tensorsMap).forEach((e=>{this.tensorsMap[e].forEach((e=>{!e||e.kept||e.isDisposed||this.keepIds.has(e.id)||e.dispose()}))}))}getIntermediateTensors(){return this.tensorsMap}resetIntermediateTensors(){for(const e in this.intermediateTensors)this.intermediateTensors[e].forEach((e=>e.dispose())),delete this.intermediateTensors[e]}async _executeAsync(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2],a=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:{};n||(e=this.mapInputs(e),this.checkInputs(e),this.checkInputShapeAndType(e),t=this.mapOutputs(t),this.checkOutputs(t));try{this.keepTensorForDebug=fP().getBool("KEEP_INTERMEDIATE_TENSORS")}catch(l){console.warn(l.message)}this.resetIntermediateTensors();const s=new U$(this.weightMap,a,r,this.functionExecutorMap);this.tensorsMap=await this.executeWithControlFlow(e,s,t,n);const o=t.map((e=>HZ(e,this.tensorsMap,s))),i=o.map((e=>e.id)),c=Object.keys(e).map((t=>e[t].id));return this.keepIds=new Set([...i,...c,...this.weightIds]),this.keepTensorForDebug||this.disposeTensorsMap(),null==this.parent&&s.dispose(this.keepIds),o}async executeFunctionAsync(e,t,n){const a=e.reduce(((e,t,n)=>(e[this.inputs[n].name]=t,e)),{});return this._executeAsync(a,this.outputNodes,!0,t,n)}async executeWithControlFlow(e,t,n,a){const r=Object.keys(e),s=r.map((e=>this.graph.nodes[qZ(e)[0]])),o=n.map((e=>qZ(e)[0]));let i=o.map((e=>this.graph.nodes[e]));0===i.length&&(i=this._outputs);const{usedNodes:c,missingInputs:l,dynamicNode:u,syncInputs:h}=G$(e,i,this.weightMap,this._initNodes),d=[...s,...this.graph.weights,...this._initNodes||[]].map((e=>({node:e,contexts:t.currentContext}))),p=Object.assign({},this.weightMap);Object.keys(e).forEach((t=>{const[n,a]=qZ(t),r=[];r[a]=e[t],p[n]=r}));const f={},m=this.getFrozenTensorIds(p),g={};for(;d.length>0;){const e=this.processStack(s,d,t,p,g,m,o,f,c);await Promise.all(e)}null!=u||a||console.warn("This model execution did not contain any nodes with control flow or dynamic output shapes. You can use model.execute() instead.");const y=i.filter((e=>!q$(e)&&!HZ(e.name,p,t))).map((e=>e.name));if(y.length>0){let e="";throw null!=u&&(e="Alternatively, to avoid the dynamic ops, use model.execute() "+"and specify the inputs [".concat(h,"]")),new Error("Cannot compute the outputs [".concat(y,"] from the provided ")+"inputs [".concat(r,"]. Consider providing the following inputs: ")+"[".concat(l,"]. ").concat(e))}return p}processStack(e,t,n,a,r,s,o,i,c){const l=[];for(;t.length>0;){const e=t.pop();n.currentContext=e.contexts;let u="";if("Enter"===e.node.op&&GZ("isConstant",e.node,a,n)&&([u]=jZ(e.node.name,n)),null==a[e.node.name]){const h=V$(e.node,a,n,this._resourceManager);u||([u]=jZ(e.node.name,n));const d=n.currentContext;uP(h)?l.push(h.then((l=>(a[u]=l,n.currentContext=d,this.checkTensorForDisposal(u,e.node,a,n,s,o,i),this.processChildNodes(e.node,t,n,a,r,c),l)))):(a[u]=h,this.checkTensorForDisposal(u,e.node,a,n,s,o,i),this.processChildNodes(e.node,t,n,a,r,c))}else this.processChildNodes(e.node,t,n,a,r,c)}return l}processChildNodes(e,t,n,a,r,s){e.children.forEach((e=>{const[o]=jZ(e.name,n);!r[o]&&s.has(e.name)&&("Merge"===e.op?e.inputNames.some((e=>!!HZ(e,a,n)))&&(r[o]=!0,t.push({contexts:n.currentContext,node:e})):e.inputNames.every((e=>!!HZ(e,a,n)))&&(r[o]=!0,t.push({contexts:n.currentContext,node:e})))}))}dispose(){Object.keys(this.weightMap).forEach((e=>this.weightMap[e].forEach((e=>e.dispose()))))}checkInputShapeAndType(e){Object.keys(e).forEach((t=>{const n=e[t],[a]=qZ(t),r=this.graph.nodes[a];if(r.attrParams.shape&&r.attrParams.shape.value){const e=r.attrParams.shape.value;Nz(e.length===n.shape.length&&n.shape.every(((t,n)=>-1===e[n]||e[n]===t)),(()=>"The shape of dict['".concat(r.name,"'] provided in ")+"model.execute(dict) must be [".concat(e,"], but was ")+"[".concat(n.shape,"]")))}r.attrParams.dtype&&r.attrParams.dtype.value&&Nz(n.dtype===r.attrParams.dtype.value,(()=>"The dtype of dict['".concat(r.name,"'] provided in ")+"model.execute(dict) must be "+"".concat(r.attrParams.dtype.value,", but was ").concat(n.dtype)))}))}mapInputs(e){const t={};for(const n in e)if(null!=this._signature&&null!=this._signature.inputs&&null!=this._signature.inputs[n]){t[this._signature.inputs[n].name]=e[n]}else t[n]=e[n];return t}checkInputs(e){const t=Object.keys(e).filter((e=>{const[t]=qZ(e);return null==this.graph.nodes[t]}));if(t.length>0)throw new Error("The dict provided in model.execute(dict) has "+"keys: [".concat(t,"] that are not part of graph"))}mapOutputs(e){return e.map((e=>{if(null!=this._signature&&null!=this._signature.outputs&&null!=this._signature.outputs[e]){return this._signature.outputs[e].name}return e}),{})}checkOutputs(e){e.forEach((e=>{const[t]=qZ(e);if(!this.graph.nodes[t])throw new Error("The output '".concat(e,"' is not found in the graph"))}))}}class J${constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:{},t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};this.hashTableNameToHandle=e,this.hashTableMap=t}addHashTable(e,t){this.hashTableNameToHandle[e]=t.handle,this.hashTableMap[t.id]=t}getHashTableHandleByName(e){return this.hashTableNameToHandle[e]}getHashTableById(e){return this.hashTableMap[e]}dispose(){for(const e in this.hashTableMap)this.hashTableMap[e].clearAndClose(),delete this.hashTableMap[e];for(const e in this.hashTableNameToHandle)this.hashTableNameToHandle[e].dispose(),delete this.hashTableNameToHandle[e]}}const Z$="?tfjs-format=file",$$="model.json";class e0{constructor(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:c;this.modelUrl=e,this.loadOptions=t,this.version="n/a",this.io=n,null==t&&(this.loadOptions={}),this.resourceManager=new J$}get modelVersion(){return this.version}get inputNodes(){return this.executor.inputNodes}get outputNodes(){return this.executor.outputNodes}get inputs(){return this.executor.inputs}get outputs(){return this.executor.outputs}get weights(){return this.executor.weightMap}get metadata(){return this.artifacts.userDefinedMetadata}get modelSignature(){return this.signature}get modelStructuredOutputKeys(){return this.structuredOutputKeys}findIOHandler(){const e=this.modelUrl;if(null!=e.load)this.handler=e;else if(null!=this.loadOptions.requestInit)this.handler=this.io.browserHTTPRequest(e,this.loadOptions);else{const t=this.io.getLoadHandlers(e,this.loadOptions);if(0===t.length)t.push(this.io.browserHTTPRequest(e,this.loadOptions));else if(t.length>1)throw new Error("Found more than one (".concat(t.length,") load handlers for ")+"URL '".concat([e],"'"));this.handler=t[0]}}load(){if(this.findIOHandler(),null==this.handler.load)throw new Error("Cannot proceed with model loading because the IOHandler provided does not have the `load` method implemented.");const e=this.handler.load();return uP(e)?e.then((e=>this.loadSync(e))):this.loadSync(e)}loadSync(e){this.artifacts=e;const t=this.artifacts.modelTopology;let n=this.artifacts.signature;if(null!=this.artifacts.userDefinedMetadata){const e=this.artifacts.userDefinedMetadata;null!=e.signature&&(n=e.signature),null!=e.structuredOutputKeys&&(this.structuredOutputKeys=e.structuredOutputKeys)}this.signature=n,this.version="".concat(t.versions.producer,".").concat(t.versions.minConsumer);const a=this.io.decodeWeights(this.artifacts.weightData,this.artifacts.weightSpecs);if(this.executor=new Q$(m$.Instance.transformGraph(t,this.signature)),this.executor.weightMap=this.convertTensorMapToTensorsMap(a),this.executor.resourceManager=this.resourceManager,null!=e.modelInitializer&&null!=e.modelInitializer.node){const t=m$.Instance.transformGraph(e.modelInitializer);this.initializer=new Q$(t),this.initializer.weightMap=this.executor.weightMap,this.initializer.resourceManager=this.resourceManager,this.initializer.executeAsync({},[])}return!0}async save(e,t){if("string"===typeof e){const t=this.io.getSaveHandlers(e);if(0===t.length)throw new Error("Cannot find any save handlers for URL '".concat(e,"'"));if(t.length>1)throw new Error("Found more than one (".concat(t.length,") save handlers for ")+"URL '".concat(e,"'"));e=t[0]}if(null==e.save)throw new Error("GraphModel.save() cannot proceed because the IOHandler provided does not have the `save` attribute defined.");return e.save(this.artifacts)}predict(e,t){const n=this.execute(e,this.outputNodes);if(this.structuredOutputKeys){const e={};return(n instanceof IU?[n]:n).forEach(((t,n)=>e[this.structuredOutputKeys[n]]=t)),e}return n}normalizeInputs(e){if(!(e instanceof IU)&&!Array.isArray(e))return e;if((e=Array.isArray(e)?e:[e]).length!==this.inputNodes.length)throw new Error("Input tensor count mismatch,"+"the graph model has ".concat(this.inputNodes.length," placeholders, ")+"while there are ".concat(e.length," input tensors."));return this.inputNodes.reduce(((t,n,a)=>(t[n]=e[a],t)),{})}normalizeOutputs(e){return e=e||this.outputNodes,Array.isArray(e)?e:[e]}execute(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=this.executor.execute(e,t);return n.length>1?n:n[0]}async executeAsync(e,t){e=this.normalizeInputs(e),t=this.normalizeOutputs(t);const n=await this.executor.executeAsync(e,t);return n.length>1?n:n[0]}getIntermediateTensors(){return this.executor.getIntermediateTensors()}disposeIntermediateTensors(){this.executor.disposeIntermediateTensors()}convertTensorMapToTensorsMap(e){return Object.keys(e).reduce(((t,n)=>(t[n]=[e[n]],t)),{})}dispose(){this.executor.dispose(),this.initializer&&this.initializer.dispose(),this.resourceManager.dispose()}}async function t0(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{},n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:c;if(null==e)throw new Error("modelUrl in loadGraphModel() cannot be null. Please provide a url or an IOHandler that loads the model");null==t&&(t={}),t.fromTFHub&&"string"===typeof e&&(e=function(e){e.endsWith("/")||(e+="/");return"".concat(e).concat($$).concat(Z$)}(e));const a=new e0(e,t,n);return await a.load(),a}var n0=function(e,t){return(n0=Object.setPrototypeOf||{__proto__:[]}instanceof Array&&function(e,t){e.__proto__=t}||function(e,t){for(var n in t)t.hasOwnProperty(n)&&(e[n]=t[n])})(e,t)};function a0(e,t){function n(){this.constructor=e}n0(e,t),e.prototype=null===t?Object.create(t):(n.prototype=t.prototype,new n)}var r0=function(){return(r0=Object.assign||function(e){for(var t,n=1,a=arguments.length;n<a;n++)for(var r in t=arguments[n])Object.prototype.hasOwnProperty.call(t,r)&&(e[r]=t[r]);return e}).apply(this,arguments)};function s0(e,t,n,a){return new(n||(n=Promise))((function(r,s){function o(e){try{c(a.next(e))}catch(e){s(e)}}function i(e){try{c(a.throw(e))}catch(e){s(e)}}function c(e){e.done?r(e.value):new n((function(t){t(e.value)})).then(o,i)}c((a=a.apply(e,t||[])).next())}))}function o0(e,t){var n,a,r,s,o={label:0,sent:function(){if(1&r[0])throw r[1];return r[1]},trys:[],ops:[]};return s={next:i(0),throw:i(1),return:i(2)},"function"==typeof Symbol&&(s[Symbol.iterator]=function(){return this}),s;function i(s){return function(i){return function(s){if(n)throw new TypeError("Generator is already executing.");for(;o;)try{if(n=1,a&&(r=2&s[0]?a.return:s[0]?a.throw||((r=a.return)&&r.call(a),0):a.next)&&!(r=r.call(a,s[1])).done)return r;switch(a=0,r&&(s=[2&s[0],r.value]),s[0]){case 0:case 1:r=s;break;case 4:return o.label++,{value:s[1],done:!1};case 5:o.label++,a=s[1],s=[0];continue;case 7:s=o.ops.pop(),o.trys.pop();continue;default:if(!(r=(r=o.trys).length>0&&r[r.length-1])&&(6===s[0]||2===s[0])){o=0;continue}if(3===s[0]&&(!r||s[1]>r[0]&&s[1]<r[3])){o.label=s[1];break}if(6===s[0]&&o.label<r[1]){o.label=r[1],r=s;break}if(r&&o.label<r[2]){o.label=r[2],o.ops.push(s);break}r[2]&&o.ops.pop(),o.trys.pop();continue}s=t.call(e,o)}catch(e){s=[6,e],a=0}finally{n=r=0}if(5&s[0])throw s[1];return{value:s[0]?s[1]:void 0,done:!0}}([s,i])}}}var i0=function(){function e(e,t){this.model=e,this.outputStride=t;var n=this.model.inputs[0].shape;Nz(-1===n[1]&&-1===n[2],(function(){return"Input shape ["+n[1]+", "+n[2]+"] must both be equal to or -1"}))}return e.prototype.predict=function(e){var t=this;return BH((function(){var n=t.preprocessInput(oH(e,"float32")),a=iX(n,0),r=t.model.predict(a).map((function(e){return jY(e,[0])})),s=t.nameOutputResults(r);return{heatmapScores:sq(s.heatmap),offsets:s.offsets,displacementFwd:s.displacementFwd,displacementBwd:s.displacementBwd}}))},e.prototype.dispose=function(){this.model.dispose()},e}(),c0=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return a0(t,e),t.prototype.preprocessInput=function(e){return BH((function(){return xK(nK(e,127.5),1)}))},t.prototype.nameOutputResults=function(e){return{offsets:e[0],heatmap:e[1],displacementFwd:e[2],displacementBwd:e[3]}},t}(i0);function l0(e){return Math.floor(e/2)}var u0=function(){function e(e,t){this.priorityQueue=new Array(e),this.numberOfElements=-1,this.getElementValue=t}return e.prototype.enqueue=function(e){this.priorityQueue[++this.numberOfElements]=e,this.swim(this.numberOfElements)},e.prototype.dequeue=function(){var e=this.priorityQueue[0];return this.exchange(0,this.numberOfElements--),this.sink(0),this.priorityQueue[this.numberOfElements+1]=null,e},e.prototype.empty=function(){return-1===this.numberOfElements},e.prototype.size=function(){return this.numberOfElements+1},e.prototype.all=function(){return this.priorityQueue.slice(0,this.numberOfElements+1)},e.prototype.max=function(){return this.priorityQueue[0]},e.prototype.swim=function(e){for(;e>0&&this.less(l0(e),e);)this.exchange(e,l0(e)),e=l0(e)},e.prototype.sink=function(e){for(;2*e<=this.numberOfElements;){var t=2*e;if(t<this.numberOfElements&&this.less(t,t+1)&&t++,!this.less(e,t))break;this.exchange(e,t),e=t}},e.prototype.getValueAt=function(e){return this.getElementValue(this.priorityQueue[e])},e.prototype.less=function(e,t){return this.getValueAt(e)<this.getValueAt(t)},e.prototype.exchange=function(e,t){var n=this.priorityQueue[e];this.priorityQueue[e]=this.priorityQueue[t],this.priorityQueue[t]=n},e}();function h0(e,t,n,a,r,s){for(var o=s.shape,i=o[0],c=o[1],l=!0,u=Math.max(n-r,0),h=Math.min(n+r+1,i),d=u;d<h;++d){for(var p=Math.max(a-r,0),f=Math.min(a+r+1,c),m=p;m<f;++m)if(s.get(d,m,e)>t){l=!1;break}if(!l)break}return l}var d0=["nose","leftEye","rightEye","leftEar","rightEar","leftShoulder","rightShoulder","leftElbow","rightElbow","leftWrist","rightWrist","leftHip","rightHip","leftKnee","rightKnee","leftAnkle","rightAnkle"],p0=d0.length,f0=d0.reduce((function(e,t,n){return e[t]=n,e}),{});[["leftHip","leftShoulder"],["leftElbow","leftShoulder"],["leftElbow","leftWrist"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["rightHip","rightShoulder"],["rightElbow","rightShoulder"],["rightElbow","rightWrist"],["rightHip","rightKnee"],["rightKnee","rightAnkle"],["leftShoulder","rightShoulder"],["leftHip","rightHip"]].map((function(e){var t=e[0],n=e[1];return[f0[t],f0[n]]}));function m0(e,t,n,a){return{y:a.get(e,t,n),x:a.get(e,t,n+p0)}}function g0(e,t,n){var a=m0(e.heatmapY,e.heatmapX,e.id,n),r=a.y,s=a.x;return{x:e.heatmapX*t+s,y:e.heatmapY*t+r}}function y0(e,t,n){return e<t?t:e>n?n:e}function b0(e,t){return{x:e.x+t.x,y:e.y+t.y}}var v0=[["nose","leftEye"],["leftEye","leftEar"],["nose","rightEye"],["rightEye","rightEar"],["nose","leftShoulder"],["leftShoulder","leftElbow"],["leftElbow","leftWrist"],["leftShoulder","leftHip"],["leftHip","leftKnee"],["leftKnee","leftAnkle"],["nose","rightShoulder"],["rightShoulder","rightElbow"],["rightElbow","rightWrist"],["rightShoulder","rightHip"],["rightHip","rightKnee"],["rightKnee","rightAnkle"]].map((function(e){var t=e[0],n=e[1];return[f0[t],f0[n]]})),x0=v0.map((function(e){return e[1]})),w0=v0.map((function(e){return e[0]}));function k0(e,t,n,a){return{y:y0(Math.round(e.y/t),0,n-1),x:y0(Math.round(e.x/t),0,a-1)}}function S0(e,t,n,a,r,s,o,i){void 0===i&&(i=2);for(var c=a.shape,l=c[0],u=c[1],h=function(e,t,n){var a=n.shape[2]/2;return{y:n.get(t.y,t.x,e),x:n.get(t.y,t.x,a+e)}}(e,k0(t.position,s,l,u),o),d=b0(t.position,h),p=0;p<i;p++){var f=k0(d,s,l,u),m=m0(f.y,f.x,n,r);d=b0({x:f.x*s,y:f.y*s},{x:m.x,y:m.y})}var g=k0(d,s,l,u),y=a.get(g.y,g.x,n);return{position:d,part:d0[n],score:y}}function I0(e,t,n,a,r,s){var o=t.shape[2],i=x0.length,c=new Array(o),l=e.part,u=e.score,h=g0(l,a,n);c[l.id]={score:u,part:d0[l.id],position:h};for(var d=i-1;d>=0;--d){var p=x0[d],f=w0[d];c[p]&&!c[f]&&(c[f]=S0(d,c[p],f,t,n,a,s))}for(d=0;d<i;++d)p=w0[d],f=x0[d],c[p]&&!c[f]&&(c[f]=S0(d,c[p],f,t,n,a,r));return c}function N0(e,t,n,a){var r=n.x,s=n.y;return e.some((function(e){var n=e.keypoints[a].position;return function(e,t,n,a){var r=n-e,s=a-t;return r*r+s*s}(s,r,n.y,n.x)<=t}))}function T0(e,t,n){return n.reduce((function(n,a,r){var s=a.position,o=a.score;return N0(e,t,s,r)||(n+=o),n}),0)/n.length}function E0(e,t,n,a,r,s,o,i){void 0===o&&(o=.5),void 0===i&&(i=20);for(var c=[],l=function(e,t,n){for(var a=n.shape,r=a[0],s=a[1],o=a[2],i=new u0(r*s*o,(function(e){return e.score})),c=0;c<r;++c)for(var l=0;l<s;++l)for(var u=0;u<o;++u){var h=n.get(c,l,u);h<e||h0(u,h,c,l,t,n)&&i.enqueue({score:h,part:{heatmapY:c,heatmapX:l,id:u}})}return i}(o,1,e),u=i*i;c.length<s&&!l.empty();){var h=l.dequeue();if(!N0(c,u,g0(h.part,r,t),h.part.id)){var d=I0(h,e,t,r,n,a),p=T0(c,u,d);c.push({keypoints:d,score:p})}}return c}function C0(e){var t=e.shape,n=t[0],a=t[1],r=t[2];return BH((function(){var t=tq(e,[n*a,r]),s=OK(t,0),o=iX(nK(s,fK(a,"int32")),1),i=iX(function(e,t){return BH((function(){var n=nK(e,fK(t,"int32"));return xK(e,aK(n,fK(t,"int32")))}))}(s,a),1);return rq([o,i],1)}))}function R0(e,t,n,a){return{y:a.get(e,t,n),x:a.get(e,t,n+p0)}}function A0(e,t,n){return BH((function(){var a=function(e,t){for(var n=[],a=0;a<p0;a++){var r=R0(e.get(a,0).valueOf(),e.get(a,1).valueOf(),a,t),s=r.x,o=r.y;n.push(o),n.push(s)}return JY(n,[p0,2])}(e,n);return eK(oH(aK(e.toTensor(),fK(t,"int32")),"float32"),a)}))}function _0(e,t,n){return s0(this,void 0,void 0,(function(){var a,r,s,o,i,c,l,u,h,d;return o0(this,(function(p){switch(p.label){case 0:return a=0,r=C0(e),[4,Promise.all([e.buffer(),t.buffer(),r.buffer()])];case 1:return s=p.sent(),o=s[0],i=s[1],c=s[2],[4,(l=A0(c,n,i)).buffer()];case 2:return u=p.sent(),h=Array.from(function(e,t){for(var n=t.shape[0],a=new Float32Array(n),r=0;r<n;r++){var s=t.get(r,0),o=t.get(r,1);a[r]=e.get(s,o,r)}return a}(o,c)),d=h.map((function(e,t){return a+=e,{position:{y:u.get(t,0),x:u.get(t,1)},part:d0[t],score:e}})),r.dispose(),l.dispose(),[2,{keypoints:d,score:a/d.length}]}}))}))}var D0="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/mobilenet/",F0="https://storage.googleapis.com/tfjs-models/savedmodel/posenet/resnet50/";var O0=[-123.15,-115.9,-103.06],M0=function(e){function t(){return null!==e&&e.apply(this,arguments)||this}return a0(t,e),t.prototype.preprocessInput=function(e){return eK(e,O0)},t.prototype.nameOutputResults=function(e){var t=e[0],n=e[1];return{offsets:e[2],heatmap:e[3],displacementFwd:t,displacementBwd:n}},t}(i0);Number.NEGATIVE_INFINITY,Number.POSITIVE_INFINITY;function L0(e){return s0(this,void 0,void 0,(function(){return o0(this,(function(t){return[2,Promise.all(e.map((function(e){return e.buffer()})))]}))}))}function z0(e,t){return V0(e,t)?e:Math.floor(e/t)*t+1}function P0(e){Nz("number"==typeof e||"object"==typeof e,(function(){return"Invalid inputResolution "+e+". Should be a number or an object with width and height"})),"object"==typeof e&&(Nz("number"==typeof e.width,(function(){return"inputResolution.width has a value of "+e.width+" which is invalid; it must be a number"})),Nz("number"==typeof e.height,(function(){return"inputResolution.height has a value of "+e.height+" which is invalid; it must be a number"})))}function B0(e,t){return P0(e),"object"==typeof e?[z0(e.height,t),z0(e.width,t)]:[z0(e,t),z0(e,t)]}var W0=[8,16,32];function V0(e,t){return(e-1)%t==0}function U0(e){return e instanceof IU?[e.shape[0],e.shape[1]]:[e.height,e.width]}function G0(e,t){var n=t[0],a=t[1],r=U0(e),s=r[0],o=r[1],i=a/n,c=[0,0,0,0],l=c[0],u=c[1],h=c[2],d=c[3];return o/s<i?(l=0,u=0,h=Math.round(.5*(i*s-o)),d=Math.round(.5*(i*s-o))):(l=Math.round(.5*(1/i*o-s)),u=Math.round(.5*(1/i*o-s)),h=0,d=0),{resized:BH((function(){var t=function(e){return e instanceof IU?e:dj(e)}(e);return t=tY(t,[[l,u],[h,d],[0,0]]),TJ.resizeBilinear(t,[n,a])})),padding:{top:l,left:h,right:d,bottom:u}}}function H0(e,t,n,a,r){var s=t[0],o=t[1],i=n[0],c=n[1],l=function(e,t,n,a,r){return void 0===a&&(a=0),void 0===r&&(r=0),1===n&&1===t&&0===a&&0===r?e:e.map((function(e){return function(e,t,n,a,r){return void 0===a&&(a=0),void 0===r&&(r=0),{score:e.score,keypoints:e.keypoints.map((function(e){var s=e.score,o=e.part,i=e.position;return{score:s,part:o,position:{x:i.x*n+r,y:i.y*t+a}}}))}}(e,t,n,a,r)}))}(e,(s+a.top+a.bottom)/i,(o+a.left+a.right)/c,-a.top,-a.left);return r?function(e,t){return t<=0?e:e.map((function(e){return function(e,t){return{score:e.score,keypoints:e.keypoints.map((function(e){var n=e.score,a=e.part,r=e.position;return{score:n,part:a,position:{x:t-1-r.x,y:r.y}}}))}}(e,t)}))}(l,o):l}var j0={architecture:"MobileNetV1",outputStride:16,multiplier:.75,inputResolution:257},K0=["MobileNetV1","ResNet50"],q0={MobileNetV1:[8,16,32],ResNet50:[32,16]},X0={MobileNetV1:[.5,.75,1],ResNet50:[1]},Y0=[1,2,4];var Q0={flipHorizontal:!1},J0={flipHorizontal:!1,maxDetections:5,scoreThreshold:.5,nmsRadius:20};var Z0=function(){function e(e,t){(function(e){Nz("number"==typeof e,(function(){return"outputStride is not a number"})),Nz(W0.indexOf(e)>=0,(function(){return"outputStride of "+e+" is invalid. It must be either 8, 16, or 32"}))})(e.outputStride),function(e,t){Nz("number"==typeof e[0]&&"number"==typeof e[1],(function(){return"both resolution values must be a number but had values "+e})),Nz(V0(e[0],t),(function(){return"height of "+e[0]+" is invalid for output stride "+t+"."})),Nz(V0(e[1],t),(function(){return"width of "+e[1]+" is invalid for output stride "+t+"."}))}(t,e.outputStride),this.baseModel=e,this.inputResolution=t}return e.prototype.estimateMultiplePoses=function(e,t){return void 0===t&&(t=J0),s0(this,void 0,void 0,(function(){var n,a,r,s,o,i,c,l,u,h,d,p,f,m,g,y,b,v,x,w,k;return o0(this,(function(S){switch(S.label){case 0:return n=r0({},J0,t),function(e){var t=e.maxDetections,n=e.scoreThreshold,a=e.nmsRadius;if(t<=0)throw new Error("Invalid maxDetections "+t+". Should be > 0");if(n<0||n>1)throw new Error("Invalid scoreThreshold "+n+". Should be in range [0.0, 1.0]");if(a<=0)throw new Error("Invalid nmsRadius "+a+".")}(t),a=this.baseModel.outputStride,r=this.inputResolution,s=U0(e),o=s[0],i=s[1],c=G0(e,r),l=c.resized,u=c.padding,h=this.baseModel.predict(l),d=h.heatmapScores,p=h.offsets,f=h.displacementFwd,m=h.displacementBwd,[4,L0([d,p,f,m])];case 1:return g=S.sent(),y=g[0],b=g[1],v=g[2],x=g[3],[4,E0(y,b,v,x,a,n.maxDetections,n.scoreThreshold,n.nmsRadius)];case 2:return w=S.sent(),k=H0(w,[o,i],r,u,n.flipHorizontal),d.dispose(),p.dispose(),f.dispose(),m.dispose(),l.dispose(),[2,k]}}))}))},e.prototype.estimateSinglePose=function(e,t){return void 0===t&&(t=Q0),s0(this,void 0,void 0,(function(){var n,a,r,s,o,i,c,l,u,h,d,p,f,m,g,y;return o0(this,(function(b){switch(b.label){case 0:return n=r0({},Q0,t),a=this.baseModel.outputStride,r=this.inputResolution,s=U0(e),o=s[0],i=s[1],c=G0(e,r),l=c.resized,u=c.padding,h=this.baseModel.predict(l),d=h.heatmapScores,p=h.offsets,f=h.displacementFwd,m=h.displacementBwd,[4,_0(d,p,a)];case 1:return g=b.sent(),y=H0([g],[o,i],r,u,n.flipHorizontal),d.dispose(),p.dispose(),f.dispose(),m.dispose(),l.dispose(),[2,y[0]]}}))}))},e.prototype.estimatePoses=function(e,t){return s0(this,void 0,void 0,(function(){return o0(this,(function(n){switch(n.label){case 0:return"single-person"!==t.decodingMethod?[3,2]:[4,this.estimateSinglePose(e,t)];case 1:return[2,[n.sent()]];case 2:return[2,this.estimateMultiplePoses(e,t)]}}))}))},e.prototype.dispose=function(){this.baseModel.dispose()},e}();function $0(e){return s0(this,void 0,void 0,(function(){var t,n,a,r,s,o,i;return o0(this,(function(c){switch(c.label){case 0:if(t=e.outputStride,n=e.quantBytes,a=e.multiplier,null==w)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");return r=function(e,t,n){var a={1:"100",.75:"075",.5:"050"},r="model-stride"+e+".json";return 4===n?D0+"float/"+a[t]+"/"+r:D0+"quant"+n+"/"+a[t]+"/"+r}(t,a,n),[4,t0(e.modelUrl||r)];case 1:return s=c.sent(),o=new c0(s,t),i=B0(e.inputResolution,o.outputStride),[2,new Z0(o,i)]}}))}))}function e1(e){return s0(this,void 0,void 0,(function(){var t,n,a,r,s,o;return o0(this,(function(i){switch(i.label){case 0:if(t=e.outputStride,n=e.quantBytes,null==w)throw new Error("Cannot find TensorFlow.js. If you are using a <script> tag, please also include @tensorflow/tfjs on the page before using this\n        model.");return a=function(e,t){var n="model-stride"+e+".json";return 4===t?F0+"float/"+n:F0+"quant"+t+"/"+n}(t,n),[4,t0(e.modelUrl||a)];case 1:return r=i.sent(),s=new M0(r,t),o=B0(e.inputResolution,s.outputStride),[2,new Z0(s,o)]}}))}))}function t1(e){return void 0===e&&(e=j0),s0(this,void 0,void 0,(function(){return o0(this,(function(t){return"ResNet50"===(e=function(e){if(null==(e=e||j0).architecture&&(e.architecture="MobileNetV1"),K0.indexOf(e.architecture)<0)throw new Error("Invalid architecture "+e.architecture+". Should be one of "+K0);if(null==e.inputResolution&&(e.inputResolution=257),P0(e.inputResolution),null==e.outputStride&&(e.outputStride=16),q0[e.architecture].indexOf(e.outputStride)<0)throw new Error("Invalid outputStride "+e.outputStride+". Should be one of "+q0[e.architecture]+" for architecture "+e.architecture+".");if(null==e.multiplier&&(e.multiplier=1),X0[e.architecture].indexOf(e.multiplier)<0)throw new Error("Invalid multiplier "+e.multiplier+". Should be one of "+X0[e.architecture]+" for architecture "+e.architecture+".");if(null==e.quantBytes&&(e.quantBytes=4),Y0.indexOf(e.quantBytes)<0)throw new Error("Invalid quantBytes "+e.quantBytes+". Should be one of "+Y0+" for architecture "+e.architecture+".");if("MobileNetV1"===e.architecture&&32===e.outputStride&&1!==e.multiplier)throw new Error("When using an output stride of 32, you must select 1 as the multiplier.");return e}(e)).architecture?[2,e1(e)]:"MobileNetV1"===e.architecture?[2,$0(e)]:[2,null]}))}))}var n1=n(579);const a1=()=>{const e=(0,U.useRef)(null),t=(0,U.useRef)(null),[n,a]=(0,U.useState)(0);let r=0;const s=(0,U.useRef)(0);return(0,U.useEffect)((()=>{const n=async(e,t,n)=>{for(;;){const i=await e.estimateSinglePose(t);if(o(i,n),r++,r%10===0){const e=performance.now()-s.current,t=Math.round(r/e*1e3);a(t)}await new Promise((e=>requestAnimationFrame(e)))}},o=(t,n)=>{n.clearRect(0,0,n.canvas.width,n.canvas.height),t.keypoints.forEach((t=>{if(t.score>=.5){const{x:a,y:r}=t.position,s=e.current,o=s.videoWidth,i=s.videoHeight,c=a*(s.offsetWidth/o),l=r*(s.offsetHeight/i);n.beginPath(),n.arc(c,l,5,0,2*Math.PI),n.fillStyle="red",n.fill()}}))};(async()=>{var a;a="webgl",ls.setBackend(a);const r=await t1(),o=e.current,i=t.current.getContext("2d");s.current=performance.now(),navigator.mediaDevices.getUserMedia&&navigator.mediaDevices.getUserMedia({video:!0}).then((e=>{o.srcObject=e,o.onloadedmetadata=()=>{o.play(),n(r,o,i)}})).catch((e=>{console.error("Error accessing the webcam: ",e)}))})()}),[r]),(0,n1.jsx)("div",{style:{display:"flex",justifyContent:"center",alignItems:"center",height:"100vh"},children:(0,n1.jsxs)("div",{style:{position:"relative"},children:[(0,n1.jsx)("video",{ref:e,width:"640",height:"480",autoPlay:!0,style:{transform:"scale(1)"}}),(0,n1.jsx)("canvas",{ref:t,width:"640",height:"480",style:{transform:"scale(1)",position:"absolute",top:0,left:0}}),(0,n1.jsxs)("div",{children:["fps: ",n]})]})})};const r1=function(){return(0,n1.jsxs)("div",{className:"App",children:[(0,n1.jsx)("h1",{children:"Pose Detection"}),(0,n1.jsx)(a1,{})]})},s1=e=>{e&&e instanceof Function&&n.e(453).then(n.bind(n,453)).then((t=>{let{getCLS:n,getFID:a,getFCP:r,getLCP:s,getTTFB:o}=t;n(e),a(e),r(e),s(e),o(e)}))};G.createRoot(document.getElementById("root")).render((0,n1.jsx)(U.StrictMode,{children:(0,n1.jsx)(r1,{})})),s1()})()})();
//# sourceMappingURL=main.cdb12007.js.map